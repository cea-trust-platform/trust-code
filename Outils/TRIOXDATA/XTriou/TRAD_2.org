comment objet_u # 0 Comments in a data file.
  attr comm chaine comm 0 Text to be commented.
bloc_comment objet_u /* 0 bloc of Comment in a data file.
  attr comm chaine comm 0 Text to be commented.
interprete objet_u interprete 0 Basic class for interpreting a data file. Interpretors allow some operations to be carried out on objects.
read interprete lire 0 Interpretor to read the a_object objet defined between the braces.
  attr a_object chaine a_object 0 Object to be read.
  attr bloc chaine bloc 0 Definition of the object.
associate interprete associer -1 This interpretor allows one object to be associated with another. The order of the two objects in this instruction is not important. The object objet_2 is associated to objet_1 if this makes sense; if not either objet_1 is associated to objet_2 or the program exits in error because it cannot execute the Associate (Associer) instruction. For example, to calculate water flow in a pipe, a Pb_Hydraulique type object needs to be defined. But also a Domaine type object to represent the pipe, a Schema_euler_explicite type object for time discretisation, a discretisation type object (VDF or VEF) and a Fluide_Incompressible type object which will contain the water properties. These objects must then all be associated with the problem.
  attr objet_1 chaine objet_1 0 Objet_1
  attr objet_2 chaine objet_2 0 Objet_2
listobj listobj_impl listobj -1 List of objects.
objet_lecture objet_u objet_lecture -1 Auxiliary class for reading.
bloc_lecture objet_lecture nul 0 to read between two braces
  attr bloc_lecture chaine bloc_lecture 0 not_set
deuxmots objet_lecture nul 0 Two words.
  attr mot_1 chaine mot_1 0 First word.
  attr mot_2 chaine mot_2 0 Second word.
format_file objet_lecture nul 0 File formatted.
  attr format chaine(into=["binaire","formatte","xyz"]) format 1 Type of file (the file format).
  attr name_file chaine name_file 0 Name of file.
deuxentiers objet_lecture nul 0 Two integers.
  attr int1 entier int1 0 First integer.
  attr int2 entier int2 0 Second integer.
floatfloat objet_lecture nul 0 Two reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
entierfloat objet_lecture nul 0 An integer and a real.
  attr the_int entier the_int 0 Integer.
  attr the_float floattant the_float 0 Real.
champ_a_post objet_lecture nul 0 Field to be post-processed.
  attr champ chaine champ 0 Name of the post-processed field.
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field values: The two available values are elem, som, or faces (LATA format only) used respectively to select field values at mesh centres (CHAMPMAILLE type field in the lml file) or at mesh nodes (CHAMPPOINT type field in the lml file). If no selection is made, localisation is set to som by default.
field_base objet_u champ_base -1 Basic class of fields.
champs_a_post listobj nul -1 champ_a_post 0 Fields to be post-processed.
champs_posts objet_lecture nul 0 Field\'s write mode.
  attr format chaine(into=["binaire","formatte"]) format 1 Type of file.
  attr mot chaine(into=["dt_post","nb_pas_dt_post"]) mot 0 Keyword to set the kind of the field\'s write frequency. Either a time period or a time step period.
  attr period chaine period 0 Value of the period.
  attr champs|fields champs_a_post champs 0 Post-processed fields.
stat_post_deriv objet_lecture stat_post_deriv 0 not_set
stat_post_t_deb stat_post_deriv t_deb 0 not_set
  attr val floattant val 0 not_set
stat_post_t_fin stat_post_deriv t_fin 0 not_set
  attr val floattant val 0 not_set
stat_post_moyenne stat_post_deriv moyenne 0 not_set
  attr field chaine field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
stat_post_ecart_type stat_post_deriv ecart_type 0 not_set
  attr field chaine field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
stat_post_correlation stat_post_deriv correlation 0 not_set
  attr first_field chaine first_field 0 not_set
  attr second_field chaine second_field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
list_stat_post listobj nul -1 stat_post_deriv 0 Post-processing for statistics
stats_posts objet_lecture nul 0 Field\'s write mode. \input{{statistiques}}
  attr mot chaine(into=["dt_post","nb_pas_dt_post"]) mot 0 Keyword to set the kind of the field\'s write frequency. Either a time period or a time step period.
  attr period chaine period 0 Value of the period.
  attr champs|fields list_stat_post champs 0 Post-processed fields.
stats_serie_posts objet_lecture nul 0 Post-processing for statistics. \input{{statistiquesseries}}
  attr mot chaine(into=["dt_integr"]) mot 0 Keyword is used to set the statistics period of integration and write period.
  attr dt_integr floattant dt_integr 0 Average on dt_integr time interval is post-processed every dt_integr seconds.
  attr stat list_stat_post stat 0 not_set
sonde_base objet_lecture sonde_base 0 Basic probe. Probes refer to sensors that allow a value or several points of the domain to be monitored over time. The probes may be a set of points defined one by one (keyword Points) or a set of points evenly distributed over a straight segment (keyword Segment) or arranged according to a layout (keyword Plan) or according to a parallelepiped (keyword Volume). The fields allow all the values of a physical value on the domain to be known at several moments in time.
un_point objet_lecture nul 0 A point.
  attr pos listf pos 0 Point co-ordinates.
listpoints listobj nul 0 un_point 0 Points.
points sonde_base points 0 Keyword to define the number of probe points. The file is arranged in columns.
  attr points listpoints points 0 Probe points.
point points point 0 Point as class-daughter of Points.
numero_elem_sur_maitre sonde_base numero_elem_sur_maitre 0 Keyword to define a probe at the special element. Useful for min/max sonde.
  attr numero entier numero 0 element number
segmentpoints points segmentpoints 0 This keyword is used to define a probe segment from specifics points. The nom_champ field is sampled at ns specifics points.
position_like sonde_base position_like 0 Keyword to define a probe at the same position of another probe named autre_sonde.
  attr autre_sonde chaine autre_sonde 0 Name of the other probe.
segment sonde_base segment 0 Keyword to define the number of probe segment points. The file is arranged in columns.
  attr nbr entier nbr 0 Number of probe points of the segment, evenly distributed.
  attr point_deb un_point point_deb 0 First outer probe segment point.
  attr point_fin un_point point_fin 0 Second outer probe segment point.
plan sonde_base plan 0 Keyword to set the number of probe layout points. The file format is type .lml
  attr nbr entier nbr 0 Number of probes in the first direction.
  attr nbr2 entier nbr2 0 Number of probes in the second direction.
  attr point_deb un_point point_deb 0 First point defining the angle. This angle should be positive.
  attr point_fin un_point point_fin 0 Second point defining the angle. This angle should be positive.
  attr point_fin_2 un_point point_fin_2 0 Third point defining the angle. This angle should be positive.
volume sonde_base volume 0 Keyword to define the probe volume in a parallelepiped passing through 4 points and the number of probes in each direction.
  attr nbr entier nbr 0 Number of probes in the first direction.
  attr nbr2 entier nbr2 0 Number of probes in the second direction.
  attr nbr3 entier nbr3 0 Number of probes in the third direction.
  attr point_deb un_point point_deb 0 Point of origin.
  attr point_fin un_point point_fin 0 Point defining the first direction (from point of origin).
  attr point_fin_2 un_point point_fin_2 0 Point defining the second direction (from point of origin).
  attr point_fin_3 un_point point_fin_3 0 Point defining the third direction (from point of origin).
circle sonde_base circle 0 Keyword to define several probes located on a circle.
  attr nbr entier nbr 0 Number of probes between teta1 and teta2 (angles given in degrees).
  attr point_deb un_point point_deb 0 Center of the circle.
  attr direction entier(into=[0,1,2]) direction 1 Axis normal to the circle plane (0:x axis, 1:y axis, 2:z axis).
  attr radius floattant radius 0 Radius of the circle.
  attr theta1 floattant theta1 0 First angle.
  attr theta2 floattant theta2 0 Second angle.
circle_3 sonde_base circle_3 0 Keyword to define several probes located on a circle (in 3-D space).
  attr nbr entier nbr 0 Number of probes between teta1 and teta2 (angles given in degrees).
  attr point_deb un_point point_deb 0 Center of the circle.
  attr direction entier(into=[0,1,2]) direction 0 Axis normal to the circle plane (0:x axis, 1:y axis, 2:z axis).
  attr radius floattant radius 0 Radius of the circle.
  attr theta1 floattant theta1 0 First angle.
  attr theta2 floattant theta2 0 Second angle.
sonde objet_lecture nul 0 Keyword is used to define the probes. Observations: the probe co-ordinates should be given in Cartesian co-ordinates (X, Y, Z), including axisymmetric.
  attr nom_sonde chaine nom_sonde 0 Name of the file in which the values taken over time will be saved. The complete file name is nom_sonde.son.
  attr special chaine(into=["chsom","nodes","grav","som"]) special 1 Option to change the positions of the probes. Several options are available: NL2 grav : each probe is moved to the nearest cell center of the mesh; NL2 som : each probe is moved to the nearest vertex of the mesh NL2 nodes : each probe is moved to the nearest face center of the mesh; NL2 chsom : only available for P1NC sampled field. The values of the probes are calculated according to P1-Conform corresponding field.
  attr nom_inco chaine nom_inco 0 Name of the sampled field.
  attr mperiode chaine(into=["periode"]) mperiode 0 Keyword to set the sampled field measurement frequency.
  attr prd floattant prd 0 Period value. Every prd seconds, the field value calculated at the previous time step is written to the nom_sonde.son file.
  attr type sonde_base type 0 Type of probe.
sondes listobj nul 1 sonde 0 List of probes.
champ_generique_base objet_u champ_generique_base 1 not_set
listchamp_generique listobj nul 1 champ_generique_base 1 XXX
champ_post_de_champs_post champ_generique_base champ_post_de_champs_post -1 not_set
  attr source champ_generique_base source 1 the source field.
  attr nom_source chaine nom_source 1 To name a source field with the nom_source keyword
  attr source_reference chaine source_reference 1 not_set
  attr sources_reference list_nom_virgule sources_reference 1 not_set
  attr sources listchamp_generique sources 1 sources { Champ_Post.... { ... } Champ_Post.. { ... }}
champ_post_operateur_eqn champ_post_de_champs_post operateur_eqn 1 not_set
  attr numero_op entier numero_op 1 not_set
  attr numero_source entier numero_source 1 not_set
  attr sans_solveur_masse rien sans_solveur_masse 1 not_set
transformation champ_post_de_champs_post transformation -1 To create a field with a transformation.
  attr methode chaine(into=["produit_scalaire","norme","vecteur","formule","composante"]) methode 0 methode norme : will calculate the norm of a vector given by a source field NL2 methode produit_scalaire : will calculate the dot product of two vectors given by two sources fields NL2 methode composante numero integer : will create a field by extracting the integer component of a field given by a source field NL2 methode formule expression 1 : will create a scalar field located to elements using expressions with x,y,z,t parameters and field names given by a source field or several sources fields. NL2 methode vecteur expression N f1(x,y,z,t) fN(x,y,z,t) : will create a vector field located to elements by defining its N components with N expressions with x,y,z,t parameters and field names given by a source field or several sources fields.
  attr expression listchaine expression 1 see methodes formule and vecteur
  attr numero entier numero 1 see methode composante
  attr localisation chaine localisation 1 type_loc indicate where is done the interpolation (elem for element or som for node). The optional keyword methode is limited to calculer_champ_post for the moment
predefini champ_generique_base predefini -1 These keyword is used to post process predefined postprocessing fields. For the moment, only kinetic energy (energie_cinetique keyword to use for field_name) is available.
  attr pb_champ deuxmots pb_champ 0 { Pb_champ nom_pb nom_champ } : nom_pb is the problem name and nom_champ is the selected field name.
refchamp champ_generique_base refchamp -1 Field of prolem
  attr pb_champ deuxmots pb_champ 0 { Pb_champ nom_pb nom_champ } : nom_pb is the problem name and nom_champ is the selected field name.
  attr nom_source chaine nom_source 1 The alias name for the field
champ_post_operateur_base champ_post_de_champs_post champ_post_operateur_base -1 not_set
gradient champ_post_operateur_base gradient -1 To calculate gradient of a given field.
divergence champ_post_operateur_base divergence -1 To calculate divergency of a given field.
champ_post_statistiques_base champ_post_de_champs_post champ_post_statistiques_base -1 not_set
  attr t_deb floattant t_deb 0 Start of integration time
  attr t_fin floattant t_fin 0 End of integration time
correlation champ_post_statistiques_base correlation -1 to calculate the correlation between the two fields.
moyenne champ_post_statistiques_base moyenne -1 to calculate the average of the field over time
  attr moyenne_convergee field_base moyenne_convergee 1 This option allows to read a converged time averaged field in a .xyz file in order to calculate, when restarting the calculation, the statistics fields (rms, correlation) which depend on this average. In that case, the time averaged field is not updated during the restarting calculation. In this case, the time averaged field must be fully converged to avoid errors when calculating high order statistics.
ecart_type champ_post_statistiques_base ecart_type -1 to calculate the standard deviation (statistic rms) of the field nom_champ.
extraction champ_post_de_champs_post extraction -1 To create a surface field (values at the boundary) of a volume field
  attr domaine ref_domaine domaine 0 name of the volume field
  attr nom_frontiere chaine nom_frontiere 0 boundary name where the values of the volume field will be picked
  attr methode chaine(into=["trace","champ_frontiere"]) methode 1 name of the extraction method (trace by_default or champ_frontiere)
morceau_equation champ_post_de_champs_post morceau_equation 1 To calculate a field related to a piece of equation. For the moment, the field which can be calculated is the stability time step of an operator equation. The problem name and the unknown of the equation should be given by Source refChamp { Pb_Champ problem_name unknown_field_of_equation }
  attr type chaine type 0 can only be operateur for equation operators.
  attr numero entier numero 0 numero will be 0 (diffusive operator) or 1 (convective operator).
  attr option chaine(into=["stabilite","flux_bords"]) option 0 option is stability for time steps or flux_bords for boundary fluxes.
  attr compo entier compo 1 compo will specify the number component of the boundary flux (for boundary fluxes, in this case compo permits to specify the number component of the boundary flux choosen).
definition_champ objet_lecture nul 0 Keyword to create new complex field for advanced postprocessing.
  attr name chaine name 0 The name of the new created field.
  attr champ_generique champ_generique_base champ_generique 0 not_set
definition_champs listobj nul 1 definition_champ 0 List of definition champ
postraitement_base objet_lecture postraitement_base -1 not_set
postraitement postraitement_base postraitement -1 An object of post-processing (without name).
  attr definition_champs definition_champs definition_champs 1 Keyword to create new or more complex field for advanced postprocessing.
  attr sondes|Probes sondes sondes 1 Probe.
  attr domaine chaine domaine 1 This optional parameter specifies the domain on which the data should be interpolated before it is written in the output file. The default is to write the data on the domain of the current problem (no interpolation).
  attr format chaine(into=["lml","lata","lata_v1","lata_v2","med","med_major"]) format 1 This optional parameter specifies the format of the output file. The basename used for the output file is the basename of the data file. For the fmt parameter, choices are lml or lata. A short description of each format can be found below. The default value is lml.
  attr champs|fields champs_posts champs 1 Field\'s write mode.
  attr statistiques stats_posts statistiques 1 Statistics between two points fixed : start of integration time and end of integration time.
  attr fichier chaine fichier 1 Name of file.
  attr statistiques_en_serie stats_serie_posts statistiques_en_serie 1 Statistics between two points not fixed : on period of integration.
  attr interfaces champs_posts interfaces 1 Keyword to read all the caracteristics of the interfaces. Different kind of interfaces exist as well as different interface intitialisations.
corps_postraitement postraitement nul -1 not_set
un_postraitement objet_lecture nul 0 An object of post-processing (with name).
  attr nom chaine nom 0 Name of the post-processing.
  attr post corps_postraitement post 0 Definition of the post-processing.
postraitements listobj postraitements -1 un_postraitement 0 Keyword to use several results files. List of objects of post-processing (with name).
type_un_post objet_lecture nul 0 not_set
  attr type chaine(into=["postraitement","post_processing"]) type 0 not_set
  attr post un_postraitement post 0 not_set
type_postraitement_ft_lata objet_lecture nul 0 not_set
  attr type chaine(into=["postraitement_ft_lata","postraitement_lata"]) type 0 not_set
  attr nom chaine nom 0 Name of the post-processing.
  attr bloc chaine bloc 0 not_set
un_postraitement_spec objet_lecture nul 0 An object of post-processing (with type +name).
  attr type_un_post type_un_post type_un_post 1 not_set
  attr type_postraitement_ft_lata type_postraitement_ft_lata type_postraitement_ft_lata 1 not_set
liste_post listobj liste_post -1 un_postraitement_spec 0 Keyword to use several results files. List of objects of post-processing (with name)
nom_postraitement objet_lecture nul 0 
  attr nom chaine nom 0 Name of the post-processing.
  attr post postraitement_base post 0 the post
liste_post_ok listobj liste_post_ok -1 nom_postraitement 0 Keyword to use several results files. List of objects of post-processing (with name)
pb_gen_base objet_u pb_gen_base -1 Basic class for problems.
discretize interprete discretiser -1 Keyword to discretise a problem problem_name according to the discretisation dis. NL2 IMPORTANT: A number of objects must be already associated (a domain, time scheme, central object) prior to invoking the Discretiser (Discretise) keyword. The physical properties of this central object must also have been read.
  attr problem_name ref_pb_gen_base problem_name 0 Name of problem.
  attr dis ref_discretisation_base dis 0 Name of the discretisation object.
condinit objet_lecture nul 0 Initial condition.
  attr nom chaine nom 0 Name of initial condition field.
  attr ch field_base ch 0 Type field and the initial values.
condinits objet_lecture nul 0 Initial conditions.
  attr aco chaine(into=["{"]) aco 0 Open accodance sign.
  attr condinit condinit condinit 0 CI
  attr acof chaine(into=["}"]) acof 0 Closed accodance sign.
condlim_base objet_u condlim_base 0 Basic class of boundary conditions.
condlimlu objet_lecture nul 0 Boundary condition specified.
  attr bord chaine bord 0 Name of the edge where the boundary condition applies.
  attr cl condlim_base cl 0 Boundary condition at the boundary called bord (edge).
condlims listobj condlims -1 condlimlu 0 Boundary conditions.
source_base objet_u source_base -1 Basic class of source terms introduced in the equation.
source_generique source_base source_generique 0 to define a source term depending on some discrete fields of the problem and (or) analytic expression. It is expressed by the way of a generic field usually used for post-processing.
  attr champ champ_generique_base champ 0 the source field
sources listobj sources -1 source_base -1 The sources.
nom objet_u nom 0 Class to name the TRUST objects.
  attr mot chaine mot 1 Chain of characters.
nom_anonyme nom nul -1 not_set
vect_nom listobj vect_nom 0 nom_anonyme 0 Vect of name.
list_nom listobj list_nom 1 nom_anonyme 0 List of name.
list_nom_virgule listobj list_nom_virgule 1 nom_anonyme 1 List of name.
mailler_base objet_lecture mailler_base -1 Basic class to mesh.
bloc_pave objet_lecture nul -1 Class to create a pave.
  attr Origine listf Origine 1 Keyword to define the pave (block) origin, that is to say one of the 8 block points (or 4 in a 2D system).
  attr longueurs listf longueurs 1 Keyword to define the block dimensions, that is to say knowing the origin, length along the axes.
  attr nombre_de_noeuds listentierf nombre_de_noeuds 1 Keyword to define the discretization (nodenumber) in each direction.
  attr facteurs listf facteurs 1 Keyword to define stretching factors for mesh discretisation in each direction. This is a real number which must be positive (by default 1.0). A stretching factor other than 1 allows refinement on one edge in one direction.
  attr symx rien symx 1 Keyword to define a block mesh that is symmetrical with respect to the YZ plane (respectively straight Y in 2D) passing through the block centre.
  attr symy rien symy 1 Keyword to define a block mesh that is symmetrical with respect to the XZ plane (respectively straight X in 2D) passing through the block centre.
  attr symz rien symz 1 Keyword defining a block mesh that is symmetrical with respect to the XY plane passing through the block centre.
  attr tanh floattant tanh 1 Keyword to generate mesh with tanh (hyperbolic tangent) variation.
  attr tanh_dilatation entier(into=[-1,0,1]) tanh_dilatation 1 Keyword to generate mesh with tanh (hyperbolic tangent) variation. tanh_dilatation: The value may be -1,0,1 (0 by default): 0: coarse mesh at the middle of the channel and smaller near the walls 1: coarse mesh at the bottom of the channel and smaller near the top -1: coarse mesh at the top of the channel and smaller near the bottom.
  attr tanh_taille_premiere_maille floattant tanh_taille_premiere_maille 1 Size of the first cell of the mesh with tanh (hyperbolic tangent) variation in the Y direction.
defbord objet_lecture nul 0 Class to define an edge.
defbord_2 defbord nul -1 1-D edge (straight) in the 2-D space.
  attr dir chaine(into=["X","Y"]) dir 0 Edge is perpendicular to this direction.
  attr eq chaine(into=["="]) eq 0 Equality sign.
  attr pos floattant pos 0 Position value.
  attr pos2_min floattant pos2_min 0 Value minimal.
  attr inf1 chaine(into=["<="]) inf1 0 Less or equal sign.
  attr dir2 chaine(into=["X","Y"]) dir2 0 Edge is parallel to this direction.
  attr inf2 chaine(into=["<="]) inf2 0 Less or equal sign.
  attr pos2_max floattant pos2_max 0 Value maximal.
defbord_3 defbord nul -1 2-D edge (plane) in the 3-D space.
  attr dir chaine(into=["X","Y","Z"]) dir 0 Edge is perpendicular to this direction.
  attr eq chaine(into=["="]) eq 0 Equality sign.
  attr pos floattant pos 0 Position value.
  attr pos2_min floattant pos2_min 0 Value minimal.
  attr inf1 chaine(into=["<="]) inf1 0 Less or equal sign.
  attr dir2 chaine(into=["X","Y"]) dir2 0 Edge is parallel to this direction.
  attr inf2 chaine(into=["<="]) inf2 0 Less or equal sign.
  attr pos2_max floattant pos2_max 0 Value maximal.
  attr pos3_min floattant pos3_min 0 Value minimal.
  attr inf3 chaine(into=["<="]) inf3 0 Less or equal sign.
  attr dir3 chaine(into=["Y","Z"]) dir3 0 Edge is parallel to this direction.
  attr inf4 chaine(into=["<="]) inf4 0 Less or equal sign.
  attr pos3_max floattant pos3_max 0 Value maximal.
bord_base objet_lecture bord_base -1 Basic class for block sides. Block sides that are neither edges nor connectors are not specified. The duplicate nodes of two blocks in contact are automatically recognised and deleted.
bord bord_base bord 0 The block side is not in contact with another block and limitation conditions are applied to it.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
raccord bord_base raccord 0 The block side is in contact with the block of another domain (case of two coupled problems).
  attr type1 chaine(into=["local","distant"]) type1 0 Contact type.
  attr type2 chaine(into=["homogene"]) type2 0 Contact type.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
internes bord_base internes 0 To indicate that the block has a set of internal faces (these faces will be duplicated automatically by the program and will be processed in a manner similar to edge faces). NL2 Two boundaries with the same limitation conditions may be given the same name (whether or not they belong to the same block). NL2 The keyword Internes (Internal) must be used to execute a calculation with plates, followed by the equation of the surface area covered by the plates.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
list_bord listobj list_bord 1 bord_base 0 The block sides.
pave mailler_base pave 0 Class to create a pave (block) with boundaries.
  attr name chaine name 0 Name of the pave (block).
  attr bloc bloc_pave bloc 0 Definition of the pave (block).
  attr list_bord list_bord list_bord 0 Definition of boundaries of domain.
epsilon mailler_base epsilon 0 Two points will be confused if the distance between them is less than eps. By default, eps is set to 1e-12. The keyword Epsilon allows an alternative value to be assigned to eps.
  attr eps floattant eps 0 New value of precision.
domain mailler_base domain 0 Class to reuse a domain.
  attr domain_name ref_domaine domain_name 0 Name of domain.
list_bloc_mailler listobj list_bloc_mailler 1 mailler_base 1 List of block mesh.
mailler interprete mailler -1 The Mailler (Mesh) interpretor allows a Domain type object domaine to be meshed with objects objet_1, objet_2, etc...
  attr domaine ref_domaine domaine 0 Name of domain.
  attr bloc list_bloc_mailler bloc 0 Instructions to mesh.
maillerparallel interprete maillerparallel 1 creates a parallel distributed hexaedral mesh of a parallelipipedic box. It is equivalent to creating a mesh with a single Pave, splitting it with Decouper and reloading it in parallel with Scatter. It only works in 3D at this time. It can also be used for a sequential computation (with all NPARTS=1)}
  attr domain ref_domaine domain 0 the name of the domain to mesh (it must be an empty domain object).
  attr nb_nodes listentier nb_nodes 0 dimension defines the spatial dimension (currently only dimension=3 is supported), and nX, nY and nZ defines the total number of nodes in the mesh in each direction.
  attr splitting listentier splitting 0 dimension is the spatial dimension and npartsX, npartsY and npartsZ are the number of parts created. The product of the number of parts must be equal to the number of processors used for the computation.
  attr ghost_thickness entier ghost_thickness 0 he number of ghost cells (equivalent to the epaisseur_joint parameter of Decouper.
  attr perio_x rien perio_x 1 change the splitting method to provide a valid mesh for periodic boundary conditions.
  attr perio_y rien perio_y 1 change the splitting method to provide a valid mesh for periodic boundary conditions.
  attr perio_z rien perio_z 1 change the splitting method to provide a valid mesh for periodic boundary conditions.
  attr function_coord_x chaine function_coord_x 1 By default, the meshing algorithm creates nX nY nZ coordinates ranging between 0 and 1 (eg a unity size box). If function_coord_x} is specified, it is used to transform the [0,1] segment to the coordinates of the nodes. funcX must be a function of the x variable only.
  attr function_coord_y chaine function_coord_y 1 like function_coord_x for y
  attr function_coord_z chaine function_coord_z 1 like function_coord_x for z
  attr file_coord_x chaine file_coord_x 1 Keyword to read the Nx floating point values used as nodes coordinates in the file.
  attr file_coord_y chaine file_coord_y 1 idem file_coord_x for y
  attr file_coord_z chaine file_coord_z 1 idem file_coord_x for z
  attr boundary_xmin chaine boundary_xmin 1 the name of the boundary at the minimum X direction. If it not provided, the default boundary names are xmin, xmax, ymin, ymax, zmin and zmax. If the mesh is periodic in a given direction, only the MIN boundary name is used, for both sides of the box.
  attr boundary_xmax chaine boundary_xmax 1 not_set
  attr boundary_ymin chaine boundary_ymin 1 not_set
  attr boundary_ymax chaine boundary_ymax 1 not_set
  attr boundary_zmin chaine boundary_zmin 1 not_set
  attr boundary_zmax chaine boundary_zmax 1 not_set
write_file interprete ecrire_fichier -1 Keyword to write the object of name name_obj to a file filename. Since the v1.6.3, the default format is now binary format file.
  attr name_obj chaine name_obj 0 Name of the object to be written.
  attr filename chaine filename 0 Name of the file.
ecrire_fichier_formatte write_file ecrire_fichier_formatte -1 Keyword to write the object of name name_obj to a file filename in ASCII format.
write interprete ecrire -1 Keyword to write the object of name name_obj to a standard outlet.
  attr name_obj chaine name_obj 0 Name of the object to be written.
read_file interprete lire_fichier -1 Keyword to read the object name_obj contained in the file filename. NL2 This is notably used when the calculation domain has already been meshed and the mesh contains the file filename, simply write read_file dom filename (where dom is the name of the meshed domain). NL2 If the filename is ;, is to execute a data set given in the file of name name_obj (a space must be entered between the semi-colon and the file name).
  attr name_obj chaine name_obj 0 Name of the object to be read.
  attr filename chaine filename 0 Name of the file.
read_unsupported_ascii_file_from_icem read_file read_unsupported_ascii_file_from_icem -1 not_set
read_file_bin read_file lire_fichier_bin -1 Keyword to read an object name_obj in the unformatted type file filename.
read_tgrid interprete lire_tgrid -1 Keyword to reaf Tgrid/Gambit mesh files. 2D (triangles or quadrangles) and 3D (tetra or hexa elements) meshes, may be read by TRUST.
  attr dom ref_domaine dom 0 Name of domaine.
  attr filename chaine filename 0 Name of file containing the mesh.
discretisation_base objet_u discretisation_base -1 Basic class for space discretization of thermohydraulic turbulent problems.
vdf discretisation_base vdf -1 Finite difference volume discretization.
vef discretisation_base vef -1 Finite element volume discretization (P1NC/P0 element) NL2 Warning: it becomes an obsolete discretization.
vefprep1b vef vefprep1b -1 Finite element volume discretization (P1NC/P1-bubble element). Since the 1.5.5 version, several new discretizations are available thanks to the optional keyword Read. By default, the VEFPreP1B keyword is equivalent to the former VEFPreP1B formulation (v1.5.4 and sooner). P0P1 (if used with the strong formulation for imposed pressure boundary) is equivalent to VEFPreP1B but the convergence is slower. VEFPreP1B dis is equivalent to VEFPreP1B dis Read dis { P0 P1 Changement_de_base_P1Bulle 1 Cl_pression_sommet_faible 0 }
  attr p0 rien p0 1 Pressure nodes are added on element centres
  attr p1 rien p1 1 Pressure nodes are added on vertices
  attr pa rien pa 1 Only available in 3D, pressure nodes are added on bones
  attr changement_de_base_p1bulle entier(into=[0,1]) changement_de_base_p1bulle 1 This option may be used to have the P1NC/P0P1 formulation (value set to 0) or the P1NC/P1Bulle formulation (value set to 1, the default).
  attr cl_pression_sommet_faible entier(into=[0,1]) cl_pression_sommet_faible 1 This option is used to specify a strong formulation (value set to 0, the default) or a weak formulation (value set to 1) for an imposed pressure boundary condition. The first formulation converges quicker and is stable in general cases. The second formulation should be used if there are several outlet boundaries with Neumann condition (see Ecoulement_Neumann test case for example).
  attr modif_div_face_dirichlet entier(into=[0,1]) modif_div_face_dirichlet 1 This option (by default 0) is used to extend control volumes for the momentum equation.
solve interprete resoudre -2 Interpretor to start calculation with TRUST.
  attr pb ref_pb_gen_base pb 0 Name of problem to be solved.
execute_parallel interprete execute_parallel 1 This keyword allows to run several computations in parallel on processors allocated to TRUST. The set of processors is split in N subsets and each subset will read and execute a different data file. Error messages usualy written to stderr and stdout are redirected to .log files (journaling must be activated).
  attr liste_cas listchaine liste_cas 0 N datafile1 ... datafileN. datafileX the name of a TRUST data file without the .data extension.
  attr nb_procs listentier nb_procs 1 nb_procs is the number of processors needed to run each data file. If not given, TRUST assumes that computations are sequential.
fin interprete fin -1 Keyword which must complete the data file.
dimension interprete dimension -1 Keyword allowing calculation dimensions to be set (2D or 3D), where dim is an integer set to 2 or 3. This instruction is mandatory.
  attr dim entier(into=[2,3]) dim 0 Number of dimensions.
bidim_axi interprete bidim_axi -1 Keyword allowing a 2D calculation to be executed using axisymetric co-ordinates (R, Z). If this instruction is not included, calculations are carried out using Cartesian co-ordinates.
axi interprete axi -1 This keyword allows a 3D calculation to be executed using cylindrical co-ordinates (R,$\jolitheta$,Z). If this instruction is not included, calculations are carried out using Cartesian co-ordinates.
domaine objet_u domaine -1 Keyword to create a domain.
transformer interprete transformer -1 Keyword to transform the coordinates of the geometry. NL2 Exemple to rotate your mesh by a 90o rotation and to scale the z coordinates by a factor 2: Transformer domain_name -y -x 2*z
  attr domain_name ref_domaine domain_name 0 Name of domain.
  attr formule listchainef formule 0 Function_for_x Function_for_y \[ Function_for z \]
rotation interprete rotation -1 Keyword to rotate the geometry of an arbitrary angle around an axis aligned with Ox, Oy or Oz axis.
  attr domain_name ref_domaine domain_name 0 Name of domain to wich the transformation is applied.
  attr dir chaine(into=["X","Y","Z"]) dir 0 X, Y or Z to indicate the direction of the rotation axis
  attr coord1 floattant coord1 0 coordinates of the center of rotation in the plane orthogonal to the rotation axis. These coordinates must be specified in the direct triad sense.
  attr coord2 floattant coord2 0 not_set
  attr angle floattant angle 0 angle of rotation (in degrees)
dilate interprete dilate -1 Keyword to multiply the whole coordinates of the geometry.
  attr domain_name ref_domaine domain_name 0 Name of domain.
  attr alpha floattant alpha 0 Value of dilatation coefficient.
class_generic objet_u class_generic -1 not_set
dt_start class_generic dt_start 0 not_set
dt_calc_dt_calc dt_start dt_calc 0 The time step at first iteration is calculated in agreement with CFL condition.
dt_calc_dt_min dt_start dt_min 0 The first iteration is based on dt_min.
dt_calc_dt_fixe dt_start dt_fixe 0 The first time step is fixed by the user (recommended when restarting calculation with Crank Nicholson temporal scheme to ensure continuity).
  attr value floattant value 0 first time step.
euler_scheme schema_temps_base schema_euler_explicite -1 This is the Euler explicite scheme.
schema_predictor_corrector schema_temps_base schema_predictor_corrector -1 This is the predictor-corrector scheme (second order). It is more accurate and economic than MacCormack scheme. It gives best results with a second ordre convective scheme like quick, centre (VDF).
solveur_implicite_base objet_u solveur_implicite_base -1 Class for solver in the situation where the time scheme is the implicit scheme. Solver allows equation diffusion and convection operators to be set as implicit terms.
solveur_sys_base class_generic solveur_sys_base -1 Basic class to solve the linear system.
Sch_CN_iteratif schema_temps_base Sch_CN_iteratif -1 The Crank-Nicholson method of second order accuracy. A mid-point rule formulation is used (Euler-centered scheme). The basic scheme is: $$u(t+1) = u(t) + du/dt(t+1/2)*dt$$ The estimation of the time derivative du/dt at the level (t+1/2) is obtained either by iterative process. The time derivative du/dt at the level (t+1/2) is calculated iteratively with a simple under-relaxations method. Since the method is implicit, neither the cfl nor the fourier stability criteria must be respected. The time step is calculated in a way that the iterative procedure converges with the less iterations as possible. NL2 Remark : for stationary or RANS calculations, no limitation can be given for time step through high value of facsec_max parameter (for instance : facsec_max 1000). In counterpart, for LES calculations, high values of facsec_max may engender numerical instabilities.
  attr niter_min entier niter_min 1 minimal number of p-iterations to satisfy convergence criteria (2 by default)
  attr niter_max entier niter_max 1 number of maximum p-iterations allowed to satisfy convergence criteria (6 by default)
  attr niter_avg entier niter_avg 1 threshold of p-iterations (3 by default). If the number of p-iterations is greater than niter_avg, facsec is reduced, if lesser than niter_avg, facsec is increased (but limited by the facsec_max value).
  attr facsec_max floattant facsec_max 1 maximum ratio allowed between dynamical time step returned by iterative process and stability time returned by CFL condition (2 by default).
  attr seuil floattant seuil 1 criteria for ending iterative process (Max( || u(p) - u(p-1)||/Max || u(p) ||) < seuil) (0.001  by default)
Sch_CN_EX_iteratif Sch_CN_iteratif Sch_CN_EX_iteratif -1 This keyword also describes a Crank-Nicholson method of second order accuracy but here, for scalars, because of instablities encountered when dt>dt_CFL, the Crank Nicholson scheme is not applied to scalar quantities. Scalars are treated according to Euler-Explicite scheme at the end of the CN treatment for velocity flow fields (by doing p Euler explicite under-iterations at dt<=dt_CFL). Parameters are the sames (but default values may change) compare to the Sch_CN_iterative scheme plus a relaxation keyword: niter_min (2 by default), niter_max (6 by default), niter_avg (3 by default), facsec_max (20 by default), seuil (0.05 by default)
  attr omega floattant omega 1 relaxation factor (0.1 by default)
runge_kutta_ordre_3 schema_temps_base runge_kutta_ordre_3 -1 This is the Runge-Kutta scheme of third order.
runge_kutta_ordre_4_d3p schema_temps_base runge_kutta_ordre_4_d3p -1 not_set
leap_frog schema_temps_base leap_frog -1 This is the leap-frog scheme.
runge_kutta_rationnel_ordre_2 schema_temps_base runge_kutta_rationnel_ordre_2 -1 This is the Runge-Kutta rational scheme of second order. The method is described in the note: Wambeck - Rational Runge-Kutta methods for solving systems of ordinary differential equations, at the link: https://link.springer.com/article/10.1007/BF02252381. Although rational methods require more computational work than linear ones, they can have some other properties, such as a stable behaviour with explicitness, which make them preferable. The CFD application of this RRK2 scheme is described in the note: https://link.springer.com/content/pdf/10.1007\%2F3-540-13917-6_112.pdf.
solveur_lineaire_std solveur_implicite_base solveur_lineaire_std 1 not_set
  attr solveur solveur_sys_base solveur 1 not_set
simpler solveur_implicite_base simpler 1 Simpler method for incompressible systems.
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 0 Keyword to set the value of the convergence criteria for the resolution of the implicit system build to solve either the Navier_Stokes equation (only for Simple and Simpler algorithms) or a scalar equation. It is adviced to use the default value (1e6) to solve the implicit system only once by time step. This value must be decreased when a coupling between problems is considered.
  attr seuil_convergence_solveur floattant seuil_convergence_solveur 1 value of the convergence criteria for the resolution of the implicit system build by solving several times per time step the Navier_Stokes equation and the scalar equations if any. This value MUST be used when a coupling between problems is considered (should be set to a value typically of 0.1 or 0.01).
  attr seuil_generation_solveur floattant seuil_generation_solveur 1 Option to create a GMRES solver and use vrel as the convergence threshold (implicit linear system Ax=B will be solved if residual error ||Ax-B|| is lesser than vrel).
  attr seuil_verification_solveur floattant seuil_verification_solveur 1 Option to check if residual error ||Ax-B|| is lesser than vrel after the implicit linear system Ax=B has been solved.
  attr seuil_test_preliminaire_solveur floattant seuil_test_preliminaire_solveur 1 Option to decide if the implicit linear system Ax=B should be solved by checking if the residual error ||Ax-B|| is bigger than vrel.
  attr solveur solveur_sys_base solveur 1 Method (different from the default one, Gmres with diagonal preconditioning) to solve the linear system.
  attr no_qdm rien no_qdm 1 Keyword to not solve qdm equation (and turbulence models of these equation).
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gmres.
  attr controle_residu rien controle_residu 1 Keyword of Boolean type (by default 0). If set to 1, the convergence occurs if the residu suddenly increases.
piso simpler piso -1 Piso (Pressure Implicit with Split Operator) - method to solve N_S.
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 1 Convergence criteria.
  attr nb_corrections_max entier nb_corrections_max 1 Maximum number of corrections performed by the PISO algorithm to achieve the projection of the velocity field. The algorithm may perform less corrections then nb_corrections_max if the accuracy of the projection is sufficient. (By default nb_corrections_max is set to 21).
implicite piso implicite -1 similar to PISO, but as it looks like a simplified solver, it will use fewer timesteps. But it may run faster because the pressure matrix is not re-assembled and thus provides CPU gains.
simple piso simple -1 SIMPLE type algorithm
  attr relax_pression floattant relax_pression 0 Value between 0 and 1 (by default 1), this keyword is used only by the SIMPLE algorithm for relaxing the increment of pressure.
parametre_equation_base objet_lecture parametre_equation_base -1 Basic class for parametre_equation
parametre_diffusion_implicite parametre_equation_base parametre_diffusion_implicite -1 To specify additional parameters for the equation when using impliciting diffusion
  attr crank entier(into=[0,1]) crank 1 Use (1) or not (0, default) a Crank Nicholson method for the diffusion implicitation algorithm. Setting crank to 1 increases the order of the algorithm from 1 to 2.
  attr preconditionnement_diag entier(into=[0,1]) preconditionnement_diag 1 The CG used to solve the implicitation of the equation diffusion operator is not preconditioned by default. If this option is set to 1, a diagonal preconditionning is used. Warning: this option is not necessarily more efficient, depending on the treated case.
  attr niter_max_diffusion_implicite entier niter_max_diffusion_implicite 1 Change the maximum number of iterations for the CG (Conjugate Gradient) algorithm when solving the diffusion implicitation of the equation.
  attr seuil_diffusion_implicite floattant seuil_diffusion_implicite 1 Change the threshold convergence value used by default for the CG resolution for the diffusion implicitation of this equation.
parametre_implicite parametre_equation_base parametre_implicite -1 Keyword to change for this equation only the parameter of the implicit scheme used to solve the problem.
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 1 Keyword to change for this equation only the value of seuil_convergence_implicite used in the implicit scheme.
  attr seuil_convergence_solveur floattant seuil_convergence_solveur 1 Keyword to change for this equation only the value of seuil_convergence_solveur used in the implicit scheme
  attr solveur solveur_sys_base solveur 1 Keyword to change for this equation only the solver used in the implicit scheme
  attr resolution_explicite rien resolution_explicite 1 To solve explicitly the equation whereas the scheme is an implicit scheme.
  attr equation_non_resolue rien equation_non_resolue 1 Keyword to specify that the equation is not solved.
  attr equation_frequence_resolue chaine equation_frequence_resolue 1 Keyword to specify that the equation is solved only every n time steps (n is an integer or given by a time-dependent function f(t)).
schema_implicite_base schema_temps_base schema_implicite_base -1 Basic class for implicite time scheme.
  attr max_iter_implicite entier max_iter_implicite 1 Maximum number of iterations allowed for the solver (by default 200).
  attr solveur solveur_implicite_base solveur 0 This keyword is used to designate the solver selected in the situation where the time scheme is an implicit scheme. solver is the name of the solver that allows equation diffusion and convection operators to be set as implicit terms. Keywords corresponding to this functionality are Simple (SIMPLE type algorithm), Simpler (SIMPLER type algorithm) for incompressible systems, Piso (Pressure Implicit with Split Operator), and Implicite (similar to PISO, but as it looks like a simplified solver, it will use fewer timesteps. But it may run faster because the pressure matrix is not re-assembled and thus provides CPU gains. NL2 Advice: Since the 1.6.0 version, we recommend to use first the Implicite or Simple, then Piso, and at least Simpler. Because the two first give a fastest convergence (several times) than Piso and the Simpler has not been validated. It seems also than Implicite and Piso schemes give better results than the Simple scheme when the flow is not fully stationary. Thus, if the solution obtained with Simple is not stationary, it is recommended to switch to Piso or Implicite scheme.
schema_euler_implicite schema_implicite_base schema_euler_implicite -1 This is the Euler implicite scheme.
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
un_pb objet_lecture nul 0 pour les groupes
  attr mot ref_Pb_base mot 0 the string
list_un_pb listobj nul 1 un_pb 1 pour les groupes
list_list_nom listobj nul 1 list_un_pb 1 pour les groupes
coupled_problem pb_gen_base probleme_couple -1 This instruction causes a probleme_couple type object to be created. This type of object has an associated problem list, that is, the coupling of n problems among them may be processed. Coupling between these problems is carried out explicitly via conditions at particular contact limits. Each problem may be associated either with the Associate keyword or with the Read/groupes keywords. The difference is that in the first case, the four problems exchange values then calculate their timestep, rather in the second case, the same strategy is used for all the problems listed inside one group, but the second group of problem exchange values with the first group of problems after the first group did its timestep. So, the first case may then also be written like this: NL2 Probleme_Couple pbc NL2 Read pbc { groupes { { pb1 , pb2 , pb3 , pb4 } } } NL2 There is a physical environment per problem (however, the same physical environment could be common to several problems). NL2 Each problem is resolved in a domain. NL2 Warning : Presently, coupling requires coincident meshes. In case of non-coincident meshes, boundary condition \'paroi_contact\' in VEF returns error message (see paroi_contact for correcting procedure).
  attr groupes list_list_nom groupes 1 { groupes { { pb1 , pb2 } , { pb3 , pb4 } } }
  ref domaine_2 domaine
  ref pb_1 Pb_base
  ref pb_2 Pb_base
  ref pb_3 Pb_base
  ref pb_4 Pb_base
  ref scheme_2 schema_temps_base
mor_eqn objet_u mor_eqn -1 Class of equation pieces (morceaux d\'equation).
bords_ecrire objet_lecture nul 0 not_set
  attr chaine chaine(into=["bords"]) chaine 0 not_set
  attr bords listchaine bords 0 Keyword to post-process only on some boundaries : NL2 bords nb_bords boundary1 ... boundaryn NL2 where NL2 nb_bords : number of boundaries NL2 boundary1 ... boundaryn : name of the boundaries.
ecrire_fichier_xyz_valeur_item objet_lecture nul 0 To write the values of a field for some boundaries in a text file. NL2 The name of the files is pb_name_field_name_time.dat NL2 Several Ecrire_fichier_xyz_valeur keywords may be written into an equation to write several fields. This kind of files may be read by Champ_don_lu or Champ_front_lu for example.
  attr name chaine name 0 Name of the field to write (Champ_Inc, Champ_Fonc or a post_processed field).
  attr dt_ecrire_fic floattant dt_ecrire_fic 0 Time period for printing in the file.
  attr bords bords_ecrire bords 1 to post-process only on some boundaries
ecrire_fichier_xyz_valeur_param listobj nul -2 ecrire_fichier_xyz_valeur_item ecrire_fichier_xyz_valeur not_set
convection_deriv objet_lecture convection_deriv 0 not_set
bloc_convection objet_lecture nul 0 not_set
  attr aco chaine(into=["{"]) aco 0 Open accodance sign.
  attr operateur convection_deriv operateur 0 not_set
  attr acof chaine(into=["}"]) acof 0 Closed accodance sign.
diffusion_deriv objet_lecture diffusion_deriv 0 not_set
op_implicite objet_lecture nul 0 not_set
  attr implicite chaine(into=["implicite"]) implicite 0 not_set
  attr mot chaine(into=["solveur"]) mot 0 not_set
  attr solveur solveur_sys_base solveur 0 not_set
bloc_diffusion objet_lecture nul 0 not_set
  attr aco chaine(into=["{"]) aco 0 Open accodance sign.
  attr operateur diffusion_deriv operateur 1 if none is specified, the diffusive scheme used is an order 2 scheme.
  attr op_implicite op_implicite op_implicite 1 To have diffusive implicitation, it use Uzawa algorithm. Very useful when viscosity has large variations.
  attr acof chaine(into=["}"]) acof 0 Closed accodance sign.
eqn_base mor_eqn eqn_base -3 Basic class for equations.
  attr convection bloc_convection convection 1 Keyword to alter the convection scheme.
  attr diffusion bloc_diffusion diffusion 1 Keyword to specify the diffusion operator.
  attr conditions_initiales|initial_conditions condinits conditions_initiales 1 Initial conditions.
  attr conditions_limites|boundary_conditions condlims conditions_limites 1 Boundary conditions.
  attr sources sources sources 1 To introduce a source term into an equation (in case of several source terms into the same equation, the blocks corresponding to the various terms need to be separated by a comma)
  attr ecrire_fichier_xyz_valeur ecrire_fichier_xyz_valeur_param ecrire_fichier_xyz_valeur 1 This keyword is used to write the values of a field for the whole domain or only for some boundaries in a text file with the following format: n_valeur NL2 x_1 y_1 [z_1] val_1 NL2 ... NL2 x_n y_n [z_n] val_n NL2 The created files are named : pbname_fieldname_[boundaryname]_time.dat
  attr ecrire_fichier_xyz_valeur_bin ecrire_fichier_xyz_valeur_param ecrire_fichier_xyz_valeur_bin 1 This keyword is used to write the values of a field for the whole domain or only for some boundaries in a binary file with the following format: n_valeur NL2 x_1 y_1 [z_1] val_1 NL2 ... NL2 x_n y_n [z_n] val_n NL2 The created files are named : pbname_fieldname_[boundaryname]_time.dat
  attr parametre_equation parametre_equation_base parametre_equation 1 Keyword used to specify additional parameters for the equation
  attr equation_non_resolue chaine equation_non_resolue 1 The equation will not be solved while condition(t) is verified if equation_non_resolue keyword is used. Exemple: The Navier Stokes is not solved between time t0 and t1. NL2 Navier_Sokes_Standard NL2 { equation_non_resolue (t>t0)*(t<t1) }
traitement_particulier_base objet_lecture traitement_particulier_base 1 Basic class to post-process particular values.
traitement_particulier objet_lecture nul 0 Auxiliary class to post-process particular values.
  attr aco chaine(into=["{"]) aco 0 Open accodance sign.
  attr trait_part traitement_particulier_base trait_part 0 Type of traitement_particulier.
  attr acof chaine(into=["}"]) acof 0 Closed accodance sign.
navier_stokes_standard eqn_base navier_stokes_standard -1 NAVIER STOKES equations.
  attr methode_calcul_pression_initiale chaine(into=["avec_les_cl","avec_sources","avec_sources_et_operateurs","sans_rien"]) methode_calcul_pression_initiale 1 Keyword to select an option for the pressure calculation before the fist time step. Options are : avec_les_cl (default option lapP=0 is solved with Neuman boundary conditions on pressure if any), avec_sources (lapP=f is solved with Neuman boundaries conditions and f integrating the source terms of the Navier Stokes equation) and avec_sources_et_operateurs (lapP=f is solved as with the previous option avec_sources but f integrating also some operators of the Navier Stokes equation). The two last options are useful and sometime necessary when source terms are implicited when using an implicit time scheme to solve the Navier Stokes equation.
  attr projection_initiale entier projection_initiale 1 Keyword to suppress, if boolean equals 0, the initial projection which checks DivU=0. By default, boolean equals 1.
  attr solveur_pression solveur_sys_base solveur_pression 1 Linear pressure system resolution method.
  attr solveur_bar solveur_sys_base solveur_bar 1 This keyword is used to define when filtering operation is called (typically for EF convective scheme, standard diffusion operator and Source_Qdm_lambdaup ). A file (solveur.bar) is then created and used for inversion procedure. Syntax is the same then for pressure solver (GCP is required for multi-processor calculations and, in a general way, for big meshes).
  attr dt_projection deuxmots dt_projection 1 nb value : This keyword checks every nb time-steps the equality of velocity divergence to zero. value is the criteria convergency for the solver used.
  attr seuil_divU floatfloat seuil_divU 1 value factor : this keyword is intended to minimise the number of iterations during the pressure system resolution. The convergence criteria during this step (\'seuil\' in solveur_pression) is dynamically adapted according to the mass conservation. At tn , the linear system Ax=B is considered as solved if the residual ||Ax-B||<seuil(tn). For tn+1, the threshold value seuil(tn+1) will be evualated as: NL2 If ( |max(DivU)*dt|<value ) NL2 Seuil(tn+1)= Seuil(tn)*factor NL2 Else NL2 Seuil(tn+1)= Seuil(tn)*factor NL2 Endif NL2 The first parameter (value) is the mass evolution the user is ready to accept per timestep, and the second one (factor) is the factor of evolution for \'seuil\' (for example 1.1, so 10% per timestep). Investigations has to be lead to know more about the effects of these two last parameters on the behaviour of the simulations.
  attr traitement_particulier traitement_particulier traitement_particulier 1 Keyword to post-process particular values.
penalisation_l2_ftd_lec objet_lecture nul 0 not_set
  attr bord chaine bord 0 not_set
  attr val list val 0 not_set
penalisation_l2_ftd listobj pp 1 penalisation_l2_ftd_lec 0 not_set
convection_diffusion_temperature eqn_base convection_diffusion_temperature -1 Energy equation (temperature diffusion convection).
  attr penalisation_l2_ftd penalisation_l2_ftd penalisation_l2_ftd 1 to activate or not (the default is Direct Forcing method) the Penalized Direct Forcing method to impose the specified temperature on the solid-fluid interface.
pb_thermohydraulique Pb_base pb_thermohydraulique -1 Resolution of thermohydraulic problem.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 NAVIER STOKES equations.
  attr convection_diffusion_temperature convection_diffusion_temperature convection_diffusion_temperature 1 Energy equation (temperature diffusion convection).
pb_hydraulique Pb_base pb_hydraulique -1 Resolution of the NAVIER STOKES equations.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 0 NAVIER STOKES equations.
turbulence_paroi_base objet_u turbulence_paroi_base -1 Basic class for wall laws for NAVIER STOKES equations.
dt_impr_ustar_mean_only objet_lecture nul 1 not_set
  attr dt_impr floattant dt_impr 0 not_set
  attr boundaries listchaine boundaries 1 not_set
modele_turbulence_hyd_deriv objet_lecture modele_turbulence_hyd_deriv -1 Basic class for turbulence model for NAVIER STOKES equations.
  attr correction_visco_turb_pour_controle_pas_de_temps rien correction_visco_turb_pour_controle_pas_de_temps 1 Keyword to set a limitation to low time steps due to high values of turbulent viscosity. The limit for turbulent viscosity is calculated so that diffusive time-step is equal or higher than convective time-step. For a stationary flow, the correction for turbulent viscosity should apply only during the first time steps and not when permanent state is reached. To check that, we could post process the corr_visco_turb field which is the correction of turbulent viscosity: it should be 1. on the whole domain.
  attr correction_visco_turb_pour_controle_pas_de_temps_parametre floattant correction_visco_turb_pour_controle_pas_de_temps_parametre 1 Keyword to set a limitation to low time steps due to high values of turbulent viscosity. The limit for turbulent viscosity is the ratio between diffusive time-step and convective time-step is higher or equal to the given value [0-1]
  attr turbulence_paroi turbulence_paroi_base turbulence_paroi 1 Keyword to set the wall law.
  attr dt_impr_ustar floattant dt_impr_ustar 1 This keyword is used to print the values (U +, d+, u$\star$) obtained with the wall laws into a file named datafile_ProblemName_Ustar.face and periode refers to the printing period, this value is expressed in seconds.
  attr dt_impr_ustar_mean_only dt_impr_ustar_mean_only dt_impr_ustar_mean_only 1 This keyword is used to print the mean values of u* ( obtained with the wall laws) on each boundary, into a file named datafile_ProblemName_Ustar_mean_only.out. periode refers to the printing period, this value is expressed in seconds. If you don\'t use the optional keyword boundaries, all the boundaries will be considered. If you use it, you must specify nb_boundaries which is the number of boundaries on which you want to calculate the mean values of u*, then you have to specify their names.
  attr nut_max floattant nut_max 1 Upper limitation of turbulent viscosity (default value 1.e8).
modele_turbulence_hyd_nul modele_turbulence_hyd_deriv NUL 0 not_set
navier_stokes_turbulent navier_stokes_standard navier_stokes_turbulent -1 NAVIER STOKES equations as well as the associated turbulence model equations.
  attr modele_turbulence modele_turbulence_hyd_deriv modele_turbulence 1 Turbulence model for NAVIER STOKES equations.
pb_hydraulique_turbulent Pb_base pb_hydraulique_turbulent -1 Resolution of NAVIER STOKES equations with turbulence modelling.
  attr navier_stokes_turbulent navier_stokes_turbulent navier_stokes_turbulent 0 NAVIER STOKES equations as well as the associated turbulence model equations.
turbulence_paroi_scalaire_base objet_u turbulence_paroi_scalaire_base -1 Basic class for wall laws for energy equation.
modele_turbulence_scal_base objet_u modele_turbulence_scal_base -1 Basic class for turbulence model for energy equation.
  attr turbulence_paroi turbulence_paroi_scalaire_base turbulence_paroi 1 Keyword to set the wall law.
  attr dt_impr_nusselt floattant dt_impr_nusselt 1 Keyword to print local values of Nusselt number and temperature near a wall during a turbulent calculation. The values wil be printed in the _Nusselt.face file each dt_impr_nusselt time period. The local Nusselt expression is as follows : Nu = ((lambda+lambda_t)/lambda)*d_wall/d_eq where d_wall is the distance from the first mesh to the wall and d_eq is given by the wall law. This option also gives the value of d_eq and h = (lambda+lambda_t)/d_eq and the fluid temperature of the first mesh near the wall. NL2 For the Neumann boundary conditions (flux_impose), the <<equivalent>> wall temperature given by the wall law is also printed (Tparoi equiv.) preceded for VEF calculation by the edge temperature <<T face de bord>>.
convection_diffusion_temperature_turbulent eqn_base convection_diffusion_temperature_turbulent -1 Energy equation (temperature diffusion convection) as well as the associated turbulence model equations.
  attr modele_turbulence modele_turbulence_scal_base modele_turbulence 1 Turbulence model for the energy equation.
pb_thermohydraulique_turbulent Pb_base pb_thermohydraulique_turbulent -1 Resolution of thermohydraulic problem, with turbulence modelling.
  attr navier_stokes_turbulent navier_stokes_turbulent navier_stokes_turbulent 0 NAVIER STOKES equations as well as the associated turbulence model equations.
  attr convection_diffusion_temperature_turbulent convection_diffusion_temperature_turbulent convection_diffusion_temperature_turbulent 0 Energy equation (temperature diffusion convection) as well as the associated turbulence model equations.
conduction eqn_base conduction -1 Heat equation.
  attr convection suppress_param convection 1 Keyword to alter the convection scheme.
pb_conduction Pb_base pb_conduction -1 Resolution of the heat equation.
  attr conduction conduction conduction 1 Heat equation.
navier_stokes_qc navier_stokes_standard navier_stokes_qc -1 NAVIER STOKES equations under smal Mach number.
convection_diffusion_chaleur_qc eqn_base convection_diffusion_chaleur_qc -1 Energy equation under smal Mach number.
  attr mode_calcul_convection chaine(into=["ancien","divuT_moins_Tdivu","divrhouT_moins_Tdivrhou"]) mode_calcul_convection 1 Option to set the form of the convective operatorNL2 divrhouT_moins_Tdivrhou (the default since 1.6.8): rho.u.gradT = div(rho.u.T )- Tdiv(rho.u.1) NL2ancien: u.gradT = div(u.T) - T.div(u) NL2 divuT_moins_Tdivu : u.gradT = div(u.T) - Tdiv(u.1)
pb_thermohydraulique_qc Pb_base pb_thermohydraulique_qc -1 Resolution of thermohydraulic problem under smal Mach number. NL2 Keywords for the unknowns other than pressure, velocity, temperature are : NL2 masse_volumique : density NL2 enthalpie : enthalpy NL2 pression : reduced pressure NL2 pression_tot : total pressure.
  attr navier_stokes_qc navier_stokes_qc navier_stokes_qc 0 NAVIER STOKES equations under smal Mach number.
  attr convection_diffusion_chaleur_qc convection_diffusion_chaleur_qc convection_diffusion_chaleur_qc 0 Energy equation under smal Mach number.
navier_stokes_turbulent_qc navier_stokes_turbulent navier_stokes_turbulent_qc -1 NAVIER STOKES equations under smal Mach number as well as the associated turbulence model equations.
convection_diffusion_chaleur_turbulent_qc convection_diffusion_chaleur_qc convection_diffusion_chaleur_turbulent_qc -1 Energy equation under smal Mach number as well as the associated turbulence model equations.
  attr modele_turbulence modele_turbulence_scal_base modele_turbulence 1 Turbulence model for the energy equation.
pb_thermohydraulique_turbulent_qc Pb_base pb_thermohydraulique_turbulent_qc -1 Resolution of turbulent thermohydraulic problem under smal Mach number. NL2 Warning : Available for VDF and VEF P0/P1NC discretization only.
  attr navier_stokes_turbulent_qc navier_stokes_turbulent_qc navier_stokes_turbulent_qc 0 NAVIER STOKES equations under smal Mach number as well as the associated turbulence model equations.
  attr convection_diffusion_chaleur_turbulent_qc convection_diffusion_chaleur_turbulent_qc convection_diffusion_chaleur_turbulent_qc 0 Energy equation under smal Mach number as well as the associated turbulence model equations.
paroi_fixe condlim_base paroi_fixe -1 Keyword to designate a situation of adherence to the wall called bord (edge) (normal and tangential speed at the edge is zero).
paroi_ft_disc_deriv objet_lecture paroi_ft_disc_deriv 0 not_set
paroi_ft_disc_symetrie paroi_ft_disc_deriv symetrie 0 Symetrie condition in the case of two-phase flows
symetrie condlim_base symetrie -1 1). For NAVIER STOKES equations, this keyword is used to designate a symmetry condition concerning the speed at the boundary called bord (edge) (normal speed at the edge equal to zero and tangential speed gradient at the edge equal to zero); 2). For scalar transport equation, this keyword is used to set a symmetry condition on scalar on the boundary named bord (edge).
periodic condlim_base periodique -1 1). For NAVIER STOKES equations, this keyword is used to indicate the fact that the horizontal speed inlet values are the same as the outlet speed values, at every moment. As regards meshing, the inlet and outlet edges bear the same name.; 2). For scalar transport equation, this keyword is used to set a periodic condition on scalar. The two edges dealing with this periodic condition bear the same name.
paroi_decalee_robin condlim_base paroi_decalee_robin 1 This keyword is used to designate a Robin boundary condition (a.u+b.du/dn=c) associated with the Pironneau methodology for the wall laws. The value of given by the delta option is the distance between the mesh (where symmetry boundary condition is applied) and the fictious wall. This boundary condition needs the definition of the dedicated source terms (Source_Robin or Source_Robin_Scalaire) according the equations used.
  attr delta floattant delta 0 not_set
paroi_adiabatique condlim_base paroi_adiabatique -1 Normal zero flux condition at the wall called bord (edge).
front_field_base objet_u champ_front_base -1 Basic class for fields at domain boundaries.
dirichlet condlim_base dirichlet -1 Dirichlet condition at the boundary called bord (edge) : 1). For NAVIER STOKES equations, speed imposed at the boundary; 2). For scalar transport equation, scalar imposed at the boundary.
paroi_defilante dirichlet paroi_defilante -1 Keyword to designate a condition where tangential speed is imposed on the wall called bord (edge). If the speed set by the user is not tangential, projection is used.
  attr ch front_field_base ch 0 Boundary field type.
paroi_knudsen_non_negligeable dirichlet paroi_knudsen_non_negligeable -1 Boundary condition for number of Knudsen (Kn) above 0.001 where slip-flow condition appears: the velocity near the wall depends on the shear stress : Kn=l/L with l is the mean-free-path of the molecules and L a characteristic length scale. NL2 U(y=0)-Uwall=k(dU/dY) NL2 Where k is a coefficient given by several laws: NL2 Mawxell : k=(2-s)*l/s NL2 Bestok\&Karniadakis :k=(2-s)/s*L*Kn/(1+Kn) NL2 Xue\&Fan :k=(2-s)/s*L*tanh(Kn) NL2 s is a value between 0 and 2 named accomodation coefficient. s=1 seems a good value. NL2 Warning : The keyword is available for VDF calculation only for the moment.
  attr name_champ_1 chaine(into=["vitesse_paroi","k"]) name_champ_1 0 Field name.
  attr champ_1 front_field_base champ_1 0 Boundary field type.
  attr name_champ_2 chaine(into=["vitesse_paroi","k"]) name_champ_2 0 Field name.
  attr champ_2 front_field_base champ_2 0 Boundary field type.
paroi_rugueuse dirichlet paroi_rugueuse 1 Rough wall boundary
  attr erugu floattant erugu 0 Constant value for roughness
neumann condlim_base neumann -1 Neumann condition at the boundary called bord (edge) : 1). For NAVIER STOKES equations, constraint imposed at the boundary; 2). For scalar transport equation, flux imposed at the boundary.
frontiere_ouverte_vitesse_imposee dirichlet frontiere_ouverte_vitesse_imposee -1 Class for velocity-inlet boundary condition. The imposed speed field at the inlet is vectorial and the imposed speed values are expressed in m.s-1.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_vitesse_imposee_sortie frontiere_ouverte_vitesse_imposee frontiere_ouverte_vitesse_imposee_sortie -1 Sub-class for velocity boundary condition. The imposed speed field at the open boundary is vectorial and the imposed speed values are expressed in m.s-1.
frontiere_ouverte_rho_u_impose frontiere_ouverte_vitesse_imposee_sortie frontiere_ouverte_rho_u_impose -1 This keyword is used to designate a condition of imposed mass rate at an open boundary called bord (edge). The imposed mass rate field at the inlet is vectorial and the imposed speed values are expressed in kg.s-1. This boundary condition can be used only with the Quasi compressible model.
frontiere_ouverte_gradient_pression_libre_vef neumann frontiere_ouverte_gradient_pression_libre_vef -1 Class for outlet boundary condition in VEF like Orlansky. There is no reference for pressure for theses boundary conditions so it is better to add pressure condition (with Frontiere_ouverte_pression_imposee) on one or two cells (for symmetry in a channel) of the boundary where Orlansky conditions are imposed.
frontiere_ouverte_gradient_pression_libre_vefprep1b neumann frontiere_ouverte_gradient_pression_libre_vefprep1b -1 Class for outlet boundary condition in VEF P1B/P1NC like Orlansky.
frontiere_ouverte_gradient_pression_impose neumann frontiere_ouverte_gradient_pression_impose -1 Normal imposed pressure gradient condition on the open boundary called bord (edge). This boundary condition may be only used in VDF discretization. The imposed $\partial P/\partial n$ value is expressed in Pa.m-1.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_pression_imposee neumann frontiere_ouverte_pression_imposee -1 Imposed pressure condition at the open boundary called bord (edge). The imposed pressure field is expressed in Pa.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_pression_imposee_orlansky neumann frontiere_ouverte_pression_imposee_orlansky -1 This boundary condition may only be used with VDF discretization. There is no reference for pressure for this boundary condition so it is better to add pressure condition (with Frontiere_ouverte_pression_imposee) on one or two cells (for symetry in a channel) of the boundary where Orlansky conditions are imposed.
frontiere_ouverte_pression_moyenne_imposee neumann frontiere_ouverte_pression_moyenne_imposee 0 Class for open boundary with pressure mean level imposed.
  attr pext floattant pext 0 Mean pressure.
frontiere_ouverte neumann frontiere_ouverte -1 Boundary outlet condition on the boundary called bord (edge) (diffusion flux zero). This condition must be associated with a boundary outlet hydraulic condition.
  attr var_name chaine(into=["T_ext","C_ext","K_Eps_ext","Fluctu_Temperature_ext","Flux_Chaleur_Turb_ext","V2_ext"]) var_name 0 Field name.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_temperature_imposee dirichlet frontiere_ouverte_temperature_imposee -1 Imposed temperature condition at the open boundary called bord (edge) (in the case of fluid inlet). This condition must be associated with an imposed inlet speed condition. The imposed temperature value is expressed in oC or K.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_concentration_imposee dirichlet frontiere_ouverte_concentration_imposee -1 Imposed concentration condition at an open boundary called bord (edge) (situation corresponding to a fluid inlet). This condition must be associated with an imposed inlet speed condition.
  attr ch front_field_base ch 0 Boundary field type.
paroi_contact condlim_base paroi_contact -1 Thermal condition between two domains. Important: the name of the boundaries in the two domains should be the same. (Warning: there is also an old limitation not yet fixed on the sequential algorithm in VDF to detect the matching faces on the two boundaries: faces should be ordered in the same way). The kind of condition depends on the discretization. In VDF, it is a heat exchange condition, and in VEF, a temperature condition. NL2 Such a coupling requires coincident meshes for the moment. In case of non-coincident meshes, run is stopped and two external files are automatically generated in VEF (connectivity_failed_boundary_name and connectivity_failed_pb_name.med). In 2D, the keyword Decouper_bord_coincident associated to the connectivity_failed_boundary_name file allows to generate a new coincident mesh. NL2 In 3D, for a first preliminary cut domain with HOMARD (fluid for instance), the second problem associated to pb_name (solide in a fluid/solid coupling problem) has to be submitted to HOMARD cutting procedure with connectivity_failed_pb_name.med. NL2 Such a procedure works as while the primary refined mesh (fluid in our example) impacts the fluid/solid interface with a compact shape as described below (values 2 or 4 indicates the number of division from primary faces obtained in fluid domain at the interface after HOMARD cutting): NL2 2-2-2-2-2-2 NL2 2-4-4-4-4-4-2 \\; 2-2-2 NL2 2-4-4-4-4-2 \\; 2-4-2 NL2 2-2-2-2-2 \\; 2-2 NL2 OK NL2 NL2 2-2 \\; \\; 2-2-2 NL2 2-4-2 \\; 2-2 NL2 2-2 \\; 2-2 NL2 NOT OK
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 boundary name of the remote problem which should be the same than the local name
paroi_contact_fictif condlim_base paroi_contact_fictif -1 This keyword is derivated from paroi_contact and is especially dedicated to compute coupled fluid/solid/fluid problem in case of thin material. Thanks to this option, solid is considered as a fictitious media (no mesh, no domain associated), and coupling is performed by considering instantaneous thermal equilibrium in it (for the moment).
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 Name of bord.
  attr conduct_fictif floattant conduct_fictif 0 thermal conductivity
  attr ep_fictive floattant ep_fictive 0 thickness of the fictitious media
paroi_echange_contact_vdf condlim_base paroi_echange_contact_vdf -1 Boundary condition type to model the heat flux between two problems. Important: the name of the boundaries in the two problems should be the same.
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 Name of bord.
  attr temp chaine temp 0 Name of field.
  attr h floattant h 0 Value assigned to a coefficient (expressed in W.K-1m-2) that characterises the contact between the two mediums. In order to model perfect contact, h must be taken to be infinite. This value must obviously be the same in both the two problems blocks. NL2 The surface thermal flux exchanged between the two mediums is represented by : NL2 fi = h (T1-T2) where 1/h = d1/lambda1 + 1/val_h_contact + d2/lambda2 NL2 where di : distance between the node where Ti and the wall is found.
paroi_echange_externe_impose condlim_base paroi_echange_externe_impose -1 External type exchange condition with a heat exchange coefficient and an imposed external temperature.
  attr h_imp chaine h_imp 0 Heat exchange coefficient value (expressed in W.m-2.K-1).
  attr himpc front_field_base himpc 0 Boundary field type.
  attr text chaine text 0 External temperature value (expressed in oC or K).
  attr ch front_field_base ch 0 Boundary field type.
paroi_echange_global_impose condlim_base paroi_echange_global_impose -1 Global type exchange condition (internal) that is to say that diffusion on the first fluid mesh is not taken into consideration.
  attr h_imp chaine h_imp 0 Global exchange coefficient value. The global exchange coefficient value is expressed in W.m-2.K-1.
  attr himpc front_field_base himpc 0 Boundary field type.
  attr text chaine text 0 External temperature value. The external temperature value is expressed in oC or K.
  attr ch front_field_base ch 0 Boundary field type.
boussinesq_temperature source_base boussinesq_temperature -1 Class to describe a source term that couples the movement quantity equation and energy equation with the Boussinesq hypothesis.
  attr t0 chaine t0 0 Reference temperature value (oC or K). It can also be a time dependant function since the 1.6.6 version.
  attr verif_boussinesq entier verif_boussinesq 1 Keyword to check (1) or not (0) the reference temperature in comparison with the mean temperature value in the domain. It is set to 1 by default.
boussinesq_concentration source_base boussinesq_concentration -1 Class to describe a source term that couples the movement quantity equation and constituent transportation equation with the Boussinesq hypothesis.
  attr c0 list c0 0 Reference concentration field type. The only field type currently available is Champ_Uniforme (Uniform field).
  attr verif_boussinesq entier verif_boussinesq 1 Keyword to check (1) or not (0) the reference concentration in comparison with the mean concentration value in the domain. It is set to 1 by default.
dirac source_base dirac 0 Class to define a source term corresponding to a volume power release in the energy equation.
  attr position list position 0 not_set
  attr ch field_base ch 0 Thermal power field type. To impose a volume power on a domain sub-area, the Champ_Uniforme_Morceaux (partly_uniform_field) type must be used. NL2 Warning : The volume thermal power is expressed in W.m-3.
puissance_thermique source_base puissance_thermique 0 Class to define a source term corresponding to a volume power release in the energy equation.
  attr ch field_base ch 0 Thermal power field type. To impose a volume power on a domain sub-area, the Champ_Uniforme_Morceaux (partly_uniform_field) type must be used. NL2 Warning : The volume thermal power is expressed in W.m-3 in 3D. It is a power per volume unit (in a porous media, it is a power per fluid volume unit).
source_qdm_lambdaup source_base source_qdm_lambdaup 1 This source term is a dissipative term which is intended to minimise the energy associated to non-conformscales u\' (responsible for spurious oscillations in some cases). The equation for these scales can be seen as: du\'/dt= -lambda. u\' + grad P\' where -lambda. u\' represents the dissipative term, with lambda = a/Delta t For Crank-Nicholson temporal scheme, recommended value for a is 2. NL2 Remark : This method requires to define a filtering operator.
  attr lambda floattant lambda_u 0 value of lambda
  attr lambda_min floattant lambda_min 1 value of lambda_min
  attr lambda_max floattant lambda_max 1 value of lambda_max
  attr ubar_umprim_cible floattant ubar_umprim_cible 1 value of ubar_umprim_cible
source_th_tdivu source_base source_th_tdivu 0 This term source is dedicated for any scalar (called T) transportation. Coupled with upwind (amont) or muscl scheme, this term gives for final expression of convection : div(U.T)-T.div (U)=U.grad(T) This ensures, in incompressible flow when divergence free is badly resolved, to stay in a better way in the physical boundaries. NL2 Warning: Only available in VEF discretization.
source_robin source_base source_robin 0 This source term should be used when a Paroi_decalee_Robin boundary condition is set in a hydraulic equation. The source term will be applied on the N specified boundaries. To post-process the values of tauw, u_tau and Reynolds_tau into the files tauw_robin.dat, reynolds_tau_robin.dat and u_tau_robin.dat, you must add a block Traitement_particulier { canal { } }
  attr bords vect_nom bords 0 not_set
source_robin_scalaire source_base source_robin_scalaire 0 This source term should be used when a Paroi_decalee_Robin boundary condition is set in a an energy equation. The source term will be applied on the N specified boundaries. The values temp_wall_valueI are the temperature specified on the Ith boundary. The last value dt_impr is a printing period which is mandatory to specify in the data file but has no effect yet.
  attr bords listdeuxmots_sacc bords 0 not_set
canal_perio source_base canal_perio 1 Momentum source term to maintain flow rate. The expression of the source term is: NL2 S(t) = (2*(Q(0) - Q(t))-(Q(0)-Q(t-dt))/(coeff*dt*area) NL2 NL2 Where: NL2 coeff=damping coefficient NL2 area=area of the periodic boundary NL2 Q(t)=flow rate at time t NL2 dt=time step NL2 NL2 Three files will be created during calculation on a datafile named DataFile.data. The first file contains the flow rate evolution. The second file is useful for restarting a calculation with the flow rate of the previous stopped calculation, and the last one contains the pressure gradient evolution: NL2 -DataFile_Channel_Flow_Rate_ProblemName_BoundaryName NL2 -DataFile_Channel_Flow_Rate_repr_ProblemName_BoundaryName NL2 -DataFile_Pressure_Gradient_ProblemName_BoundaryName
  attr bord chaine bord 0 The name of the (periodic) boundary normal to the flow direction.
  attr h floattant h 1 Half heigth of the channel.
  attr coeff floattant coeff 1 Damping coefficient (optional, default value is 10).
  attr debit_impose floattant debit_impose 1 Optional option to specify the aimed flow rate Q(0). If not used, Q(0) is computed by the code after the projection phase, where velocity initial conditions are slighlty changed to verify incompressibility.
champ_don_base field_base champ_don_base -1 Basic class for data fields (not calculated), p.e. physics properties.
uniform_field champ_don_base champ_uniforme 0 Field that is constant in space and stationary.
  attr val list val 0 Values of field components.
champ_uniforme_morceaux champ_don_base champ_uniforme_morceaux 0 Field which is partly constant in space and stationary.
  attr nom_dom ref_domaine nom_dom 0 Name of the domain to which the sub-areas belong.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr data bloc_lecture data 0 { Defaut val_def sous_zone_1 val_1 ... sous_zone_i val_i } By default, the value val_def is assigned to the field. It takes the sous_zone_i identifier Sous_Zone (sub_area) type object value, val_i. Sous_Zone (sub_area) type objects must have been previously defined if the operator wishes to use a Champ_Uniforme_Morceaux(partly_uniform_field) type object.
champ_uniforme_morceaux_tabule_temps champ_uniforme_morceaux champ_uniforme_morceaux_tabule_temps -1 this type of field is constant in space on one or several sub_zones and tabulated as a function of time.
testeur interprete testeur 0 not_set
  attr data bloc_lecture data 0 not_set
valeur_totale_sur_volume champ_uniforme_morceaux valeur_totale_sur_volume -1 Similar as Champ_Uniforme_Morceaux with the same syntax. Used for source terms when we want to specify a source term with a value given for the volume (eg: heat in Watts) and not a value per volume unit (eg: heat in Watts/m3).
field_func_xyz champ_don_base champ_fonc_xyz 0 Field defined by analytical functions. It makes it possible the definition of a field that depends on (x,y,z).
  attr dom ref_domaine dom 0 Name of domain of calculation.
  attr val listchaine val 0 List of functions on (x,y,z).
field_func_txyz champ_don_base champ_fonc_txyz 0 Field defined by analytical functions. It makes it possible the definition of a field that depends on the time and the space.
  attr dom ref_domaine dom 0 Name of domain of calculation.
  attr val listchaine val 0 List of functions on (t,x,y,z).
champ_don_lu champ_don_base champ_don_lu 0 Field to read a data field (values located at the center of the cells) in a file.
  attr dom ref_domaine dom 0 Name of the domain.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr file chaine file 0 Name of the file. NL2 This file has the following format: NL2 nb_val_lues -> Number of values readen in th file NL2 Xi Yi Zi -> Coordinates readen in the file NL2 Ui Vi Wi -> Value of the field
init_par_partie champ_don_base init_par_partie 0 ne marche que pour n_comp=1
  attr n_comp entier(into=[1]) n_comp 0 not_set
  attr val1 floattant val1 0 not_set
  attr val2 floattant val2 0 not_set
  attr val3 floattant val3 0 not_set
champ_front_uniforme front_field_base champ_front_uniforme 0 Boundary field which is constant in space and stationary.
  attr val list val 0 Values of field components.
champ_front_fonc_xyz front_field_base champ_front_fonc_xyz 0 Boundary field which is not constant in space.
  attr val listchaine val 0 Values of field components (mathematical expressions).
champ_front_fonc_txyz front_field_base champ_front_fonc_txyz 0 Boundary field which is not constant in space and in time.
  attr val listchaine val 0 Values of field components (mathematical expressions).
champ_front_fonc_pois_ipsn front_field_base champ_front_fonc_pois_ipsn 0 Boundary field champ_front_fonc_pois_ipsn.
  attr r_tube floattant r_tube 0 not_set
  attr umoy list umoy 0 not_set
  attr r_loc listf r_loc 0 not_set
champ_front_fonc_pois_tube front_field_base champ_front_fonc_pois_tube 0 Boundary field champ_front_fonc_pois_tube.
  attr r_tube floattant r_tube 0 not_set
  attr umoy list umoy 0 not_set
  attr r_loc listf r_loc 0 not_set
  attr r_loc_mult listentierf r_loc_mult 0 not_set
champ_front_tabule front_field_base champ_front_tabule 0 Constant field on the boundary, tabulated as a function of time.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr bloc bloc_lecture bloc 0 {nt1 t2 t3 ....tn u1 [v1 w1 ...] u2 [v2 w2 ...] u3 [v3 w3 ...] ... un [vn wn ...] } NL2 Values are entered into a table based on n couples (ti, ui) if nb_comp value is 1. The value of a field at a given time is calculated by linear interpolation from this table.
champ_front_fonction front_field_base champ_front_fonction 0 boundary field that is function of another field
  attr dim entier dim 0 Number of field components.
  attr inco chaine inco 0 Name of the field (for example: temperature).
  attr expression chaine expression 0 keyword to use a analytical expression like 10.*EXP(-0.1*val) where val be the keyword for the field.
champ_front_bruite front_field_base champ_front_bruite 0 Field which is variable in time and space in a random manner.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr bloc bloc_lecture bloc 0 { [N val L val ] Moyenne m_1.....[m_i ] Amplitude A_1.....[A_ i ]}: Random nois: If N and L are not defined, the ith component of the field varies randomly around an average value m_i with a maximum amplitude A_i. NL2 White noise: If N and L are defined, these two additional parameters correspond to L, the domain length and N, the number of nodes in the domain. Noise frequency will be between 2*Pi/L and 2*Pi*N/(4*L). NL2 For example, formula for speed: u=U0(t) v=U1(t)Uj(t)=Mj+2*Aj*bruit_blanc where bruit_blanc (white_noise) is the formula given in the mettre_a_jour (update) method of the Champ_front_bruite (noise_boundary_field) (Refer to the Ch_fr_bruite.cpp file).
champ_front_tangentiel_vef front_field_base champ_front_tangentiel_vef 0 Field to define the tangential speed vector field standard at the boundary in VEF discretisation.
  attr mot chaine(into=["vitesse_tangentielle"]) mot 0 Name of vector field.
  attr vit_tan floattant vit_tan 0 Vector field standard [m/s].
champ_front_lu front_field_base champ_front_lu 0 boundary field which is given from data issued from a read file. The format of this file has to be the same that the one generated by Ecrire_fichier_xyz_valeur NL2 Example for K and epsilon quantities to be defined for inlet condition in a boundary named \'entree\': NL2entree frontiere_ouverte_K_Eps_impose Champ_Front_lu dom 2pb_K_EPS_PERIO_1006.306198.dat
  attr domaine ref_domaine domain 0 Name of domain
  attr dim entier dim 0 number of components
  attr file chaine file 0 path for the read file
boundary_field_inward front_field_base boundary_field_inward 1 this field is used to define the normal vector field standard at the boundary in VDF or VEF discretization.
  attr normal_value chaine normal_value 0 normal vector value (positive value for a vector oriented outside to inside) which can depend of the time.
champ_front_pression_from_u front_field_base champ_front_pression_from_u 0 this field is used to define a pressure field depending of a velocity field.
  attr expression chaine expression 0 value depending of a velocity (like $2*u_moy^2$).
milieu_base objet_u milieu_base -1 Basic class for medium (physics properties of medium).
  attr rho field_base rho 1 Density (kg.m-3).
  attr cp field_base cp 1 Specific heat (J.kg-1.K-1).
  attr lambda field_base lambda_u 1 Conductivity (W.m-1.K-1).
  ref gravite field_base
solide milieu_base solide -1 Solid.
constituant milieu_base constituant -1 Constituent.
  attr coefficient_diffusion field_base coefficient_diffusion 1 Constituent diffusion coefficient value (m2.s-1). If a multi-constituent problem is being processed, the diffusivite will be a vectorial and each components will be the diffusion of the constituent.
source_constituant source_base source_constituant 0 Keyword to specify source rates, in [[C]/s], for each one of the nb constituents. [C] is the concentration unit.
  attr ch field_base ch 0 Field type.
fluide_incompressible milieu_base fluide_incompressible -1 This is a uncompressible fluid.
  attr beta_th field_base beta_th 1 Thermal expansion (K-1).
  attr mu field_base mu 1 Dynamic viscosity (kg.m-1.s-1).
  attr beta_co field_base beta_co 1 Volume expansion coefficient values in concentration.
  attr indice field_base indice 1 Refractivity of fluid.
  attr kappa field_base kappa 1 Absorptivity of fluid (m-1).
loi_etat_base objet_u loi_etat_base -1 Basic class for state laws.
perfect_gaz loi_etat_base gaz_parfait 1 Perfect gas.
  attr Cp floattant Cp 0 Specific heat at constant pressure (J/kg/K).
  attr Cv floattant Cv 1 Specific heat at constant volume (J/kg/K).
  attr gamma floattant gamma 1 Cp/Cv
  attr Prandtl floattant Prandtl 0 Prandtl number of the gas Pr=mu*Cp/lambda
  attr rho_constant_pour_debug field_base rho_constant_pour_debug 1 not_set
gaz_reel_rhot loi_etat_base gaz_reel_rhot 0 Real gas.
  attr bloc bloc_lecture bloc 0 Description.
bloc_sutherland objet_lecture nul 0 Sutherland law for viscosity mu(T)=mu0*((T0+C)/(T+C))*(T/T0)**1.5 and (optional) for conductivity lambda(T)=mu0*Cp/Prandtl*((T0+Slambda)/(T+Slambda))*(T/T0)**1.5
  attr m chaine(into=["mu0"]) m 0 not_set
  attr mu0 floattant mu0 0 not_set
  attr t chaine(into=["T0"]) t 0 not_set
  attr t0 floattant t0 0 not_set
  attr ms chaine(into=["Slambda"]) ms 1 not_set
  attr s floattant s 1 not_set
  attr mc chaine(into=["C"]) mc 0 not_set
  attr c floattant c 0 not_set
fluide_quasi_compressible fluide_incompressible fluide_quasi_compressible -1 Compressible flow at low mach number.
  attr sutherland bloc_sutherland sutherland 1 Sutherland law for viscosity and for conductivity.
  attr pression floattant pression 1 Initial pression.
  attr loi_etat loi_etat_base loi_etat 1 State law.
  attr traitement_pth chaine(into=["edo","constant","conservation_masse"]) traitement_pth 1 Particular treatment for the thermodynamic pressure Pth ; there are three possibilities: NL2 1) with the keyword \'edo\' the code computes Pth solving an O.D.E. ; in this case, the mass is not strictly conserved (it is the default case for quasi compressible computation): NL2 2) the keyword \'conservation_masse\' forces the conservation of the mass (closed geometry or with periodic boundaries condition) NL2 3) the keyword \'constant\' makes it possible to have a constant Pth ; it\'s the good choice when the flow is open (e.g. with pressure boundary conditions).
  attr traitement_rho_gravite chaine(into=["standard","moins_rho_moyen"]) traitement_rho_gravite 1 It may be :1) \`standard\` : the gravity term is evaluted with rho*g (It is the default). 2) \`moins_rho_moyen\` : the gravity term is evaluated with (rho-rhomoy) *g.
  attr temps_debut_prise_en_compte_drho_dt floattant temps_debut_prise_en_compte_drho_dt 1 While time<value, dRho/dt is set to zero (Rho, volumic mass). Useful for some calculation during the first time steps with big variation of temperature and volumic mass.
  attr omega_relaxation_drho_dt floattant omega_relaxation_drho_dt 1 Optional option to have a relaxed algorithm to solve the mass equation. value is used (1 per default) to specify omega.
  attr beta_th suppress_param beta_th 1 suppress
  attr beta_co suppress_param beta_co 1 suppress
form_a_nb_points objet_lecture nul 0 The structure fonction is calculated on nb points and we should add the 2 directions (0:OX, 1:OY, 2:OZ) constituting the homegeneity planes. Example for channel flows, planes parallel to the walls.
  attr nb entier(into=[4]) nb 0 Number of points.
  attr dir1 entier(max=2) dir1 0 First direction.
  attr dir2 entier(max=2) dir2 0 Second direction.
mod_turb_hyd_ss_maille modele_turbulence_hyd_deriv mod_turb_hyd_ss_maille -1 Class for sub-grid turbulence model for NAVIER STOKES equations.
  attr formulation_a_nb_points form_a_nb_points formulation_a_nb_points 1 The structure fonction is calculated on nb points and we should add the 2 directions (0:OX, 1:OY, 2:OZ) constituting the homegeneity planes. Example for channel flows, planes parallel to the walls.
  attr longueur_maille chaine(into=["volume","volume_sans_lissage","scotti","arrete"]) longueur_maille 1 different ways to calculate the characteristic length may be specified : NL2 volume : It is the default option. Characteristic length is based on the cubic root of the volume cells. A smoothing procedure is applied to avoid discontinuities of this quantity in VEF from a cell to another. NL2 volume_sans_lissage : For VEF only. Characteristic length is based on the cubic root of the volume cells (without smoothing procedure).NL2 scotti : Characteristic length is based on the cubic root of the volume cells and the Scotti correction is applied to take into account the stretching of the cell in the case of anisotropic meshes. NL2 arete : For VEF only. Characteristic length relies on the max edge (+ smoothing procedure) is taken into account.
sous_maille_wale mod_turb_hyd_ss_maille sous_maille_wale -1 This is the WALE-model. It is a new sub-grid scale model for eddy-viscosity in LES that has the following properties : NL2 - it goes naturally to 0 at the wall (it doesn\'t need any information on the wall position or geometry) NL2 - it has the proper wall scaling in o(y3) in the vicinity of the wall NL2 - it reproduces correctly the laminar to turbulent transition.
  attr cw floattant cw 0 The unique parameter (constant) of the WALE-model (by default value 0.5).
sous_maille_smago mod_turb_hyd_ss_maille sous_maille_smago -1 Smagorinsky sub-grid turbulence model. NL2 Nut=Cs1*Cs1*l*l*sqrt(2*S*S) NL2 K=Cs2*Cs2*l*l*2*S
  attr cs floattant cs 1 This is an optional keyword and the value is used to set the constant used in the Smagorinsky model (This is currently only valid for Smagorinsky models and it is set to 0.18 by default) .
combinaison mod_turb_hyd_ss_maille combinaison -1 This keyword specify a turbulent viscosity model where the turbulent viscosity is user-defined.
  attr nb_var listchaine nb_var 1 Number and names of variables which will be used in the turbulent viscosity definition (by default 0)
  attr fonction chaine fonction 1 Fonction for turbulent viscosity. X,Y,Z and variables defined previously can be used.
longueur_melange mod_turb_hyd_ss_maille longueur_melange -1 This model is based on mixing length modelling. For a non academic configuration, formulation used in the code can be expressed basically as : NL2 $nu_t=(Kappa.y)^2$.dU/dy NL2 Till a maximum distance (dmax) set by the user in the data file, y is set equal to the distance from the wall (dist_w) calculated previously and saved in file Wall_length.xyz. [see Distance_paroi keyword] NL2 Then (from y=dmax), y decreases as an exponential function : y=dmax*exp[-2.*(dist_w-dmax)/dmax]
  attr canalx floattant canalx 1 [height] : plane channel according to Ox direction (for the moment, formulation in the code relies on fixed heigh : H=2).
  attr tuyauz floattant tuyauz 1 [diameter] : pipe according to Oz direction (for the moment, formulation in the code relies on fixed diameter : D=2).
  attr verif_dparoi chaine verif_dparoi 1 not_set
  attr dmax floattant dmax 1 Maximum distance.
  attr fichier chaine fichier 1 not_set
  attr fichier_ecriture_K_Eps chaine fichier_ecriture_K_Eps 1 When a restart with k-epsilon model is envisaged, this keyword allows to generate external MED-format file with evaluation of k and epsilon quantities (based on eddy turbulent viscosity and turbulent characteristic length returned by mixing length model). The frequency of the MED file print is set equal to dt_impr_ustar. Moreover, k-eps MED field is automatically saved at the last time step. MED file is then used for the restarting K-Epsilon calculation with the Champ_Fonc_Med keyword.
sous_maille mod_turb_hyd_ss_maille sous_maille -1 Structure sub-grid function model.
prandtl modele_turbulence_scal_base prandtl -1 The Prandtl model. For the scalar equations, only the model based on Reynolds analogy is available. If K_Epsilon was selected in the hydraulic equation, Prandtl must be selected for the convection-diffusion temperature equation coupled to the hydraulic equation and Schmidt for the concentration equations.
  attr prdt chaine prdt 1 Keyword to modify the constant (Prdt) of Prandtl model : Alphat=Nut/Prdt Default value is 0.9
  attr prandt_turbulent_fonction_nu_t_alpha chaine prandt_turbulent_fonction_nu_t_alpha 1 Optional keyword to specify turbulent diffusivity (by default, alpha_t=nu_t/Prt) with another formulae, for example: alpha_t=nu_t2/(0,7*alpha+0,85*nu_tt) with the string nu_t*nu_t/(0,7*alpha+0,85*nu_t) where alpha is the thermal diffusivity.
schmidt modele_turbulence_scal_base schmidt -1 The Schmidt model. For the scalar equations, only the model based on Reynolds analogy is available. If K_Epsilon was selected in the hydraulic equation, Prandtl must be selected for the convection-diffusion temperature equation coupled to the hydraulic equation and Schmidt for the concentration equations.
  attr scturb floattant scturb 1 Keyword to modify the constant (Sct) of Schmlidt model : Dt=Nut/Sct Default value is 0.7.
modele_fonction_bas_reynolds_base objet_lecture modele_fonction_bas_reynolds_base -1 not_set
transport_k_epsilon eqn_base transport_k_epsilon -1 The (k-eps) transportation equation. To restart from a previous mixing length calculation, an external MED-format file containing reconstructed K and Epsilon quantities can be read (see fichier_ecriture_k_eps) thanks to the Champ_fonc_MED keyword. NL2 Warning, When used with the Quasi-compressible model, k and eps should be viewed as rho k and rho epsilon when defining initial and boundary conditions or when visualizing values for k and eps. This bug will be fixed in a future version.
  attr with_nu chaine(into=["yes","no"]) with_nu 1 yes/no
mod_turb_hyd_rans modele_turbulence_hyd_deriv mod_turb_hyd_rans -1 Class for RANS turbulence model for NAVIER STOKES equations.
  attr eps_min floattant eps_min 1 Lower limitation of epsilon (default value 1.e-10).
  attr eps_max floattant eps_max 1 Upper limitation of epsilon (default value 1.e+10).
  attr k_min floattant k_min 1 Lower limitation of k (default value 1.e-10).
  attr quiet rien quiet 1 To disable printing of information about k and epsilon.
k_epsilon mod_turb_hyd_rans k_epsilon -1 Turbulence model (k-eps).
  attr cmu floattant cmu 1 Keyword to modify the Cmu constant of k-eps model : Nut=Cmu*k*k/eps Default value is 0.09
  attr transport_k_epsilon transport_k_epsilon transport_k_epsilon 0 Keyword to define the (k-eps) transportation equation.
  attr modele_fonc_bas_reynolds modele_fonction_bas_reynolds_base modele_fonc_bas_reynolds 1 This keyword is used to set the bas Reynolds model used.
loi_standard_hydr_old turbulence_paroi_base loi_standard_hydr_old 0 not_set
loi_standard_hydr turbulence_paroi_base loi_standard_hydr 0 Keyword for the logarithmic wall law for a hydraulic problem. Loi_standard_hydr refers to first cell rank eddy-viscosity defined from continuous analytical functions, whereas Loi_standard_hydr_3couches from functions separataly defined for each sub-layer
loi_expert_hydr loi_standard_hydr loi_expert_hydr 1 This keyword is similar to the previous keyword Loi_standard_hydr but has several additional options into brackets.
  attr u_star_impose floattant u_star_impose 1 The value of the friction velocity (u*) is not calculated but given by the user.
  attr methode_calcul_face_keps_impose chaine(into=["toutes_les_faces_accrochees","que_les_faces_des_elts_dirichlet"]) methode_calcul_face_keps_impose 1 The available options select the algorithm to apply K and Eps boundaries condition (the algorithms differ according to the faces).NL2 toutes_les_faces_accrochees : Default option in 2D (the algorithm is the same than the algorithm used in Loi_standard_hydr) NL2 que_les_faces_des_elts_dirichlet : Default option in 3D (another algorithm where less faces are concerned when applying K-Eps boundary condition).
  attr kappa floattant kappa 1 The value can be changed from the default one (0.415)
  attr Erugu floattant Erugu 1 The value of E can be changed from the default one for a smooth wall (9.11). It is also possible to change the value for one boundary wall only with paroi_rugueuse keyword/
  attr A_plus floattant A_plus 1 The value can can be changed from the default one (26.0)
loi_standard_hydr_scalaire turbulence_paroi_scalaire_base loi_standard_hydr_scalaire 0 Keyword for the law of the wall.
loi_expert_scalaire loi_standard_hydr_scalaire loi_expert_scalaire 1 Keyword similar to keyword Loi_standard_hydr_scalaire but with additional option.
  attr prdt_sur_kappa floattant prdt_sur_kappa 1 This option is to change the default value of 2.12 in the scalable wall function.
  attr calcul_ldp_en_flux_impose entier(into=[0,1]) calcul_ldp_en_flux_impose 1 By default (value set to 0), the law of the wall is not applied for a wall with a Neumann condition. With value set to 1, the law is applied even on a wall with Neumann condition.
tparoi_vef champ_post_de_champs_post tparoi_vef -1 These keyword is used to post process (only for VEF discretization) the temperature field with a slight difference on boundaries with Neumann condition where law of the wall is applied on the temperature field. nom_pb is the problem name and field_name is the selected field name. A keyword (temperature_physique) is available to post process this field without using Definition_champs.
loi_analytique_scalaire turbulence_paroi_scalaire_base loi_analytique_scalaire 0 not_set
fourfloat objet_lecture nul 0 Four reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
  attr c floattant c 0 Third real.
  attr d floattant d 0 Fourth real.
twofloat objet_lecture nul 0 two reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
sonde_tble objet_lecture nul 0 not_set
  attr name chaine name 0 not_set
  attr point un_point point 0 not_set
liste_sonde_tble listobj nul 0 sonde_tble 0 not_set
paroi_tble turbulence_paroi_base paroi_tble 1 Keyword for the Thin Boundary Layer Equation wall-model (a more complete description of the model can be found into this PDF file). The wall shear stress is evaluated thanks to boundary layer equations applied in a one-dimensional fine grid in the near-wall region.
  attr n entier n 1 Number of nodes in the TBLE grid (mandatory option).
  attr facteur floattant facteur 1 Stretching ratio for the TBLE grid (to refine, the TBLE facteur must be greater than 1).
  attr modele_visco chaine modele_visco 1 File name containing the description of the eddy viscosity model.
  attr stats twofloat stats 1 Statistics of the TBLE velocity and turbulent viscosity profiles. 2 values are required : the starting time and ending time of the statistics computation.
  attr sonde_tble liste_sonde_tble sonde_tble 1 not_set
  attr restart rien restart 1 not_set
  attr stationnaire entierfloat stationnaire 1 not_set
  attr lambda chaine lambda_u 1 not_set
  attr mu chaine mu 1 not_set
  attr sans_source_boussinesq rien sans_source_boussinesq 1 not_set
  attr alpha floattant alpha 1 not_set
  attr kappa floattant kappa 1 not_set
paroi_tble_scal turbulence_paroi_scalaire_base paroi_tble_scal 1 Keyword for the Thin Boundary Layer Equation thermal wall-model.
  attr n entier n 1 Number of nodes in the TBLE grid (mandatory option).
  attr facteur floattant facteur 1 Stretching ratio for the TBLE grid (to refine, the TBLE facteur must be greater than 1).
  attr modele_visco chaine modele_visco 1 File name containing the description of the eddy viscosity model.
  attr nb_comp entier nb_comp 1 Number of component to solve in the fine grid (1 if 2D simulation (2D not available yet), 2 if 3D simulation).
  attr stats fourfloat stats 1 Statistics of the TBLE velocity and turbulent viscosity profiles. 4 values are required : the starting time of velocity averaging, the starting time of the RMS fluctuations, the ending time of the statistics computation and finally the print time period for the statistics.
  attr sonde_tble liste_sonde_tble sonde_tble 1 not_set
  attr prandtl floattant prandtl 1 not_set
loi_paroi_nu_impose turbulence_paroi_scalaire_base loi_paroi_nu_impose 1 Keyword to impose Nusselt numbers on the wall for the thermohydraulic problems. To use this option, it is necessary to give in the data file the value of the hydraulic diameter and the expression of the Nusselt number.
  attr nusselt chaine nusselt 0 The Nusselt number. This expression can be a function of x, y, z, Re (Reynolds number), Pr (Prandtl number).
  attr diam_hydr field_base diam_hydr 0 The hydraulic diameter.
negligeable turbulence_paroi_base negligeable 0 Keyword to suppress the calculation of a law of the wall with a turbulence model. The wall stress is directly calculated with the derivative of the velocity, in the direction perpendicular to the wall (tau_tan /rho= nu dU/dy). NL2 Warning: This keyword is not available for k-epsilon models. In that case you must choose a wall law.
negligeable_scalaire turbulence_paroi_scalaire_base negligeable_scalaire 0 Keyword to suppress the calculation of a law of the wall with a turbulence model for thermohydraulic problems. The wall stress is directly calculated with the derivative of the velocity, in the direction perpendicular to the wall.
utau_imp turbulence_paroi_base utau_imp 1 Keyword to impose the friction velocity on the wall with a turbulence model for thermohydraulic problems. There are two possibilities to use this keyword : NL2 1 - we can impose directly the value of the friction velocity u_star. NL2 2 - we can also give the friction coefficient and hydraulic diameter. So, TRUST determines the friction velocity by : u_star = U*sqrt(lambda_c/8).
  attr u_tau field_base u_tau 1 Field type.
  attr lambda_c chaine lambda_c 1 The friction coefficient. It can be function of the spatial coordinates x,y,z, the Reynolds number Re, and the hydraulic diameter.
  attr diam_hydr field_base diam_hydr 1 The hydraulic diameter.
source_transport_k_eps source_base source_transport_k_eps -1 Keyword to alter the source term constants in the standard k-eps model epsilon transportation equation. By default, these constants are set to: C1_eps=1.44 C2_eps=1.92
  attr c1_eps floattant c1_eps 1 First constant.
  attr c2_eps floattant c2_eps 1 Second constant.
Source_Transport_K_Eps_anisotherme source_transport_k_eps Source_Transport_K_Eps_anisotherme -1 Keywords to modify the source term constants in the anisotherm standard k-eps model epsilon transportation equation. By default, these constants are set to: C1_eps=1.44 C2_eps=1.92 C3_eps=1.0
  attr c3_eps floattant c3_eps 1 Third constant.
source_transport_k_eps_aniso_concen source_transport_k_eps source_transport_k_eps_aniso_concen -1 Keywords to modify the source term constants in the anisotherm standard k-eps model epsilon transportation equation. By default, these constants are set to: C1_eps=1.44 C2_eps=1.92 C3_eps=1.0
  attr c3_eps floattant c3_eps 1 Third constant.
source_transport_k_eps_aniso_therm_concen source_transport_k_eps source_transport_k_eps_aniso_therm_concen -1 Keywords to modify the source term constants in the anisotherm standard k-eps model epsilon transportation equation. By default, these constants are set to: C1_eps=1.44 C2_eps=1.92 C3_eps=1.0
  attr c3_eps floattant c3_eps 1 Third constant.
Paroi condlim_base Paroi 0 Impermeability condition at a wall called bord (edge) (standard flux zero). This condition must be associated with a wall type hydraulic condition.
frontiere_ouverte_k_eps_impose condlim_base frontiere_ouverte_k_eps_impose -1 Turbulence condition imposed on an open boundary called bord (edge) (this situation corresponds to a fluid inlet). This condition must be associated with an imposed inlet speed condition.
  attr ch front_field_base ch 0 Boundary field type.
precond_base objet_u precond_base -1 Basic class for preconditioning.
ssor precond_base ssor 1 Symmetric successive over-relaxation algorithm.
  attr omega floattant omega 0 Over-relaxation facteur (between 1 and 2, optimal value around 1.5-1.6).
ssor_bloc precond_base ssor_bloc -1 not_set
  attr alpha_0 floattant alpha_0 1 not_set
  attr precond0 precond_base precond0 1 not_set
  attr alpha_1 floattant alpha_1 1 not_set
  attr precond1 precond_base precond1 1 not_set
  attr alpha_a floattant alpha_a 1 not_set
  attr preconda precond_base preconda 1 not_set
precondsolv precond_base precondsolv 0 not_set
  attr solveur solveur_sys_base solveur 0 Solver type.
optimal solveur_sys_base optimal 1 Optimal is a solver which tests several solvers of the previous list to choose the fastest one for the considered linear system.
  attr seuil floattant seuil 0 Convergence threshold
  attr impr rien impr 1 To print the convergency of the fastest solver
  attr quiet rien quiet 1 To disable printing of information
  attr save_matrice|save_matrix rien save_matrice 1 To save the linear system (A, x, B) into a file
  attr frequence_recalc entier frequence_recalc 1 To set a time step period (by default, 100) for re-checking the fatest solver
  attr nom_fichier_solveur chaine nom_fichier_solveur 1 To specify the file containing the list of the tested solvers
  attr fichier_solveur_non_recree rien fichier_solveur_non_recree 1 To avoid the creation of the file containing the list
test_solveur interprete test_solveur 1 To test several solvers
  attr fichier_secmem chaine fichier_secmem 1 Filename containing the second member B
  attr fichier_matrice chaine fichier_matrice 1 Filename containing the matrix A
  attr fichier_solution chaine fichier_solution 1 Filename containing the solution x
  attr nb_test entier nb_test 1 Number of tests to measure the time resolution (one preconditionnement)
  attr impr rien impr 1 To print the convergence solver
  attr solveur solveur_sys_base solveur 1 To specify a solver
  attr fichier_solveur chaine fichier_solveur 1 To specify a file containing a list of solvers
  attr genere_fichier_solveur floattant genere_fichier_solveur 1 To create a file of the solver with a threshold convergence
  attr seuil_verification floattant seuil_verification 1 Check if the solution satisfy ||Ax-B||<precision
  attr pas_de_solution_initiale rien pas_de_solution_initiale 1 Resolution isn\'t initialized with the solution x
  attr ascii rien ascii 1 Ascii files
gen solveur_sys_base gen 0 not_set
  attr data bloc_lecture data 0 not_set
petsc solveur_sys_base petsc 0 Solveur via Petsc API NL2 \input{{solvpetsc}}
  attr solveur chaine solveur 0 not_set
  attr option_solveur bloc_lecture option_solveur 0 not_set
solv_gcp solveur_sys_base gcp 1 Preconditioned conjugated gradient.
  attr precond precond_base precond 1 Keyword to define system preconditioning in order to accelerate resolution by the conjugated gradient. Many parallel preconditioning methods are not equivalent to their sequential counterpart, and you should therefore expect differences, especially when you select a high value of the final residue (seuil). The result depends on the number of processors and on the mesh splitting. It is sometimes useful to run the solver with no preconditioning at all. In particular: NL2 - when the solver does not converge during initial projection, NL2 - when comparing sequential and parallel computations. NL2 With no preconditioning, except in some particular cases (no open boundary), the sequential and the parallel computations should provide exactly the same results within fpu accuracy. If not, there might be a coding error or the system of equations is singular.
  attr precond_nul rien precond_nul 1 Keyword to not use a preconditioning method.
  attr seuil floattant seuil 0 Value of the final residue. The gradient ceases iteration when the Euclidean residue standard ||Ax-B|| is less than this value.
  attr impr rien impr 1 Keyword which is used to request display of the Euclidean residue standard each time this iterates through the conjugated gradient (display to the standard outlet).
  attr quiet rien quiet 1 To not displaying any outputs of the solver.
  attr save_matrice|save_matrix rien save_matrice 1 to save the matrix in a file.
  attr optimized rien optimized 1 This keyword triggers a memory and network optimized algorithms useful for strong scaling (when computing less than 100 000 elements per processor). The matrix and the vectors are duplicated, common items removed and only virtual items really used in the matrix are exchanged.NL2 Warning: this is experimental and known to fail in some VEF computations (L2 projection step will not converge). Works well in VDF.
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gcp.
gcp_ns solv_gcp gcp_ns -1 not_set
  attr solveur0 solveur_sys_base solveur0 0 Solver type.
  attr solveur1 solveur_sys_base solveur1 0 Solver type.
cholesky solveur_sys_base cholesky -1 Cholesky direct method.
  attr impr rien impr 1 Keyword which may be used to print the resolution time.
  attr quiet rien quiet 1 To disable printing of information
gmres solveur_sys_base gmres -1 Gmres method (for non symetric matrix).
  attr impr rien impr 1 Keyword which may be used to print the convergence.
  attr quiet rien quiet 1 To disable printing of information
  attr seuil floattant seuil 1 Convergence value.
  attr diag rien diag 1 Keyword to use diagonal preconditionner (in place of pilut that is not parallel).
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gmres.
  attr controle_residu entier(into=["0","1"]) controle_residu 1 Keyword of Boolean type (by default 0). If set to 1, the convergence occurs if the residu suddenly increases.
  attr save_matrice|save_matrix rien save_matrice 1 to save the matrix in a file.
  attr dim_espace_krilov entier dim_espace_krilov 1 not_set
postraiter_domaine interprete postraiter_domaine 1 To write one or more domains in a file with a specified format (MED,LML,LATA).
  attr format chaine(into=["lml","lata","lata_v1","lata_v2","med"]) format 0 File format.
  attr fichier|file chaine fichier 1 The file name can be changed with the fichier option.
  attr domaine ref_domaine domain 1 Name of domain
  attr domaines bloc_lecture domaines 1 Names of domains : { name1 name2 }
  attr joints_non_postraites entier(into=[0,1]) joints_non_postraites 1 The joints_non_postraites (1 by default) will not write the boundaries between the partitioned mesh.
  attr binaire entier(into=[0,1]) binaire 1 Binary (binaire 1) or ASCII (binaire 0) may be used. By default, it is 0 for LATA and only ASCII is available for LML and only binary is available for MED.
  attr ecrire_frontiere entier(into=[0,1]) ecrire_frontiere 1 This option will write (if set to 1, the default) or not (if set to 0) the boundaries as fields into the file (it is useful to not add the boundaries when writing a domain extracted from another domain)
modif_bord_to_raccord interprete modif_bord_to_raccord -1 Keyword to convert a boundary of domain_name domain of kind Bord to a boundary of kind Raccord (named boundary_name). It is useful when using meshes with boundaries of kind Bord defined and to run a coupled calculation.
  attr domaine ref_domaine domain 0 Name of domain
  attr nom_bord chaine nom_bord 0 Name of the boundary to transform.
remove_elem_bloc objet_lecture nul 1 not_set
  attr liste listentier liste 1 not_set
  attr fonction chaine fonction 1 not_set
remove_elem interprete remove_elem -1 Keyword to remove element from a VDF mesh (named domaine_name), either from an explicit list of elements or from a geometric condition defined by a condition f(x,y)>0 in 2D and f(x,y,z)>0 in 3D. All the new borders generated are gathered in one boundary called : newBord (to rename it, use RegroupeBord keyword. To split it to different boundaries, use DecoupeBord_Pour_Rayonnement keyword). Example of a removed zone of radius 0.2 centered at (x,y)=(0.5,0.5): NL2 Remove_elem dom { fonction $0.2*0.2-(x-0.5)^2-(y-0.5)^2>0$ } NL2 Warning : the thickness of removed zone has to be large enough to avoid singular nodes as decribed below : \includepng{{removeelem.png}}{{11.234}}
  attr domaine ref_domaine domain 0 Name of domain
  attr bloc remove_elem_bloc bloc 0 not_set
regroupebord interprete regroupebord -1 Keyword to build one boundary new_bord with several boundaries of the domain named domaine.
  attr domaine ref_domaine domain 0 Name of domain
  attr new_bord chaine new_bord 0 Name of the new boundary
  attr bords bloc_lecture bords 0 { Bound1 Bound2 }
supprime_bord interprete supprime_bord -1 Keyword to remove boundaries (named Boundary_name1 Boundary_name2 ) of the domain named domain_name.
  attr domaine ref_domaine domain 0 Name of domain
  attr bords list_nom bords 0 { Boundary_name1 Boundaray_name2 }
lecture_bloc_moment_base objet_lecture nul 0 Auxiliary class for calcul and print of the moments.
calcul lecture_bloc_moment_base calcul -1 The centre of gravity will be calculated.
centre_de_gravite lecture_bloc_moment_base centre_de_gravite -1 To specify a specific centre of gravity.
  attr point un_point point 0 A centre of gravity.
calculer_moments interprete calculer_moments -1 Calculate and print the torque (moment of force) exerted by the fluid on each boundaries in output files (.out) of the domain nom_dom.
  attr nom_dom ref_domaine nom_dom 0 Name of domain.
  attr mot lecture_bloc_moment_base mot 0 Keyword.
imprimer_flux interprete imprimer_flux -1 This keyword allows the flux per face at the edges (boundaries) of a domain defined by the user in the data set to be printed. The flux are written to the .face files at a frequency defined by dt_impr, the evaluation printing frequency (refer to time scheme keywords). By default, flux are incorporated onto the edges before being displayed.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr noms_bord bloc_lecture noms_bord 0 Liste des noms des bords ex: { Bord1 Bord2 }
imprimer_flux_sum imprimer_flux imprimer_flux_sum -1 This keyword allows the sum of the flux per face at the boundaries of a domain defined by the user in the data set to be printed. The flux are written into the .out files at a frequency defined by dt_impr, the evaluation printing frequency (refer to time scheme keywords).
bloc_origine_cotes objet_lecture nul 0 Class to create a rectangle (or a box).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the origin of the rectangle (or the box).
  attr origin listf origine 0 Co-ordinates of the origin of the rectangle (or the box).
  attr name2 chaine(into=["Cotes"]) name2 0 Keyword to define the length along the axes.
  attr cotes listf cotes 0 Length along the axes.
bloc_couronne objet_lecture nul 0 Class to create a couronne (2D).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the center of the circle.
  attr origin listf origine 0 Center of the circle.
  attr name3 chaine(into=["ri"]) name3 0 Keyword to define the interior radius.
  attr ri floattant ri 0 Interior radius.
  attr name4 chaine(into=["re"]) name4 0 Keyword to define the exterior radius.
  attr re floattant re 0 Exterior radius.
bloc_tube objet_lecture nul 0 Class to create a tube (3D).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the center of the tube.
  attr origin listf origine 0 Center of the tube.
  attr name2 chaine(into=["dir"]) name2 0 Keyword to define the direction of the main axis.
  attr direction chaine(into=["X","Y","Z"]) direction 0 direction of the main axis X, Y or Z
  attr name3 chaine(into=["ri"]) name3 0 Keyword to define the interior radius.
  attr ri floattant ri 0 Interior radius.
  attr name4 chaine(into=["re"]) name4 0 Keyword to define the exterior radius.
  attr re floattant re 0 Exterior radius.
  attr name5 chaine(into=["hauteur"]) name5 0 Keyword to define the heigth of the tube.
  attr h floattant h 0 Heigth of the tube.
sous_zone objet_u sous_zone 1 It is an object type describing a domain sub-set. NL2 A Sous_Zone (Sub-area) type object must be associated with a Domaine type object. The Read (Lire) interpretor is used to define the items comprising the sub-area. NL2 Caution: The Domain type object nom_domaine must have been meshed (and triangulated or tetrahedralised in VEF) prior to carrying out the Associate (Associer) nom_sous_zone nom_domaine instruction; this instruction must always be preceded by the read instruction.
  attr restriction ref_sous_zone restriction 1 The elements of the sub-area nom_sous_zone must be included into the other sub-area named nom_sous_zone2. This keyword should be used first in the Read keyword.
  attr rectangle bloc_origine_cotes rectangle 1 The sub-area will include all the domain elements whose centre of gravity is within the Rectangle (in dimension 2).
  attr segment bloc_origine_cotes segment 1 not_set
  attr boite bloc_origine_cotes box 1 The sub-area will include all the domain elements whose centre of gravity is within the Box (in dimension 3).
  attr liste listentier liste 1 The sub-area will include n domain items, numbers No. 1 No. i No. n.
  attr fichier chaine filename 1 The sub-area is read into the file filename.
  attr intervalle deuxentiers intervalle 1 The sub-area will include domain items whose number is between n1 and n2 (where n1<=n2).
  attr polynomes bloc_lecture polynomes 1 A REPRENDRE
  attr couronne bloc_couronne couronne 1 In 2D case, to create a couronne.
  attr tube bloc_tube tube 1 In 3D case, to create a tube.
  attr fonction_sous_zone chaine fonction_sous_zone 1 Keyword to build a sub-area with the the elements included into the area defined by fonction>0.
  attr union ref_sous_zone union_with 1 The elements of the sub-area nom_sous_zone3 will be added to the sub-area nom_sous_zone. This keyword should be used last in the Read keyword.
  ref domaine domaine
decouper_bord_coincident interprete decouper_bord_coincident -1 In case of non-coincident meshes and a paroi_contact condition, run is stopped and two external files are automatically generated in VEF (connectivity_failed_boundary_name and connectivity_failed_pb_name.med). In 2D, the keyword Decouper_bord_coincident associated to the connectivity_failed_boundary_name file allows to generate a new coincident mesh.
  attr domain_name ref_domaine domain_name 0 Name of domain.
  attr bord chaine bord 0 connectivity_failed_boundary_name
raffiner_anisotrope interprete raffiner_anisotrope -1 Only for VEF discretizations, allow to cut triangle elements in 3, or tetrahedra in 4 parts, by defining a new summit located at the center of the element: \includepng{{raffineranisotri.pdf}}{{4}} \includepng{{raffineranisotetra.jpeg}}{{6}} NL2 Note that such a cut creates flat elements (anisotropic).
  attr domain_name ref_domaine domain_name 0 Name of domain.
raffiner_isotrope interprete raffiner_isotrope -1 For VDF and VEF discretizations, allows to cut triangles/quadrangles or tetrahedral/hexaedras elements respectively in 4 or 8 new ones by defining new summits located at the middle of edges (and center of faces and elements for quadrangles and hexaedra). Such a cut preserves the shape of original elements (isotropic). For 2D elements: \includetabfig{{raffinerisotri.pdf}}{{4}}{{raffinerisorect.pdf}}{{4}} For 3D elements: \includetabfig{{raffinerisotetra.jpeg}}{{6}}{{raffinerisohexa.jpeg}}{{5}}.
  attr domain_name ref_domaine domain_name 0 Name of domain.
triangulate interprete trianguler -1 To achieve a triangular mesh from a mesh comprising rectangles (2 triangles per rectangle). Should be used in VEF discretization. Principle: NL2 \includepng{{trianguler.pdf}}{{10}}
  attr domain_name ref_domaine domain_name 0 Name of domain.
trianguler_h triangulate trianguler_h -1 To achieve a triangular mesh from a mesh comprising rectangles (4 triangles per rectangle). Should be used in VEF discretization. Principle: NL2 \includepng{{triangulerh.pdf}}{{10}}
trianguler_fin triangulate trianguler_fin -1 Trianguler_fin is the recommended option to triangulate rectangles. NL2 As an extension (subdivision) of Triangulate_h option, this one cut each initial rectangle in 8 triangles (against 4, previously). This cutting ensures : NL2 - a correct cutting in the corners (in respect to pressure discretisation PreP1B). NL2 - a better isotropy of elements than with Trianguler_h option. NL2 - a better alignment of summits (this could have a benefit effect on calculation near walls since first elements in contact with it are all contained in the same constant thickness, and, by this way, a 2D cartesian grid based on summits can be engendered and used to realise statistical analysis in plan channel configuration for instance). Principle: NL2 \includepng{{triangulerfin.pdf}}{{10}}
tetraedriser interprete tetraedriser -1 To achieve a tetrahedral mesh based on a mesh comprising blocks, the Tetraedriser (Tetrahedralise) interpretor is used in VEF discretisation. Initial block is divided in 6 tetrahedra: \includepng{{tetraedriser.jpeg}}{{5}}
  attr domain_name ref_domaine domain_name 0 Name of domain.
orientefacesbord interprete orientefacesbord -1 Keyword to modify the order of the boundary verteces included in a domain, such that the surface normals are outer pointing.
  attr domain_name ref_domaine domain_name 0 Name of domain.
reorienter_tetraedres interprete reorienter_tetraedres -1 This keyword is mandatory for front-tracking computations with the VEF discretisation. For each tetrahedral element of the domain, it checks if it has a positive volume. If the volume (determinant of the three vectors) is negative, it swaps two nodes to reverse the orientation of this tetrahedron.
  attr domain_name ref_domaine domain_name 0 Name of domain.
reorienter_triangles interprete reorienter_triangles -1 not_set
  attr domain_name ref_domaine domain_name 0 Name of domain.
tetraedriser_homogene tetraedriser tetraedriser_homogene -1 Use the Tetraedriser_homogene (Homogeneous_Tetrahedralisation) interpretor in VEF discretisation to mesh a block in tetrahedrals. Each block hexahedral is no longer divided into 6 tetrahedrals (keyword Tetraedriser (Tetrahedralise)), it is now broken down into 40 tetrahedrals. Thus a block defined with 11 nodes in each X, Y, Z direction will contain 10*10*10*40=40,000 tetrahedrals. This also allows problems in the mesh corners with the P1NC/P1iso/P1bulle or P1/P1 discretisation items to be avoided. Initial block is divided in 40 tetrahedra: \includepng{{tetraedriserhomogene.jpeg}}{{5}}
tetraedriser_homogene_fin tetraedriser tetraedriser_homogene_fin -1 Tetraedriser_homogene_fin is the recommended option to tetrahedralise blocks. As an extension (subdivision) of Tetraedriser_homogene_compact, this last one cut each initial block in 48 tetrahedra (against 24, previously). This cutting ensures : NL2 - a correct cutting in the corners (in respect to pressure discretization PreP1B), NL2 - a better isotropy of elements than with Tetraedriser_homogene_compact, NL2 - a better alignment of summits (this could have a benefit effect on calculation near walls since first elements in contact with it are all contained in the same constant thickness and ii/ by the way, a 3D cartesian grid based on summits can be engendered and used to realise spectral analysis in HIT for instance). Initial block is divided in 48 tetrahedra: \includepng{{tetraedriserhomogenefin.jpeg}}{{5}}
tetraedriser_homogene_compact tetraedriser tetraedriser_homogene_compact -1 This new discretisation generates tetrahedral elements from cartesian or non-cartesian hexahedral elements. The process cut each hexahedral in 6 pyramids, each of them being cut then in 4 tetrahedral. So, in comparison with tetra_homogene, less elements (*24 instead of*40) with more homogeneous volumes are generated. Moreover, this process is done in a faster way. Initial block is divided in 24 tetrahedra: \includepng{{tetraedriserhomogenecompact.jpeg}}{{5}}
tetraedriser_par_prisme tetraedriser tetraedriser_par_prisme -1 Tetraedriser_par_prisme generates 6 iso-volume tetrahedral element from primary hexahedral one (contrarily to the 5 elements ordinarily generated by tetraedriser). This element is suitable for calculation of gradients at the summit (coincident with the gravity centre of the jointed elements related with) and spectra (due to a better alignment of the points). \includetabfig{{tetraedriserparprisme.jpeg}}{{5}}{{tetraedriserparprisme2.jpeg}}{{5}} Initial block is divided in 6 prismes.
verifiercoin interprete verifiercoin -1 This keyword subdivides inconsistent 2D/3D cells used with VEFPreP1B discretization. Must be used before the mesh is discretized. NL The Read_file option can be used only if the file.decoupage_som was previously created by TRUST. This option, only in 2D, reverses the common face at two cells (at least one is inconsistent), through the nodes opposed. In 3D, the option has no effect. NL2 The expert_only option deactivates, into the VEFPreP1B divergence operator, the test of inconsistent cells.
  attr dom ref_domaine dom 0 Name of domain.
paroi_flux_impose condlim_base paroi_flux_impose 0 Normal flux condition at the wall called bord (edge). The surface area of the flux (W.m-1 in 2D or W.m-2 in 3D) is imposed at the boundary according to the following convention: a positive flux is a flux that enters into the domain according to convention.
  attr ch front_field_base ch 0 Boundary field type.
paroi_temperature_imposee dirichlet paroi_temperature_imposee 0 Imposed temperature condition at the wall called bord (edge).
  attr ch front_field_base ch 0 Boundary field type.
temperature_imposee_paroi paroi_temperature_imposee temperature_imposee_paroi 0 Imposed temperature condition at the wall called bord (edge).
champ_front_contact_vef front_field_base champ_front_contact_vef 0 This field is used on a boundary between a solid and fluid domain to exchange a calculated temperature at the contact face of the two domains according to the flux of the two problems.
  attr local_pb ref_Pb_base local_pb 0 Name of the problem.
  attr local_boundary chaine local_boundary 0 Name of the boundary.
  attr remote_pb ref_Pb_base remote_pb 0 Name of the second problem.
  attr remote_boundary chaine remote_boundary 0 Name of the boundary in the second problem.
bloc_lecture_poro objet_lecture nul 1 Surface and volume porosity values.
  attr volumique floattant volumique 0 Volume porosity value.
  attr surfacique list surfacique 0 Surface porosity values (in X, Y, Z directions).
porosites interprete porosites 0 To define the volume porosity and surface porosity that are uniform in every direction in space on a sub-area. NL2 Porosity was only usable in VDF discretization, and now available for VEF P1NC/P0. NL2 Observations : NL2 - Surface porosity values must be given in every direction in space (set this value to 1 if there is no porosity), NL2 - Prior to defining porosity, the problem must have been discretized.NL2 Can \'t be used in VEF discretization, use Porosites_champ instead.
  attr pb ref_Pb_base pb 0 Name of the problem to which the sub-area is attached.
  attr sous_zone ref_sous_zone sous_zone 0 Name of the sub-area to which porosity are allocated.
  attr bloc bloc_lecture_poro bloc 0 Surface and volume porosity values.
porosites_champ interprete porosites_champ -2 The porosity is given at each element and the porosity at each face, Psi(face), is calculated by the average of the porosities of the two neighbour elements Psi(elem1), Psi(elem2) : Psi(face)=2/(1/Psi(elem1)+1/Psi(elem2)).
  attr pb ref_Pb_base pb 0 Name of the problem to which the sub-area is attached.
  attr ch field_base ch 0 field used to define the porosity field
discretiser_domaine interprete discretiser_domaine 0 Useful to discretize the domain domain_name (faces will be created) without defining a problem.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
champ_front_calc front_field_base champ_front_calc 0 This keyword is used on a boundary to get a field from another boundary. The local and remote boundaries should have the same mesh. If not, the Champ_front_recyclage keyword could be used instead. It is used in the condition block at the limits of equation which itself refers to a problem called pb1. We are working under the supposition that pb1 is coupled to another problem.
  attr problem_name ref_Pb_base problem_name 0 Name of the other problem to which pb1 is coupled.
  attr bord chaine bord 0 Name of the side which is the boundary between the 2 domains in the domain object description associated with the problem_name object.
  attr field_name chaine field_name 0 Name of the field containing the value that the user wishes to use at the boundary. The field_name object must be recognised by the problem_name object.
champ_tabule_temps champ_don_base champ_tabule_temps 0 Field that is constant in space and tabulated as a function of time.
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lecture bloc 0 Values as a table. The value of the field at any time is calculated by linear interpolation from this table.
champ_fonc_t champ_don_base champ_fonc_t 0 Field that is constant in space and is a function of time.
  attr val listchaine val 0 Values of field components (time dependant functions).
champ_fonc_tabule champ_don_base champ_fonc_tabule 0 Field that is tabulated as a function of another field.
  attr dim entier dim 0 Number of field components.
  attr inco chaine inco 0 Name of the field (for example: temperature).
  attr bloc bloc_lecture bloc 0 Values (the table (the value of the field at any time is calculated by linear interpolation from this table) or the analytical expression (with keyword expression to use an analytical expression)).
champ_fonc_fonction champ_fonc_tabule champ_fonc_fonction 0 Field that is a function of another field.
champ_fonc_fonction_txyz champ_fonc_fonction champ_fonc_fonction_txyz -1 this refers to a field that is a function of another field and time and/or space coordinates
frontiere_ouverte_gradient_pression_impose_vefprep1b frontiere_ouverte_gradient_pression_impose frontiere_ouverte_gradient_pression_impose_vefprep1b -1 Keyword for an outlet boundary condition in VEF P1B/P1NC on the gradient of the pressure.
bloc_lec_champ_init_canal_sinal objet_lecture nul 1 Parameters for the class champ_init_canal_sinal. NL2 in 2D: NL2 U=ucent*y(2h-y)/h/h NL2 V=ampli_bruit*rand+ampli_sin*sin(omega*x) NL2 rand: unpredictable value between -1 and 1. NL2 in 3D: NL2 U=ucent*y(2h-y)/h/h NL2 V=ampli_bruit*rand1+ampli_sin*sin(omega*x) NL2 W=ampli_bruit*rand2 NL2 rand1 and rand2: unpredictables values between -1 and 1.
  attr ucent floattant ucent 0 Velocity value at the center of the channel.
  attr h floattant h 0 Half hength of the channel.
  attr ampli_bruit floattant ampli_bruit 0 Amplitude for the disturbance.
  attr ampli_sin floattant ampli_sin 1 Amplitude for the sinusoidal disturbance (by default equals to ucent/10).
  attr omega floattant omega 0 Value of pulsation for the of the sinusoidal disturbance.
  attr dir_flow entier(into=[0,1,2]) dir_flow 1 Flow direction for the initialization of the flow in a channel. NL2 - if dir_flow=0, the flow direction is X NL2 - if dir_flow=1, the flow direction is Y NL2 - if dir_flow=2, the flow direction is Z NL2 Default value for dir_flow is 0
  attr dir_wall entier(into=[0,1,2]) dir_wall 1 Wall direction for the initialization of the flow in a channel. NL2 - if dir_wall=0, the normal to the wall is in X direction NL2 - if dir_wall=1, the normal to the wall is in Y direction NL2 - if dir_wall=2, the normal to the wall is in Z direction NL2 Default value for dir_flow is 1
  attr min_dir_flow floattant min_dir_flow 1 Value of the minimum coordinate in the flow direction for the initialization of the flow in a channel. Default value for dir_flow is 0.
  attr min_dir_wall floattant min_dir_wall 1 Value of the minimum coordinate in the wall direction for the initialization of the flow in a channel. Default value for dir_flow is 0.
champ_init_canal_sinal champ_don_base champ_init_canal_sinal 0 For a parabolic profile on U velocity with an unpredictable disturbance on V and W and a sinusoidal disturbance on V velocity.
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lec_champ_init_canal_sinal bloc 0 Parameters for the class champ_init_canal_sinal.
champ_som_lu_vdf champ_don_base champ_som_lu_vdf 0 Keyword to read in a file values located at the nodes of a mesh in VDF discretisation.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr dim entier dim 0 Value of the dimension of the field.
  attr tolerance floattant tolerance 0 Value of the tolerance to check the coordinates of the nodes.
  attr file chaine file 0 name of the file NL2 This file has the following format: NL2 Xi Yi Zi -> Coordinates of the node NL2 Ui Vi Wi -> Value of the field on this node NL2 Xi+1 Yi+1 Zi+1 -> Next point NL2 Ui+1 Vi+1 Zi+1 -> Next value ...
champ_som_lu_vef champ_don_base champ_som_lu_vef 0 Keyword to read in a file values located at the nodes of a mesh in VEF discretisation.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr dim entier dim 0 Value of the dimension of the field.
  attr tolerance floattant tolerance 0 Value of the tolerance to check the coordinates of the nodes.
  attr file chaine file 0 Name of the file. NL2 This file has the following format: NL2 Xi Yi Zi -> Coordinates of the node NL2 Ui Vi Wi -> Value of the field on this node NL2 Xi+1 Yi+1 Zi+1 -> Next point NL2 Ui+1 Vi+1 Zi+1 -> Next value ...
acceleration source_base acceleration 1 Momentum source term to take in account the forces due to rotation or translation of a non Galilean referential R\' (centre 0\') into the Galilean referential R (centre 0).
  attr vitesse field_base vitesse 1 Keyword for the velocity of the referential R\' into the R referential (dOO\'/dt term [m.s-1]). The velocity is mandatory when you want to print the total cinetic energy into the non-mobile Galilean referential R (see Ec_dans_repere_fixe keyword).
  attr acceleration field_base acceleration 1 Keyword for the acceleration of the referential R\' into the R referential (d2OO\'/dt2 term [m.s-2]). field_base is a time dependant field (eg: Champ_Fonc_t).
  attr omega field_base omega 1 Keyword for a rotation of the referential R\' into the R referential [rad.s-1]. field_base is a 3D time dependant field specified for example by a Champ_Fonc_t keyword. The time_field field should have 3 components even in 2D (In 2D: 0 0 omega).
  attr domegadt field_base domegadt 1 Keyword to define the time derivative of the previous rotation [rad.s-2]. Should be zero if the rotation is constant. The time_field field should have 3 components even in 2D (In 2D: 0 0 domegadt).
  attr centre_rotation field_base centre_rotation 1 Keyword to specify the centre of rotation (expressed in R\' coordinates) of R\' into R (if the domain rotates with the R\' referential, the centre of rotation is 0\'=(0,0,0)). The time_field should have 2 or 3 components according the dimension 2 or 3.
  attr option chaine(into=["terme_complet","coriolis_seul","entrainement_seul"]) option 1 Keyword to specify the kind of calculation: terme_complet (default option) will calculate both the Coriolis and centrifugal forces, coriolis_seul will calculate the first one only, entrainement_seul will calculate the second one only.
coriolis source_base coriolis 0 Keyword for a Coriolis term in hydraulic equation. Warning: Only available in VDF.
  attr omega chaine omega 0 Value of omega.
champ_front_recyclage front_field_base champ_front_recyclage 0 \input{{champfrontrecyclage}}
  attr bloc chaine bloc 0 not_set
paroi_echange_externe_impose_h paroi_echange_externe_impose paroi_echange_externe_impose_h -1 Particular case of class paroi_echange_externe_impose for enthalpy equation.
entree_temperature_imposee_h frontiere_ouverte_temperature_imposee entree_temperature_imposee_h -1 Particular case of class frontiere_ouverte_temperature_imposee for enthalpy equation.
sortie_libre_temperature_imposee_h neumann sortie_libre_temperature_imposee_h 0 Open boundary for heat equation with enthalpy as unknown.
  attr ch front_field_base ch 0 Boundary field type.
fluide_ostwald fluide_incompressible fluide_ostwald -1 Non-Newtonian fluids governed by Ostwald\'s law. The law applicable to stress tensor is: NL2 tau=K(T)*(D:D/2)**((n-1)/2)*D Where: NL2 D refers to the deformation speed tensor NL2 K refers to fluid consistency (may be a function of the temperature T) NL2 n refers to the fluid structure index n=1 for a Newtonian fluid, n<1 for a rheofluidifier fluid, n>1 for a rheothickening fluid.
  attr k field_base k 1 Fluid consistency.
  attr n field_base n 1 Fluid structure index.
champ_ostwald field_base champ_ostwald 0 This keyword is used to define the viscosity variation law: NL2 Mu(T)= K(T)*(D:D/2)**((n-1)/2)
tayl_green champ_don_base tayl_green 0 Class Tayl_green.
  attr dim entier dim 0 Dimension.
fonction_champ_reprise objet_lecture nul 0 not_set
  attr mot chaine(into=["fonction"]) mot 0 not_set
  attr fonction listchaine fonction 0 n f1(val) f2(val) ... fn(val)] time
champ_fonc_reprise champ_don_base champ_fonc_reprise 0 This field is used to read a data field in a save file (.xyz or .sauv) at a specified time. It is very useful, for example, to run a thermohydraulic calculation with velocity initial condition read into a save file from a previous hydraulic calculation.
  attr format chaine(into=["binaire","formatte","xyz"]) format 1 Type of file (the file format). If xyz format is activated, the .xyz file from the previous calculation will be given for filename, and if formatte or binaire is choosen, the .sauv file of the previous calculation will be specified for filename. In the case of a parallel calculation, if the mesh partition does not changed between the previous calculation and the next one, the binaire format should be preferred, because is faster than the xyz format.
  attr filename chaine filename 0 Name of the save file.
  attr pb_name ref_Pb_base pb_name 0 Name of the problem.
  attr champ chaine champ 0 Name of the problem unknown. It may also be the temporal average of a problem unknown (like moyenne_vitesse, moyenne_temperature,...)
  attr fonction fonction_champ_reprise fonction 1 Optional keyword to apply a function on the field being read in the save file (e.g. to read a temperature field in Celsius units and convert it for the calculation on Kelvin units, you will use: fonction 1 273.+val )
  attr temps chaine time 0 Time of the saved field in the save file or last_time. If you give the keyword last_time instead, the last time saved in the save file will be used.
source_qdm source_base source_qdm 0 Momentum source term in the Navier Stokes equation.
  attr ch field_base champ 0 Field type.
perte_charge_singuliere source_base perte_charge_singuliere 0 Source term that is used to model a pressure loss over a surface area (transition through a grid, sudden enlargement) defined by the faces of elements located on the intersection of a subzone named subzone_name and a X,Y, or Z plane located at X,Y or Z = location.
  attr dir chaine(into=["kx","ky","kz"]) dir 0 KX, KY or KZ designate directional pressure loss coefficients for respectively X, Y or Z direction.
  attr coeff floattant coeff 0 Value of friction coefficient (KX, KY, KZ).
  attr bloc_definition_surface bloc_lecture bloc_definition_surface 0 Two syntaxes are possible for the surface definition block: NL2 For VDF and VEF: { X|Y|Z = location subzone_name } NL2 Only for VEF: { Surface surface_name }.
perte_charge_directionnelle source_base perte_charge_directionnelle 1 Directional pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_isotrope source_base perte_charge_isotrope 1 Isotropic pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_anisotrope source_base perte_charge_anisotrope 1 Anisotropic pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr lambda_ortho chaine lambda_ortho 0 Function for loss coefficient in transverse direction which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_circulaire source_base perte_charge_circulaire 1 New pressure loss.
  attr lambda chaine lambda_u 0 Function f(Re_tot, Re_long, t, x, y, z) for loss coefficient in the longitudinal direction
  attr lambda_ortho chaine lambda_ortho 0 function: Function f(Re_tot, Re_ortho, t, x, y, z) for loss coefficient in transverse direction
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr diam_hydr_ortho champ_don_base diam_hydr_ortho 0 Transverse hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
convection_diffusion_concentration eqn_base convection_diffusion_concentration -1 Constituent transportation vectorial equation (concentration diffusion convection).
  attr nom_inconnue chaine nom_inconnue 1 Keyword Nom_inconnue will rename the unknown of this equation with the given name. In the postprocessing part, the concentration field will be accessible with this name. This is usefull if you want to track more than one concentration (otherwise, only the concentration field in the first concentration equation can be accessed).
  attr masse_molaire floattant masse_molaire 1 not_set
  attr alias chaine alias 1 not_set
convection_diffusion_concentration_turbulent convection_diffusion_concentration convection_diffusion_concentration_turbulent -1 Constituent transportation equations (concentration diffusion convection) as well as the associated turbulence model equations.
  attr modele_turbulence modele_turbulence_scal_base modele_turbulence 1 Turbulence model to be used in the constituent transportation equations. The only model currently available is Schmidt.
pb_hydraulique_concentration Pb_base pb_hydraulique_concentration -1 Resolution of NAVIER STOKES/multiple constituent transportation equations.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 NAVIER STOKES equations.
  attr convection_diffusion_concentration convection_diffusion_concentration convection_diffusion_concentration 1 Constituent transportation vectorial equation (concentration diffusion convection).
  ref constituant constituant
pb_hydraulique_concentration_turbulent Pb_base pb_hydraulique_concentration_turbulent -1 Resolution of NAVIER STOKES/multiple constituent transportation equations, with turbulence modelling.
  attr navier_stokes_turbulent navier_stokes_turbulent navier_stokes_turbulent 1 NAVIER STOKES equations as well as the associated turbulence model equations.
  attr convection_diffusion_concentration_turbulent convection_diffusion_concentration_turbulent convection_diffusion_concentration_turbulent 1 Constituent transportation equations (concentration diffusion convection) as well as the associated turbulence model equations.
  ref constituant constituant
pb_thermohydraulique_concentration Pb_base pb_thermohydraulique_concentration -1 Resolution of NAVIER STOKES/energy/multiple constituent transportation equations.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 NAVIER STOKES equations.
  attr convection_diffusion_concentration convection_diffusion_concentration convection_diffusion_concentration 1 Constituent transportation equations (concentration diffusion convection).
  attr convection_diffusion_temperature convection_diffusion_temperature convection_diffusion_temperature 1 Energy equation (temperature diffusion convection).
  ref constituant constituant
pb_thermohydraulique_concentration_turbulent Pb_base pb_thermohydraulique_concentration_turbulent -1 Resolution of NAVIER STOKES/energy/multiple constituent transportation equations, with turbulence modelling.
  attr navier_stokes_turbulent navier_stokes_turbulent navier_stokes_turbulent 1 NAVIER STOKES equations as well as the associated turbulence model equations.
  attr convection_diffusion_concentration_turbulent convection_diffusion_concentration_turbulent convection_diffusion_concentration_turbulent 1 Constituent transportation equations (concentration diffusion convection) as well as the associated turbulence model equations.
  attr convection_diffusion_temperature_turbulent convection_diffusion_temperature_turbulent convection_diffusion_temperature_turbulent 1 Energy equation (temperature diffusion convection) as well as the associated turbulence model equations.
  ref constituant constituant
darcy source_base darcy 0 Class for calculation in a porius media with source term of Darcy -nu/K*V. This keyword must be used with a permeability model. For the moment there are two models : permeability constant or Ergun\'s law. Darcy source term is available for quasi compressible calculation. A new keyword is aded for porosity (porosite).
  attr bloc bloc_lecture bloc 0 Description.
forchheimer source_base forchheimer 0 Class to add the source term of Forchheimer -Cf/sqrt(K)*V2 in the Navier Stokes equations. We must precise a permeability model : constant or Ergun\'s law. Moreover we can give the constant Cf : by default its value is 1. Forchheimer source term is available also for quasi compressible calculation. A new keyword is aded for porosity (porosite).
  attr bloc bloc_lecture bloc 0 Description.
debut_bloc interprete { 0 Block\'s beginning.
fin_bloc interprete } 0 Block\'s end.
export interprete export 0 Class to make the object have a global range, if not its range will apply to the block only (the associated object will be destroyed on exiting the block).
debog interprete debog 0 Class to debug some differences between two TRUST versions on a same data file. NL2 If you want to compare the results of the same code in sequential and parallel calculation, first run (mode=0) in sequential mode (the files fichier1 and fichier2 will be written first) then the second run in parallel calculation (mode=1). NL2 During the first run (mode=0), it prints into the file DEBOG, values at different points of the code thanks to the C++ instruction call. see for example in Noyau/Resoudre.cpp file the instruction: Debog::verifier(msg,value); Where msg is a string and value may be a double, integer or array. NL2 During the second run (mode=1), it prints into a file Err_Debog.dbg the same messages than in the DEBOG file and checks if the differences between results from the two codes are less than error. If not, it prints Ok else show the differences and the lines where it occured.
  attr pb ref_pb_gen_base pb 0 Name of the problem to debug.
  attr fichier1 chaine file1 0 Name of the file where domain will be written in sequential calculation.
  attr fichier2 chaine file2 0 Name of the file where faces will be written in sequential calculation.
  attr seuil floattant seuil 0 Minimal value (by default 1.e-20) for the differences between the two codes.
  attr mode entier mode 0 By default -1 (nothing is written in the different files), you will set 0 for the run with the first code, and 1 for the run with the second code.
pilote_icoco interprete pilote_icoco 1 not_set
  attr pb_name chaine pb_name 0 not_set
  attr main chaine main 0 not_set
ch_front_input front_field_base ch_front_input 1 not_set
  attr nb_comp entier nb_comp 0 not_set
  attr nom chaine nom 0 not_set
  attr initial_value list initial_value 1 not_set
  attr probleme chaine probleme 0 not_set
  attr sous_zone ref_sous_zone sous_zone 1 not_set
ch_front_input_uniforme ch_front_input ch_front_input_uniforme -1 for coupling, you can use ch_front_input_uniforme which is a champ_front_uniforme, which use an external value. It must be used with Problem.setInputField.
champ_input_base field_base champ_input_base 1 not_set
  attr nb_comp entier nb_comp 0 not_set
  attr nom chaine nom 0 not_set
  attr initial_value list initial_value 1 not_set
  attr probleme chaine probleme 0 not_set
  attr sous_zone ref_sous_zone sous_zone 1 not_set
champ_input_p0 champ_input_base champ_input_p0 1 not_set
moyenne_volumique interprete moyenne_volumique 1 This keyword should be used after Resoudre keyword. It computes the convolution product of one or more fields with a given filtering function.
  attr nom_pb ref_Pb_base nom_pb 0 name of the problem where the source fields will be searched.
  attr nom_domaine ref_domaine nom_domaine 0 name of the destination domain (for example, it can be a coarser mesh, but for optimal performance in parallel, the domain should be split with the same algorithm as the computation mesh, eg, same tranche parameters for example)
  attr noms_champs listchaine noms_champs 0 name of the source fields (these fields must be accessible from the postraitement) N source_field1 source_field2 ... source_fieldN
  attr nom_fichier_post chaine nom_fichier_post 1 indicates the filename where the result is written
  attr format_post chaine format_post 1 gives the fileformat for the result (by default : lata)
  attr localisation chaine(into=["elem","som"]) localisation 1 indicates where the convolution product should be computed: either on the elements or on the nodes of the destination domain.
  attr fonction_filtre bloc_lecture fonction_filtre 0 to specify the given filter NL2 Fonction_filtre {NL2 type filter_typeNL2 demie-largeur lNL2 [ omega w ] NL2 [ expression string ]NL2 } NL2 NL2 type filter_type : This parameter specifies the filtering function. Valid filter_type are:NL2 Boite is a box filter, $f(x,y,z)=(abs(x)<l)*(abs(y) <l)*(abs(z) <l) / (8 l^3)$NL2 Chapeau is a hat filter (product of hat filters in each direction) centered on the origin, the half-width of the filter being l and its integral being 1.NL2 Quadra is a 2nd order filter.NL2 Gaussienne is a normalized gaussian filter of standard deviation sigma in each direction (all field elements outside a cubic box defined by clipping_half_width are ignored, hence, taking clipping_half_width=2.5*sigma yields an integral of 0.99 for a uniform unity field).NL2 Parser allows a user defined function of the x,y,z variables. All elements outside a cubic box defined by clipping_half_width are ignored. The parser is much slower than the equivalent c++ coded function...NL2 NL2 demie-largeur l : This parameter specifies the half width of the filterNL2 [ omega w ] : This parameter must be given for the gaussienne filter. It defines the standard deviation of the gaussian filter.NL2 [ expression string] : This parameter must be given for the parser filter type. This expression will be interpreted by the math parser with the predefined variables x, y and z.
ecrire_champ_med interprete ecrire_champ_med -1 Keyword to write a field to MED format into a file. Useful with Homard.
  attr nom_dom ref_domaine nom_dom 0 domain name
  attr nom_chp ref_field_base nom_chp 0 field name
  attr file chaine file 0 file name
Read_MED interprete lire_med -1 Keyword to read MED mesh files where domain_name corresponds to the domain name, filename.med corresponds to the file (written in format MED) containing the mesh named mesh_name. NL2 Note about naming boundaries: When reading filename.med, TRUST will detect boundaries between domain (Raccord) when the name of the boundary begins by type_raccord_. For example, a boundary named type_raccord_wall in filename.med will be considered by TRUST as a boundary named wall between two domains. NL2 NB: To read several domains from a mesh issued from a MED file, use Read_Med to read the mesh then use Create_domain_from_sous_zone keyword. NL2 NB: If the MED file contains one or several subzone defined as a group of volumes, then Read_MED will read it and will create two files domain_name_ssz.geo and domain_name_ssz_par.geo defining the subzones for sequential and/or parallel calculations. These subzones will be read in sequential in the datafile by including (after Read_Med keyword) something like: NL2 Read_Med .... NL2 Read_file domain_name_ssz.geo ; NL2 During the parallel calculation, you will include something: NL2 Scatter { ... } NL2 Read_file domain_name_ssz_par.geo ;
  attr vef chaine(into=["vef"]) vef 1 Option vef is obsolete and is kept for backward compatibility.
  attr family_names_from_group_names chaine(into=["family_names_from_group_names"]) family_names_from_group_names 1 The option family_names_from_group_names uses the group names instead of the family names to detect the boundaries into a MED mesh (useful when trying to read a MED mesh file from Gmsh tool which can now read and write MED meshes).
  attr short_family_names chaine(into=["short_family_names"]) short_family_names 1 The option shorty_family_names is useful to suppress FAM_-*_ from the boundary names of the MED meshes.
  attr nom_dom ref_domaine nom_dom 0 corresponds to the domain name
  attr nom_dom_med chaine nom_dom_med 0 name of the mesh in med file
  attr file chaine file 0 corresponds to the file (written in format MED) containing the mesh
lire_ideas interprete lire_ideas -1 Read a geom in a unv file. 3D tetra mesh elements only may be read by TRUST.
  attr nom_dom ref_domaine nom_dom 0 Name of domain.
  attr file chaine file 0 Name of file.
writemed interprete ecrire_med -1 Write a domain to MED format into a file.
  attr nom_dom ref_domaine nom_dom 0 Name of domain.
  attr file chaine file 0 Name of file.
system interprete system -1 To run Unix commands from the data file. Example: System \'echo The End | mail triou@cea.fr\'
  attr cmd chaine cmd 0 command to execute.
redresser_hexaedres_vdf interprete redresser_hexaedres_vdf -1 Keyword to convert a domain (named domain_name) with quadrilaterals/VEF hexaedras which looks like rectangles/VDF hexaedras into a domain with real rectangles/VDF hexaedras.
  attr domain_name ref_domaine domain_name 0 Name of domain to resequence.
analyse_angle interprete analyse_angle -1 Keyword Analyse_angle prints the histogram of the largest angle of each mesh elements of the domain named name_domain. nb_histo is the histogram number of bins. It is called by default during the domain discretization with nb_histo set to 18. Useful to check the number of elements with angles above 90 degrees.
  attr domain_name ref_domaine domain_name 0 Name of domain to resequence.
  attr nb_histo entier nb_histo 0 not_set
remove_invalid_internal_boundaries interprete remove_invalid_internal_boundaries -1 Keyword to suppress an internal boundary of the domain_name domain. Indeed, some mesh tools may define internal boundaries (eg: for post processing task after the calculation) but TRUST does not support it yet.
  attr domain_name ref_domaine domain_name 0 Name of domain.
resequencing interprete reordonner -1 The Reordonner interpretor is required sometimes for a VDF mesh which is not produced by the internal mesher. Example where this is used: NL2 Read_file dom fichier.geom NL2 Reordonner dom NL2 Observations: This keyword is redundant when the mesh that is read is correctly sequenced in the TRUST sense. This significant mesh operation may take some time... The message returned by TRUST is not explicit when the Reordonner (Resequencing) keyword is required but not included in the data set...
  attr domain_name ref_domaine domain_name 0 Name of domain to resequence.
option_vdf interprete option_vdf 1 Class of VDF options.
  attr traitement_coins chaine(into=["oui","non"]) traitement_coins 1 Treatment of corners (yes or no).
  attr p_imposee_aux_faces chaine(into=["oui","non"]) p_imposee_aux_faces 1 Pressure imposed at the faces (yes or no).
precisiongeom interprete precisiongeom 0 Class to change the way floating-point number comparison is done. By default, two numbers are the same if their absolute difference is less than 1e-10. The keyword is useful to change this value. Moreover, nodes coordinates will be written in .geom files with this same precision.
  attr precision floattant precision 0 New value of precision.
nettoiepasnoeuds interprete nettoiepasnoeuds 0 Keyword NettoiePasNoeuds does not delete useless nodes (nodes without elements) from a domain.
  attr domain_name ref_domaine domain_name 0 Name of domain.
scatter interprete scatter 0 Class to read a partionned mesh in the files during a parallel calculation. The files are in binary format.
  attr file chaine file 0 Name of file.
  attr domaine ref_domaine domaine 0 Name of domain.
scatterformatte scatter scatterformatte 0 Class to read a partionned mesh in the files during a parallel calculation. The files are formatted.
scattermed scatter scattermed 0 This keyword will read the partition of the domain_name domain into a the MED format files file.med created by Medsplitter.
listdeuxmots_sacc listobj nul 0 deuxmots 0 List of groups of two words (without accodances).
partitionneur_deriv objet_u partitionneur_deriv -1 not_set
  attr nb_parts entier nb_parts 1 The number of non empty parts that must be generated (generally equal to the number of processors in the parallel run).
partitionneur_metis partitionneur_deriv metis -1 Metis is an external partitionning library. It is a general algorithm that will generate a partition of the domain.
  attr kmetis rien kmetis 1 The default values are pmetis, default parameters are automatically chosen by Metis. \'kmetis\' is faster than pmetis option but the last option produces better partitioning quality. In both cases, the partitioning quality may be slightly improved by increasing the nb_essais option (by default N=1). It will compute N partitions and will keep the best one (smallest edge cut number). But this option is CPU expensive, taking N=10 will multiply the CPU cost of partitioning by 10. NL2 Experiments show that only marginal improvements can be obtained with non default parameters.
  attr use_weights rien use_weights 1 If use_weights is specified, weighting of the element-element links in the graph is used to force metis to keep opposite periodic elements on the same processor. This option can slightly improve the partitionning quality but it consumes more memory and takes more time. It is not mandatory since a correction algorithm is always applied afterwards to ensure a correct partitionning for periodic boundaries.
partitionneur_sous_zones partitionneur_deriv sous_zones -1 This algorithm will create one part for each specified subzone. All elements contained in the first subzone are put in the first part, all remaining elements contained in the second subzone in the second part, etc... NL2 If all elements of the domain are contained in the specified subzones, then N parts are created, otherwise, a supplemental part is created with the remaining elements. NL2 If no subzone is specified, all subzones defined in the domain are used to split the mesh.
  attr sous_zones listchaine sous_zones 0 N SUBZONE_NAME_1 SUBZONE_NAME_2 ...
partitionneur_tranche partitionneur_deriv tranche -1 This algorithm will create a geometrical partitionning by slicing the mesh in the two or three axis directions, based on the geometric center of each mesh element. nz must be given if dimension=3. Each slice contains the same number of elements (slices don\'t have the same geometrical width, and for VDF meshes, slice boundaries are generally not flat except if the number of mesh elements in each direction is an exact multiple of the number of slices). First, nx slices in the X direction are created, then each slice is split in ny slices in the Y direction, and finally, each part is split in nz slices in the Z direction. The resulting number of parts is nx*ny*nz. If one particular direction has been declared periodic, the default slicing (0, 1, 2, ..., n-1)is replaced by (0, 1, 2, ... n-1, 0), each of the two \'0\' slices having twice less elements than the other slices.
  attr tranches listentierf tranches 1 Partitioned by nx in the X direction, ny in the Y direction, nz in the Z direction. Works only for structured meshes. No warranty for unstructured meshes.
partitionneur_partition partitionneur_deriv partition -1 This algorithm re-use the partition of the domain named DOMAINE_NAME. It is useful to partition for example a post processing domain. The partition should match with the calculation domain.
  attr domaine ref_domaine domaine 0 domain name
partitionneur_fichier_decoupage partitionneur_deriv fichier_decoupage -1 This algorithm reads an array of integer values on the disc, one value for each mesh element. Each value is interpreted as the target part number n>=0 for this element. The number of parts created is the highest value in the array plus one. Empty parts can be created if some values are not present in the array. NL2 The file format is ASCII, and contains space, tab or carriage-return separated integer values. The first value is the number nb_elem of elements in the domain, followed by nb_elem integer values (positive or zero). NL2 This algorithm has been designed to work together with the \'ecrire_decoupage\' option. You can generate a partition with any other algorithm, write it to disc, modify it, and read it again to generate the .Zone files. NL2 Contrary to other partitioning algorithms, no correction is applied by default to the partition (eg. element 0 on processor 0 and corrections for periodic boundaries). If \'corriger_partition\' is specified, these corrections are applied.
  attr fichier chaine fichier 0 FILENAME
  attr corriger_partition rien corriger_partition 1 not_set
bloc_decouper objet_lecture nul 1 Auxiliary class to cut a domain.
  attr partitionneur|Partition_tool partitionneur_deriv partitionneur 1 Defines the partitionning algorithm (the effective C++ object used is \'Partitionneur_ALGORITHM_NAME\').
  attr larg_joint entier larg_joint 1 This keyword specifies the thickness of the virtual ghost zone (data known by one processor though not owned by it). The default value is 1 and is generally correct for all algorithms except the QUICK convection scheme that require a thickness of 2. Since the 1.5.5 version, the VEF discretization imply also a thickness of 2 (except VEF P0). Any non-zero positive value can be used, but the amount of data to store and exchange between processors grows quickly with the thickness.
  attr nom_zones|zones_name chaine nom_zones 1 Name of the files containing the different partition of the domain. The files will be : NL2 name_0001.Zones NL2 name_0002.Zones NL2 ... NL2 name_000n.Zones. If this keyword is not specified, the geometry is not written on disc (you might just want to generate a \'ecrire_decoupage\' or \'ecrire_lata\').
  attr ecrire_decoupage chaine ecrire_decoupage 1 After having called the partitionning algorithm, the resulting partition is written on disc in the specified filename. See also partitionneur Fichier_Decoupage. This keyword is useful to change the partition numbers: first, you write the partition into a file with the option ecrire_decoupage. This file contains the zone number for each element\'s mesh. Then you can easily permute zone numbers in this file. Then read the new partition to create the .Zones files with the Fichier_Decoupage keyword.
  attr ecrire_lata chaine ecrire_lata 1 not_set
  attr nb_parts_tot entier nb_parts_tot 1 Keyword to generates N .Zone files, instead of the default number M obtained after the partitionning algorithm. N must be greater or equal to M. This option might be used to perform coupled parallel computations. Supplemental empty zones from M to N-1 are created. This keyword is used when you want to run a parallel calculation on several domains with for example, 2 processors on a first domain and 10 on the second domain because the first domain is very small compare to second one. You will write Nb_parts 2 and Nb_parts_tot 10 for the first domain and Nb_parts 10 for the second domain.
  attr formatte rien formatte 1 Optional keyword to have formatted format for .Zones files. By default, it is binary format.
  attr periodique listchaine periodique 1 N BOUNDARY_NAME_1 BOUNDARY_NAME_2 ... : N is the number of boundary names given. Periodic boundaries must be declared by this method. The partitionning algorithm will ensure that facing nodes and faces in the periodic boundaries are located on the same processor.
  attr reorder entier reorder 1 If this option is set to 1 (0 by default), the partition is renumbered in order that the processes which communicate the most are nearer on the network. This may slighlty improves parallel performance.
partition interprete decouper -1 Class for parallel calculation to cut a domain for each processor. By default, these keyword is commented in the reference test cases.
  attr domaine ref_domaine domaine 0 Name of the domain to be cut.
  attr bloc_decouper bloc_decouper bloc_decouper 0 Description how to cut a domain.
reordonner_faces_periodiques interprete reordonner_faces_periodiques -1 The Reordonner_faces_periodiques keyword is mandatory to first define the periodic boundaries and also to reorder the faces of theses boundaries.
  attr domaine ref_domaine domaine 0 Name of domain.
  attr nom_bord_perio chaine nom_bord_perio 0 boundary_name.
corriger_frontiere_periodique interprete corriger_frontiere_periodique 1 The Corriger_frontiere_periodique keyword is mandatory to first define the periodic boundaries, to reorder the faces and eventually fix unaligned nodes of theses boundaries. Faces on one side of the periodic domain are put first, then the faces on the opposite side, in the same order. It must be run in sequential before mesh splitting.
  attr domaine chaine domaine 0 Name of domain.
  attr bord chaine bord 0 the name of the boundary (which must contain two opposite sides of the domain)
  attr direction list direction 1 defines the periodicity direction vector (a vector that points from one node on one side to the opposite node on the other side. This vector must be given if the automatic algorithm fails, that is:NL2 - when the node coordinates are not perfectly periodic NL2 - when the periodic direction is not aligned with the normal vector of the boundary faces
  attr fichier_post chaine fichier_post 1 .
distance_paroi interprete distance_paroi 0 Class to generate external file Wall_length.xyz devoted for instance, for mixing length modelling. In this file, are saved the coordinates of each element (center of gravity) of dom domain and minimum distance between this point and boundaries (specified bords) that user specifies in data file (typically, those which are associated to walls). A field Distance_paroi is available to post process the distance to the wall.
  attr dom ref_domaine dom 0 Name of domain.
  attr bords listchaine bords 0 Boundaries.
  attr format chaine(into=["binaire","formatte"]) format 0 Value for format may be binaire (a binary file Wall_length.xyz is written) or formatte (moreover, a formatted file Wall_length_formatted.xyz is written).
extrudebord interprete extrudebord 1 Class to generate an extruded mesh from a boundary of a tetrahedral or an hexahedral mesh. NL2 Warning: If the initial domain is an tetrahedral mesh, the boundary will be moved in the XY plan then extrusion will be applied (you should may be use the Transformer keyword on the final domain to have the domain you really want). You can use the keyword Ecrire_Fichier_Meshtv to generate a meshtv file to visualize your initial and final meshes. NL2 This keyword can be used for example to create a periodic box extracted from a boundary of a tetrahedral or a hexaedral mesh. This periodic box may be used then to engender turbulent inlet flow condition for the main domain.NL2 Note that ExtrudeBord in VEF generates 3 or 14 tetrahedra from extruded prisms.
  attr domaine_init ref_domaine domaine_init 0 Initial domain with hexaedras or tetrahedras.
  attr direction listf direction 1 Directions for the extrusion.
  attr nb_tranches entier nb_tranches 1 Number of elements in the extrusion direction.
  attr domaine_final chaine domaine_final 1 Extruded domain.
  attr nom_bord chaine nom_bord 1 Name of the boundary of the initial domain where extrusion will be applied.
  attr non_perio rien non_perio 1 Extruded domain will not have periodic boundaries. So, the boundaries will be named DEVANT and DERRIERE instead of PERIO.
  attr hexa_old rien hexa_old 1 Old algorithm for boundary extrusion from a hexahedral mesh.
  attr trois_tetra rien trois_tetra 1 To extrude in 3 tetrahedras instead of 14 tetrahedras.
  attr vingt_tetra rien vingt_tetra 1 To extrude in 20 tetrahedras instead of 14 tetrahedras.
  attr sans_passer_par_le2D entier sans_passer_par_le2D 1 Only for non regression
troisf objet_lecture nul 0 Auxiliary class to extrude.
  attr lx floattant lx 0 X direction of the extrude operation.
  attr ly floattant ly 0 Y direction of the extrude operation.
  attr lz floattant lz 0 Z direction of the extrude operation.
extruder interprete extruder 1 Class to create a 3D tetrahedral/hexahedral mesh (a prism is cut in 14) from a 2D triangular/quadrangular mesh.
  attr domaine ref_domaine domain_name 0 Name of the domain.
  attr direction troisf direction 0 Direction of the extrude operation.
  attr nb_tranches entier nb_tranches 0 Number of elements in the extrusion direction.
extract_2d_from_3d interprete extract_2d_from_3d -1 Keyword to extract a 2D mesh by selecting a boundary of the 3D mesh. To generate a 2D axisymmetric mesh prefer Extract_2Daxi_from_3D keyword.
  attr dom3D ref_domaine dom3D 0 Domain name of the 3D mesh
  attr bord chaine bord 0 Boundary name. This boundary become the new 2D mesh and all the boundaries, in 3D, attached to the selected boundary, give their name to the news boundaries, in 2D.
  attr dom2D chaine dom2D 0 Domain name of the new 2D mesh
extract_2daxi_from_3d extract_2d_from_3d extract_2daxi_from_3d -1 Keyword to extract a 2D axisymetric mesh by selecting a boundary of the 3D mesh.
extruder_en3 extruder extruder_en3 1 Class to create a 3D tetrahedral/hexahedral mesh (a prism is cut in 3) from a 2D triangular/quadrangular mesh. The names of the (by default, devant and derriere ) may be renamed by the keyword nom_cl_devant and nom_cl_derriere. If NULL is written for nom_cl, then no boundary condition is generated at this place. NL2 Recommendation : to ensure conformity between meshes (in case of fluid/solid coupling) it is recommended to extrude all the domains at the same time.
  attr domaine listchaine domain_name 0 List of the domains
  attr nom_cl_devant chaine nom_cl_devant 1 New name of the first boundary.
  attr nom_cl_derriere chaine nom_cl_derriere 1 New name of the second boundary.
extruder_en20 interprete extruder_en20 1 It does the same task as Extruder except a prism is cut in 20 instead of 3. The nem of the boundaries will be devant and derriere. But you can change this name with the keyword RegroupeBord.
  attr domaine ref_domaine domain_name 0 Name of the domain.
  attr direction troisf direction 1 0 Direction of the extrude operation.
  attr nb_tranches entier nb_tranches 0 Number of elements in the extrusion direction.
extrudeparoi interprete extrudeparoi 1 Keyword dedicated in 3D (VEF) to create prismatic layer at wall. Each prism is cut in 3 tetraedra.
  attr domaine ref_domaine domain_name 0 Name of the domain.
  attr nom_bord chaine nom_bord 0 Name of the (no slide) boundary for creation of prismatic layers.
  attr epaisseur list epaisseur 1 n r1 r2 .... rn : (relative or absolute) width for each layer.
  attr critere_absolu entier critere_absolu 1 relative (0, the default) or absolute (1) width for each layer.
  attr projection_normale_bord rien projection_normale_bord 1 keyword to project layers on the same plane that contiguous boundaries. defaut values are : epaisseur_relative 1 0.5 projection_normale_bord 1
ecriturelecturespecial interprete ecriturelecturespecial -1 Class to write or not to write a .xyz file on the disc at the end of the calculation.
  attr type chaine type 0 If set to 0, no xyz file is created. If set to EFichierBin, it uses prior 1.7.0 way of reading xyz files (now LecFicDiffuseBin). If set to EcrFicPartageBin, it uses prior 1.7.0 way of writing xyz files (now EcrFicPartageMPIIO).
listeqn listobj nul 1 eqn_base 0 List of equations.
pb_avec_passif Pb_base pb_avec_passif -1 Class to create a classical problem with a scalar transport equation (e.g: temperature or concentration) and an additional set of passive scalars (e.g: temperature or concentration) equations.
  attr equations_scalaires_passifs listeqn equations_scalaires_passifs 0 Passive scalar equations. The unknowns of the passive scalar equation number N are named temperatureN or concentrationN or fraction_massiqueN. This keyword is used to define initial conditions and the post processing fields. This kind of problem is very useful to test in only one data file (and then only one calculation) different schemes or different boundary conditions for the scalar transport equation.
pb_thermohydraulique_concentration_turbulent_scalaires_passifs pb_avec_passif pb_thermohydraulique_concentration_turbulent_scalaires_passifs -1 Resolution of NAVIER STOKES/energy/multiple constituent transportation equations, with turbulence modelling and with the additional passive scalar equations.
  attr navier_stokes_turbulent navier_stokes_turbulent navier_stokes_turbulent 1 NAVIER STOKES equations as well as the associated turbulence model equations.
  attr convection_diffusion_concentration_turbulent convection_diffusion_concentration_turbulent convection_diffusion_concentration_turbulent 1 Constituent transportation equations (concentration diffusion convection) as well as the associated turbulence model equations.
  attr convection_diffusion_temperature_turbulent convection_diffusion_temperature_turbulent convection_diffusion_temperature_turbulent 1 Energy equations (temperature diffusion convection) as well as the associated turbulence model equations.
  ref constituant constituant
pb_thermohydraulique_concentration_scalaires_passifs pb_avec_passif pb_thermohydraulique_concentration_scalaires_passifs -1 Resolution of NAVIER STOKES/energy/multiple constituent transportation equations, with the additional passive scalar equations.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 NAVIER STOKES equations.
  attr convection_diffusion_concentration convection_diffusion_concentration convection_diffusion_concentration 1 Constituent transportation equations (concentration diffusion convection).
  attr convection_diffusion_temperature convection_diffusion_temperature convection_diffusion_temperature 1 Energy equations (temperature diffusion convection).
  ref constituant constituant
pb_thermohydraulique_turbulent_scalaires_passifs pb_avec_passif pb_thermohydraulique_turbulent_scalaires_passifs -1 Resolution of thermohydraulic problem, with turbulence modelling and with the additional passive scalar equations.
  attr navier_stokes_turbulent navier_stokes_turbulent navier_stokes_turbulent 1 NAVIER STOKES equations as well as the associated turbulence model equations.
  attr convection_diffusion_temperature_turbulent convection_diffusion_temperature_turbulent convection_diffusion_temperature_turbulent 1 Energy equations (temperature diffusion convection) as well as the associated turbulence model equations.
pb_thermohydraulique_scalaires_passifs pb_avec_passif pb_thermohydraulique_scalaires_passifs -1 Resolution of thermohydraulic problem, with the additional passive scalar equations.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 NAVIER STOKES equations.
  attr convection_diffusion_temperature convection_diffusion_temperature convection_diffusion_temperature 1 Energy equations (temperature diffusion convection).
pb_hydraulique_concentration_turbulent_scalaires_passifs pb_avec_passif pb_hydraulique_concentration_turbulent_scalaires_passifs -1 Resolution of NAVIER STOKES/multiple constituent transportation equations, with turbulence modelling and with the additional passive scalar equations.
  attr navier_stokes_turbulent navier_stokes_turbulent navier_stokes_turbulent 1 NAVIER STOKES equations as well as the associated turbulence model equations.
  attr convection_diffusion_concentration_turbulent convection_diffusion_concentration_turbulent convection_diffusion_concentration_turbulent 1 Constituent transportation equations (concentration diffusion convection) as well as the associated turbulence model equations.
  ref constituant constituant
pb_hydraulique_concentration_scalaires_passifs pb_avec_passif pb_hydraulique_concentration_scalaires_passifs -1 Resolution of NAVIER STOKES/multiple constituent transportation equations with the additional passive scalar equations.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 NAVIER STOKES equations.
  attr convection_diffusion_concentration convection_diffusion_concentration convection_diffusion_concentration 1 Constituent transportation equations (concentration diffusion convection).
  ref constituant constituant
pb_thermohydraulique_qc_fraction_massique pb_avec_passif pb_thermohydraulique_qc_fraction_massique -1 Resolution of thermohydraulic problem under smal Mach number with passive scalar equations.
  attr navier_stokes_qc navier_stokes_qc navier_stokes_qc 0 NAVIER STOKES equations under smal Mach number.
  attr convection_diffusion_chaleur_qc convection_diffusion_chaleur_qc convection_diffusion_chaleur_qc 0 Energy equation under smal Mach number.
pb_thermohydraulique_turbulent_qc_fraction_massique pb_avec_passif pb_thermohydraulique_turbulent_qc_fraction_massique -1 Resolution of turbulent thermohydraulic problem under smal Mach number with passive scalar equations.
  attr navier_stokes_turbulent_qc navier_stokes_turbulent_qc navier_stokes_turbulent_qc 0 NAVIER STOKES equations under smal Mach number as well as the associated turbulence model equations.
  attr convection_diffusion_chaleur_turbulent_qc convection_diffusion_chaleur_turbulent_qc convection_diffusion_chaleur_turbulent_qc 0 Energy equation under smal Mach number as well as the associated turbulence model equations.
espece objet_u nul -1 not_set
  attr cp field_base cp 0 Specific heat value (J.kg-1.K-1).
  attr lambda field_base lambda_u 0 Conductivity value (W.m-1.K-1).
  attr mu field_base mu 0 Dynamic viscosity value (kg.m-1.s-1).
  attr masse_molaire floattant masse_molaire 0 Gas molar mass.
convection_diffusion_fraction_massique_qc eqn_base convection_diffusion_fraction_massique_qc -1 not_set
  attr espece espece espece 0 not_set
convection_diffusion_fraction_massique_turbulent_qc eqn_base convection_diffusion_fraction_massique_turbulent_qc -1 not_set
  attr modele_turbulence modele_turbulence_scal_base modele_turbulence 1 Turbulence model to be used.
  attr espece espece espece 0 not_set
frontiere_ouverte_fraction_massique_imposee condlim_base frontiere_ouverte_fraction_massique_imposee -1 not_set
  attr ch front_field_base ch 0 Boundary field type.
paroi_echange_contact_correlation_vdf condlim_base paroi_echange_contact_correlation_vdf 1 Class to define a thermohydraulic 1D model which will apply to a boundary of 2D or 3D domain. NL2 Warning : For parallel calculation, the only possible partition will be according the axis of the model with the keyword Tranche.
  attr dir entier dir 0 Direction (0 : axis X, 1 : axis Y, 2 : axis Z) of the 1D model.
  attr tinf floattant tinf 0 Inlet fluid temperature of the 1D model (oC or K).
  attr tsup floattant tsup 0 Outlet fluid temperature of the 1D model (oC or K).
  attr lambda chaine lambda_u 0 Thermal conductivity of the fluid (W.m-1.K-1).
  attr rho chaine rho 0 Mass density of the fluid (kg.m-3) which may be a function of the temperature T.
  attr cp floattant cp 0 Calorific capacity value at a constant pressure of the fluid (J.kg-1.K-1).
  attr dt_impr floattant dt_impr 0 Printing period in name_of_data_file_time.dat files of the 1D model results.
  attr mu chaine mu 0 Dynamic viscosity of the fluid (kg.m-1.s-1) which may be a function of thetemperature T.
  attr debit floattant debit 0 Surface flow rate (kg.s-1.m-2) of the fluid into the channel.
  attr dh floattant dh 0 Hydraulic diameter may be a function f(x) with x position along the 1D axis (xinf <= x <= xsup)
  attr volume chaine volume 0 Exact volume of the 1D domain (m3) which may be a function of the hydraulic diameter (Dh) and the lateral surface (S) of the meshed boundary.
  attr nu chaine nu 0 Nusselt number which may be a function of the Reynolds number (Re) and the Prandtl number (Pr).
  attr reprise_correlation rien reprise_correlation 1 Keyword in the case of a restarting calculation with this correlation.
paroi_echange_contact_correlation_vef condlim_base paroi_echange_contact_correlation_vef 1 Class to define a thermohydraulic 1D model which will apply to a boundary of 2D or 3D domain. NL2 Warning : For parallel calculation, the only possible partition will be according the axis of the model with the keyword Tranche_geom.
  attr dir entier dir 0 Direction (0 : axis X, 1 : axis Y, 2 : axis Z) of the 1D model.
  attr tinf floattant tinf 0 Inlet fluid temperature of the 1D model (oC or K).
  attr tsup floattant tsup 0 Outlet fluid temperature of the 1D model (oC or K).
  attr lambda chaine lambda_u 0 Thermal conductivity of the fluid (W.m-1.K-1).
  attr rho chaine rho 0 Mass density of the fluid (kg.m-3) which may be a function of the temperature T.
  attr cp floattant cp 0 Calorific capacity value at a constant pressure of the fluid (J.kg-1.K-1).
  attr dt_impr floattant dt_impr 0 Printing period in name_of_data_file_time.dat files of the 1D model results.
  attr mu chaine mu 0 Dynamic viscosity of the fluid (kg.m-1.s-1) which may be a function of thetemperature T.
  attr debit floattant debit 0 Surface flow rate (kg.s-1.m-2) of the fluid into the channel.
  attr dh floattant dh 0 Hydraulic diameter may be a function f(x) with x position along the 1D axis (xinf <= x <= xsup)
  attr n entier n 0 Number of 1D cells of the 1D mesh.
  attr surface chaine surface 0 Section surface of the channel which may be function f(Dh,x) of the hydraulic diameter (Dh) and x position along the 1D axis (xinf <= x <= xsup)
  attr nu chaine nu 0 Nusselt number which may be a function of the Reynolds number (Re) and the Prandtl number (Pr).
  attr xinf floattant xinf 0 Position of the inlet of the 1D mesh on the axis direction.
  attr xsup floattant xsup 0 Position of the outlet of the 1D mesh on the axis direction.
  attr emissivite_pour_rayonnement_entre_deux_plaques_quasi_infinies floattant emissivite_pour_rayonnement_entre_deux_plaques_quasi_infinies 1 Coefficient of emissivity for radiation between two quasi infinite plates.
  attr reprise_correlation rien reprise_correlation 1 Keyword in the case of a restarting calculation with this correlation.
spec_pdcr_base objet_lecture spec_pdcr_base 0 Class to read the source term modelling the presence of a bundle of tubes in a flow. Cf=A Re-B.
  attr ch_a chaine(into=["a","cf"]) ch_a 0 Keyword to be used to set law coefficient values for the coefficient of regular pressure losses.
  attr a floattant a 0 Value of a law coefficient for regular pressure losses.
  attr ch_b chaine(into=["b"]) ch_b 1 Keyword to be used to set law coefficient values for regular pressure losses.
  attr b floattant b 1 Value of a law coefficient for regular pressure losses.
longitudinale spec_pdcr_base longitudinale 0 Class to define the pressure loss in the direction of the tube bundle.
  attr dir chaine(into=["x","y","z"]) dir 0 Direction.
  attr dd floattant dd 0 Tube bundle hydraulic diameter value. This value is expressed in m.
transversale spec_pdcr_base transversale 0 Class to define the pressure loss in the direction perpendicular to the tube bundle.
  attr dir chaine(into=["x","y","z"]) dir 0 Direction.
  attr dd floattant dd 0 Value of the tube bundle step.
  attr chaine_d chaine(into=["d"]) chaine_d 0 Keyword to be used to set the value of the tube external diameter.
  attr d floattant d 0 Value of the tube external diameter.
perte_charge_reguliere source_base perte_charge_reguliere 0 Source term modelling the presence of a bundle of tubes in a flow.
  attr spec spec_pdcr_base spec 0 Description of longitudinale or transversale type.
  attr zone_name chaine name_of_zone 0 Name of the sub-area occupied by the tube bundle. A Sous_Zone (Sub-area) type object called zone_name should have been previously created.
pb_post Pb_base nul -1 not_set
format_lata_to_med objet_lecture nul 0 not_set
  attr mot chaine(into=["format_post_sup"]) mot 0 not_set
  attr format chaine(into=["lml","lata","lata_v1","lata_v2","med"]) format 1 generated file post_med.data use format (MED or LATA or LML keyword).
lata_to_med interprete lata_to_med -1 To convert results file written with LATA format to MED file. Warning: Fields located to faces are not supported yet.
  attr format format_lata_to_med format 1 generated file post_med.data use format (MED or LATA or LML keyword).
  attr file chaine file 0 LATA file to convert to the new format.
  attr file_med chaine file_med 0 Name of file med.
lata_to_other interprete lata_to_other -1 To convert results file written with LATA format to MED or LML format. Warning: Fields located to faces are not supported yet.
  attr format chaine(into=["lml","lata","lata_v1","lata_v2","med"]) format 1 Results format (MED or LATA or LML keyword).
  attr file chaine file 0 LATA file to convert to the new format.
  attr file_post chaine file_post 0 Name of file post.
info_med objet_lecture nul 0 not_set
  attr file_med chaine file_med 0 Name of file med.
  attr domaine chaine domaine 0 Name of domain.
  attr pb_post pb_post pb_post 0 not_set
list_info_med listobj nul -1 info_med 1 not_set
pbc_med pb_gen_base pbc_med 0 Allow to read med files and post-process them.
  attr list_info_med list_info_med list_info_med 0 not_set
decoupebord_pour_rayonnement interprete decoupebord_pour_rayonnement 1 To subdivide the external boundary of a domain in several parts (may be useful for better accuracy when using radiation model in transparent medium). to specify the boundaries of the fine_domain_name domain to be splitted. These boundaries will be cut according the coarse mesh defined by either the keyword domaine_grossier (each boundary face of the coarse mesh coarse_domain_name will be used to group boundary faces of the fine mesh to define a new boundary), either by the keyword nb_parts_naif (each boundary of the fine mesh is splitted into a partition with nx*ny*nz elements), either by a geometric condition given by a formulae with the keyword condition_geometrique. If used, the coarse_domain_name domain should have the same boundaries name of the fine_domain_name domain. NL2 A mesh file (ASCII format, except if binaire option is specified) named by default newgeom (or specified by the nom_fichier_sortie keyword) will be created and will contain the fine_domain_name domain with the splitted boundaries named boundary_name%I (where I is between from 0 and n-1). Furthermore, several files named boundary_name%I and boundary_name_xv will be created, containing the definition of the subdived boundaries. newgeom will be used to calculate view factors with geom2ansys script whereas only the boundary_name_xv files will be necessary for the radiation calculation. The file listb will contain the list of the boundaries boundary_name%I.
  attr domaine ref_domaine domaine 0 not_set
  attr domaine_grossier ref_domaine domaine_grossier 1 not_set
  attr nb_parts_naif listentier nb_parts_naif 1 not_set
  attr nb_parts_geom listentier nb_parts_geom 1 not_set
  attr bords_a_decouper listchaine bords_a_decouper 0 not_set
  attr nom_fichier_sortie chaine nom_fichier_sortie 1 not_set
  attr condition_geometrique listchaine condition_geometrique 1 not_set
  attr binaire entier binaire 1 not_set
methode_transport_deriv objet_lecture methode_transport_deriv 0 Basic class for method of transport of interface.
loi_horaire objet_u loi_horaire 1 to define the movement with a time-dependant law for the solid interface.
  attr position listchaine position 0 not_set
  attr vitesse listchaine vitesse 0 not_set
  attr rotation listchaine rotation 1 not_set
  attr derivee_rotation listchaine derivee_rotation 1 not_set
methode_loi_horaire methode_transport_deriv loi_horaire -1 not_set
  attr nom_loi ref_loi_horaire nom_loi 0 not_set
problem_read_generic Pb_base problem_read_generic -1 The probleme_read_generic differs rom the rest of the TRUST code : The problem does not state the number of equations that are enclosed in the problem. As the list of equations to be solved in the generic read problem is declared in the data file and not pre-defined in the structure of the problem, each equation has to be distinctively associated with the problem with the Associate keyword.
  ref eqn1 eqn_base
  ref eqn2 eqn_base
  ref eqn3 eqn_base
  ref eqn4 eqn_base
  ref eqn5 eqn_base
  ref eqn6 eqn_base
  ref eqn7 eqn_base
  ref eqn8 eqn_base
  ref eqn9 eqn_base
  ref eqn10 eqn_base
temperature traitement_particulier_base temperature -1 not_set
  attr bord chaine bord 0 not_set
  attr direction entier direction 0 not_set
canal traitement_particulier_base canal -1 Keyword for statistics on a periodic plane channel.
  attr dt_impr_moy_spat floattant dt_impr_moy_spat 1 Period to print the spatial average (default value is 1e6).
  attr dt_impr_moy_temp floattant dt_impr_moy_temp 1 Period to print the temporal average (default value is 1e6).
  attr debut_stat floattant debut_stat 1 Time to start the temporal averaging (default value is 1e6).
  attr fin_stat floattant fin_stat 1 Time to end the temporal averaging (default value is 1e6).
  attr pulsation_w floattant pulsation_w 1 Pulsation for phase averaging (in case of pulsating forcing term) (no default value).
  attr nb_points_par_phase entier nb_points_par_phase 1 Number of samples to represent phase average all along a period (no default value).
  attr reprise chaine reprise 1 val_moy_temp_xxxxxx.sauv : Keyword to restart a calculation with previous average quantities. NL2 Note that for thermal and turbulent problems, averages on temperature and turbulent viscosity are automatically calculated. To restart a calculation with phase averaging, val_moy_temp_xxxxxx.sauv_phase file is required on the directory where the job is submitted (this last file will be then automatically loaded by TRUST).
ec traitement_particulier_base ec -1 Keyword to print total kinetic energy into the referential linked to the domain (keyword Ec). In the case where the domain is moving into a Galilean referential, the keyword Ec_dans_repere_fixe will print total kinetic energy in the Galilean referential whereas Ec will print the value calculated into the moving referential linked to the domain
  attr Ec rien Ec 1 not_set
  attr Ec_dans_repere_fixe rien Ec_dans_repere_fixe 1 not_set
  attr periode floattant periode 1 periode is the keyword to set the period of printing into the file datafile_Ec.son or datafile_Ec_dans_repere_fixe.son.
thi traitement_particulier_base thi -1 Keyword for a THI (Homogeneous Isotropic Turbulence) calculation.
  attr init_Ec entier init_Ec 0 Keyword to renormalize initial velocity so as kinetic energy equals to the value given by keyword val_Ec.
  attr val_Ec floattant val_Ec 1 Keyword to impose a value for kinetic energy by velocity renormalizated if init_Ec value is 1.
  attr facon_init entier(into=["0","1"]) facon_init 1 Keyword to specify how kinetic energy is computed (0 or 1).
  attr calc_spectre entier(into=["0","1"]) calc_spectre 1 Calculate or not the spectrum of kinetic energy. NL2 Files called Sorties_THI are written with inside four columns : NL2 time:t global_kinetic_energy:Ec enstrophy:D skewness:S NL2 If calc_spectre is set to 1, a file Sorties_THI2_2 is written with three columns : NL2 time:t kinetic_energy_at_kc=32 enstrophy_at_kc=32 NL2 If calc_spectre is set to 1, a file spectre_xxxxx is written with two columns at each time xxxxx : NL2 frequency:k energy:E(k).
  attr periode_calc_spectre floattant periode_calc_spectre 1 Period for calculating spectrum of kinetic energy
  attr 3D entier(into=["0","1"]) flag3D 1 Calculate or not the 3D spectrum
  attr 1D entier(into=["0","1"]) flag1D 1 Calculate or not the 1D spectrum
  attr conservation_Ec rien conservation_Ec 1 If set to 1, velocity field will be changed as to have a constant kinetic energy (default 0)
  attr longueur_boite floattant longueur_boite 1 Length of the calculation domain
chmoy_faceperio traitement_particulier_base chmoy_faceperio 0 non documente
  attr bloc bloc_lecture bloc 0 not_set
extraire_plan interprete extraire_plan -3 This keyword extract a plan mesh named domain_name (this domain should have be declared before) from the mesh of the pb_name problem. The plan can be either a triangle (defined by the keywords Origine, Point1, Point2 and Triangle), either a regular quadrangle (with keywords Origine, Point1 and Point2), or either a generalized quadrangle (with keywords Origine, Point1, Point2, Point3). The keyword Epaisseur specifies the thickness of volume around the plan which contains the faces of the extracted mesh. The keyword via_extraire_surface will create a plan and use Extraire_surface algorithm. Inverse_condition_element keyword then will be used in the case where the plan is a boundary not well oriented, and avec_certains_bords_pour_extraire_surface is the option related to the Extraire_surface option named avec_certains_bords.
  attr domaine ref_domaine domaine 0 domain_namme
  attr probleme ref_Pb_base probleme 0 pb_name
  attr epaisseur floattant epaisseur 0 not_set
  attr origine list origine 0 not_set
  attr point1 list point1 0 not_set
  attr point2 list point2 0 not_set
  attr point3 list point3 1 not_set
  attr triangle rien triangle 1 not_set
  attr via_extraire_surface rien via_extraire_surface 1 not_set
  attr inverse_condition_element rien inverse_condition_element 1 not_set
  attr avec_certains_bords_pour_extraire_surface listchaine avec_certains_bords_pour_extraire_surface 1 not_set
extraire_domaine interprete extraire_domaine -3 Keyword to create a new domain built with the domain elements of the pb_name problem verifying the two conditions given by Condition_elements. The problem pb_name should have been discretized.
  attr domaine ref_domaine domaine 0 domaine dans lequel stocke les faces
  attr probleme ref_Pb_base probleme 0 Probleme duquel il faut extraire les faces
  attr condition_elements chaine condition_elements 1 not_set
  attr sous_zone ref_sous_zone sous_zone 1 not_set
extraire_surface interprete extraire_surface -3 This keyword extract a surface mesh named domain_name (this domain should have be declared before) from the mesh of the pb_name problem. The surface mesh is defined by one or two conditions. The first condition is about elements with Condition_elements. For example: Condition_elements x*x+y*y+z*z<1 NL2 Will define a surface mesh with external faces of the mesh elements inside the sphere of radius 1 located at (0,0,0). The second conditions Condition_faces is useful to give a restriction.NL2 By default, the faces from the boundaries are not added to the surface mesh excepted if option avec_les_bords is given (all the boundaries are added), or if the option avec_certains_bords is used to add only some boundaries.
  attr domaine ref_domaine domaine 0 domaine dans lequel stocke les faces
  attr probleme ref_Pb_base probleme 0 Probleme duquel il faut extraire les faces
  attr condition_elements chaine condition_elements 1 not_set
  attr condition_faces chaine condition_faces 1 not_set
  attr avec_les_bords rien avec_les_bords 1 not_set
  attr avec_certains_bords listchaine avec_certains_bords 1 not_set
integrer_champ_med interprete integrer_champ_med 1 his keyword is used to calculate a flow rate from a velocity MED field read before. The method is either debit_total to calculate the flow rate on the whole surface, either integrale_en_z to calculate flow rates between z=zmin and z=zmax on nb_tranche surfaces. The output file indicates first the flow rate for the whole surface and then lists for each tranche : the height z, the surface average value, the surface area and the flow rate. For the debit_total method case, only one tranche is considered.NL2 file :z Sum(u.dS)/Sum(dS) Sum(dS) Sum(u.dS)
  attr champ_med ref_champ_fonc_med champ_med 0 not_set
  attr methode chaine(into=["integrale_en_z","debit_total"]) methode 0 to choose between the integral following z or over the entire height (debit_total correspond to zmin=-DMAXFLOAT, ZMax=DMAXFLOAT, nb_tranche=1)
  attr zmin floattant zmin 1 not_set
  attr zmax floattant zmax 1 not_set
  attr nb_tranche entier nb_tranche 1 not_set
  attr fichier_sortie chaine fichier_sortie 1 name of the output file, by default: integrale.
convection_amont convection_deriv amont 0 Keyword for upwind scheme for VDF or VEF discretizations. In VEF discretization equivalent to generic amont for TRUST version 1.5 or later. The previous upwind scheme can be used with the obsolete in future amont_old keyword.
convection_amont_old convection_deriv amont_old 0 Only for VEF discretization, obsolete keyword, see amont.
convection_centre convection_deriv centre 0 For VDF and VEF discretizations.
convection_centre4 convection_deriv centre4 0 For VDF and VEF discretizations.
convection_centre_old convection_deriv centre_old 0 Only for VEF discretization.
convection_di_l2 convection_deriv di_l2 0 Only for VEF discretization.
bloc_ef objet_lecture nul 0 not_set
  attr mot1 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot1 0 not_set
  attr val1 entier(into=[0,1]) val1 0 not_set
  attr mot2 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot2 0 not_set
  attr val2 entier(into=[0,1]) val2 0 not_set
  attr mot3 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot3 0 not_set
  attr val3 entier(into=[0,1]) val3 0 not_set
  attr mot4 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot4 0 not_set
  attr val4 entier(into=[0,1]) val4 0 not_set
convection_ef convection_deriv ef 0 For VEF calculations, a centred convective scheme based on Finite Elements formulation can be called through the following data:NL2 NL2 Convection { EF transportant_bar val transporte_bar val antisym val filtrer_resu val }NL2 NL2 This scheme is 2nd order accuracy (and get better the property of kinetic energy conservation). Due to possible problems of instabilities phenomena, this scheme has to be coupled with stabilisation process (see Source_Qdm_lambdaup).These two last data are equivalent from a theoretical point of view in variationnal writing to : div(( u. grad ub , vb) - (u. grad vb, ub)), where vb corresponds to the filtered reference test functions.NL2 NL2 Remark:NL2 This class requires to define a filtering operator : see solveur_bar
  attr mot1 chaine(into=["defaut_bar"]) mot1 1 equivalent to transportant_bar 0 transporte_bar 1 filtrer_resu 1 antisym 1
  attr bloc_ef bloc_ef bloc_ef 1 not_set
convection_muscl3 convection_deriv muscl3 1 Keyword for a scheme using a ponderation between muscl and center schemes in VEF.
  attr alpha floattant alpha 1 To weight the scheme centering with the factor double (between 0 (full centered) and 1 (muscl), by default 1).
sous_zone_valeur objet_lecture nul 0 Two words.
  attr sous_zone ref_sous_zone sous_zone 0 sous zone
  attr valeur floattant valeur 0 value
listsous_zone_valeur listobj nul 0 sous_zone_valeur 0 List of groups of two words.
convection_ef_stab convection_deriv ef_stab 1 Keyword for a VEF convective scheme.
  attr alpha floattant alpha 1 To weight the scheme centering with the factor double (between 0 (full centered) and 1 (mix between upwind and centered), by default 1). For scalar equation, it is adviced to use alpha=1 and for the momentum equation, alpha=0.2 is adviced.
  attr test entier test 1 Developer option to compare old and new version of EF_stab
  attr tdivu rien tdivu 1 To have the convective operator calculated as div(TU)-TdivU(=UgradT).
  attr old rien old 1 To use old version of EF_stab scheme (default no).
  attr volumes_etendus rien volumes_etendus 1 Option for the scheme to use the extended volumes (default, yes).
  attr volumes_non_etendus rien volumes_non_etendus 1 Option for the scheme to not use the extended volumes (default, no).
  attr amont_sous_zone ref_sous_zone amont_sous_zone 1 Option to degenerate EF_stab scheme into Amont (upwind) scheme in the sub zone of name sz_name. The sub zone may be located arbitrarily in the domain but the more often this option will be activated in a zone where EF_stab scheme generates instabilities as for free outlet for example.
  attr alpha_sous_zone listsous_zone_valeur alpha_sous_zone 1 Option to change locally the alpha value on N sub-zones named sub_zone_name_I. Generally, it is used to prevent from a local divergence by increasing locally the alpha parameter.
convection_generic convection_deriv generic 0 Keyword for generic calling of upwind and muscl convective scheme in VEF discretization. For muscl scheme, limiters and order for fluxes calculations have to be specified. The available limiters are : minmod - vanleer -vanalbada - chakravarthy - superbee, and the order of accuracy is 1 or 2. Note that chakravarthy is a non-symmetric limiter and superbee may engender results out of physical limits. By consequence, these two limiters are not recommended. NL2 Examples: NL2 convection { generic amont }NL2 convection { generic muscl minmod 1 }NL2 convection { generic muscl vanleer 2 }NL2 NL2 In case of results out of physical limits with muscl scheme (due for instance to strong non-conformal velocity flow field), user can redefine in data file a lower order and a smoother limiter, as : convection { generic muscl minmod 1 }
  attr type chaine(into=["amont","muscl","centre"]) type 0 type of scheme
  attr limiteur chaine(into=["minmod","vanleer","vanalbada","chakravarthy","superbee"]) limiteur 1 type of limiter
  attr ordre entier(into=[1,2,3]) ordre 1 order of accuracy
  attr alpha floattant alpha 1 alpha
convection_kquick convection_deriv kquick 0 Only for VEF discretization.
convection_muscl convection_deriv muscl 0 Keyword for muscl scheme in VEF discretization equivalent to generic muscl vanleer 2 for the 1.5 version or later. The previous muscl scheme can be used with the obsolete in future muscl_old keyword.
convection_muscl_old convection_deriv muscl_old 0 Only for VEF discretization.
convection_muscl_new convection_deriv muscl_new 0 Only for VEF discretization.
convection_negligeable convection_deriv negligeable 0 For VDF and VEF discretizations. Suppresses the convection operator.
convection_quick convection_deriv quick 0 Only for VDF discretization.
diffusion_negligeable diffusion_deriv negligeable 0 the diffusivity will not taken in count
bloc_diffusion_standard objet_lecture nul 0 grad_Ubar 1 makes the gradient calculated through the filtered values of velocity (P1-conform).NL2 nu 1 (respectively nut 1) takes the molecular viscosity (eddy viscosity) into account in the velocity gradient part of the diffusion expression. NL2 nu_transp 1 (respectively nut_transp 1) takes the molecular viscosity (eddy viscosity) into account according in the TRANSPOSED velocity gradient part of the diffusion expression.NL2 filtrer_resu 1 allows to filter the resulting diffusive fluxes contribution.
  attr mot1 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot1 0 not_set
  attr val1 entier(into=[0,1]) val1 0 not_set
  attr mot2 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot2 0 not_set
  attr val2 entier(into=[0,1]) val2 0 not_set
  attr mot3 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot3 0 not_set
  attr val3 entier(into=[0,1]) val3 0 not_set
  attr mot4 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot4 0 not_set
  attr val4 entier(into=[0,1]) val4 0 not_set
  attr mot5 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot5 0 not_set
  attr val5 entier(into=[0,1]) val5 0 not_set
  attr mot6 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot6 0 not_set
  attr val6 entier(into=[0,1]) val6 0 not_set
difusion_p1b diffusion_deriv p1b 0 not_set
diffusion_p1ncp1b diffusion_deriv p1ncp1b 1 not_set
diffusion_stab diffusion_deriv stab 1 keyword allowing consistent and stable calculations even in case of obtuse angle meshes.
  attr standard entier standard 1 to recover the same results as calculations made by standard laminar diffusion operator. However, no stabilization technique is used and calculations may be unstable when working with obtuse angle meshes (by default 0)
  attr info entier info 1 developer option to get the stabilizing ratio (by default 0)
  attr new_jacobian entier new_jacobian 1 when implicit time schemes are used, this option defines a new jacobian that may be more suitable to get stationary solutions (by default 0)
  attr nu entier nu 1 (respectively nut 1) takes the molecular viscosity (resp. eddy viscosity) into account in the velocity gradient part of the diffusion expression (by default nu=1 and nut=1)
  attr nut entier nut 1 not_set
  attr nu_transp entier nu_transp 1 (respectively nut_transp 1) takes the molecular viscosity (resp. eddy viscosity) into account in the transposed velocity gradient part of the diffusion expression (by default nu_transp=0 and nut_transp=1)
  attr nut_transp entier nut_transp 1 not_set
diffusion_standard diffusion_deriv standard 0 A new keyword, intended for LES calculations, has been developed to optimise and parameterise each term of the diffusion operator. Remark:NL2 NL2 1. This class requires to define a filtering operator : see solveur_barNL2 2. The former (original) version: diffusion { } -which omitted some of the term of the diffusion operator- can be recovered by using the following parameters in the new class :NL2 diffusion { standard grad_Ubar 0 nu 1 nut 1 nu_transp 0 nut_transp 1 filtrer_resu 0}.
  attr mot1 chaine(into=["defaut_bar"]) mot1 1 equivalent to grad_Ubar 1 nu 1 nut 1 nu_transp 1 nut_transp 1 filtrer_resu 1
  attr bloc_diffusion_standard bloc_diffusion_standard bloc_diffusion_standard 1 not_set
champ_fonc_med field_base champ_fonc_med 0 Field to read a data field in a MED-format file .med at a specified time. It is very useful, for example, to restart a calculation with a new or refined geometry. The field post-processed on the new geometry at med format is used as initial condition for restarting.
  attr use_existing_domain chaine(into=["use_existing_domain"]) use_existing_domain 1 not_set
  attr last_time chaine(into=["last_time"]) last_time 1 to use the last time of the MED file instead of the specified time.
  attr filename chaine filename 0 Name of the .med file.
  attr domain_name chaine domain_name 0 Name of the domain.
  attr field_name chaine field_name 0 Name of the problem unknown.
  attr location chaine(into=["som","elem"]) location 0 To indicate where the field has been post-processed.
  attr time floattant time 0 Time of the field in the .med file.
reaction objet_lecture nul 1 Keyword to describe reaction: NL2 w =K pow(T,beta) exp(-Ea/( R T)) $\Pi$ pow(Reactif_i,activitivity_i). NL2 If K_inv >0, NL2 w= K pow(T,beta) exp(-Ea/( R T)) ( $\Pi$ pow(Reactif_i,activitivity_i) - Kinv/exp(-c_r_Ea/(R T)) $\Pi$ pow(Produit_i,activitivity_i ))
  attr reactifs chaine reactifs 0 LHS of equation (ex CH4+2*O2)
  attr produits chaine produits 0 RHS of equation (ex CO2+2*H20)
  attr constante_taux_reaction floattant constante_taux_reaction 1 constante of cinetic K
  attr coefficients_activites bloc_lecture coefficients_activites 1 coefficients od ativity (exemple { CH4 1 O2 2 })
  attr enthalpie_reaction floattant enthalpie_reaction 0 DH
  attr energie_activation floattant energie_activation 0 Ea
  attr exposant_beta floattant exposant_beta 0 Beta
  attr contre_reaction floattant contre_reaction 1 K_inv
  attr contre_energie_activation floattant contre_energie_activation 1 c_r_Ea
reactions listobj nul 1 reaction 1 list of reactions
chimie objet_u chimie 1 Keyword to describe the chmical reactions
  attr reactions reactions reactions 0 list of reactions
  attr modele_micro_melange entier modele_micro_melange 1 modele_micro_melange (0 by default)
  attr constante_modele_micro_melange floattant constante_modele_micro_melange 1 constante of modele (1 by default)
  attr espece_en_competition_micro_melange chaine espece_en_competition_micro_melange 1 espece in competition in reactions
rectify_mesh interprete rectify_mesh -1 Keyword to raffine a mesh
  attr domain_name ref_domaine domain_name 0 Name of domain.
verifier_simplexes interprete verifier_simplexes -1 Keyword to raffine a simplexes
  attr domain_name ref_domaine domain_name 0 Name of domain.
verifier_qualite_raffinements interprete verifier_qualite_raffinements 0 not_set
  attr domain_names vect_nom domain_names 0 not_set
schema_adams_bashforth_order_2 schema_temps_base schema_adams_bashforth_order_2 -1 not_set
schema_adams_bashforth_order_3 schema_temps_base schema_adams_bashforth_order_3 -1 not_set
schema_adams_moulton_order_2 schema_implicite_base schema_adams_moulton_order_2 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_adams_moulton_order_3 schema_implicite_base schema_adams_moulton_order_3 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_backward_differentiation_order_2 schema_implicite_base schema_backward_differentiation_order_2 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_backward_differentiation_order_3 schema_implicite_base schema_backward_differentiation_order_3 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
field_uniform_keps_from_ud field_base field_uniform_keps_from_ud 1 field which allows to impose on a domain K and EPS values derived from U velocity and D hydraulic diameter
  attr u floattant u 0 value of velocity specified in boundary condition.
  attr d floattant d 0 value of hydraulic diameter specified in boundary condition
boundary_field_uniform_keps_from_ud front_field_base boundary_field_uniform_keps_from_ud 1 field which allows to impose on a boundary K and EPS values derived from U velocity and D hydraulic diameter
  attr u floattant u 0 value of velocity
  attr d floattant d 0 value of hydraulic diameter
ef discretisation_base ef -1 Element Finite discretization.
diffusion_option diffusion_deriv option 0 not_set
  attr bloc_lecture bloc_lecture bloc_lecture 0 not_set
testeur_medcoupling interprete testeur_medcoupling 0 not_set
  attr pb_name chaine pb_name 0 Name of domain.
  attr field_name chaine filed_name 0 Name of domain.
champ_front_normal_vef front_field_base champ_front_normal_vef 0 Field to define the normal vector field standard at the boundary in VEF discretization.
  attr mot chaine(into=["valeur_normale"]) mot 0 Name of vector field.
  attr vit_tan floattant vit_tan 0 normal vector value (positive value for a vector oriented outside to inside).
loi_fermeture_test loi_fermeture_base loi_fermeture_test -1 Loi for test only 
  attr coef floattant coef 1 coefficient
Pb_base pb_gen_base Pb_base -3 Resolution of equations on a domain. A problem is defined by creating an object and assigning the problem type that the user wishes to resolve. To enter values for the problem objects created, the Read (Lire) interpretor is used with a data block. 
  attr postraitement|Post_processing corps_postraitement postraitement 1 One post-processing (without name).
  attr postraitements|Post_processings postraitements postraitements 1 List of Postraitement objects (with name).
  attr liste_de_postraitements liste_post_ok liste_de_postraitements 1 This
  attr liste_postraitements liste_post liste_postraitements 1 This block defines the output files to be written during the computation. The output format is lata in order to use OpenDX to draw the results. This block can be divided in one or several sub-blocks that can be written at different frequencies and in different directories. Attention. The directory lata used in this example should be created before running the computation or the lata files will be lost.
  attr sauvegarde format_file sauvegarde 1 Keyword used when calculation results are to be backed up. When a coupling is performed, the backup-recovery file name must be well specified for each problem. In this case, you must save to different files and correctly specify these files when restarting the calculation.
  attr sauvegarde_simple format_file sauvegarde_simple 1 The same keyword than Sauvegarde except, the last time step only is saved.
  attr reprise format_file reprise 1 Keyword to restart a calculation based on the name_file file (see the class format_file). If format_reprise is xyz, the name_file file should be the .xyz file created by the previous calculation. With this file, it is possible to restart a parallel calculation on P processors, whereas the previous calculation has been run on N (N<>P) processors. Should the calculation be restarted, values for the tinit (see schema_temps_base) time fields are taken from the name_file file. If there is no backup corresponding to this time in the name_file, TRUST exits in error.
  attr resume_last_time format_file resume_last_time 1 Keyword to restart a calculation based on the name_file file, restart the calculation at the last time found in the file (tinit is set to last time of saved files).
  ref domaine domaine
  ref scheme schema_temps_base
  ref milieu milieu_base
  ref loi1 loi_fermeture_base
  ref loi2 loi_fermeture_base
  ref loi3 loi_fermeture_base
  ref loi4 loi_fermeture_base
  ref loi5 loi_fermeture_base
loi_fermeture_base objet_u loi_fermeture_base -3 Class for appends fermeture to problem 
scalaire_impose_paroi dirichlet scalaire_impose_paroi 0 Imposed temperature condition at the wall called bord (edge). 
  attr ch front_field_base ch 0 Boundary field type.

