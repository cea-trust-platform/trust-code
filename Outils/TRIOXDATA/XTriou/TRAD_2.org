comment objet_u # 0 Comments in a data file.
  attr comm chaine comm 0 Text to be commented.
bloc_comment objet_u /* 0 bloc of Comment in a data file.
  attr comm chaine comm 0 Text to be commented.
interprete objet_u interprete 0 Basic class for interpreting a data file. Interpretors allow some operations to be carried out on objects.
read interprete lire 0 Interpretor to read the a_object objet defined between the braces.
  attr a_object chaine a_object 0 Object to be read.
  attr bloc chaine bloc 0 Definition of the object.
associate interprete associer -1 This interpretor allows one object to be associated with another. The order of the two objects in this instruction is not important. The object objet_2 is associated to objet_1 if this makes sense; if not either objet_1 is associated to objet_2 or the program exits with error because it cannot execute the Associate (Associer) instruction. For example, to calculate water flow in a pipe, a Pb_Hydraulique type object needs to be defined. But also a Domaine type object to represent the pipe, a Scheme_euler_explicit type object for time discretization, a discretization type object (VDF or VEF) and a Fluide_Incompressible type object which will contain the water properties. These objects must then all be associated with the problem.
  attr objet_1 chaine objet_1 0 Objet_1
  attr objet_2 chaine objet_2 0 Objet_2
listobj listobj_impl listobj -1 List of objects.
objet_lecture objet_u objet_lecture -1 Auxiliary class for reading.
bloc_lecture objet_lecture nul 0 to read between two braces
  attr bloc_lecture chaine bloc_lecture 0 not_set
deuxmots objet_lecture nul 0 Two words.
  attr mot_1 chaine mot_1 0 First word.
  attr mot_2 chaine mot_2 0 Second word.
troismots objet_lecture nul 0 Three words.
  attr mot_1 chaine mot_1 0 First word.
  attr mot_2 chaine mot_2 0 Snd word.
  attr mot_3 chaine mot_3 0 Third word.
format_file objet_lecture nul 0 File formatted.
  attr format chaine(into=["binaire","formatte","xyz","single_hdf"]) format 1 Type of file (the file format).
  attr name_file chaine name_file 0 Name of file.
deuxentiers objet_lecture nul 0 Two integers.
  attr int1 entier int1 0 First integer.
  attr int2 entier int2 0 Second integer.
floatfloat objet_lecture nul 0 Two reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
entierfloat objet_lecture nul 0 An integer and a real.
  attr the_int entier the_int 0 Integer.
  attr the_float floattant the_float 0 Real.
champ_a_post objet_lecture nul 0 Field to be post-processed.
  attr champ chaine champ 0 Name of the post-processed field.
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field values: The two available values are elem, som, or faces (LATA format only) used respectively to select field values at mesh centres (CHAMPMAILLE type field in the lml file) or at mesh nodes (CHAMPPOINT type field in the lml file). If no selection is made, localisation is set to som by default.
field_base objet_u champ_base -1 Basic class of fields.
champs_a_post listobj nul -1 champ_a_post 0 Fields to be post-processed.
champs_posts objet_lecture nul 0 Field\'s write mode.
  attr format chaine(into=["binaire","formatte"]) format 1 Type of file.
  attr mot chaine(into=["dt_post","nb_pas_dt_post"]) mot 0 Keyword to set the kind of the field\'s write frequency. Either a time period or a time step period.
  attr period chaine period 0 Value of the period which can be like (2.*t).
  attr champs|fields champs_a_post champs 0 Post-processed fields.
stat_post_deriv objet_lecture stat_post_deriv 0 not_set
stat_post_t_deb stat_post_deriv t_deb 0 not_set
  attr val floattant val 0 not_set
stat_post_t_fin stat_post_deriv t_fin 0 not_set
  attr val floattant val 0 not_set
stat_post_moyenne stat_post_deriv moyenne 0 not_set
  attr field chaine field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
stat_post_ecart_type stat_post_deriv ecart_type 0 not_set
  attr field chaine field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
stat_post_correlation stat_post_deriv correlation 0 not_set
  attr first_field chaine first_field 0 not_set
  attr second_field chaine second_field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
list_stat_post listobj nul -1 stat_post_deriv 0 Post-processing for statistics
stats_posts objet_lecture nul 0 Field\'s write mode. \input{{statistiques}}
  attr mot chaine(into=["dt_post","nb_pas_dt_post"]) mot 0 Keyword to set the kind of the field\'s write frequency. Either a time period or a time step period.
  attr period chaine period 0 Value of the period which can be like (2.*t).
  attr champs|fields list_stat_post champs 0 Post-processed fields.
stats_serie_posts objet_lecture nul 0 Post-processing for statistics. \input{{statistiquesseries}}
  attr mot chaine(into=["dt_integr"]) mot 0 Keyword is used to set the statistics period of integration and write period.
  attr dt_integr floattant dt_integr 0 Average on dt_integr time interval is post-processed every dt_integr seconds.
  attr stat list_stat_post stat 0 not_set
sonde_base objet_lecture sonde_base 0 Basic probe. Probes refer to sensors that allow a value or several points of the domain to be monitored over time. The probes may be a set of points defined one by one (keyword Points) or a set of points evenly distributed over a straight segment (keyword Segment) or arranged according to a layout (keyword Plan) or according to a parallelepiped (keyword Volume). The fields allow all the values of a physical value on the domain to be known at several moments in time.
un_point objet_lecture nul 0 A point.
  attr pos listf pos 0 Point coordinates.
listpoints listobj nul 0 un_point 0 Points.
points sonde_base points 0 Keyword to define the number of probe points. The file is arranged in columns.
  attr points listpoints points 0 Probe points.
point points point 0 Point as class-daughter of Points.
numero_elem_sur_maitre sonde_base numero_elem_sur_maitre 0 Keyword to define a probe at the special element. Useful for min/max sonde.
  attr numero entier numero 0 element number
segmentpoints points segmentpoints 0 This keyword is used to define a probe segment from specifics points. The nom_champ field is sampled at ns specifics points.
position_like sonde_base position_like 0 Keyword to define a probe at the same position of another probe named autre_sonde.
  attr autre_sonde chaine autre_sonde 0 Name of the other probe.
segment sonde_base segment 0 Keyword to define the number of probe segment points. The file is arranged in columns.
  attr nbr entier nbr 0 Number of probe points of the segment, evenly distributed.
  attr point_deb un_point point_deb 0 First outer probe segment point.
  attr point_fin un_point point_fin 0 Second outer probe segment point.
plan sonde_base plan 0 Keyword to set the number of probe layout points. The file format is type .lml
  attr nbr entier nbr 0 Number of probes in the first direction.
  attr nbr2 entier nbr2 0 Number of probes in the second direction.
  attr point_deb un_point point_deb 0 First point defining the angle. This angle should be positive.
  attr point_fin un_point point_fin 0 Second point defining the angle. This angle should be positive.
  attr point_fin_2 un_point point_fin_2 0 Third point defining the angle. This angle should be positive.
volume sonde_base volume 0 Keyword to define the probe volume in a parallelepiped passing through 4 points and the number of probes in each direction.
  attr nbr entier nbr 0 Number of probes in the first direction.
  attr nbr2 entier nbr2 0 Number of probes in the second direction.
  attr nbr3 entier nbr3 0 Number of probes in the third direction.
  attr point_deb un_point point_deb 0 Point of origin.
  attr point_fin un_point point_fin 0 Point defining the first direction (from point of origin).
  attr point_fin_2 un_point point_fin_2 0 Point defining the second direction (from point of origin).
  attr point_fin_3 un_point point_fin_3 0 Point defining the third direction (from point of origin).
circle sonde_base circle 0 Keyword to define several probes located on a circle.
  attr nbr entier nbr 0 Number of probes between teta1 and teta2 (angles given in degrees).
  attr point_deb un_point point_deb 0 Center of the circle.
  attr direction entier(into=[0,1,2]) direction 1 Axis normal to the circle plane (0:x axis, 1:y axis, 2:z axis).
  attr radius floattant radius 0 Radius of the circle.
  attr theta1 floattant theta1 0 First angle.
  attr theta2 floattant theta2 0 Second angle.
circle_3 sonde_base circle_3 0 Keyword to define several probes located on a circle (in 3-D space).
  attr nbr entier nbr 0 Number of probes between teta1 and teta2 (angles given in degrees).
  attr point_deb un_point point_deb 0 Center of the circle.
  attr direction entier(into=[0,1,2]) direction 0 Axis normal to the circle plane (0:x axis, 1:y axis, 2:z axis).
  attr radius floattant radius 0 Radius of the circle.
  attr theta1 floattant theta1 0 First angle.
  attr theta2 floattant theta2 0 Second angle.
sondes listobj nul 1 sonde 0 List of probes.
champ_generique_base objet_u champ_generique_base 1 not_set
listchamp_generique listobj nul 1 champ_generique_base 1 XXX
champ_post_de_champs_post champ_generique_base champ_post_de_champs_post -1 not_set
  attr source champ_generique_base source 1 the source field.
  attr nom_source chaine nom_source 1 To name a source field with the nom_source keyword
  attr source_reference chaine source_reference 1 not_set
  attr sources_reference list_nom_virgule sources_reference 1 not_set
  attr sources listchamp_generique sources 1 sources { Champ_Post.... { ... } Champ_Post.. { ... }}
refchamp champ_generique_base refchamp -1 Field of prolem
  attr pb_champ deuxmots pb_champ 0 { Pb_champ nom_pb nom_champ } : nom_pb is the problem name and nom_champ is the selected field name.
  attr nom_source chaine nom_source 1 The alias name for the field
champ_post_operateur_base champ_post_de_champs_post champ_post_operateur_base -1 not_set
gradient champ_post_operateur_base gradient -1 To calculate gradient of a given field.
divergence champ_post_operateur_base divergence -1 To calculate divergency of a given field.
champ_post_statistiques_base champ_post_de_champs_post champ_post_statistiques_base -1 not_set
  attr t_deb floattant t_deb 0 Start of integration time
  attr t_fin floattant t_fin 0 End of integration time
correlation champ_post_statistiques_base correlation -1 to calculate the correlation between the two fields.
moyenne champ_post_statistiques_base moyenne -1 to calculate the average of the field over time
  attr moyenne_convergee field_base moyenne_convergee 1 This option allows to read a converged time averaged field in a .xyz file in order to calculate, when resuming the calculation, the statistics fields (rms, correlation) which depend on this average. In that case, the time averaged field is not updated during the resume of calculation. In this case, the time averaged field must be fully converged to avoid errors when calculating high order statistics.
ecart_type champ_post_statistiques_base ecart_type -1 to calculate the standard deviation (statistic rms) of the field nom_champ.
extraction champ_post_de_champs_post extraction -1 To create a surface field (values at the boundary) of a volume field
  attr domaine ref_domaine domaine 0 name of the volume field
  attr nom_frontiere chaine nom_frontiere 0 boundary name where the values of the volume field will be picked
  attr methode chaine(into=["trace","champ_frontiere"]) methode 1 name of the extraction method (trace by_default or champ_frontiere)
definition_champ objet_lecture nul 0 Keyword to create new complex field for advanced postprocessing.
  attr name chaine name 0 The name of the new created field.
  attr champ_generique champ_generique_base champ_generique 0 not_set
definition_champs listobj nul 1 definition_champ 0 List of definition champ
postraitement_base objet_lecture postraitement_base -1 not_set
corps_postraitement postraitement nul -1 not_set
un_postraitement objet_lecture nul 0 An object of post-processing (with name).
  attr nom chaine nom 0 Name of the post-processing.
  attr post corps_postraitement post 0 Definition of the post-processing.
postraitements listobj postraitements -1 un_postraitement 0 Keyword to use several results files. List of objects of post-processing (with name).
type_un_post objet_lecture nul 0 not_set
  attr type chaine(into=["postraitement","post_processing"]) type 0 not_set
  attr post un_postraitement post 0 not_set
type_postraitement_ft_lata objet_lecture nul 0 not_set
  attr type chaine(into=["postraitement_ft_lata","postraitement_lata"]) type 0 not_set
  attr nom chaine nom 0 Name of the post-processing.
  attr bloc chaine bloc 0 not_set
un_postraitement_spec objet_lecture nul 0 An object of post-processing (with type +name).
  attr type_un_post type_un_post type_un_post 1 not_set
  attr type_postraitement_ft_lata type_postraitement_ft_lata type_postraitement_ft_lata 1 not_set
liste_post listobj liste_post -1 un_postraitement_spec 0 Keyword to use several results files. List of objects of post-processing (with name)
nom_postraitement objet_lecture nul 0 not_set
  attr nom chaine nom 0 Name of the post-processing.
  attr post postraitement_base post 0 the post
liste_post_ok listobj liste_post_ok -1 nom_postraitement 0 Keyword to use several results files. List of objects of post-processing (with name)
pb_gen_base objet_u pb_gen_base -1 Basic class for problems.
discretize interprete discretiser -1 Keyword to discretise a problem problem_name according to the discretization dis. NL2 IMPORTANT: A number of objects must be already associated (a domain, time scheme, central object) prior to invoking the Discretize (Discretiser) keyword. The physical properties of this central object must also have been read.
  attr problem_name ref_pb_gen_base problem_name 0 Name of problem.
  attr dis ref_discretisation_base dis 0 Name of the discretization object.
condinit objet_lecture nul 0 Initial condition.
  attr nom chaine nom 0 Name of initial condition field.
  attr ch field_base ch 0 Type field and the initial values.
condinits listobj condinits -1 condinit 0 Initial conditions.
nom objet_u nom 0 Class to name the TRUST objects.
  attr mot chaine mot 1 Chain of characters.
nom_anonyme nom nul -1 not_set
vect_nom listobj vect_nom 0 nom_anonyme 0 Vect of name.
list_nom listobj list_nom 1 nom_anonyme 0 List of name.
list_nom_virgule listobj list_nom_virgule 1 nom_anonyme 1 List of name.
mailler_base objet_lecture mailler_base -1 Basic class to mesh.
defbord objet_lecture nul 0 Class to define an edge.
defbord_2 defbord nul -1 1-D edge (straight line) in the 2-D space.
  attr dir chaine(into=["X","Y"]) dir 0 Edge is perpendicular to this direction.
  attr eq chaine(into=["="]) eq 0 Equality sign.
  attr pos floattant pos 0 Position value.
  attr pos2_min floattant pos2_min 0 Minimal value.
  attr inf1 chaine(into=["<="]) inf1 0 Less than or equal to sign.
  attr dir2 chaine(into=["X","Y"]) dir2 0 Edge is parallel to this direction.
  attr inf2 chaine(into=["<="]) inf2 0 Less than or equal to sign.
  attr pos2_max floattant pos2_max 0 Maximal value.
defbord_3 defbord nul -1 2-D edge (plane) in the 3-D space.
  attr dir chaine(into=["X","Y","Z"]) dir 0 Edge is perpendicular to this direction.
  attr eq chaine(into=["="]) eq 0 Equality sign.
  attr pos floattant pos 0 Position value.
  attr pos2_min floattant pos2_min 0 Minimal value.
  attr inf1 chaine(into=["<="]) inf1 0 Less than or equal to sign.
  attr dir2 chaine(into=["X","Y"]) dir2 0 Edge is parallel to this direction.
  attr inf2 chaine(into=["<="]) inf2 0 Less than or equal to sign.
  attr pos2_max floattant pos2_max 0 Maximal value.
  attr pos3_min floattant pos3_min 0 Minimal value.
  attr inf3 chaine(into=["<="]) inf3 0 Less than or equal to sign.
  attr dir3 chaine(into=["Y","Z"]) dir3 0 Edge is parallel to this direction.
  attr inf4 chaine(into=["<="]) inf4 0 Less than or equal to sign.
  attr pos3_max floattant pos3_max 0 Maximal value.
bord bord_base bord 0 The block side is not in contact with another block and boundary conditions are applied to it.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
raccord bord_base raccord 0 The block side is in contact with the block of another domain (case of two coupled problems).
  attr type1 chaine(into=["local","distant"]) type1 0 Contact type.
  attr type2 chaine(into=["homogene"]) type2 0 Contact type.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
internes bord_base internes 0 To indicate that the block has a set of internal faces (these faces will be duplicated automatically by the program and will be processed in a manner similar to edge faces). NL2 Two boundaries with the same boundary conditions may have the same name (whether or not they belong to the same block). NL2 The keyword Internes (Internal) must be used to execute a calculation with plates, followed by the equation of the surface area covered by the plates.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
epsilon mailler_base epsilon 0 Two points will be confused if the distance between them is less than eps. By default, eps is set to 1e-12. The keyword Epsilon allows an alternative value to be assigned to eps.
  attr eps floattant eps 0 New value of precision.
domain mailler_base domain 0 Class to reuse a domain.
  attr domain_name ref_domaine domain_name 0 Name of domain.
list_bloc_mailler listobj list_bloc_mailler 1 mailler_base 1 List of block mesh.
mailler interprete mailler -1 The Mailler (Mesh) interpretor allows a Domain type object domaine to be meshed with objects objet_1, objet_2, etc...
  attr domaine ref_domaine domaine 0 Name of domain.
  attr bloc list_bloc_mailler bloc 0 Instructions to mesh.
write_file interprete ecrire_fichier -1 Keyword to write the object of name name_obj to a file filename. Since the v1.6.3, the default format is now binary format file.
  attr name_obj chaine name_obj 0 Name of the object to be written.
  attr filename chaine filename 0 Name of the file.
ecrire_fichier_formatte write_file ecrire_fichier_formatte -1 Keyword to write the object of name name_obj to a file filename in ASCII format.
write interprete ecrire -1 Keyword to write the object of name name_obj to a standard outlet.
  attr name_obj chaine name_obj 0 Name of the object to be written.
discretisation_base objet_u discretisation_base -1 Basic class for space discretization of thermohydraulic turbulent problems.
vdf discretisation_base vdf -1 Finite difference volume discretization.
polymac discretisation_base polymac -1 polymac discretization (polymac discretization that is not compatible with pb_multi).
polymac_P0P1NC discretisation_base polymac_P0P1NC -1 polymac_P0P1NC discretization (previously polymac discretization compatible with pb_multi).
polymac_p0 discretisation_base polymac_p0 -1 polymac_p0 discretization (previously covimac discretization compatible with pb_multi).
fin interprete fin -1 Keyword which must complete the data file. The execution of the data file stops when reaching this keyword.
domaine objet_u domaine -1 Keyword to create a domain.
class_generic objet_u class_generic -1 not_set
dt_start class_generic dt_start 0 not_set
dt_calc_dt_calc dt_start dt_calc 0 The time step at first iteration is calculated in agreement with CFL condition.
dt_calc_dt_min dt_start dt_min 0 The first iteration is based on dt_min.
dt_calc_dt_fixe dt_start dt_fixe 0 The first time step is fixed by the user (recommended when resuming calculation with Crank Nicholson temporal scheme to ensure continuity).
  attr value floattant value 0 first time step.
euler_scheme schema_temps_base schema_euler_explicite -1 This is the Euler explicit scheme.
schema_predictor_corrector schema_temps_base schema_predictor_corrector -1 This is the predictor-corrector scheme (second order). It is more accurate and economic than MacCormack scheme. It gives best results with a second ordre convective scheme like quick, centre (VDF).
solveur_implicite_base objet_u solveur_implicite_base -1 Class for solver in the situation where the time scheme is the implicit scheme. Solver allows equation diffusion and convection operators to be set as implicit terms.
solveur_sys_base class_generic solveur_sys_base -1 Basic class to solve the linear system.
Sch_CN_iteratif schema_temps_base Sch_CN_iteratif -1 The Crank-Nicholson method of second order accuracy. A mid-point rule formulation is used (Euler-centered scheme). The basic scheme is: $$u(t+1) = u(t) + du/dt(t+1/2)*dt$$ The estimation of the time derivative du/dt at the level (t+1/2) is obtained either by iterative process. The time derivative du/dt at the level (t+1/2) is calculated iteratively with a simple under-relaxations method. Since the method is implicit, neither the cfl nor the fourier stability criteria must be respected. The time step is calculated in a way that the iterative procedure converges with the less iterations as possible. NL2 Remark : for stationary or RANS calculations, no limitation can be given for time step through high value of facsec_max parameter (for instance : facsec_max 1000). In counterpart, for LES calculations, high values of facsec_max may engender numerical instabilities.
  attr niter_min entier niter_min 1 minimal number of p-iterations to satisfy convergence criteria (2 by default)
  attr niter_max entier niter_max 1 number of maximum p-iterations allowed to satisfy convergence criteria (6 by default)
  attr niter_avg entier niter_avg 1 threshold of p-iterations (3 by default). If the number of p-iterations is greater than niter_avg, facsec is reduced, if lesser than niter_avg, facsec is increased (but limited by the facsec_max value).
  attr facsec_max floattant facsec_max 1 maximum ratio allowed between dynamical time step returned by iterative process and stability time returned by CFL condition (2 by default).
  attr seuil floattant seuil 1 criteria for ending iterative process (Max( || u(p) - u(p-1)||/Max || u(p) ||) < seuil) (0.001  by default)
Sch_CN_EX_iteratif Sch_CN_iteratif Sch_CN_EX_iteratif -1 This keyword also describes a Crank-Nicholson method of second order accuracy but here, for scalars, because of instablities encountered when dt>dt_CFL, the Crank Nicholson scheme is not applied to scalar quantities. Scalars are treated according to Euler-Explicite scheme at the end of the CN treatment for velocity flow fields (by doing p Euler explicite under-iterations at dt<=dt_CFL). Parameters are the sames (but default values may change) compare to the Sch_CN_iterative scheme plus a relaxation keyword: niter_min (2 by default), niter_max (6 by default), niter_avg (3 by default), facsec_max (20 by default), seuil (0.05 by default)
  attr omega floattant omega 1 relaxation factor (0.1 by default)
leap_frog schema_temps_base leap_frog -1 This is the leap-frog scheme.
solveur_lineaire_std solveur_implicite_base solveur_lineaire_std 1 not_set
  attr solveur solveur_sys_base solveur 1 not_set
simpler solveur_implicite_base simpler 1 Simpler method for incompressible systems.
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 0 Keyword to set the value of the convergence criteria for the resolution of the implicit system build to solve either the Navier_Stokes equation (only for Simple and Simpler algorithms) or a scalar equation. It is adviced to use the default value (1e6) to solve the implicit system only once by time step. This value must be decreased when a coupling between problems is considered.
  attr seuil_convergence_solveur floattant seuil_convergence_solveur 1 value of the convergence criteria for the resolution of the implicit system build by solving several times per time step the Navier_Stokes equation and the scalar equations if any. This value MUST be used when a coupling between problems is considered (should be set to a value typically of 0.1 or 0.01).
  attr seuil_generation_solveur floattant seuil_generation_solveur 1 Option to create a GMRES solver and use vrel as the convergence threshold (implicit linear system Ax=B will be solved if residual error ||Ax-B|| is lesser than vrel).
  attr seuil_verification_solveur floattant seuil_verification_solveur 1 Option to check if residual error ||Ax-B|| is lesser than vrel after the implicit linear system Ax=B has been solved.
  attr seuil_test_preliminaire_solveur floattant seuil_test_preliminaire_solveur 1 Option to decide if the implicit linear system Ax=B should be solved by checking if the residual error ||Ax-B|| is bigger than vrel.
  attr solveur solveur_sys_base solveur 1 Method (different from the default one, Gmres with diagonal preconditioning) to solve the linear system.
  attr no_qdm rien no_qdm 1 Keyword to not solve qdm equation (and turbulence models of these equation).
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gmres.
  attr controle_residu rien controle_residu 1 Keyword of Boolean type (by default 0). If set to 1, the convergence occurs if the residu suddenly increases.
piso simpler piso -1 Piso (Pressure Implicit with Split Operator) - method to solve N_S.
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 1 Convergence criteria.
  attr nb_corrections_max entier nb_corrections_max 1 Maximum number of corrections performed by the PISO algorithm to achieve the projection of the velocity field. The algorithm may perform less corrections then nb_corrections_max if the accuracy of the projection is sufficient. (By default nb_corrections_max is set to 21).
implicite piso implicite -1 similar to PISO, but as it looks like a simplified solver, it will use fewer timesteps. But it may run faster because the pressure matrix is not re-assembled and thus provides CPU gains.
simple piso simple -1 SIMPLE type algorithm
  attr relax_pression floattant relax_pression 1 Value between 0 and 1 (by default 1), this keyword is used only by the SIMPLE algorithm for relaxing the increment of pressure.
solveur_u_p simple solveur_u_p 1 similar to simple.
schema_implicite_base schema_temps_base schema_implicite_base -1 Basic class for implicite time scheme.
  attr max_iter_implicite entier max_iter_implicite 1 Maximum number of iterations allowed for the solver (by default 200).
  attr solveur solveur_implicite_base solveur 0 This keyword is used to designate the solver selected in the situation where the time scheme is an implicit scheme. solver is the name of the solver that allows equation diffusion and convection operators to be set as implicit terms. Keywords corresponding to this functionality are Simple (SIMPLE type algorithm), Simpler (SIMPLER type algorithm) for incompressible systems, Piso (Pressure Implicit with Split Operator), and Implicite (similar to PISO, but as it looks like a simplified solver, it will use fewer timesteps, and ICE (for PB_multiphase). But it may run faster because the pressure matrix is not re-assembled and thus provides CPU gains. NL2 Advice: Since the 1.6.0 version, we recommend to use first the Implicite or Simple, then Piso, and at least Simpler. Because the two first give a fastest convergence (several times) than Piso and the Simpler has not been validated. It seems also than Implicite and Piso schemes give better results than the Simple scheme when the flow is not fully stationary. Thus, if the solution obtained with Simple is not stationary, it is recommended to switch to Piso or Implicite scheme.
un_pb objet_lecture nul 0 pour les groupes
  attr mot ref_Pb_base mot 0 the string
list_un_pb listobj nul 1 un_pb 1 pour les groupes
list_list_nom listobj nul 1 list_un_pb 1 pour les groupes
coupled_problem pb_gen_base probleme_couple -1 This instruction causes a probleme_couple type object to be created. This type of object has an associated problem list, that is, the coupling of n problems among them may be processed. Coupling between these problems is carried out explicitly via conditions at particular contact limits. Each problem may be associated either with the Associate keyword or with the Read/groupes keywords. The difference is that in the first case, the four problems exchange values then calculate their timestep, rather in the second case, the same strategy is used for all the problems listed inside one group, but the second group of problem exchange values with the first group of problems after the first group did its timestep. So, the first case may then also be written like this: NL2 Probleme_Couple pbc NL2 Read pbc { groupes { { pb1 , pb2 , pb3 , pb4 } } } NL2 There is a physical environment per problem (however, the same physical environment could be common to several problems). NL2 Each problem is resolved in a domain. NL2 Warning : Presently, coupling requires coincident meshes. In case of non-coincident meshes, boundary condition \'paroi_contact\' in VEF returns error message (see paroi_contact for correcting procedure).
  attr groupes list_list_nom groupes 1 { groupes { { pb1 , pb2 } , { pb3 , pb4 } } }
  ref domaine_2 domaine
  ref pb_1 Pb_base
  ref pb_2 Pb_base
  ref pb_3 Pb_base
  ref pb_4 Pb_base
  ref scheme_2 schema_temps_base
mor_eqn objet_u mor_eqn -1 Class of equation pieces (morceaux d\'equation).
bords_ecrire objet_lecture nul 0 not_set
  attr chaine chaine(into=["bords"]) chaine 0 not_set
  attr bords listchaine bords 0 Keyword to post-process only on some boundaries : NL2 bords nb_bords boundary1 ... boundaryn NL2 where NL2 nb_bords : number of boundaries NL2 boundary1 ... boundaryn : name of the boundaries.
convection_deriv objet_lecture convection_deriv 0 not_set
bloc_convection objet_lecture nul 0 not_set
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr operateur convection_deriv operateur 0 not_set
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
diffusion_deriv objet_lecture diffusion_deriv 0 not_set
op_implicite objet_lecture nul 0 not_set
  attr implicite chaine(into=["implicite"]) implicite 0 not_set
  attr mot chaine(into=["solveur"]) mot 0 not_set
  attr solveur solveur_sys_base solveur 0 not_set
bloc_diffusion objet_lecture nul 0 not_set
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr operateur diffusion_deriv operateur 1 if none is specified, the diffusive scheme used is a 2nd-order scheme.
  attr op_implicite op_implicite op_implicite 1 To have diffusive implicitation, it use Uzawa algorithm. Very useful when viscosity has large variations.
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
traitement_particulier_base objet_lecture traitement_particulier_base 1 Basic class to post-process particular values.
traitement_particulier objet_lecture nul 0 Auxiliary class to post-process particular values.
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr trait_part traitement_particulier_base trait_part 0 Type of traitement_particulier.
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
navier_stokes_standard eqn_base navier_stokes_standard -1 Navier-Stokes equations.
  attr methode_calcul_pression_initiale chaine(into=["avec_les_cl","avec_sources","avec_sources_et_operateurs","sans_rien"]) methode_calcul_pression_initiale 1 Keyword to select an option for the pressure calculation before the fist time step. Options are : avec_les_cl (default option lapP=0 is solved with Neuman boundary conditions on pressure if any), avec_sources (lapP=f is solved with Neuman boundaries conditions and f integrating the source terms of the Navier-Stokes equations) and avec_sources_et_operateurs (lapP=f is solved as with the previous option avec_sources but f integrating also some operators of the Navier-Stokes equations). The two last options are useful and sometime necessary when source terms are implicited when using an implicit time scheme to solve the Navier-Stokes equations.
  attr projection_initiale entier projection_initiale 1 Keyword to suppress, if boolean equals 0, the initial projection which checks DivU=0. By default, boolean equals 1.
  attr solveur_pression solveur_sys_base solveur_pression 1 Linear pressure system resolution method.
  attr solveur_bar solveur_sys_base solveur_bar 1 This keyword is used to define when filtering operation is called (typically for EF convective scheme, standard diffusion operator and Source_Qdm_lambdaup ). A file (solveur.bar) is then created and used for inversion procedure. Syntax is the same then for pressure solver (GCP is required for multi-processor calculations and, in a general way, for big meshes).
  attr dt_projection deuxmots dt_projection 1 nb value : This keyword checks every nb time-steps the equality of velocity divergence to zero. value is the criteria convergency for the solver used.
  attr seuil_divU floatfloat seuil_divU 1 value factor : this keyword is intended to minimise the number of iterations during the pressure system resolution. The convergence criteria during this step (\'seuil\' in solveur_pression) is dynamically adapted according to the mass conservation. At tn , the linear system Ax=B is considered as solved if the residual ||Ax-B||<seuil(tn). For tn+1, the threshold value seuil(tn+1) will be evualated as: NL2 If ( |max(DivU)*dt|<value ) NL2 Seuil(tn+1)= Seuil(tn)*factor NL2 Else NL2 Seuil(tn+1)= Seuil(tn)*factor NL2 Endif NL2 The first parameter (value) is the mass evolution the user is ready to accept per timestep, and the second one (factor) is the factor of evolution for \'seuil\' (for example 1.1, so 10% per timestep). Investigations has to be lead to know more about the effects of these two last parameters on the behaviour of the simulations.
  attr traitement_particulier traitement_particulier traitement_particulier 1 Keyword to post-process particular values.
  attr correction_matrice_projection_initiale entier correction_matrice_projection_initiale 1 (IBM advanced) fix matrix of initial projection for PDF
  attr correction_calcul_pression_initiale entier correction_calcul_pression_initiale 1 (IBM advanced) fix initial pressure computation for PDF
  attr correction_vitesse_projection_initiale entier correction_vitesse_projection_initiale 1 (IBM advanced) fix initial velocity computation for PDF
  attr correction_matrice_pression entier correction_matrice_pression 1 (IBM advanced) fix pressure matrix for PDF
  attr correction_vitesse_modifie entier correction_vitesse_modifie 1 (IBM advanced) fix velocity for PDF
  attr gradient_pression_qdm_modifie entier gradient_pression_qdm_modifie 1 (IBM advanced) fix pressure gradient
  attr correction_pression_modifie entier correction_pression_modifie 1 (IBM advanced) fix pressure for PDF
  attr postraiter_gradient_pression_sans_masse rien postraiter_gradient_pression_sans_masse 1 (IBM advanced) avoid mass matrix multiplication for the gradient postprocessing
penalisation_l2_ftd_lec objet_lecture nul 0 not_set
  attr postraiter_gradient_pression_sans_masse entier postraiter_gradient_pression_sans_masse 1 (IBM advanced) avoid mass matrix multiplication for the gradient postprocessing
  attr correction_matrice_projection_initiale entier correction_matrice_projection_initiale 1 (IBM advanced) fix matrix of initial projection for PDF
  attr correction_calcul_pression_initiale entier correction_calcul_pression_initiale 1 (IBM advanced) fix initial pressure computation for PDF
  attr correction_vitesse_projection_initiale entier correction_vitesse_projection_initiale 1 (IBM advanced) fix initial velocity computation for PDF
  attr correction_matrice_pression entier correction_matrice_pression 1 (IBM advanced) fix pressure matrix for PDF
  attr matrice_pression_penalisee_H1 entier matrice_pression_penalisee_H1 1 (IBM advanced) fix pressure matrix for PDF
  attr correction_vitesse_modifie entier correction_vitesse_modifie 1 (IBM advanced) fix velocity for PDF
  attr correction_pression_modifie entier correction_pression_modifie 1 (IBM advanced) fix pressure for PDF
  attr gradient_pression_qdm_modifie entier gradient_pression_qdm_modifie 1 (IBM advanced) fix pressure gradient
  attr bord chaine bord 0 not_set
  attr val list val 0 not_set
penalisation_l2_ftd listobj pp 1 penalisation_l2_ftd_lec 0 not_set
convection_diffusion_temperature eqn_base convection_diffusion_temperature -1 Energy equation (temperature diffusion convection).
  attr penalisation_l2_ftd penalisation_l2_ftd penalisation_l2_ftd 1 to activate or not (the default is Direct Forcing method) the Penalized Direct Forcing method to impose the specified temperature on the solid-fluid interface.
turbulence_paroi_base objet_u turbulence_paroi_base -1 Basic class for wall laws for Navier-Stokes equations.
dt_impr_ustar_mean_only objet_lecture nul 1 not_set
  attr dt_impr floattant dt_impr 0 not_set
  attr boundaries listchaine boundaries 1 not_set
modele_turbulence_hyd_deriv objet_lecture modele_turbulence_hyd_deriv -1 Basic class for turbulence model for Navier-Stokes equations.
  attr correction_visco_turb_pour_controle_pas_de_temps rien correction_visco_turb_pour_controle_pas_de_temps 1 Keyword to set a limitation to low time steps due to high values of turbulent viscosity. The limit for turbulent viscosity is calculated so that diffusive time-step is equal or higher than convective time-step. For a stationary flow, the correction for turbulent viscosity should apply only during the first time steps and not when permanent state is reached. To check that, we could post process the corr_visco_turb field which is the correction of turbulent viscosity: it should be 1. on the whole domain.
  attr correction_visco_turb_pour_controle_pas_de_temps_parametre floattant correction_visco_turb_pour_controle_pas_de_temps_parametre 1 Keyword to set a limitation to low time steps due to high values of turbulent viscosity. The limit for turbulent viscosity is the ratio between diffusive time-step and convective time-step is higher or equal to the given value [0-1]
  attr turbulence_paroi turbulence_paroi_base turbulence_paroi 1 Keyword to set the wall law.
  attr dt_impr_ustar floattant dt_impr_ustar 1 This keyword is used to print the values (U +, d+, u$\star$) obtained with the wall laws into a file named datafile_ProblemName_Ustar.face and periode refers to the printing period, this value is expressed in seconds.
  attr dt_impr_ustar_mean_only dt_impr_ustar_mean_only dt_impr_ustar_mean_only 1 This keyword is used to print the mean values of u* ( obtained with the wall laws) on each boundary, into a file named datafile_ProblemName_Ustar_mean_only.out. periode refers to the printing period, this value is expressed in seconds. If you don\'t use the optional keyword boundaries, all the boundaries will be considered. If you use it, you must specify nb_boundaries which is the number of boundaries on which you want to calculate the mean values of u*, then you have to specify their names.
  attr nut_max floattant nut_max 1 Upper limitation of turbulent viscosity (default value 1.e8).
paroi_fixe condlim_base paroi_fixe -1 Keyword to designate a situation of adherence to the wall called bord (edge) (normal and tangential velocity at the edge is zero).
symetrie condlim_base symetrie -1 1). For Navier-Stokes equations, this keyword is used to designate a symmetry condition concerning the velocity at the boundary called bord (edge) (normal velocity at the edge equal to zero and tangential velocity gradient at the edge equal to zero); 2). For scalar transport equation, this keyword is used to set a symmetry condition on scalar on the boundary named bord (edge).
periodic condlim_base periodique -1 1). For Navier-Stokes equations, this keyword is used to indicate that the horizontal inlet velocity values are the same as the outlet velocity values, at every moment. As regards meshing, the inlet and outlet edges bear the same name.; 2). For scalar transport equation, this keyword is used to set a periodic condition on scalar. The two edges dealing with this periodic condition bear the same name.
paroi_adiabatique condlim_base paroi_adiabatique -1 Normal zero flux condition at the wall called bord (edge).
front_field_base objet_u champ_front_base -1 Basic class for fields at domain boundaries.
dirichlet condlim_base dirichlet -1 Dirichlet condition at the boundary called bord (edge) : 1). For Navier-Stokes equations, velocity imposed at the boundary; 2). For scalar transport equation, scalar imposed at the boundary.
paroi_defilante dirichlet paroi_defilante -1 Keyword to designate a condition where tangential velocity is imposed on the wall called bord (edge). If the velocity components set by the user is not tangential, projection is used.
  attr ch front_field_base ch 0 Boundary field type.
paroi_knudsen_non_negligeable dirichlet paroi_knudsen_non_negligeable -1 Boundary condition for number of Knudsen (Kn) above 0.001 where slip-flow condition appears: the velocity near the wall depends on the shear stress : Kn=l/L with l is the mean-free-path of the molecules and L a characteristic length scale. NL2 U(y=0)-Uwall=k(dU/dY) NL2 Where k is a coefficient given by several laws: NL2 Mawxell : k=(2-s)*l/s NL2 Bestok\&Karniadakis :k=(2-s)/s*L*Kn/(1+Kn) NL2 Xue\&Fan :k=(2-s)/s*L*tanh(Kn) NL2 s is a value between 0 and 2 named accomodation coefficient. s=1 seems a good value. NL2 Warning : The keyword is available for VDF calculation only for the moment.
  attr name_champ_1 chaine(into=["vitesse_paroi","k"]) name_champ_1 0 Field name.
  attr champ_1 front_field_base champ_1 0 Boundary field type.
  attr name_champ_2 chaine(into=["vitesse_paroi","k"]) name_champ_2 0 Field name.
  attr champ_2 front_field_base champ_2 0 Boundary field type.
neumann condlim_base neumann -1 Neumann condition at the boundary called bord (edge) : 1). For Navier-Stokes equations, constraint imposed at the boundary; 2). For scalar transport equation, flux imposed at the boundary.
frontiere_ouverte_vitesse_imposee dirichlet frontiere_ouverte_vitesse_imposee -1 Class for velocity-inlet boundary condition. The imposed velocity field at the inlet is vectorial and the imposed velocity values are expressed in m.s-1.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_vitesse_imposee_sortie frontiere_ouverte_vitesse_imposee frontiere_ouverte_vitesse_imposee_sortie -1 Sub-class for velocity boundary condition. The imposed velocity field at the open boundary is vectorial and the imposed velocity values are expressed in m.s-1.
frontiere_ouverte_rho_u_impose frontiere_ouverte_vitesse_imposee_sortie frontiere_ouverte_rho_u_impose -1 This keyword is used to designate a condition of imposed mass rate at an open boundary called bord (edge). The imposed mass rate field at the inlet is vectorial and the imposed velocity values are expressed in kg.s-1. This boundary condition can be used only with the Quasi compressible model.
frontiere_ouverte_gradient_pression_libre_vef neumann frontiere_ouverte_gradient_pression_libre_vef -1 Class for outlet boundary condition in VEF like Orlansky. There is no reference for pressure for theses boundary conditions so it is better to add pressure condition (with Frontiere_ouverte_pression_imposee) on one or two cells (for symmetry in a channel) of the boundary where Orlansky conditions are imposed.
frontiere_ouverte_gradient_pression_libre_vefprep1b neumann frontiere_ouverte_gradient_pression_libre_vefprep1b -1 Class for outlet boundary condition in VEF P1B/P1NC like Orlansky.
frontiere_ouverte_gradient_pression_impose neumann frontiere_ouverte_gradient_pression_impose -1 Normal imposed pressure gradient condition on the open boundary called bord (edge). This boundary condition may be only used in VDF discretization. The imposed $\partial P/\partial n$ value is expressed in Pa.m-1.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_pression_imposee neumann frontiere_ouverte_pression_imposee -1 Imposed pressure condition at the open boundary called bord (edge). The imposed pressure field is expressed in Pa.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_pression_imposee_orlansky neumann frontiere_ouverte_pression_imposee_orlansky -1 This boundary condition may only be used with VDF discretization. There is no reference for pressure for this boundary condition so it is better to add pressure condition (with Frontiere_ouverte_pression_imposee) on one or two cells (for symetry in a channel) of the boundary where Orlansky conditions are imposed.
frontiere_ouverte_pression_moyenne_imposee neumann frontiere_ouverte_pression_moyenne_imposee 0 Class for open boundary with pressure mean level imposed.
  attr pext floattant pext 0 Mean pressure.
frontiere_ouverte neumann frontiere_ouverte -1 Boundary outlet condition on the boundary called bord (edge) (diffusion flux zero). This condition must be associated with a boundary outlet hydraulic condition.
  attr var_name chaine(into=["T_ext","C_ext","Y_ext","K_Eps_ext","Fluctu_Temperature_ext","Flux_Chaleur_Turb_ext","V2_ext","a_ext","tau_ext","k_ext","omega_ext","H_ext"]) var_name 0 Field name.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_temperature_imposee dirichlet frontiere_ouverte_temperature_imposee -1 Imposed temperature condition at the open boundary called bord (edge) (in the case of fluid inlet). This condition must be associated with an imposed inlet velocity condition. The imposed temperature value is expressed in oC or K.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_concentration_imposee dirichlet frontiere_ouverte_concentration_imposee -1 Imposed concentration condition at an open boundary called bord (edge) (situation corresponding to a fluid inlet). This condition must be associated with an imposed inlet velocity condition.
  attr ch front_field_base ch 0 Boundary field type.
paroi_contact condlim_base paroi_contact -1 Thermal condition between two domains. Important: the name of the boundaries in the two domains should be the same. (Warning: there is also an old limitation not yet fixed on the sequential algorithm in VDF to detect the matching faces on the two boundaries: faces should be ordered in the same way). The kind of condition depends on the discretization. In VDF, it is a heat exchange condition, and in VEF, a temperature condition. NL2 Such a coupling requires coincident meshes for the moment. In case of non-coincident meshes, run is stopped and two external files are automatically generated in VEF (connectivity_failed_boundary_name and connectivity_failed_pb_name.med). In 2D, the keyword Decouper_bord_coincident associated to the connectivity_failed_boundary_name file allows to generate a new coincident mesh. NL2 In 3D, for a first preliminary cut domain with HOMARD (fluid for instance), the second problem associated to pb_name (solide in a fluid/solid coupling problem) has to be submitted to HOMARD cutting procedure with connectivity_failed_pb_name.med. NL2 Such a procedure works as while the primary refined mesh (fluid in our example) impacts the fluid/solid interface with a compact shape as described below (values 2 or 4 indicates the number of division from primary faces obtained in fluid domain at the interface after HOMARD cutting): NL2 2-2-2-2-2-2 NL2 2-4-4-4-4-4-2 \\; 2-2-2 NL2 2-4-4-4-4-2 \\; 2-4-2 NL2 2-2-2-2-2 \\; 2-2 NL2 OK NL2 NL2 2-2 \\; \\; 2-2-2 NL2 2-4-2 \\; 2-2 NL2 2-2 \\; 2-2 NL2 NOT OK
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 boundary name of the remote problem which should be the same than the local name
paroi_contact_fictif condlim_base paroi_contact_fictif -1 This keyword is derivated from paroi_contact and is especially dedicated to compute coupled fluid/solid/fluid problem in case of thin material. Thanks to this option, solid is considered as a fictitious media (no mesh, no domain associated), and coupling is performed by considering instantaneous thermal equilibrium in it (for the moment).
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 Name of bord.
  attr conduct_fictif floattant conduct_fictif 0 thermal conductivity
  attr ep_fictive floattant ep_fictive 0 thickness of the fictitious media
paroi_echange_contact_vdf condlim_base paroi_echange_contact_vdf -1 Boundary condition type to model the heat flux between two problems. Important: the name of the boundaries in the two problems should be the same.
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 Name of bord.
  attr temp chaine temp 0 Name of field.
  attr h floattant h 0 Value assigned to a coefficient (expressed in W.K-1m-2) that characterises the contact between the two mediums. In order to model perfect contact, h must be taken to be infinite. This value must obviously be the same in both the two problems blocks. NL2 The surface thermal flux exchanged between the two mediums is represented by : NL2 fi = h (T1-T2) where 1/h = d1/lambda1 + 1/val_h_contact + d2/lambda2 NL2 where di : distance between the node where Ti and the wall is found.
paroi_echange_externe_impose condlim_base paroi_echange_externe_impose -1 External type exchange condition with a heat exchange coefficient and an imposed external temperature.
  attr h_imp chaine h_imp 0 Heat exchange coefficient value (expressed in W.m-2.K-1).
  attr himpc front_field_base himpc 0 Boundary field type.
  attr text chaine text 0 External temperature value (expressed in oC or K).
  attr ch front_field_base ch 0 Boundary field type.
paroi_echange_global_impose condlim_base paroi_echange_global_impose -1 Global type exchange condition (internal) that is to say that diffusion on the first fluid mesh is not taken into consideration.
  attr h_imp chaine h_imp 0 Global exchange coefficient value. The global exchange coefficient value is expressed in W.m-2.K-1.
  attr himpc front_field_base himpc 0 Boundary field type.
  attr text chaine text 0 External temperature value. The external temperature value is expressed in oC or K.
  attr ch front_field_base ch 0 Boundary field type.
boussinesq_temperature source_base boussinesq_temperature -1 Class to describe a source term that couples the movement quantity equation and energy equation with the Boussinesq hypothesis.
  attr t0 chaine t0 0 Reference temperature value (oC or K). It can also be a time dependant function since the 1.6.6 version.
  attr verif_boussinesq entier verif_boussinesq 1 Keyword to check (1) or not (0) the reference temperature in comparison with the mean temperature value in the domain. It is set to 1 by default.
boussinesq_concentration source_base boussinesq_concentration -1 Class to describe a source term that couples the movement quantity equation and constituent transport equation with the Boussinesq hypothesis.
  attr c0 list c0 0 Reference concentration field type. The only field type currently available is Champ_Uniforme (Uniform field).
  attr verif_boussinesq entier verif_boussinesq 1 Keyword to check (1) or not (0) the reference concentration in comparison with the mean concentration value in the domain. It is set to 1 by default.
dirac source_base dirac 0 Class to define a source term corresponding to a volume power release in the energy equation.
  attr position list position 0 not_set
  attr ch field_base ch 0 Thermal power field type. To impose a volume power on a domain sub-area, the Champ_Uniforme_Morceaux (partly_uniform_field) type must be used. NL2 Warning : The volume thermal power is expressed in W.m-3.
puissance_thermique source_base puissance_thermique 0 Class to define a source term corresponding to a volume power release in the energy equation.
  attr ch field_base ch 0 Thermal power field type. To impose a volume power on a domain sub-area, the Champ_Uniforme_Morceaux (partly_uniform_field) type must be used. NL2 Warning : The volume thermal power is expressed in W.m-3 in 3D (in W.m-2 in 2D). It is a power per volume unit (in a porous media, it is a power per fluid volume unit).
source_qdm_lambdaup source_base source_qdm_lambdaup 1 This source term is a dissipative term which is intended to minimise the energy associated to non-conformscales u\' (responsible for spurious oscillations in some cases). The equation for these scales can be seen as: du\'/dt= -lambda. u\' + grad P\' where -lambda. u\' represents the dissipative term, with lambda = a/Delta t For Crank-Nicholson temporal scheme, recommended value for a is 2. NL2 Remark : This method requires to define a filtering operator.
  attr lambda floattant lambda_u 0 value of lambda
  attr lambda_min floattant lambda_min 1 value of lambda_min
  attr lambda_max floattant lambda_max 1 value of lambda_max
  attr ubar_umprim_cible floattant ubar_umprim_cible 1 value of ubar_umprim_cible
source_th_tdivu source_base source_th_tdivu 0 This term source is dedicated for any scalar (called T) transport. Coupled with upwind (amont) or muscl scheme, this term gives for final expression of convection : div(U.T)-T.div (U)=U.grad(T) This ensures, in incompressible flow when divergence free is badly resolved, to stay in a better way in the physical boundaries. NL2 Warning: Only available in VEF discretization.
source_robin source_base source_robin 0 This source term should be used when a Paroi_decalee_Robin boundary condition is set in a hydraulic equation. The source term will be applied on the N specified boundaries. To post-process the values of tauw, u_tau and Reynolds_tau into the files tauw_robin.dat, reynolds_tau_robin.dat and u_tau_robin.dat, you must add a block Traitement_particulier { canal { } }
  attr bords vect_nom bords 0 not_set
source_robin_scalaire source_base source_robin_scalaire 0 This source term should be used when a Paroi_decalee_Robin boundary condition is set in a an energy equation. The source term will be applied on the N specified boundaries. The values temp_wall_valueI are the temperature specified on the Ith boundary. The last value dt_impr is a printing period which is mandatory to specify in the data file but has no effect yet.
  attr bords listdeuxmots_sacc bords 0 not_set
canal_perio source_base canal_perio 1 Momentum source term to maintain flow rate. The expression of the source term is: NL2 S(t) = (2*(Q(0) - Q(t))-(Q(0)-Q(t-dt))/(coeff*dt*area) NL2 NL2 Where: NL2 coeff=damping coefficient NL2 area=area of the periodic boundary NL2 Q(t)=flow rate at time t NL2 dt=time step NL2 NL2 Three files will be created during calculation on a datafile named DataFile.data. The first file contains the flow rate evolution. The second file is useful for resuming a calculation with the flow rate of the previous stopped calculation, and the last one contains the pressure gradient evolution: NL2 -DataFile_Channel_Flow_Rate_ProblemName_BoundaryName NL2 -DataFile_Channel_Flow_Rate_repr_ProblemName_BoundaryName NL2 -DataFile_Pressure_Gradient_ProblemName_BoundaryName
  attr bord chaine bord 0 The name of the (periodic) boundary normal to the flow direction.
  attr h floattant h 1 Half heigth of the channel.
  attr coeff floattant coeff 1 Damping coefficient (optional, default value is 10).
  attr debit_impose floattant debit_impose 1 Optional option to specify the aimed flow rate Q(0). If not used, Q(0) is computed by the code after the projection phase, where velocity initial conditions are slighlty changed to verify incompressibility.
champ_don_base field_base champ_don_base -1 Basic class for data fields (not calculated), p.e. physics properties.
uniform_field champ_don_base champ_uniforme 0 Field that is constant in space and stationary.
  attr val list val 0 Values of field components.
champ_uniforme_morceaux champ_don_base champ_uniforme_morceaux 0 Field which is partly constant in space and stationary.
  attr nom_dom ref_domaine nom_dom 0 Name of the domain to which the sub-areas belong.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr data bloc_lecture data 0 { Defaut val_def sous_zone_1 val_1 ... sous_zone_i val_i } By default, the value val_def is assigned to the field. It takes the sous_zone_i identifier Sous_Zone (sub_area) type object value, val_i. Sous_Zone (sub_area) type objects must have been previously defined if the operator wishes to use a Champ_Uniforme_Morceaux(partly_uniform_field) type object.
champ_uniforme_morceaux_tabule_temps champ_uniforme_morceaux champ_uniforme_morceaux_tabule_temps -1 this type of field is constant in space on one or several sub_zones and tabulated as a function of time.
testeur interprete testeur 0 not_set
  attr data bloc_lecture data 0 not_set
valeur_totale_sur_volume champ_uniforme_morceaux valeur_totale_sur_volume -1 Similar as Champ_Uniforme_Morceaux with the same syntax. Used for source terms when we want to specify a source term with a value given for the volume (eg: heat in Watts) and not a value per volume unit (eg: heat in Watts/m3).
field_func_xyz champ_don_base champ_fonc_xyz 0 Field defined by analytical functions. It makes it possible the definition of a field that depends on (x,y,z).
  attr dom ref_domaine dom 0 Name of domain of calculation.
  attr val listchaine val 0 List of functions on (x,y,z).
field_func_txyz champ_don_base champ_fonc_txyz 0 Field defined by analytical functions. It makes it possible the definition of a field that depends on the time and the space.
  attr dom ref_domaine dom 0 Name of domain of calculation.
  attr val listchaine val 0 List of functions on (t,x,y,z).
champ_don_lu champ_don_base champ_don_lu 0 Field to read a data field (values located at the center of the cells) in a file.
  attr dom ref_domaine dom 0 Name of the domain.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr file chaine file 0 Name of the file. NL2 This file has the following format: NL2 nb_val_lues -> Number of values readen in th file NL2 Xi Yi Zi -> Coordinates readen in the file NL2 Ui Vi Wi -> Value of the field
init_par_partie champ_don_base init_par_partie 0 ne marche que pour n_comp=1
  attr n_comp entier(into=[1]) n_comp 0 not_set
  attr val1 floattant val1 0 not_set
  attr val2 floattant val2 0 not_set
  attr val3 floattant val3 0 not_set
champ_front_uniforme front_field_base champ_front_uniforme 0 Boundary field which is constant in space and stationary.
  attr val list val 0 Values of field components.
champ_front_fonc_pois_ipsn front_field_base champ_front_fonc_pois_ipsn 0 Boundary field champ_front_fonc_pois_ipsn.
  attr r_tube floattant r_tube 0 not_set
  attr umoy list umoy 0 not_set
  attr r_loc listf r_loc 0 not_set
champ_front_fonc_pois_tube front_field_base champ_front_fonc_pois_tube 0 Boundary field champ_front_fonc_pois_tube.
  attr r_tube floattant r_tube 0 not_set
  attr umoy list umoy 0 not_set
  attr r_loc listf r_loc 0 not_set
  attr r_loc_mult listentierf r_loc_mult 0 not_set
champ_front_tangentiel_vef front_field_base champ_front_tangentiel_vef 0 Field to define the tangential velocity vector field standard at the boundary in VEF discretization.
  attr mot chaine(into=["vitesse_tangentielle"]) mot 0 Name of vector field.
  attr vit_tan floattant vit_tan 0 Vector field standard [m/s].
champ_front_lu front_field_base champ_front_lu 0 boundary field which is given from data issued from a read file. The format of this file has to be the same that the one generated by Ecrire_fichier_xyz_valeur NL2 Example for K and epsilon quantities to be defined for inlet condition in a boundary named \'entree\': NL2entree frontiere_ouverte_K_Eps_impose Champ_Front_lu dom 2pb_K_EPS_PERIO_1006.306198.dat
  attr domaine ref_domaine domain 0 Name of domain
  attr dim entier dim 0 number of components
  attr file chaine file 0 path for the read file
boundary_field_inward front_field_base boundary_field_inward 1 this field is used to define the normal vector field standard at the boundary in VDF or VEF discretization.
  attr normal_value chaine normal_value 0 normal vector value (positive value for a vector oriented outside to inside) which can depend of the time.
constituant milieu_base constituant -1 Constituent.
  attr rho field_base rho 1 Density (kg.m-3).
  attr cp field_base cp 1 Specific heat (J.kg-1.K-1).
  attr lambda field_base lambda_u 1 Conductivity (W.m-1.K-1).
  attr coefficient_diffusion field_base coefficient_diffusion 1 Constituent diffusion coefficient value (m2.s-1). If a multi-constituent problem is being processed, the diffusivite will be a vectorial and each components will be the diffusion of the constituent.
  ref gravite field_base
champ_front_pression_from_u front_field_base champ_front_pression_from_u 0 this field is used to define a pressure field depending of a velocity field.
  attr expression chaine expression 0 value depending of a velocity (like $2*u_moy^2$).
source_constituant source_base source_constituant 0 Keyword to specify source rates, in [[C]/s], for each one of the nb constituents. [C] is the concentration unit.
  attr ch field_base ch 0 Field type.
radioactive_decay source_base radioactive_decay 0 Radioactive decay source term of the form $-\lambda_i c_i$, where $0 \leq i \leq N$, N is the number of component of the constituent, $c_i$ and $\lambda_i$ are the concentration and the decay constant of the i-th component of the constituant.
  attr val list val 0 n is the number of decay constants to read (int), and val1, val2... are the decay constants (double)
form_a_nb_points objet_lecture nul 0 The structure fonction is calculated on nb points and we should add the 2 directions (0:OX, 1:OY, 2:OZ) constituting the homegeneity planes. Example for channel flows, planes parallel to the walls.
  attr nb entier(into=[4]) nb 0 Number of points.
  attr dir1 entier(max=2) dir1 0 First direction.
  attr dir2 entier(max=2) dir2 0 Second direction.
tparoi_vef champ_post_de_champs_post tparoi_vef -1 This keyword is used to post process (only for VEF discretization) the temperature field with a slight difference on boundaries with Neumann condition where law of the wall is applied on the temperature field. nom_pb is the problem name and field_name is the selected field name. A keyword (temperature_physique) is available to post process this field without using Definition_champs.
fourfloat objet_lecture nul 0 Four reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
  attr c floattant c 0 Third real.
  attr d floattant d 0 Fourth real.
twofloat objet_lecture nul 0 two reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
sonde_tble objet_lecture nul 0 not_set
  attr name chaine name 0 not_set
  attr point un_point point 0 not_set
liste_sonde_tble listobj nul 0 sonde_tble 0 not_set
Paroi condlim_base Paroi 0 Impermeability condition at a wall called bord (edge) (standard flux zero). This condition must be associated with a wall type hydraulic condition.
precond_base objet_u precond_base -1 Basic class for preconditioning.
ssor precond_base ssor 1 Symmetric successive over-relaxation algorithm.
  attr omega floattant omega 1 Over-relaxation facteur (between 1 and 2, default value 1.6).
ssor_bloc precond_base ssor_bloc -1 not_set
  attr alpha_0 floattant alpha_0 1 not_set
  attr precond0 precond_base precond0 1 not_set
  attr alpha_1 floattant alpha_1 1 not_set
  attr precond1 precond_base precond1 1 not_set
  attr alpha_a floattant alpha_a 1 not_set
  attr preconda precond_base preconda 1 not_set
precondsolv precond_base precondsolv 0 not_set
  attr solveur solveur_sys_base solveur 0 Solver type.
ilu precond_base ilu -1 This preconditionner can be only used with the generic GEN solver. 
  attr type entier type 1 values can be 0|1|2|3 for null|left|right|left-and-right preconditionning (default value = 2)
  attr filling entier filling 1 default value = 1.
gen solveur_sys_base gen -1 not_set
  attr solv_elem chaine solv_elem 0 To specify a solver among gmres or bicgstab.
  attr precond precond_base precond 0 The only preconditionner that we can specify is ilu.
  attr seuil floattant seuil 1 Value of the final residue. The solver ceases iterations when the Euclidean residue standard ||Ax-B|| is less than this value. default value 1e-12.
  attr impr rien impr 1 Keyword which is used to request display of the Euclidean residue standard each time this iterates through the conjugated gradient (display to the standard outlet).
  attr save_matrice|save_matrix rien save_matrice 1 To save the matrix in a file.
  attr quiet rien quiet 1 To not displaying any outputs of the solver.
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the GEN solver.
  attr force rien force 1 Keyword to set ipar[5]=-1 in the GEN solver. This is helpful if you notice that the solver does not perform more than 100 iterations. If this keyword is specified in the datafile, you should provide nb_it_max.
petsc solveur_sys_base petsc 0 Solver via Petsc API NL2 \input{{solvpetsc}}
  attr solveur chaine solveur 0 not_set
  attr option_solveur bloc_lecture option_solveur 0 not_set
  attr atol floattant atol 1 Absolute threshold for convergence (same as seuil option)
  attr rtol floattant rtol 1 Relative threshold for convergence
amgx petsc amgx 0 Solver via AmgX API
  attr solveur chaine solveur 0 not_set
  attr option_solveur bloc_lecture option_solveur 0 not_set
rocalution petsc rocalution 0 Solver via rocALUTION API
  attr solveur chaine solveur 0 not_set
  attr option_solveur bloc_lecture option_solveur 0 not_set
solv_gcp solveur_sys_base gcp 1 Preconditioned conjugated gradient.
  attr precond precond_base precond 1 Keyword to define system preconditioning in order to accelerate resolution by the conjugated gradient. Many parallel preconditioning methods are not equivalent to their sequential counterpart, and you should therefore expect differences, especially when you select a high value of the final residue (seuil). The result depends on the number of processors and on the mesh splitting. It is sometimes useful to run the solver with no preconditioning at all. In particular: NL2 - when the solver does not converge during initial projection, NL2 - when comparing sequential and parallel computations. NL2 With no preconditioning, except in some particular cases (no open boundary), the sequential and the parallel computations should provide exactly the same results within fpu accuracy. If not, there might be a coding error or the system of equations is singular.
  attr precond_nul rien precond_nul 1 Keyword to not use a preconditioning method.
  attr seuil floattant seuil 0 Value of the final residue. The gradient ceases iteration when the Euclidean residue standard ||Ax-B|| is less than this value.
  attr impr rien impr 1 Keyword which is used to request display of the Euclidean residue standard each time this iterates through the conjugated gradient (display to the standard outlet).
  attr quiet rien quiet 1 To not displaying any outputs of the solver.
  attr save_matrice|save_matrix rien save_matrice 1 to save the matrix in a file.
  attr optimized rien optimized 1 This keyword triggers a memory and network optimized algorithms useful for strong scaling (when computing less than 100 000 elements per processor). The matrix and the vectors are duplicated, common items removed and only virtual items really used in the matrix are exchanged.NL2 Warning: this is experimental and known to fail in some VEF computations (L2 projection step will not converge). Works well in VDF.
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gcp.
gcp_ns solv_gcp gcp_ns -1 not_set
  attr solveur0 solveur_sys_base solveur0 0 Solver type.
  attr solveur1 solveur_sys_base solveur1 0 Solver type.
cholesky solveur_sys_base cholesky -1 Cholesky direct method.
  attr impr rien impr 1 Keyword which may be used to print the resolution time.
  attr quiet rien quiet 1 To disable printing of information
gmres solveur_sys_base gmres -1 Gmres method (for non symetric matrix).
  attr impr rien impr 1 Keyword which may be used to print the convergence.
  attr quiet rien quiet 1 To disable printing of information
  attr seuil floattant seuil 1 Convergence value.
  attr diag rien diag 1 Keyword to use diagonal preconditionner (in place of pilut that is not parallel).
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gmres.
  attr controle_residu entier(into=["0","1"]) controle_residu 1 Keyword of Boolean type (by default 0). If set to 1, the convergence occurs if the residu suddenly increases.
  attr save_matrice|save_matrix rien save_matrice 1 to save the matrix in a file.
  attr dim_espace_krilov entier dim_espace_krilov 1 not_set
lecture_bloc_moment_base objet_lecture nul 0 Auxiliary class to compute and print the moments.
calcul lecture_bloc_moment_base calcul -1 The centre of gravity will be calculated.
centre_de_gravite lecture_bloc_moment_base centre_de_gravite -1 To specify the centre of gravity.
  attr point un_point point 0 A centre of gravity.
calculer_moments interprete calculer_moments -1 Calculates and prints the torque (moment of force) exerted by the fluid on each boundary in output files (.out) of the domain nom_dom.
  attr nom_dom ref_domaine nom_dom 0 Name of domain.
  attr mot lecture_bloc_moment_base mot 0 Keyword.
bloc_origine_cotes objet_lecture nul 0 Class to create a rectangle (or a box).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the origin of the rectangle (or the box).
  attr origin listf origine 0 Coordinates of the origin of the rectangle (or the box).
  attr name2 chaine(into=["Cotes"]) name2 0 Keyword to define the length along the axes.
  attr cotes listf cotes 0 Length along the axes.
bloc_couronne objet_lecture nul 0 Class to create a couronne (2D).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the center of the circle.
  attr origin listf origine 0 Center of the circle.
  attr name3 chaine(into=["ri"]) name3 0 Keyword to define the interior radius.
  attr ri floattant ri 0 Interior radius.
  attr name4 chaine(into=["re"]) name4 0 Keyword to define the exterior radius.
  attr re floattant re 0 Exterior radius.
bloc_tube objet_lecture nul 0 Class to create a tube (3D).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the center of the tube.
  attr origin listf origine 0 Center of the tube.
  attr name2 chaine(into=["dir"]) name2 0 Keyword to define the direction of the main axis.
  attr direction chaine(into=["X","Y","Z"]) direction 0 direction of the main axis X, Y or Z
  attr name3 chaine(into=["ri"]) name3 0 Keyword to define the interior radius.
  attr ri floattant ri 0 Interior radius.
  attr name4 chaine(into=["re"]) name4 0 Keyword to define the exterior radius.
  attr re floattant re 0 Exterior radius.
  attr name5 chaine(into=["hauteur"]) name5 0 Keyword to define the heigth of the tube.
  attr h floattant h 0 Heigth of the tube.
sous_zone objet_u sous_zone 1 It is an object type describing a domain sub-set. NL2 A Sous_Zone (Sub-area) type object must be associated with a Domaine type object. The Read (Lire) interpretor is used to define the items comprising the sub-area. NL2 Caution: The Domain type object nom_domaine must have been meshed (and triangulated or tetrahedralised in VEF) prior to carrying out the Associate (Associer) nom_sous_zone nom_domaine instruction; this instruction must always be preceded by the read instruction.
  attr restriction ref_sous_zone restriction 1 The elements of the sub-area nom_sous_zone must be included into the other sub-area named nom_sous_zone2. This keyword should be used first in the Read keyword.
  attr rectangle bloc_origine_cotes rectangle 1 The sub-area will include all the domain elements whose centre of gravity is within the Rectangle (in dimension 2).
  attr segment bloc_origine_cotes segment 1 not_set
  attr boite bloc_origine_cotes box 1 The sub-area will include all the domain elements whose centre of gravity is within the Box (in dimension 3).
  attr liste listentier liste 1 The sub-area will include n domain items, numbers No. 1 No. i No. n.
  attr fichier chaine filename 1 The sub-area is read into the file filename.
  attr intervalle deuxentiers intervalle 1 The sub-area will include domain items whose number is between n1 and n2 (where n1<=n2).
  attr polynomes bloc_lecture polynomes 1 A REPRENDRE
  attr couronne bloc_couronne couronne 1 In 2D case, to create a couronne.
  attr tube bloc_tube tube 1 In 3D case, to create a tube.
  attr fonction_sous_zone chaine fonction_sous_domaine 1 Keyword to build a sub-area with the the elements included into the area defined by fonction>0.
  attr union ref_sous_zone union_with 1 The elements of the sub-area nom_sous_zone3 will be added to the sub-area nom_sous_zone. This keyword should be used last in the Read keyword.
  ref domaine domaine
raffiner_anisotrope interprete raffiner_anisotrope -1 Only for VEF discretizations, allows to cut triangle elements in 3, or tetrahedra in 4 parts, by defining a new summit located at the center of the element: \includepng{{raffineranisotri.pdf}}{{4}} \includepng{{raffineranisotetra.jpeg}}{{6}} NL2 Note that such a cut creates flat elements (anisotropic).
  attr domain_name ref_domaine domain_name 0 Name of domain.
raffiner_isotrope interprete raffiner_isotrope -1 For VDF and VEF discretizations, allows to cut triangles/quadrangles or tetrahedral/hexaedras elements respectively in 4 or 8 new ones by defining new summits located at the middle of edges (and center of faces and elements for quadrangles and hexaedra). Such a cut preserves the shape of original elements (isotropic). For 2D elements: \includetabfig{{raffinerisotri.pdf}}{{4}}{{raffinerisorect.pdf}}{{4}} For 3D elements: \includetabfig{{raffinerisotetra.jpeg}}{{6}}{{raffinerisohexa.jpeg}}{{5}}.
  attr domain_name ref_domaine domain_name 0 Name of domain.
triangulate interprete trianguler -1 To achieve a triangular mesh from a mesh comprising rectangles (2 triangles per rectangle). Should be used in VEF discretization. Principle: NL2 \includepng{{trianguler.pdf}}{{10}}
  attr domain_name ref_domaine domain_name 0 Name of domain.
trianguler_h triangulate trianguler_h -1 To achieve a triangular mesh from a mesh comprising rectangles (4 triangles per rectangle). Should be used in VEF discretization. Principle: NL2 \includepng{{triangulerh.pdf}}{{10}}
trianguler_fin triangulate trianguler_fin -1 Trianguler_fin is the recommended option to triangulate rectangles. NL2 As an extension (subdivision) of Triangulate_h option, this one cut each initial rectangle in 8 triangles (against 4, previously). This cutting ensures : NL2 - a correct cutting in the corners (in respect to pressure discretization PreP1B). NL2 - a better isotropy of elements than with Trianguler_h option. NL2 - a better alignment of summits (this could have a benefit effect on calculation near walls since first elements in contact with it are all contained in the same constant thickness, and, by this way, a 2D cartesian grid based on summits can be engendered and used to realize statistical analysis in plane channel configuration for instance). Principle: NL2 \includepng{{triangulerfin.pdf}}{{10}}
tetraedriser interprete tetraedriser -1 To achieve a tetrahedral mesh based on a mesh comprising blocks, the Tetraedriser (Tetrahedralise) interpretor is used in VEF discretization. Initial block is divided in 6 tetrahedra: \includepng{{tetraedriser.jpeg}}{{5}}
  attr domain_name ref_domaine domain_name 0 Name of domain.
orientefacesbord interprete orientefacesbord -1 Keyword to modify the order of the boundary vertices included in a domain, such that the surface normals are outer pointing.
  attr domain_name ref_domaine domain_name 0 Name of domain.
reorienter_tetraedres interprete reorienter_tetraedres -1 This keyword is mandatory for front-tracking computations with the VEF discretization. For each tetrahedral element of the domain, it checks if it has a positive volume. If the volume (determinant of the three vectors) is negative, it swaps two nodes to reverse the orientation of this tetrahedron.
  attr domain_name ref_domaine domain_name 0 Name of domain.
reorienter_triangles interprete reorienter_triangles -1 not_set
  attr domain_name ref_domaine domain_name 0 Name of domain.
tetraedriser_homogene tetraedriser tetraedriser_homogene -1 Use the Tetraedriser_homogene (Homogeneous_Tetrahedralisation) interpretor in VEF discretization to mesh a block in tetrahedrals. Each block hexahedral is no longer divided into 6 tetrahedrals (keyword Tetraedriser (Tetrahedralise)), it is now broken down into 40 tetrahedrals. Thus a block defined with 11 nodes in each X, Y, Z direction will contain 10*10*10*40=40,000 tetrahedrals. This also allows problems in the mesh corners with the P1NC/P1iso/P1bulle or P1/P1 discretization items to be avoided. Initial block is divided in 40 tetrahedra: \includepng{{tetraedriserhomogene.jpeg}}{{5}}
tetraedriser_homogene_fin tetraedriser tetraedriser_homogene_fin -1 Tetraedriser_homogene_fin is the recommended option to tetrahedralise blocks. As an extension (subdivision) of Tetraedriser_homogene_compact, this last one cut each initial block in 48 tetrahedra (against 24, previously). This cutting ensures : NL2 - a correct cutting in the corners (in respect to pressure discretization PreP1B), NL2 - a better isotropy of elements than with Tetraedriser_homogene_compact, NL2 - a better alignment of summits (this could have a benefit effect on calculation near walls since first elements in contact with it are all contained in the same constant thickness and ii/ by the way, a 3D cartesian grid based on summits can be engendered and used to realise spectral analysis in HIT for instance). Initial block is divided in 48 tetrahedra: \includepng{{tetraedriserhomogenefin.jpeg}}{{5}}
tetraedriser_homogene_compact tetraedriser tetraedriser_homogene_compact -1 This new discretization generates tetrahedral elements from cartesian or non-cartesian hexahedral elements. The process cut each hexahedral in 6 pyramids, each of them being cut then in 4 tetrahedral. So, in comparison with tetra_homogene, less elements (*24 instead of*40) with more homogeneous volumes are generated. Moreover, this process is done in a faster way. Initial block is divided in 24 tetrahedra: \includepng{{tetraedriserhomogenecompact.jpeg}}{{5}}
tetraedriser_par_prisme tetraedriser tetraedriser_par_prisme -1 Tetraedriser_par_prisme generates 6 iso-volume tetrahedral element from primary hexahedral one (contrarily to the 5 elements ordinarily generated by tetraedriser). This element is suitable for calculation of gradients at the summit (coincident with the gravity centre of the jointed elements related with) and spectra (due to a better alignment of the points). \includetabfig{{tetraedriserparprisme.jpeg}}{{5}}{{tetraedriserparprisme2.jpeg}}{{5}} Initial block is divided in 6 prismes.
paroi_flux_impose condlim_base paroi_flux_impose 0 Normal flux condition at the wall called bord (edge). The surface area of the flux (W.m-1 in 2D or W.m-2 in 3D) is imposed at the boundary according to the following convention: a positive flux is a flux that enters into the domain according to convention.
  attr ch front_field_base ch 0 Boundary field type.
paroi_temperature_imposee dirichlet paroi_temperature_imposee 0 Imposed temperature condition at the wall called bord (edge).
  attr ch front_field_base ch 0 Boundary field type.
temperature_imposee_paroi paroi_temperature_imposee temperature_imposee_paroi 0 Imposed temperature condition at the wall called bord (edge).
champ_front_contact_vef front_field_base champ_front_contact_vef 0 This field is used on a boundary between a solid and fluid domain to exchange a calculated temperature at the contact face of the two domains according to the flux of the two problems.
  attr local_pb ref_Pb_base local_pb 0 Name of the problem.
  attr local_boundary chaine local_boundary 0 Name of the boundary.
  attr remote_pb ref_Pb_base remote_pb 0 Name of the second problem.
  attr remote_boundary chaine remote_boundary 0 Name of the boundary in the second problem.
bloc_lecture_poro objet_lecture nul 1 Surface and volume porosity values.
  attr volumique floattant volumique 0 Volume porosity value.
  attr surfacique list surfacique 0 Surface porosity values (in X, Y, Z directions).
porosites objet_u porosites 0 To define the volume porosity and surface porosity that are uniform in every direction in space on a sub-area. NL2 Porosity was only usable in VDF discretization, and now available for VEF P1NC/P0. NL2 Observations : NL2 - Surface porosity values must be given in every direction in space (set this value to 1 if there is no porosity), NL2 - Prior to defining porosity, the problem must have been discretized.NL2 Can \'t be used in VEF discretization, use Porosites_champ instead.
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr sous_zone|sous_zone1 chaine sous_zone 0 Name of the sub-area to which porosity are allocated.
  attr bloc bloc_lecture_poro bloc 0 Surface and volume porosity values.
  attr sous_zone2 chaine sous_zone2 1 Name of the 2nd sub-area to which porosity are allocated.
  attr bloc2 bloc_lecture_poro bloc2 1 Surface and volume porosity values.
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
champ_front_calc front_field_base champ_front_calc 0 This keyword is used on a boundary to get a field from another boundary. The local and remote boundaries should have the same mesh. If not, the Champ_front_recyclage keyword could be used instead. It is used in the condition block at the limits of equation which itself refers to a problem called pb1. We are working under the supposition that pb1 is coupled to another problem.
  attr problem_name ref_Pb_base problem_name 0 Name of the other problem to which pb1 is coupled.
  attr bord chaine bord 0 Name of the side which is the boundary between the 2 domains in the domain object description associated with the problem_name object.
  attr field_name chaine field_name 0 Name of the field containing the value that the user wishes to use at the boundary. The field_name object must be recognized by the problem_name object.
champ_tabule_temps champ_don_base champ_tabule_temps 0 Field that is constant in space and tabulated as a function of time.
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lecture bloc 0 Values as a table. The value of the field at any time is calculated by linear interpolation from this table.
champ_fonc_t champ_don_base champ_fonc_t 0 Field that is constant in space and is a function of time.
  attr val listchaine val 0 Values of field components (time dependant functions).
frontiere_ouverte_gradient_pression_impose_vefprep1b frontiere_ouverte_gradient_pression_impose frontiere_ouverte_gradient_pression_impose_vefprep1b -1 Keyword for an outlet boundary condition in VEF P1B/P1NC on the gradient of the pressure.
bloc_lec_champ_init_canal_sinal objet_lecture nul 1 Parameters for the class champ_init_canal_sinal. NL2 in 2D: NL2 U=ucent*y(2h-y)/h/h NL2 V=ampli_bruit*rand+ampli_sin*sin(omega*x) NL2 rand: unpredictable value between -1 and 1. NL2 in 3D: NL2 U=ucent*y(2h-y)/h/h NL2 V=ampli_bruit*rand1+ampli_sin*sin(omega*x) NL2 W=ampli_bruit*rand2 NL2 rand1 and rand2: unpredictables values between -1 and 1.
  attr ucent floattant ucent 0 Velocity value at the center of the channel.
  attr h floattant h 0 Half hength of the channel.
  attr ampli_bruit floattant ampli_bruit 0 Amplitude for the disturbance.
  attr ampli_sin floattant ampli_sin 1 Amplitude for the sinusoidal disturbance (by default equals to ucent/10).
  attr omega floattant omega 0 Value of pulsation for the of the sinusoidal disturbance.
  attr dir_flow entier(into=[0,1,2]) dir_flow 1 Flow direction for the initialization of the flow in a channel. NL2 - if dir_flow=0, the flow direction is X NL2 - if dir_flow=1, the flow direction is Y NL2 - if dir_flow=2, the flow direction is Z NL2 Default value for dir_flow is 0
  attr dir_wall entier(into=[0,1,2]) dir_wall 1 Wall direction for the initialization of the flow in a channel. NL2 - if dir_wall=0, the normal to the wall is in X direction NL2 - if dir_wall=1, the normal to the wall is in Y direction NL2 - if dir_wall=2, the normal to the wall is in Z direction NL2 Default value for dir_flow is 1
  attr min_dir_flow floattant min_dir_flow 1 Value of the minimum coordinate in the flow direction for the initialization of the flow in a channel. Default value for dir_flow is 0.
  attr min_dir_wall floattant min_dir_wall 1 Value of the minimum coordinate in the wall direction for the initialization of the flow in a channel. Default value for dir_flow is 0.
champ_init_canal_sinal champ_don_base champ_init_canal_sinal 0 For a parabolic profile on U velocity with an unpredictable disturbance on V and W and a sinusoidal disturbance on V velocity.
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lec_champ_init_canal_sinal bloc 0 Parameters for the class champ_init_canal_sinal.
champ_som_lu_vdf champ_don_base champ_som_lu_vdf 0 Keyword to read in a file values located at the nodes of a mesh in VDF discretization.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr dim entier dim 0 Value of the dimension of the field.
  attr tolerance floattant tolerance 0 Value of the tolerance to check the coordinates of the nodes.
  attr file chaine file 0 name of the file NL2 This file has the following format: NL2 Xi Yi Zi -> Coordinates of the node NL2 Ui Vi Wi -> Value of the field on this node NL2 Xi+1 Yi+1 Zi+1 -> Next point NL2 Ui+1 Vi+1 Zi+1 -> Next value ...
champ_som_lu_vef champ_don_base champ_som_lu_vef 0 Keyword to read in a file values located at the nodes of a mesh in VEF discretization.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr dim entier dim 0 Value of the dimension of the field.
  attr tolerance floattant tolerance 0 Value of the tolerance to check the coordinates of the nodes.
  attr file chaine file 0 Name of the file. NL2 This file has the following format: NL2 Xi Yi Zi -> Coordinates of the node NL2 Ui Vi Wi -> Value of the field on this node NL2 Xi+1 Yi+1 Zi+1 -> Next point NL2 Ui+1 Vi+1 Zi+1 -> Next value ...
acceleration source_base acceleration 1 Momentum source term to take in account the forces due to rotation or translation of a non Galilean referential R\' (centre 0\') into the Galilean referential R (centre 0).
  attr vitesse field_base vitesse 1 Keyword for the velocity of the referential R\' into the R referential (dOO\'/dt term [m.s-1]). The velocity is mandatory when you want to print the total cinetic energy into the non-mobile Galilean referential R (see Ec_dans_repere_fixe keyword).
  attr acceleration field_base acceleration 1 Keyword for the acceleration of the referential R\' into the R referential (d2OO\'/dt2 term [m.s-2]). field_base is a time dependant field (eg: Champ_Fonc_t).
  attr omega field_base omega 1 Keyword for a rotation of the referential R\' into the R referential [rad.s-1]. field_base is a 3D time dependant field specified for example by a Champ_Fonc_t keyword. The time_field field should have 3 components even in 2D (In 2D: 0 0 omega).
  attr domegadt field_base domegadt 1 Keyword to define the time derivative of the previous rotation [rad.s-2]. Should be zero if the rotation is constant. The time_field field should have 3 components even in 2D (In 2D: 0 0 domegadt).
  attr centre_rotation field_base centre_rotation 1 Keyword to specify the centre of rotation (expressed in R\' coordinates) of R\' into R (if the domain rotates with the R\' referential, the centre of rotation is 0\'=(0,0,0)). The time_field should have 2 or 3 components according the dimension 2 or 3.
  attr option chaine(into=["terme_complet","coriolis_seul","entrainement_seul"]) option 1 Keyword to specify the kind of calculation: terme_complet (default option) will calculate both the Coriolis and centrifugal forces, coriolis_seul will calculate the first one only, entrainement_seul will calculate the second one only.
coriolis source_base coriolis 0 Keyword for a Coriolis term in hydraulic equation. Warning: Only available in VDF.
  attr omega chaine omega 0 Value of omega.
champ_front_recyclage front_field_base champ_front_recyclage 0 \input{{champfrontrecyclage}}
  attr bloc chaine bloc 0 not_set
paroi_echange_externe_impose_h paroi_echange_externe_impose paroi_echange_externe_impose_h -1 Particular case of class paroi_echange_externe_impose for enthalpy equation.
entree_temperature_imposee_h frontiere_ouverte_temperature_imposee entree_temperature_imposee_h -1 Particular case of class frontiere_ouverte_temperature_imposee for enthalpy equation.
sortie_libre_temperature_imposee_h neumann sortie_libre_temperature_imposee_h 0 Open boundary for heat equation with enthalpy as unknown.
  attr ch front_field_base ch 0 Boundary field type.
champ_ostwald field_base champ_ostwald 0 This keyword is used to define the viscosity variation law: NL2 Mu(T)= K(T)*(D:D/2)**((n-1)/2)
tayl_green champ_don_base tayl_green 0 Class Tayl_green.
  attr dim entier dim 0 Dimension.
fonction_champ_reprise objet_lecture nul 0 not_set
  attr mot chaine(into=["fonction"]) mot 0 not_set
  attr fonction listchaine fonction 0 n f1(val) f2(val) ... fn(val)] time
source_qdm source_base source_qdm 0 Momentum source term in the Navier-Stokes equations.
  attr ch field_base champ 0 Field type.
perte_charge_singuliere source_base perte_charge_singuliere 1 Source term that is used to model a pressure loss over a surface area (transition through a grid, sudden enlargement) defined by the faces of elements located on the intersection of a subzone named subzone_name and a X,Y, or Z plane located at X,Y or Z = location.
  attr dir chaine(into=["kx","ky","kz","K"]) dir 0 KX, KY or KZ designate directional pressure loss coefficients for respectively X, Y or Z direction. Or in the case where you chose a target flow rate with regul. Use K for isotropic pressure loss coefficient
  attr coeff floattant coeff 1 Value (float) of friction coefficient (KX, KY, KZ).
  attr regul bloc_lecture regul 1 option to have adjustable K with flowrate target  NL2 { K0 valeur_initiale_de_k deb debit_cible eps intervalle_variation_mutiplicatif}.
  attr surface bloc_lecture surface 0 Three syntaxes are possible for the surface definition block: NL2 For VDF and VEF: { X|Y|Z = location subzone_name } NL2 Only for VEF: { Surface surface_name }. NL2 For polymac { Surface surface_name Orientation champ_uniforme }
perte_charge_directionnelle source_base perte_charge_directionnelle 1 Directional pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_isotrope source_base perte_charge_isotrope 1 Isotropic pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_anisotrope source_base perte_charge_anisotrope 1 Anisotropic pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr lambda_ortho chaine lambda_ortho 0 Function for loss coefficient in transverse direction which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_circulaire source_base perte_charge_circulaire 1 New pressure loss.
  attr lambda chaine lambda_u 0 Function f(Re_tot, Re_long, t, x, y, z) for loss coefficient in the longitudinal direction
  attr lambda_ortho chaine lambda_ortho 0 function: Function f(Re_tot, Re_ortho, t, x, y, z) for loss coefficient in transverse direction
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr diam_hydr_ortho champ_don_base diam_hydr_ortho 0 Transverse hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
darcy source_base darcy 0 Class for calculation in a porous media with source term of Darcy -nu/K*V. This keyword must be used with a permeability model. For the moment there are two models : permeability constant or Ergun\'s law. Darcy source term is available for quasi compressible calculation. A new keyword is aded for porosity (porosite).
  attr bloc bloc_lecture bloc 0 Description.
forchheimer source_base forchheimer 0 Class to add the source term of Forchheimer -Cf/sqrt(K)*V2 in the Navier-Stokes equations. We must precise a permeability model : constant or Ergun\'s law. Moreover we can give the constant Cf : by default its value is 1. Forchheimer source term is available also for quasi compressible calculation. A new keyword is aded for porosity (porosite).
  attr bloc bloc_lecture bloc 0 Description.
debut_bloc interprete { 0 Block\'s beginning.
fin_bloc interprete } 0 Block\'s end.
export interprete export 0 Class to make the object have a global range, if not its range will apply to the block only (the associated object will be destroyed on exiting the block).
debog interprete debog 0 Class to debug some differences between two TRUST versions on a same data file. NL2 If you want to compare the results of the same code in sequential and parallel calculation, first run (mode=0) in sequential mode (the files fichier1 and fichier2 will be written first) then the second run in parallel calculation (mode=1). NL2 During the first run (mode=0), it prints into the file DEBOG, values at different points of the code thanks to the C++ instruction call. see for example in Kernel/Framework/Resoudre.cpp file the instruction: Debog::verifier(msg,value); Where msg is a string and value may be a double, an integer or an array. NL2 During the second run (mode=1), it prints into a file Err_Debog.dbg the same messages than in the DEBOG file and checks if the differences between results from both codes are less than a given value (error). If not, it prints Ok else show the differences and the lines where it occured.
  attr pb ref_pb_gen_base pb 0 Name of the problem to debug.
  attr fichier1 chaine file1 0 Name of the file where domain will be written in sequential calculation.
  attr fichier2 chaine file2 0 Name of the file where faces will be written in sequential calculation.
  attr seuil floattant seuil 0 Minimal value (by default 1.e-20) for the differences between the two codes.
  attr mode entier mode 0 By default -1 (nothing is written in the different files), you will set 0 for the sequential run, and 1 for the parallel run.
champ_input_base field_base champ_input_base 1 not_set
  attr nb_comp entier nb_comp 0 not_set
  attr nom chaine nom 0 not_set
  attr initial_value list initial_value 1 not_set
  attr probleme chaine probleme 0 not_set
  attr sous_zone ref_sous_zone sous_zone 1 not_set
champ_input_p0 champ_input_base champ_input_p0 1 not_set
system interprete system -1 To run Unix commands from the data file. Example: System \'echo The End | mail trust@cea.fr\'
  attr cmd chaine cmd 0 command to execute.
listdeuxmots_sacc listobj nul 0 deuxmots 0 List of groups of two words (without curly brackets).
partitionneur_deriv objet_u partitionneur_deriv -1 not_set
  attr nb_parts entier nb_parts 1 The number of non empty parts that must be generated (generally equal to the number of processors in the parallel run).
partitionneur_metis partitionneur_deriv metis -1 Metis is an external partitionning library. It is a general algorithm that will generate a partition of the domain.
  attr kmetis rien kmetis 1 The default values are pmetis, default parameters are automatically chosen by Metis. \'kmetis\' is faster than pmetis option but the last option produces better partitioning quality. In both cases, the partitioning quality may be slightly improved by increasing the nb_essais option (by default N=1). It will compute N partitions and will keep the best one (smallest edge cut number). But this option is CPU expensive, taking N=10 will multiply the CPU cost of partitioning by 10. NL2 Experiments show that only marginal improvements can be obtained with non default parameters.
  attr use_weights rien use_weights 1 If use_weights is specified, weighting of the element-element links in the graph is used to force metis to keep opposite periodic elements on the same processor. This option can slightly improve the partitionning quality but it consumes more memory and takes more time. It is not mandatory since a correction algorithm is always applied afterwards to ensure a correct partitionning for periodic boundaries.
partitionneur_sous_zones partitionneur_deriv sous_zones -1 This algorithm will create one part for each specified subzone. All elements contained in the first subzone are put in the first part, all remaining elements contained in the second subzone in the second part, etc... NL2 If all elements of the domain are contained in the specified subzones, then N parts are created, otherwise, a supplemental part is created with the remaining elements. NL2 If no subzone is specified, all subzones defined in the domain are used to split the mesh.
  attr sous_zones listchaine sous_zones 0 N SUBZONE_NAME_1 SUBZONE_NAME_2 ...
partitionneur_tranche partitionneur_deriv tranche -1 This algorithm will create a geometrical partitionning by slicing the mesh in the two or three axis directions, based on the geometric center of each mesh element. nz must be given if dimension=3. Each slice contains the same number of elements (slices don\'t have the same geometrical width, and for VDF meshes, slice boundaries are generally not flat except if the number of mesh elements in each direction is an exact multiple of the number of slices). First, nx slices in the X direction are created, then each slice is split in ny slices in the Y direction, and finally, each part is split in nz slices in the Z direction. The resulting number of parts is nx*ny*nz. If one particular direction has been declared periodic, the default slicing (0, 1, 2, ..., n-1)is replaced by (0, 1, 2, ... n-1, 0), each of the two \'0\' slices having twice less elements than the other slices.
  attr tranches listentierf tranches 1 Partitioned by nx in the X direction, ny in the Y direction, nz in the Z direction. Works only for structured meshes. No warranty for unstructured meshes.
partitionneur_partition partitionneur_deriv partition -1 This algorithm re-use the partition of the domain named DOMAINE_NAME. It is useful to partition for example a post processing domain. The partition should match with the calculation domain.
  attr domaine ref_domaine domaine 0 domain name
partitionneur_fichier_decoupage partitionneur_deriv fichier_decoupage -1 This algorithm reads an array of integer values on the disc, one value for each mesh element. Each value is interpreted as the target part number n>=0 for this element. The number of parts created is the highest value in the array plus one. Empty parts can be created if some values are not present in the array. NL2 The file format is ASCII, and contains space, tab or carriage-return separated integer values. The first value is the number nb_elem of elements in the domain, followed by nb_elem integer values (positive or zero). NL2 This algorithm has been designed to work together with the \'ecrire_decoupage\' option. You can generate a partition with any other algorithm, write it to disc, modify it, and read it again to generate the .Zone files. NL2 Contrary to other partitioning algorithms, no correction is applied by default to the partition (eg. element 0 on processor 0 and corrections for periodic boundaries). If \'corriger_partition\' is specified, these corrections are applied.
  attr fichier chaine fichier 0 FILENAME
  attr corriger_partition rien corriger_partition 1 not_set
distance_paroi interprete distance_paroi 0 Class to generate external file Wall_length.xyz devoted for instance, for mixing length modelling. In this file, are saved the coordinates of each element (center of gravity) of dom domain and minimum distance between this point and boundaries (specified bords) that user specifies in data file (typically, those associated to walls). A field Distance_paroi is available to post process the distance to the wall.
  attr dom ref_domaine dom 0 Name of domain.
  attr bords listchaine bords 0 Boundaries.
  attr format chaine(into=["binaire","formatte"]) format 0 Value for format may be binaire (a binary file Wall_length.xyz is written) or formatte (moreover, a formatted file Wall_length_formatted.xyz is written).
troisf objet_lecture nul 0 Auxiliary class to extrude.
  attr lx floattant lx 0 X direction of the extrude operation.
  attr ly floattant ly 0 Y direction of the extrude operation.
  attr lz floattant lz 0 Z direction of the extrude operation.
extruder interprete extruder 1 Class to create a 3D tetrahedral/hexahedral mesh (a prism is cut in 14) from a 2D triangular/quadrangular mesh.
  attr domaine ref_domaine domain_name 0 Name of the domain.
  attr direction troisf direction 0 Direction of the extrude operation.
  attr nb_tranches entier nb_tranches 0 Number of elements in the extrusion direction.
extruder_en3 extruder extruder_en3 1 Class to create a 3D tetrahedral/hexahedral mesh (a prism is cut in 3) from a 2D triangular/quadrangular mesh. The names of the boundaries (by default, devant (front) and derriere (back)) may be edited by the keyword nom_cl_devant and nom_cl_derriere. If NULL is written for nom_cl, then no boundary condition is generated at this place. NL2 Recommendation : to ensure conformity between meshes (in case of fluid/solid coupling) it is recommended to extrude all the domains at the same time.
  attr domaine listchaine domain_name 0 List of the domains
  attr nom_cl_devant chaine nom_cl_devant 1 New name of the first boundary.
  attr nom_cl_derriere chaine nom_cl_derriere 1 New name of the second boundary.
extruder_en20 interprete extruder_en20 1 It does the same task as Extruder except that a prism is cut into 20 tetraedra instead of 3. The name of the boundaries will be devant (front) and derriere (back). But you can change these names with the keyword RegroupeBord.
  attr domaine ref_domaine domain_name 0 Name of the domain.
  attr direction troisf direction 1 0 Direction of the extrude operation.
  attr nb_tranches entier nb_tranches 0 Number of elements in the extrusion direction.
frontiere_ouverte_fraction_massique_imposee condlim_base frontiere_ouverte_fraction_massique_imposee -1 not_set
  attr ch front_field_base ch 0 Boundary field type.
spec_pdcr_base objet_lecture spec_pdcr_base 0 Class to read the source term modelling the presence of a bundle of tubes in a flow. Cf=A Re-B.
  attr ch_a chaine(into=["a","cf"]) ch_a 0 Keyword to be used to set law coefficient values for the coefficient of regular pressure losses.
  attr a floattant a 0 Value of a law coefficient for regular pressure losses.
  attr ch_b chaine(into=["b"]) ch_b 1 Keyword to be used to set law coefficient values for regular pressure losses.
  attr b floattant b 1 Value of a law coefficient for regular pressure losses.
longitudinale spec_pdcr_base longitudinale 0 Class to define the pressure loss in the direction of the tube bundle.
  attr dir chaine(into=["x","y","z"]) dir 0 Direction.
  attr dd floattant dd 0 Tube bundle hydraulic diameter value. This value is expressed in m.
transversale spec_pdcr_base transversale 0 Class to define the pressure loss in the direction perpendicular to the tube bundle.
  attr dir chaine(into=["x","y","z"]) dir 0 Direction.
  attr dd floattant dd 0 Value of the tube bundle step.
  attr chaine_d chaine(into=["d"]) chaine_d 0 Keyword to be used to set the value of the tube external diameter.
  attr d floattant d 0 Value of the tube external diameter.
perte_charge_reguliere source_base perte_charge_reguliere 0 Source term modelling the presence of a bundle of tubes in a flow.
  attr spec spec_pdcr_base spec 0 Description of longitudinale or transversale type.
  attr zone_name chaine name_of_zone 0 Name of the sub-area occupied by the tube bundle. A Sous_Zone (Sub-area) type object called zone_name should have been previously created.
methode_transport_deriv objet_lecture methode_transport_deriv 0 Basic class for method of transport of interface.
loi_horaire objet_u loi_horaire 1 to define the movement with a time-dependant law for the solid interface.
  attr position listchaine position 0 not_set
  attr vitesse listchaine vitesse 0 not_set
  attr rotation listchaine rotation 1 not_set
  attr derivee_rotation listchaine derivee_rotation 1 not_set
methode_loi_horaire methode_transport_deriv loi_horaire -1 not_set
  attr nom_loi ref_loi_horaire nom_loi 0 not_set
problem_read_generic Pb_base problem_read_generic -1 The probleme_read_generic differs rom the rest of the TRUST code : The problem does not state the number of equations that are enclosed in the problem. As the list of equations to be solved in the generic read problem is declared in the data file and not pre-defined in the structure of the problem, each equation has to be distinctively associated with the problem with the Associate keyword.
  ref eqn1 eqn_base
  ref eqn2 eqn_base
  ref eqn3 eqn_base
  ref eqn4 eqn_base
  ref eqn5 eqn_base
  ref eqn6 eqn_base
  ref eqn7 eqn_base
  ref eqn8 eqn_base
  ref eqn9 eqn_base
  ref eqn10 eqn_base
temperature traitement_particulier_base temperature -1 not_set
  attr bord chaine bord 0 not_set
  attr direction entier direction 0 not_set
canal traitement_particulier_base canal -1 Keyword for statistics on a periodic plane channel.
  attr dt_impr_moy_spat floattant dt_impr_moy_spat 1 Period to print the spatial average (default value is 1e6).
  attr dt_impr_moy_temp floattant dt_impr_moy_temp 1 Period to print the temporal average (default value is 1e6).
  attr debut_stat floattant debut_stat 1 Time to start the temporal averaging (default value is 1e6).
  attr fin_stat floattant fin_stat 1 Time to end the temporal averaging (default value is 1e6).
  attr pulsation_w floattant pulsation_w 1 Pulsation for phase averaging (in case of pulsating forcing term) (no default value).
  attr nb_points_par_phase entier nb_points_par_phase 1 Number of samples to represent phase average all along a period (no default value).
  attr reprise chaine reprise 1 val_moy_temp_xxxxxx.sauv : Keyword to resume a calculation with previous averaged quantities. NL2 Note that for thermal and turbulent problems, averages on temperature and turbulent viscosity are automatically calculated. To resume a calculation with phase averaging, val_moy_temp_xxxxxx.sauv_phase file is required on the directory where the job is submitted (this last file will be then automatically loaded by TRUST).
ec traitement_particulier_base ec -1 Keyword to print total kinetic energy into the referential linked to the domain (keyword Ec). In the case where the domain is moving into a Galilean referential, the keyword Ec_dans_repere_fixe will print total kinetic energy in the Galilean referential whereas Ec will print the value calculated into the moving referential linked to the domain
  attr Ec rien Ec 1 not_set
  attr Ec_dans_repere_fixe rien Ec_dans_repere_fixe 1 not_set
  attr periode floattant periode 1 periode is the keyword to set the period of printing into the file datafile_Ec.son or datafile_Ec_dans_repere_fixe.son.
thi traitement_particulier_base thi -1 Keyword for a THI (Homogeneous Isotropic Turbulence) calculation.
  attr init_Ec entier init_Ec 0 Keyword to renormalize initial velocity so that kinetic energy equals to the value given by keyword val_Ec.
  attr val_Ec floattant val_Ec 1 Keyword to impose a value for kinetic energy by velocity renormalizated if init_Ec value is 1.
  attr facon_init entier(into=["0","1"]) facon_init 1 Keyword to specify how kinetic energy is computed (0 or 1).
  attr calc_spectre entier(into=["0","1"]) calc_spectre 1 Calculate or not the spectrum of kinetic energy. NL2 Files called Sorties_THI are written with inside four columns : NL2 time:t global_kinetic_energy:Ec enstrophy:D skewness:S NL2 If calc_spectre is set to 1, a file Sorties_THI2_2 is written with three columns : NL2 time:t kinetic_energy_at_kc=32 enstrophy_at_kc=32 NL2 If calc_spectre is set to 1, a file spectre_xxxxx is written with two columns at each time xxxxx : NL2 frequency:k energy:E(k).
  attr periode_calc_spectre floattant periode_calc_spectre 1 Period for calculating spectrum of kinetic energy
  attr spectre_3D entier(into=["0","1"]) Spectre_3D 1 Calculate or not the 3D spectrum
  attr spectre_1D entier(into=["0","1"]) Spectre_1D 1 Calculate or not the 1D spectrum
  attr conservation_Ec rien conservation_Ec 1 If set to 1, velocity field will be changed as to have a constant kinetic energy (default 0)
  attr longueur_boite floattant longueur_boite 1 Length of the calculation domain
chmoy_faceperio traitement_particulier_base chmoy_faceperio 0 non documente
  attr bloc bloc_lecture bloc 0 not_set
integrer_champ_med interprete integrer_champ_med 1 his keyword is used to calculate a flow rate from a velocity MED field read before. The method is either debit_total to calculate the flow rate on the whole surface, either integrale_en_z to calculate flow rates between z=zmin and z=zmax on nb_tranche surfaces. The output file indicates first the flow rate for the whole surface and then lists for each tranche : the height z, the surface average value, the surface area and the flow rate. For the debit_total method, only one tranche is considered.NL2 file :z Sum(u.dS)/Sum(dS) Sum(dS) Sum(u.dS)
  attr champ_med ref_champ_fonc_med champ_med 0 not_set
  attr methode chaine(into=["integrale_en_z","debit_total"]) methode 0 to choose between the integral following z or over the entire height (debit_total corresponds to zmin=-DMAXFLOAT, ZMax=DMAXFLOAT, nb_tranche=1)
  attr zmin floattant zmin 1 not_set
  attr zmax floattant zmax 1 not_set
  attr nb_tranche entier nb_tranche 1 not_set
  attr fichier_sortie chaine fichier_sortie 1 name of the output file, by default: integrale.
convection_amont convection_deriv amont 0 Keyword for upwind scheme for VDF or VEF discretizations. In VEF discretization equivalent to generic amont for TRUST version 1.5 or later. The previous upwind scheme can be used with the obsolete in future amont_old keyword.
convection_amont_old convection_deriv amont_old 0 Only for VEF discretization, obsolete keyword, see amont.
convection_centre convection_deriv centre 0 For VDF and VEF discretizations.
convection_centre4 convection_deriv centre4 0 For VDF and VEF discretizations.
convection_centre_old convection_deriv centre_old 0 Only for VEF discretization.
convection_di_l2 convection_deriv di_l2 0 Only for VEF discretization.
bloc_ef objet_lecture nul 0 not_set
  attr mot1 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot1 0 not_set
  attr val1 entier(into=[0,1]) val1 0 not_set
  attr mot2 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot2 0 not_set
  attr val2 entier(into=[0,1]) val2 0 not_set
  attr mot3 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot3 0 not_set
  attr val3 entier(into=[0,1]) val3 0 not_set
  attr mot4 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot4 0 not_set
  attr val4 entier(into=[0,1]) val4 0 not_set
convection_ef convection_deriv ef 0 For VEF calculations, a centred convective scheme based on Finite Elements formulation can be called through the following data:NL2 NL2 Convection { EF transportant_bar val transporte_bar val antisym val filtrer_resu val }NL2 NL2 This scheme is 2nd order accuracy (and get better the property of kinetic energy conservation). Due to possible problems of instabilities phenomena, this scheme has to be coupled with stabilisation process (see Source_Qdm_lambdaup).These two last data are equivalent from a theoretical point of view in variationnal writing to : div(( u. grad ub , vb) - (u. grad vb, ub)), where vb corresponds to the filtered reference test functions.NL2 NL2 Remark:NL2 This class requires to define a filtering operator : see solveur_bar
  attr mot1 chaine(into=["defaut_bar"]) mot1 1 equivalent to transportant_bar 0 transporte_bar 1 filtrer_resu 1 antisym 1
  attr bloc_ef bloc_ef bloc_ef 1 not_set
convection_muscl3 convection_deriv muscl3 1 Keyword for a scheme using a ponderation between muscl and center schemes in VEF.
  attr alpha floattant alpha 1 To weight the scheme centering with the factor double (between 0 (full centered) and 1 (muscl), by default 1).
sous_zone_valeur objet_lecture nul 0 Two words.
  attr sous_zone ref_sous_zone sous_zone 0 sous zone
  attr valeur floattant valeur 0 value
listsous_zone_valeur listobj nul 0 sous_zone_valeur 0 List of groups of two words.
convection_ef_stab convection_deriv ef_stab 1 Keyword for a VEF convective scheme.
  attr alpha floattant alpha 1 To weight the scheme centering with the factor double (between 0 (full centered) and 1 (mix between upwind and centered), by default 1). For scalar equation, it is adviced to use alpha=1 and for the momentum equation, alpha=0.2 is adviced.
  attr test entier test 1 Developer option to compare old and new version of EF_stab
  attr tdivu rien tdivu 1 To have the convective operator calculated as div(TU)-TdivU(=UgradT).
  attr old rien old 1 To use old version of EF_stab scheme (default no).
  attr volumes_etendus rien volumes_etendus 1 Option for the scheme to use the extended volumes (default, yes).
  attr volumes_non_etendus rien volumes_non_etendus 1 Option for the scheme to not use the extended volumes (default, no).
  attr amont_sous_zone ref_sous_zone amont_sous_zone 1 Option to degenerate EF_stab scheme into Amont (upwind) scheme in the sub zone of name sz_name. The sub zone may be located arbitrarily in the domain but the more often this option will be activated in a zone where EF_stab scheme generates instabilities as for free outlet for example.
  attr alpha_sous_zone listsous_zone_valeur alpha_sous_zone 1 Option to change locally the alpha value on N sub-zones named sub_zone_name_I. Generally, it is used to prevent from a local divergence by increasing locally the alpha parameter.
convection_generic convection_deriv generic 0 Keyword for generic calling of upwind and muscl convective scheme in VEF discretization. For muscl scheme, limiters and order for fluxes calculations have to be specified. The available limiters are : minmod - vanleer -vanalbada - chakravarthy - superbee, and the order of accuracy is 1 or 2. Note that chakravarthy is a non-symmetric limiter and superbee may engender results out of physical limits. By consequence, these two limiters are not recommended. NL2 Examples: NL2 convection { generic amont }NL2 convection { generic muscl minmod 1 }NL2 convection { generic muscl vanleer 2 }NL2 NL2 In case of results out of physical limits with muscl scheme (due for instance to strong non-conformal velocity flow field), user can redefine in data file a lower order and a smoother limiter, as : convection { generic muscl minmod 1 }
  attr type chaine(into=["amont","muscl","centre"]) type 0 type of scheme
  attr limiteur chaine(into=["minmod","vanleer","vanalbada","chakravarthy","superbee"]) limiteur 1 type of limiter
  attr ordre entier(into=[1,2,3]) ordre 1 order of accuracy
  attr alpha floattant alpha 1 alpha
convection_kquick convection_deriv kquick 0 Only for VEF discretization.
convection_muscl convection_deriv muscl 0 Keyword for muscl scheme in VEF discretization equivalent to generic muscl vanleer 2 for the 1.5 version or later. The previous muscl scheme can be used with the obsolete in future muscl_old keyword.
convection_muscl_old convection_deriv muscl_old 0 Only for VEF discretization.
convection_muscl_new convection_deriv muscl_new 0 Only for VEF discretization.
convection_negligeable convection_deriv negligeable 0 For VDF and VEF discretizations. Suppresses the convection operator.
convection_quick convection_deriv quick 0 Only for VDF discretization.
diffusion_negligeable diffusion_deriv negligeable 0 the diffusivity will not taken in count
bloc_diffusion_standard objet_lecture nul 0 grad_Ubar 1 makes the gradient calculated through the filtered values of velocity (P1-conform).NL2 nu 1 (respectively nut 1) takes the molecular viscosity (eddy viscosity) into account in the velocity gradient part of the diffusion expression. NL2 nu_transp 1 (respectively nut_transp 1) takes the molecular viscosity (eddy viscosity) into account according in the TRANSPOSED velocity gradient part of the diffusion expression.NL2 filtrer_resu 1 allows to filter the resulting diffusive fluxes contribution.
  attr mot1 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot1 0 not_set
  attr val1 entier(into=[0,1]) val1 0 not_set
  attr mot2 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot2 0 not_set
  attr val2 entier(into=[0,1]) val2 0 not_set
  attr mot3 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot3 0 not_set
  attr val3 entier(into=[0,1]) val3 0 not_set
  attr mot4 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot4 0 not_set
  attr val4 entier(into=[0,1]) val4 0 not_set
  attr mot5 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot5 0 not_set
  attr val5 entier(into=[0,1]) val5 0 not_set
  attr mot6 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot6 0 not_set
  attr val6 entier(into=[0,1]) val6 0 not_set
difusion_p1b diffusion_deriv p1b 0 not_set
diffusion_p1ncp1b diffusion_deriv p1ncp1b 1 not_set
diffusion_stab diffusion_deriv stab 1 keyword allowing consistent and stable calculations even in case of obtuse angle meshes.
  attr standard entier standard 1 to recover the same results as calculations made by standard laminar diffusion operator. However, no stabilization technique is used and calculations may be unstable when working with obtuse angle meshes (by default 0)
  attr info entier info 1 developer option to get the stabilizing ratio (by default 0)
  attr new_jacobian entier new_jacobian 1 when implicit time schemes are used, this option defines a new jacobian that may be more suitable to get stationary solutions (by default 0)
  attr nu entier nu 1 (respectively nut 1) takes the molecular viscosity (resp. eddy viscosity) into account in the velocity gradient part of the diffusion expression (by default nu=1 and nut=1)
  attr nut entier nut 1 not_set
  attr nu_transp entier nu_transp 1 (respectively nut_transp 1) takes the molecular viscosity (resp. eddy viscosity) into account in the transposed velocity gradient part of the diffusion expression (by default nu_transp=0 and nut_transp=1)
  attr nut_transp entier nut_transp 1 not_set
diffusion_standard diffusion_deriv standard 0 A new keyword, intended for LES calculations, has been developed to optimise and parameterise each term of the diffusion operator. Remark:NL2 NL2 1. This class requires to define a filtering operator : see solveur_barNL2 2. The former (original) version: diffusion { } -which omitted some of the term of the diffusion operator- can be recovered by using the following parameters in the new class :NL2 diffusion { standard grad_Ubar 0 nu 1 nut 1 nu_transp 0 nut_transp 1 filtrer_resu 0}.
  attr mot1 chaine(into=["defaut_bar"]) mot1 1 equivalent to grad_Ubar 1 nu 1 nut 1 nu_transp 1 nut_transp 1 filtrer_resu 1
  attr bloc_diffusion_standard bloc_diffusion_standard bloc_diffusion_standard 1 not_set
reaction objet_lecture nul 1 Keyword to describe reaction: NL2 w =K pow(T,beta) exp(-Ea/( R T)) $\Pi$ pow(Reactif_i,activitivity_i). NL2 If K_inv >0, NL2 w= K pow(T,beta) exp(-Ea/( R T)) ( $\Pi$ pow(Reactif_i,activitivity_i) - Kinv/exp(-c_r_Ea/(R T)) $\Pi$ pow(Produit_i,activitivity_i ))
  attr reactifs chaine reactifs 0 LHS of equation (ex CH4+2*O2)
  attr produits chaine produits 0 RHS of equation (ex CO2+2*H20)
  attr constante_taux_reaction floattant constante_taux_reaction 1 constante of cinetic K
  attr coefficients_activites bloc_lecture coefficients_activites 1 coefficients od ativity (exemple { CH4 1 O2 2 })
  attr enthalpie_reaction floattant enthalpie_reaction 0 DH
  attr energie_activation floattant energie_activation 0 Ea
  attr exposant_beta floattant exposant_beta 0 Beta
  attr contre_reaction floattant contre_reaction 1 K_inv
  attr contre_energie_activation floattant contre_energie_activation 1 c_r_Ea
reactions listobj nul 1 reaction 1 list of reactions
chimie objet_u chimie 1 Keyword to describe the chmical reactions
  attr reactions reactions reactions 0 list of reactions
  attr modele_micro_melange entier modele_micro_melange 1 modele_micro_melange (0 by default)
  attr constante_modele_micro_melange floattant constante_modele_micro_melange 1 constante of modele (1 by default)
  attr espece_en_competition_micro_melange chaine espece_en_competition_micro_melange 1 espece in competition in reactions
schema_adams_bashforth_order_2 schema_temps_base schema_adams_bashforth_order_2 -1 not_set
schema_adams_bashforth_order_3 schema_temps_base schema_adams_bashforth_order_3 -1 not_set
schema_adams_moulton_order_2 schema_implicite_base schema_adams_moulton_order_2 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_adams_moulton_order_3 schema_implicite_base schema_adams_moulton_order_3 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_backward_differentiation_order_2 schema_implicite_base schema_backward_differentiation_order_2 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_backward_differentiation_order_3 schema_implicite_base schema_backward_differentiation_order_3 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
ef discretisation_base ef -1 Element Finite discretization.
diffusion_option diffusion_deriv option 0 not_set
  attr bloc_lecture bloc_lecture bloc_lecture 0 not_set
champ_front_normal_vef front_field_base champ_front_normal_vef 0 Field to define the normal vector field standard at the boundary in VEF discretization.
  attr mot chaine(into=["valeur_normale"]) mot 0 Name of vector field.
  attr vit_tan floattant vit_tan 0 normal vector value (positive value for a vector oriented outside to inside).
