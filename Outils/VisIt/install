#!/bin/bash
installation_visit()
{
   if [ ! -f $TRUST_ROOT/exec/VisIt/bin/visit ]
   then   
      echo "#########################################################"
      echo "# Installation of VisIt $version_visit for $ARCH ...     "
      echo "#########################################################"
      # Securite on verifie que le visit_install va pas tourner sur lui meme et remplir le disque
      [ `echo $ECHO_OPTS "1\n"` != 1 ] && echo "Problem in installation_visit" && exit -1
      # Desormais le visit-install a le numero de version
      echo $ECHO_OPTS "1\nn" | ./$visit_install ${version_visit#v} $ARCH $TRUST_ROOT/exec/VisIt 1>visit-install.log 2>&1
      [ $? != 0 ] && cat visit-install.log && echo "Installation of VisIt failed!" && echo "See `pwd`/visit-install.log" && exit -1
      rm -f $package
   fi
   # Ajout en debut du script visit d'un appel a check_visit
   # pour faire des verifications et ajouter des messages 
   # pour les utilisateurs:
   sed -i "1,$ s?#!\/bin/sh?#!\/bin/bash\nsource \$TRUST_ROOT/Outils/VisIt/check_visit \$\*?g" $TRUST_ROOT/exec/VisIt/bin/visit 1>/dev/null 2>&1
   [ $? != 0 ] && echo "The change of visit script failed." && exit -1  
}

# Definition de TMPDIR car utilise par Visit pour l'installation
# Si faite par sudo et que TMPDIR vide, $HOME est pris ce qui cree des permission denied (cezanne30)
# Donc on anticipe le probleme en fixant un TMPDIR qui marchera toujours:
export TMPDIR=/tmp

# Quit if $TRUST_WITHOUT_VISIT defined
if [ "$TRUST_WITHOUT_VISIT" = 1 ]
then
   echo "TRUST_WITHOUT_VISIT=$TRUST_WITHOUT_VISIT so VisIt not installed."
   exit 0
fi
if [ ${#TRUST_ROOT} = 0 ]
then
   echo "The TRUST_ROOT variable is not defined. Initialize TRUST environment."
   exit -1
fi

echo "Usage: ./`basename $0` version [visit | plugins | check]"
if [ "$1" = "" ] || [ "$2" = "" ]
then
   exit -1
fi
version=$1
what=$2
parallel=""
new=1
# PL: Migration progressive avec les nouvelles machines vers une procedure plus propre a partir de VisIt 3.1.1
# Ajouter les OS uniquement si l'ancienne procedure avec VisIt 2.12.1 ne marche pas:
[ "`grep 'Debian GNU/Linux [7-8]'  				/etc/issue.net 2>/dev/null`" != "" ]		&& new=0
[ "`grep 'Ubuntu 1[4-7]' 					/etc/issue 2>/dev/null`" != "" ]		&& new=0
[ "`grep 'Fedora release 2[0-5]' 				/etc/fedora-release 2>/dev/null`" != "" ]	&& new=0
[ "`grep 'CentOS Linux release [6-7]' 				/etc/centos-release 2>/dev/null`" != "" ]	&& new=0
[ "`grep 'CentOS release [6-7]' 				/etc/centos-release 2>/dev/null`" != "" ]	&& new=0
[ "`grep 'Red Hat Enterprise Linux Server release [6-7]' 	/etc/redhat-release 2>/dev/null`" != "" ]	&& new=0
[ "`grep 'Scientific Linux release 6'				/etc/issue.net 2>/dev/null`" != "" ]		&& new=0 # gutta aar

if [ "$new" = 1 ]
then
   # Nouvelle procedure
   build=build_new.sh
   version=$3
   export HTTPS="https://github.com/visit-dav/visit/releases/download"
   version_visit=v`echo $version | $TRUST_Awk '{gsub("_",".",$1);print $1}'`
   [ "$MPI_ROOT" != "" ] && [ "$TRUST_WITHOUT_HOST" = 0 ] && parallel="parallel" # Construction de VisIt parallele uniquement sur cluster desormais
else
   # Ancienne procedure, peu a peu obsolete
   build=build.sh
   # suppression de python/conda du path :
   OLDPATH_=$PATH
   NEWPATH_=`echo $PATH | sed "s/exec\/python\/bin/exec/g"`
   export PATH=$NEWPATH_
   export HTTPS="http://portal.nersc.gov/project/visit/releases https://wci.llnl.gov/simulation/computer-codes/visit/executables http://visit.ilight.com/svn/visit/trunk/releases"
   version_visit=`echo $version | $TRUST_Awk '{gsub("_",".",$1);print $1}'`
  [ "$MPI_ROOT" != "" ] && parallel="parallel"
fi   

echo $version $what $version_visit

##############################
# Script visit-install a jour?
##############################
visit_install=visit-install$version
if [ ! -f $visit_install ]
then
   CHECKOUT . 1>/dev/null 2>&1
   RM.sh visit-install* 1>/dev/null 2>&1
   DOWNLOADED=0
   for HTTP in $HTTPS
   do
      if [ $DOWNLOADED = 0 ]
      then
         echo $ECHO_OPTS "Try to download $HTTP/$version_visit/$visit_install...\c"
	 wget_ $HTTP/$version_visit/$visit_install 1>/dev/null 2>&1
	 if [ $? = 0 ]
	 then
	    echo "OK"
	    DOWNLOADED=1
	 else
	    echo "KO"
	 fi
      fi
   done
   [ $DOWNLOADED = 0 ] && echo "Fail to download $visit_install" && exit -1
   chmod +x $visit_install  
   MKELEM $visit_install 1>/dev/null 2>&1
fi

##################################
# Definition de quelques variables
##################################
ARCH=`uname -s | awk '{print tolower($1)}'`
# Pour Linux, on ajoute le type
[ $ARCH = linux ] && ARCH=$ARCH"-"`uname -m`

export package=visit$version.$ARCH.tar.gz
if [ $what = visit ] 
then
   status=0
   if [ ! -f $package ] && [ "$TRUST_DOWNLOAD_VISIT" != 1 ]
   then
      echo "#################################################"
      echo "# Trying to build a $parallel version for VisIt..."
      echo "#################################################"
      org_dir=`pwd`
      if [ "$TRUST_BUILD_IN_TMP" = "1" ]
	  then
	  name=visit
	  build_dir=$TRUST_TMP/build/$name
	  mkdir -p $build_dir
	  cp -r src $build_dir
	  cd $build_dir
      fi
      cd src
      ./$build $package $parallel 
      status=$?
      if [ $status -ne 0 ] && [ "$parallel" != "" ]
      then
          echo "Try sequentiel compilation"
         ./$build clean
         ./$build $package
	 status=$?
      fi 
      cd $org_dir
   fi
   # Telechargement demande ou suite echec de construction (sauf si une configuration parallele existe
   # auquel cas la construction parallele DOIT avoir fonctionne
   if [ "$TRUST_DOWNLOAD_VISIT" = 1 ] || [ "$status" != 0 ]
   then
      echo "###########################################"
      echo "# Trying to download a version for VisIt..."
      echo "###########################################"
      # ce n est plus le cas: version telechargee est parallele
#      if [ "`grep parallel host_*$HOST.xml 2>/dev/null | grep true`" != "" ]
#      then
#         echo "Can't download a sequential version of VisIt on $HOST cause the file `ls host_*$HOST.xml`"
#	 echo "suppose VisIt should be parallel."
#	 exit -1
#      else
	 if [ $version = 2_5_2 ]
	 then
            # Pour 2.5.2, rhel4 n'existe plus, choix possibles:
	    # linux-rhel5
	    # linux-x86_64-rhel5
	    # linux-x86_64-rhel6
	    # linux-x86_64-ubuntu11
	    # linux-euclid
	    rhel=rhel5 
	    ARCH=linux-$rhel && [ "`uname -m`" = x86_64 ] && ARCH=linux-x86_64-$rhel
	 elif [ $version = 2_10_0 ]
	 then
            # No 32bits version...
            ARCH=linux-x86_64-rhel6
	    #ARCH=linux-x86_64-ubuntu11
	 elif [ $version = 2_12_1 ]
	 then
            if [ "`grep 'Ubuntu ' /etc/issue.net 2>/dev/null`" != "" ]
            then
               ARCH=linux-x86_64-ubuntu14-wmesa
            else
               ARCH=linux-x86_64-rhel7-wmesa
            fi
	 elif [ $version = 3_1_1 ] && [ "$TRUST_INT64" = 0 ]
	 then
            # See https://wci.llnl.gov/simulation/computer-codes/visit/executables
            [ "`grep 'Ubuntu 16.04' /etc/issue 2>/dev/null`" != "" ] 				&& os=ubuntu16
            [ "`grep 'Ubuntu 18.04' /etc/issue 2>/dev/null`" != "" ] 				&& os=ubuntu18
            [ "`grep 'Ubuntu 19'    /etc/issue 2>/dev/null`" != "" ] 				&& os=ubuntu19
            [ "`grep 'Ubuntu 20'    /etc/issue 2>/dev/null`" != "" ] 				&& os=ubuntu20 && version=3_1_2 && version_visit=v3.1.2
            [ "`grep 'Debian GNU/Linux 9'  /etc/issue.net 2>/dev/null`" != "" ]			&& os=debian9
            [ "`grep 'Debian GNU/Linux 10' /etc/issue.net 2>/dev/null`" != "" ]			&& os=debian10 && version=3_1_2 && version_visit=v3.1.2
            [ "`grep 'CentOS Linux release 8' /etc/centos-release 2>/dev/null`" != "" ] 	&& os=centos8
            [ "`grep 'Fedora release 2[7-9]' /etc/fedora-release 2>/dev/null`" != "" ] 		&& os=fedora27
            [ "`grep 'Fedora release 3[0-4]' /etc/fedora-release 2>/dev/null`" != "" ] 		&& os=fedora27
            [ "`grep 'Red' /etc/redhat-release 2>/dev/null`" != "" ]				&& os=rhel7
            [ "$os" = "" ] && echo "OS not detected." && exit -1
	    ARCH=linux-x86_64-$os
	 else   
            if [ "$TRUST_INT64" = 0 ]
            then
               echo "No ARCH defined yet for $version."
            else
               echo "Visit $version binary is not compatible with the 64 bits integers build of TRUST."
            fi
            exit -1
	 fi
	 package=visit$version.$ARCH.tar.gz
	 rm -f $package
	 DOWNLOADED=0
	 for HTTP in $HTTPS
	 do
            if [ $DOWNLOADED = 0 ]
	    then
	       echo "Try to download $HTTP/$version_visit/$package..."
	       # Regarde dans le cache:
	       [ ! -f $TRUST_TMP/$package ] && wget_ $HTTP/$version_visit/$package 1>/dev/null 2>&1 && mv -f $package $TRUST_TMP
	       [ -f $TRUST_TMP/$package ] && DOWNLOADED=1 && ln -s -f $TRUST_TMP/$package .
	    fi
	 done
	 [ $DOWNLOADED = 0 ] && echo "Fail to download $package" && exit -1
#      fi
   fi  
   #################
   # Install VisIt #
   #################
   installation_visit   

elif [ $what = plugins ]
then   
   ###############################################
   # Build plugins if the VisIt version is built #
   ###############################################
   # Essai de construire les plugins sur une version telechargee recente de VisIt
   if [ "$TRUST_DOWNLOAD_VISIT" != 1 ] || [ $new = 1 ]
   then
      for plugin in `ls plugins/*/build_plugin 2>/dev/null`
      do
	 rep=`dirname $plugin`
	 cd $rep 1>/dev/null 2>&1
	 echo "#########################################"
	 echo "# Building `basename $rep` plugin:"
	 ./build_plugin || exit -1
	 cd - 1>/dev/null 2>&1
	 echo "#########################################" 
      done
   else
      echo "##########################################################################################"
      echo "Plugins not built cause VisIt version has not been rebuilt on the platform but downloaded."
      echo "##########################################################################################"
   fi   
     
elif [ $what = check ]
then
   ########################
   # Update host profiles #
   ########################
   mkdir -p $TRUST_ROOT/exec/VisIt/current/.visit/hosts
   for xml in `ls $TRUST_ROOT/exec/VisIt/current/.visit/hosts/*.xml 2>/dev/null`
   do
      xml=`basename $xml`
      [ ! -f $xml ] && rm -f $TRUST_ROOT/exec/VisIt/current/.visit/hosts/$xml && echo "$TRUST_ROOT/exec/VisIt/current/.visit/hosts/$xml deleted."
      #machine=`echo ${xml%.xml} | $TRUST_Awk -F_ '{print $NF}'`
      #if [ ! -f $xml ] ||  [ $machine != $HOST ] 
      #then
      #   rm -f $TRUST_ROOT/exec/VisIt/current/.visit/hosts/$xml && echo "$TRUST_ROOT/exec/VisIt/current/.visit/hosts/$xml deleted."
      #fi
   done
   for xml in `ls *.xml 2>/dev/null`
   do
      machine=`echo ${xml%.xml} | $TRUST_Awk -F_ '{print $NF}'`
      #if [ $machine = $HOST ] 
      #then
      # La premier ligne <Field name="host" definit le host en remote 
      # La deuxieme ligne <Field name="host" definit le host en local
      # Ainsi pour configurer VisIt sur Windows, il suffit de copier
      # les .xml sous current/.visit/hosts la premiere ligne etant lue
      # par defaut pour une connection vers les serveurs de calcul
      # ATTENTION: VisIt n'aime pas les commentaires dans le xml:
      # On en profite pour geler les remote hosts qui ne marchent pas en inserant un commentaire en debut de fichier
      # On change egalement le chemin vers la version de VisIt si la version TRUST est de type stable ou beta
      # La version TRUST sera toujours de type beta si on est sous la vue Livraison
      ligne=1 && [ $machine = $HOST ] && ligne=2
      if [ ${TRUST_VERSION%_beta} != $TRUST_VERSION ] || [ "$MA_VUE" = triou_admin ] || [ "`echo $TRUST_ROOT | grep $WORKBASE 2>&1`" != "" ]
      then
         VERSION=$WORKBASE$machine/TRUST
      else
         VERSION=TRUST/TRUST-$TRUST_VERSION
      fi
      $TRUST_Awk -v ligne=$ligne -v TRUST_VERSION=$VERSION '(ligne==2) && /<!--/ {getline} /"host"/ {n++;if (n==ligne) print $0} !/"host"/ {gsub("TRUST_VERSION",TRUST_VERSION,$0);print $0}' $xml > $xml.tmp
      #$TRUST_Awk -v ligne=$ligne -v TRUST_VERSION=$VERSION '(ligne==2) && /<!--/ {getline} /"toto"/ {n++;if (n==ligne) print $0} !/"toto"/ {gsub("TRUST_VERSION",TRUST_VERSION,$0);print $0}' $xml > $xml.tmp
      if [ ! -f $TRUST_ROOT/exec/VisIt/current/.visit/hosts/$xml ] || [ "`diff $xml.tmp $TRUST_ROOT/exec/VisIt/current/.visit/hosts/$xml`" != "" ]
      then
         echo "$TRUST_ROOT/exec/VisIt/current/.visit/hosts/$xml updated."
         mv -f $xml.tmp $TRUST_ROOT/exec/VisIt/current/.visit/hosts/$xml
	 if [ $HOST = $TRUST_HOST_ADMIN ] && [ "$3" = -update_for_test ]
         then
	    adr=`awk -F">" '/"host"/ {print $2}' $xml | awk -F"<" '{print $1}' | head -1`
	    tmp=/tmp/remote.xml;$TRUST_Awk -v ligne=2 '(ligne==2) && /<!--/ {getline} /"host"/ {n++;if (n==ligne) print $0} !/"host"/ {print $0}' $xml > $tmp
	    scp $tmp $adr:~/$WORKBASE$machine/TRUST/exec/VisIt/current/.visit/hosts/$xml	 
         fi
      else
         rm -f $xml.tmp
      fi
      #fi
   done
   ###############################################################
   # Debut des corrections de scripts de visit (pour le parallele)
   ###############################################################
   file=$TRUST_ROOT/exec/VisIt/current/bin/internallauncher
   # Par defaut aucune machine ne supporte -l nodes=???:ppn=??? donc on hacke le fichier
   if [ "`grep 'useppn = 0' $file`" = "" ]
   then
      echo $ECHO_OPTS "1,$ s?useppn = 1?useppn = 0?g\nw" | ed $file 1>/dev/null 2>&1
      [ $? != 0 ] && echo "Error when hacking the file $file" && exit -1           
   fi
   # Les 2 modifications sont necessaires (useppn=0 ne suffit pas...)
   if [ "`grep '#parcmd = parcmd + self.SetupPPN' $file`" = "" ]
   then
      echo $ECHO_OPTS "1,$ s? parcmd = parcmd + self.SetupPPN?#parcmd = parcmd + self.SetupPPN?g\nw" | ed $file 1>/dev/null 2>&1
      [ $? != 0 ] && echo "Error when hacking the file $file" && exit -1   
   fi
   # On callisto, --ppn with sbatch/mpirun should also be deactivated cause unknown by mpirun
   if [ "`grep '\-\-ppn' $file`" != "" ]
   then
      echo $ECHO_OPTS "1,$ s?\-\-ppn??g\nw" | ed $file 1>/dev/null 2>&1
      [ $? != 0 ] && echo "Error when hacking the file $file" && exit -1      
   fi
   if [ "`grep 'str(ppn)' $file`" != "" ]
   then
      echo $ECHO_OPTS "1,$ s?str(ppn)?\"\"?g\nw" | ed $file 1>/dev/null 2>&1
      [ $? != 0 ] && echo "Error when hacking the file $file" && exit -1      
   fi
   # On change la date (car pb sur castor/eris): Colon (':') not allowed in objectname.
   if [ "`grep 'root, tuser, string.replace' $file`" = "" ]
   then
      echo $ECHO_OPTS "1,$ s?root, tuser, tdate?root, tuser, string.replace(tdate, \":\", \"-\")?g\nw" | ed $file 1>/dev/null 2>&1
      [ $? != 0 ] && echo "Error when hacking the file $file" && exit -1   
   fi
   ########################################################################
   # Customize customlauncher for several tasks (called by internalauncher)
   ########################################################################
   # eg: Useful to load TRUST environment automatically for client/server mode -> users don't need anymore loading it
   echo $ECHO_OPTS "1,$ s?TRUST_ROOT?$TRUST_ROOT?g\nw customlauncher.tmp" | ed customlauncher 1>/dev/null 2>&1
   echo $ECHO_OPTS "1,$ s?MPI_ROOT?$MPI_ROOT?g\nw" | ed customlauncher.tmp 1>/dev/null 2>&1
   if [ "`diff customlauncher customlauncher.tmp`" != "" ]
   then
      echo "current/bin/customlauncher updated."
      mv -f customlauncher.tmp $TRUST_ROOT/exec/VisIt/current/bin/customlauncher
      chmod +x $TRUST_ROOT/exec/VisIt/current/bin/customlauncher
   else
      rm -f customlauncher.tmp
   fi
   #############
   # Run tests #
   #############
   cd $TRUST_ROOT/Outils/VisIt/test
   ./test_visit
   if [ $? != 0 ]
   then
      # GF si erreur test avec build VisIt on arrete et on propose de tester download VisIt (TRUST_DOWNLOAD_VISIT=1) manuellement et non automatiquement
      echo "======================================================="
      echo "VisIt does NOT work so you try to download a version..."
      echo "======================================================="
      echo "Error with build VisIt of $TRUST_ROOT/Outils/VisIt/test/test_visit"
      echo "You can test with download VisIt:"
      echo "cd $TRUST_ROOT/Outils/VisIt"
      echo "make clean"
      echo "export TRUST_DOWNLOAD_VISIT=1"
      echo "make"
      echo "==========================================================================="
      exit -1
#      if [ "`ls $TRUST_ROOT/exec/VisIt/current/*/bin/engine_par 2>/dev/null`" != "" ]
#      then
#	 echo "==============================================================="
#	 echo "Parallel VisIt does NOT work so we try to download a version..."
#	 echo "==============================================================="
#	 cd $TRUST_ROOT/Outils/VisIt
#	 make clean
#	 export TRUST_DOWNLOAD_VISIT=1
#	 make
#	 exit $?
#      fi      
   else
      ###########################################
      # Build of VisIt is deleted if test is OK #
      ###########################################
#      if [ "`ls $TRUST_ROOT/exec/VisIt/current/*/bin/engine_par 2>/dev/null`" != "" ]
#      then
	 rm -rf $TRUST_TMP/build/visit # install is done in TRUST_TMP on CCRT, shoud clean this folder
	 cd $TRUST_ROOT/Outils/VisIt/src 
	 ./$build clean
#      fi      
   fi
else
   echo "$what unknown."
   export PATH=$OLDPATH_
   exit -1
fi
export PATH=$OLDPATH_
exit 0
