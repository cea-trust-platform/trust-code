/*****************************************************************************
*
* Copyright (c) 2000 - 2010, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avttriofieldFileFormat.C                           //
// ************************************************************************* //

#include <avttriofieldFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <vtkCellType.h>
#include <fstream>

using     std::string;


// ****************************************************************************
//  Method: avttriofieldFileFormat constructor
//
//  Programmer: fauchet -- generated by xml2avt
//  Creation:   Tue Jun 28 17:16:19 PST 2011
//
// ****************************************************************************

avttriofieldFileFormat::~avttriofieldFileFormat() 
{
  
}
avttriofieldFileFormat::avttriofieldFileFormat(const char *filename)
    : avtSTMDFileFormat(&filename, 1)
{
    // INITIALIZE DATA MEMBERS
 
  
  nproc_=1;
  int test_format_maitre=0;
  {
    ifstream file(filename);
    std::string mot;
    file >> mot;
    if (mot=="nb_proc")
      {
	test_format_maitre=1;
	file >> nproc_ ;
      }
  }
  ifstream fichiermaitre;
  if (test_format_maitre)
    {
      fichiermaitre.open(filename);
      std::string mot;
      int n;
      fichiermaitre>>mot;
      fichiermaitre>>n;
    }
  fields_.resize(nproc_);
  string currentfile=filename;
  for (int i=0;i<nproc_;i++)
    {
      ICoCo::TrioField& field_ =fields_[i];
      if (test_format_maitre==1)
	{
	  fichiermaitre >>currentfile;
	}
      ifstream file(currentfile.c_str());
      if (!file.good())
	{
	  cerr<<"file not found: "<<currentfile<<endl;
	  cerr<<"masterfile "<<filename <<endl;
	  throw 0;
	}
      else
	field_.restore(file);  
      
      
      name_="test";// filename
      
    }
}

// ****************************************************************************
//  Method: avttriofieldFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: fauchet -- generated by xml2avt
//  Creation:   Tue Jun 28 17:16:19 PST 2011
//
// ****************************************************************************

void
avttriofieldFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avttriofieldFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: fauchet -- generated by xml2avt
//  Creation:   Tue Jun 28 17:16:19 PST 2011
//
// ****************************************************************************

void
avttriofieldFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{

  avtMeshType mt = AVT_UNSTRUCTURED_MESH;
  
  /*
  switch(data.element_type_) {
    case Domain::point:     topo_dim = 0; mt = AVT_POINT_MESH; break;
    case Domain::line:      topo_dim = 1; break;
    case Domain::triangle:
    case Domain::quadri:    topo_dim = 2; break;
    case Domain::tetra:
    case Domain::prism6:
    case Domain::polyedre:
    case Domain::hexa:      topo_dim = 3; break;
    default:
      cerr << "avtlataFileFormat::PopulateDatabaseMetaData error: unknown element type" << endl;
      exit(-1);
    } 
  */
  
    //
    // CODE TO ADD A MESH
    //
    // string meshname = ...
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_RECTILINEAR_MESH;
    //
  int nblocks = nproc_;  //<-- this must be 1 for STSD
  int block_origin = 0;
  
  ICoCo::TrioField& field_=fields_[0];
  int spatial_dimension = field_._space_dim;
  int topological_dimension = field_._mesh_dim;
  double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
 
  AddMeshToMetaData(md, name_, mt, extents, nblocks, block_origin,
                       spatial_dimension, topological_dimension);
    //
 
    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
  
    if (field_._field)
      {
	avtCentering cent = AVT_ZONECENT;
	if (field_._type==1) 
	  cent=AVT_NODECENT;

	if (field_._nb_field_components==1)
	  {
	    AddScalarVarToMetaData(md, "Values", name_, cent);
	  }
	else
	  {
	    AddVectorVarToMetaData(md, "Values", name_, cent,field_._nb_field_components);
	  }
      }
    //
    
    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int vector_dim = 2;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int tensor_dim = 9;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
    //

    //
    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or -- 
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    // 
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    
}


// ****************************************************************************
//  Method: avttriofieldFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: fauchet -- generated by xml2avt
//  Creation:   Tue Jun 28 17:16:19 PST 2011
//
// ****************************************************************************

#define pos(i,j) coords[i*field_._space_dim + j]
#define conn(i,j) connect[i*nverts + j]

vtkDataSet *
avttriofieldFileFormat::GetMesh(int domain, const char *meshname)
{
  
  //YOU MUST IMPLEMENT THIS
  //  abort();
  vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
  vtkPoints *points = vtkPoints::New();
  ICoCo::TrioField& field_=fields_[domain];
  const double*  coords = field_._coords;
  const int nnodes = field_._nbnodes;
  const int dim3 =field_._space_dim == 3;
  points->SetNumberOfPoints(nnodes);
  float* pts = (float *) points->GetVoidPointer(0);
  int jl=0;
  int i;
  for (i = 0; i < nnodes; i++) {
    pts[jl]   = pos(i,0);
    pts[jl+1] = pos(i,1);
    pts[jl+2] = dim3 ? pos(i,2) : 0.;
    jl+=3;
  }
  ugrid->SetPoints(points);
  points->Delete();
    
  const  int* connect = field_._connectivity;
  const int ncells = field_._nb_elems;
  int nverts = field_._nodes_per_elem;
  
  int type_cell=VTK_QUAD;
  
  switch (nverts) {
  case 1:
    type_cell=VTK_VERTEX; 
    break;
  case 2:
    type_cell=VTK_LINE;
    break;
  case 3:
    type_cell=VTK_TRIANGLE;
    break;
  case 4:
    if (field_._mesh_dim==2)
      type_cell=VTK_QUAD;
    else
      type_cell=VTK_TETRA;
    break;
  case 6:
    type_cell=VTK_WEDGE;
    break;
  case 8:
    type_cell=VTK_HEXAHEDRON;
    break;
  case 0:
    cerr<<"sous domaine "<<domain<<" vide ?"<<endl;
    break;
  default:
    type_cell=-1;
    cerr<<"avtlataFileFormat::GetMesh unknown elt type nverts "<<nverts<<endl;
    exit(-1);
    break;
  }
  

  vtkIdType *verts = new vtkIdType[nverts];
  /*
  if (type_cell == VTK_VERTEX && ncells == 0) {
    // Cells are implicit. Create them:
    ugrid->Allocate(nnodes);
      for (i = 0; i < nnodes; i++) {
	verts[0] = i;
	ugrid->InsertNextCell(type_cell, nverts, verts);
      }
    } else {
  */

      ugrid->Allocate(ncells);
      for (i = 0; i < ncells; i++) {
	/*
	if (type_cell==VTK_QUAD) {
	  // Nodes order is different in visit than in trio_u
	  verts[0]=conn(i,0);
	  verts[1]=conn(i,1);
	  verts[2]=conn(i,3);
	  verts[3]=conn(i,2);
	} else if (type_cell==VTK_HEXAHEDRON) {
	  // Nodes order is different in visit than in trio_u
	  verts[0]=conn(i,0);
	  verts[1]=conn(i,1);
	  verts[2]=conn(i,3);
	  verts[3]=conn(i,2);
	  verts[4]=conn(i,4);
	  verts[5]=conn(i,5);
	  verts[6]=conn(i,7);
	  verts[7]=conn(i,6);
	} else if (type_cell==VTK_CONVEX_POINT_SET) {
	  int nverts_loc=nverts;
	  for (int j = 0; j < nverts; j++) 
	    {
	      verts[j] = conn(i,j);
	     
	      if (verts[j]==-1)
		{  
		  nverts_loc=j; 
		  break;
		}    
	    }
	  int  nb_som_max_to_regularize=0;
	  if (filter_.get_options().regularize_polyedre!=0)
	    {
	      nb_som_max_to_regularize=8;
	      if (filter_.get_options().regularize_polyedre==-1)
		  nb_som_max_to_regularize=32000;
	    }
	  if ((nb_som_max_to_regularize>=6) && (nverts_loc==6))
	    ugrid->InsertNextCell(VTK_WEDGE, nverts_loc, verts);
	  else if ((nb_som_max_to_regularize>=12)&&(nverts_loc==12))
	    ugrid->InsertNextCell(VTK_HEXAGONAL_PRISM, nverts_loc, verts);
	  else if ((nb_som_max_to_regularize>=8)&&(nverts_loc==8))
	    {
	      	  // Nodes order is different in visit than in trio_u
	      verts[0]=conn(i,0);
	      verts[1]=conn(i,1);
	      verts[2]=conn(i,3);
	      verts[3]=conn(i,2);
	      verts[4]=conn(i,4);
	      verts[5]=conn(i,5);
	      verts[6]=conn(i,7);
	      verts[7]=conn(i,6);
	      ugrid->InsertNextCell(VTK_HEXAHEDRON, nverts_loc, verts);
	       
	    }
	  else
	    ugrid->InsertNextCell(type_cell, nverts_loc, verts);
	}
	*/
	 {
	  
	  for (int j = 0; j < nverts; j++) 
	    verts[j] = conn(i,j);
	}    
	 //	if (type_cell!=VTK_CONVEX_POINT_SET)	  
	 
	  ugrid->InsertNextCell(type_cell, nverts, verts);
      }

  
  delete [] verts;
  verts = 0;
  return  ugrid;
    
} 


// ****************************************************************************
//  Method: avttriofieldFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: fauchet -- generated by xml2avt
//  Creation:   Tue Jun 28 17:16:19 PST 2011
//
// ****************************************************************************
#define values(i,j) val[i*field_._nb_field_components+j]
vtkDataArray *
avttriofieldFileFormat::GetVar(int domain, const char *varname)
{
  vtkFloatArray *rv = vtkFloatArray::New();
  ICoCo::TrioField& field_=fields_[domain];
  const double* val = field_._field;
  int ntuples = field_.nb_values();
  rv->SetNumberOfTuples(ntuples);
  float * data = rv->GetPointer(0);
  for (int i = 0; i < ntuples; i++) 
    data[i] = values(i, 0);
  return  rv;
  abort();
  //    YOU MUST IMPLEMENT THIS

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    //
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // rv->SetNumberOfTuples(ntuples);
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
    // }
    //
    // return rv;
    //
}


// ****************************************************************************
//  Method: avttriofieldFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: fauchet -- generated by xml2avt
//  Creation:   Tue Jun 28 17:16:19 PST 2011
//
// ****************************************************************************

     double    avttriofieldFileFormat::GetTime(void)
{
	return fields_[0]._time1;
}
vtkDataArray *
avttriofieldFileFormat::GetVectorVar(int domain, const char *varname)
{
  vtkFloatArray *rv = vtkFloatArray::New();
  ICoCo::TrioField& field_=fields_[domain];
  const double* val = field_._field;
  int ntuples = field_.nb_values();
  rv->SetNumberOfTuples(ntuples);
  int dim = field_._nb_field_components;
  rv->SetNumberOfComponents(3);
  float * data = rv->WritePointer(0,3*ntuples);
  
  for (int i = 0; i < ntuples; i++) 
      for (int j = 0; j < 3; j++)
	data[i*3+j] = (j<dim) ? values(i, j) : 0;
  return rv;
  
  //   YOU MUST IMPLEMENT THISrt

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}
