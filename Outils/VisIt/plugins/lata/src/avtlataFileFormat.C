/*****************************************************************************
 *
 * Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
 * Produced at the Lawrence Livermore National Laboratory
 * All rights reserved.
 *
 * This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
 * full copyright notice is contained in the file COPYRIGHT located at the root
 * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
 *
 * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of  source code must  retain the above  copyright notice,
 *    this list of conditions and the disclaimer below.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
 *    documentation and/or materials provided with the distribution.
 *  - Neither the name of the UC/LLNL nor  the names of its contributors may be
 *    used to  endorse or  promote products derived from  this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
 * ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
 * CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
 * ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
 * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
 * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
 * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 *****************************************************************************/

// ************************************************************************* //
//                            avtlataFileFormat.C                           //
// ************************************************************************* //

#include <avtlataFileFormat.h>

#include <LmlReader.h>
#include <LataJournal.h>

#include <avtDatabaseMetaData.h>
#include <avtGhostData.h>

#include <DebugStream.h>
#include <Expression.h>
#include <InvalidVariableException.h>

#include <vtkCellData.h>
#include <vtkCellType.h>
#include <vtkFloatArray.h>
#include <vtkInformation.h>
#include <vtkIntArray.h>
#include <vtkLongArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStreamingDemandDrivenPipeline.h>
#include <vtkStructuredGrid.h>
#include <vtkUnsignedCharArray.h>
#include <vtkUnstructuredGrid.h>

#include <string>
#include <fstream>
#include <iostream>
#include <visitstream.h>
#include <vector>

// ****************************************************************************
//  Method: avtlata constructor
//
//  Programmer: fauchet -- generated by xml2avt
//
// ****************************************************************************

avtlataFileFormat::avtlataFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
    debug1 << "avtlataFileFormat constructor " << filename << endl;
    try {
        set_Journal_level(0);

        LataOptions opt;
        LataOptions::extract_path_basename(filename, opt.path_prefix, opt.basename);
        opt.dual_mesh = true;
        opt.faces_mesh = true;
        opt.regularize = 2;
        opt.regularize_tolerance = 1e-7f;
        opt.user_fields_=true;
        read_any_format_options(filename, opt);
        debug1 << "avtlataFileFormat: initializing filter" << endl;
        // Read the source file to the lata database
        read_any_format(filename, opt.path_prefix, lata_db_);
        filter_.initialize(opt, lata_db_);
    }
    catch (LataDBError& err) {
        cerr << "Error in LataFilter::initialize " << filename << " " << err.describe() << endl;
        throw;
    }
}

avtlataFileFormat::~avtlataFileFormat()
{
}

// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: fauchet -- generated by xml2avt
//
// ****************************************************************************

int
avtlataFileFormat::GetNTimesteps(void)
{
    int n;
    try {
        n = filter_.get_nb_timesteps();
        // Timestep 0 contains global definitions.
        // If we have "real" timesteps, do not show timestep 0
        if (n > 1)
            n--;
    }
    catch (LataDBError& err) {
        cerr << "Error in getntimesteps " << filename << " " << err.describe() << endl;
        throw;
    }
    return n;
}

void avtlataFileFormat::GetTimes(std::vector<double>& times)
{
    int n;
    try {
        n = filter_.get_nb_timesteps();
        if (n == 1)
            times.push_back(0.);
        else
            for (int i = 1; i < n; i++)
                times.push_back(filter_.get_timestep(i));
    }
    catch (LataDBError& err) {
        cerr << "Error in gettimes " << filename << " " << err.describe() << endl;
        throw;
    }
    return;
}

// ****************************************************************************
//  Method: avtlataFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: fauchet -- generated by xml2avt
//
// ****************************************************************************

void
avtlataFileFormat::FreeUpResources(void)
{
}

int is_fort21(const char* filename);

// ****************************************************************************
//  Method: avtlataFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: fauchet -- generated by xml2avt
//
// ****************************************************************************
void
avtlataFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    try {
        debug1 << "avtlataFileFormat::PopulateDatabaseMetaData : "
               << filename << " " << timeState << endl;

        const char *suffix_vector_names[] = { "_X", "_Y", "_Z" };
        const char *suffix_vector_expr[] = { "[0]", "[1]", "[2]" };

        const Noms geoms = filter_.get_exportable_geometry_names();

        for (int i_geom = 0; i_geom < geoms.size(); i_geom++) {
            debug1 << " Domain : " << geoms[i_geom] << endl;
            const LataGeometryMetaData data = filter_.get_geometry_metadata(geoms[i_geom]);

            avtMeshType mt = AVT_UNSTRUCTURED_MESH;

            if (data.is_ijk_==1)
            {
                mt = AVT_RECTILINEAR_MESH;
            }
            int block_origin = 0;
            int topo_dim;
            switch(data.element_type_) {
            case Domain::point:
                topo_dim = 0;
                mt = AVT_POINT_MESH;
                break;
            case Domain::line:
                topo_dim = 1;
                break;
            case Domain::triangle:
            case Domain::polygone:
            case Domain::quadri:
                topo_dim = 2;
                break;
            case Domain::tetra:
            case Domain::prism6:
            case Domain::polyedre:
            case Domain::hexa:
                topo_dim = 3;
                break;
            default:
                cerr << "avtlataFileFormat::PopulateDatabaseMetaData error: unknown element type" << endl;
                topo_dim = 3; ///TODO: this should be an error in default case!
                EXCEPTION1(InvalidVariableException,
                           "avtlataFileFormat::PopulateDatabaseMetaData error: unknown element type");
                throw;
            }

            bool mesh_faces=false;
            if  (data.internal_name_.finit_par("_centerfaces"))
            {
                //cerr<<"la "<<data.internal_name_<<endl;
                mesh_faces=true;
            }
            double *extents = NULL;
            const std::string geom_name(data.displayed_name_);
            AddMeshToMetaData(md, geom_name, mt, extents, data.nblocks_, block_origin,
                              data.dimension_, topo_dim);
            mesh_username_.add(data.displayed_name_);
            mesh_latafilter_name_.add(data.internal_name_);

            Field_UNames fields = filter_.get_exportable_field_unames(geoms[i_geom]);

            bool c3 = (is_fort21(filename)==1);
            for (int i_field = 0; i_field < fields.size(); i_field++) {
                const LataFieldMetaData data2 = filter_.get_field_metadata(fields[i_field]);
                avtCentering cent;
                switch (data2.localisation_) {
                case LataField_base::ELEM:
                    cent = AVT_ZONECENT;
                    break;
                case LataField_base::SOM:
                    cent = AVT_NODECENT;
                    break;
                default:
                    // Do not export fields that cannot be shown
                    continue;
                }

                // Take localisation of source field
                Nom loc = data2.source_localisation_;
                std::string varname(data2.name_);
                if (!c3)
                  {
                    varname += "_";
                    varname += loc;
                    varname += "_";
                    varname += geom_name;
                  }
                else
                  {
                    varname = geom_name;
                    varname += "/";
                    varname+=data2.name_;
                  }
                if (data2.nb_components_ == 1) {
                    // Scalar field
                    // We append the geometry name to the component name:
                    register_fieldname(varname.c_str(), fields[i_field], 0);
                    if (!mesh_faces)
                        AddScalarVarToMetaData(md, varname, geom_name, cent);
                } else if (data2.is_vector_ && data2.nb_components_ == data.dimension_) {
                    // Vector field
                    register_fieldname(varname.c_str(), fields[i_field], -1);
                    AddVectorVarToMetaData(md, varname, geom_name, cent, data2.nb_components_);
                    if (!mesh_faces)
                    {
                        std::string n;
                        for (int i = 0; i < data2.nb_components_; i++) {
                            Expression v;
                            n = data2.name_;
                            n += suffix_vector_names[i];
                            n += "_";
                            n += loc;
                            n += "_";
                            n += geom_name;
                            v.SetName(n);
                            n = varname;
                            n += suffix_vector_expr[i];
                            v.SetDefinition(n);
                            v.SetType(Expression::ScalarMeshVar);
                            md->AddExpression(&v);
                        }
                        if (varname.find_first_of("/",0)==std::string::npos)
                        {
                            // On calcule la norme des vecteurs de premier niveau (pas de / dans le chemin)
                            Expression norme_v;
                            n = "norme_";
                            n += varname;
                            norme_v.SetName(n);
                            n = "magnitude(";
                            n += varname;
                            n += ")";
                            norme_v.SetDefinition(n);
                            norme_v.SetType(Expression::ScalarMeshVar);
                            md->AddExpression(&norme_v);
                        }
                    }
                } else {
                    // Multiscalar field
                    // I chose to postfix the varname with the component name, perhaps not the best choice.
                    if (!mesh_faces)
                    {
                        for (int i_compo = 0; i_compo < data2.nb_components_; i_compo++) {
                            std::string varname2(data2.name_);
                            varname2 += "_";
                            if (data2.component_names_.size() == data2.nb_components_) {
                                varname2 += data2.component_names_[i_compo];
                            } else {
                                Nom n(i_compo);
                                varname2 += n;
                            }
                            varname2 += "_";
                            varname2 += loc;
                            varname2 += "_";
                            varname2 += geom_name;
                            register_fieldname(varname2.c_str(), fields[i_field], i_compo);
                            AddScalarVarToMetaData(md, varname2, geom_name, cent);
                        }
                    }
                }
            }
        }
        debug1 << "End avtlataFileFormat::PopulateDatabaseMetaData" << endl;
    }
    catch (LataDBError& err) {
        cerr << "Error in PopulateDatabaseMetaData " << err.describe() << endl;
        throw;
    }
}

void
avtlataFileFormat::register_fieldname(const char *visit_name, const Field_UName & uname, int component)
{
    if (field_username_.rang(visit_name) >= 0) {
        cerr << "Error in avtlataFileFormat::register_fieldname: duplicate field name " << visit_name << endl;
        cerr << "Ignoring field" << endl;
        return;
    }
    field_username_.add(visit_name);
    field_uname_.add(uname);
    field_component_.add(component);
}

void
avtlataFileFormat::register_meshname(const char *visit_name, const char *latafilter_name)
{
    if (mesh_username_.rang(visit_name) >= 0) {
        cerr << "Error in avtlataFileFormat::register_meshname: duplicate name " << visit_name << endl;
        cerr << "Ignoring mesh" << endl;
        return;
    }
    mesh_username_.add(visit_name);
    mesh_latafilter_name_.add(latafilter_name);
}

// ****************************************************************************
//  Method: avtlataFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: fauchet -- generated by xml2avt
//
// ****************************************************************************

vtkDataSet *
avtlataFileFormat::GetMesh(int timestate, int block, const char *meshname)
{
    vtkDataSet *return_value = 0;
    try {
        debug1 << " avtlataFileFormat::GetMesh ts=" << timestate
               << " block=" << block
               << " meshname=" << meshname << endl;

        // We have real timesteps in the database, add one to timestep index:
        if (filter_.get_nb_timesteps() > 1)
            timestate++;

        const int index = mesh_username_.rang(meshname);
        if (index < 0) {
            cerr << "internal error in avtlataFileFormat::GetMesh: name " << meshname << " not found" << endl;
            throw;
        }
        Domain_Id id(mesh_latafilter_name_[index], timestate, block);
        const Domain & geometry = filter_.get_geometry(id);

        const DomainUnstructured * geom_ptr = dynamic_cast<const DomainUnstructured*>(&geometry);
        const DomainIJK          * ijk_ptr = dynamic_cast<const DomainIJK*>(&geometry);

        if (geom_ptr) {
            const DomainUnstructured & geom = *geom_ptr;

            vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
            vtkPoints *points = vtkPoints::New();
            const BigFloatTab & pos = geom.nodes_;
            const trustIdType nnodes = pos.dimension(0);
            const bool dim3 = (int)pos.dimension(1) == 3;
            points->SetNumberOfPoints(nnodes);
            float* pts = (float *) points->GetVoidPointer(0);
            trustIdType i, jl=0;
            for (i = 0; i < nnodes; i++) {
                pts[jl]   = pos(i,0);
                pts[jl+1] = pos(i,1);
                pts[jl+2] = dim3 ? pos(i,2) : 0.f;
                jl+=3;
            }
            ugrid->SetPoints(points);
            points->Delete();

            const BigTIDTab & conn = geom.elements_;
            const BigTIDTab & elem_faces = geom.elem_faces_;
            const BigTIDTab & faces = geom.faces_;
            const trustIdType ncells = conn.dimension(0);
            int nverts = (int)conn.dimension(1);

            int type_cell;
            switch (geom.elt_type_) {
            case Domain::point:
                type_cell=VTK_VERTEX;
                if (ncells == 0)
                    nverts = 1;
                break;
            case Domain::line:
                type_cell=VTK_LINE;
                break;
            case Domain::triangle:
                type_cell=VTK_TRIANGLE;
                break;
            case Domain::quadri:
                type_cell=VTK_QUAD;
                break;
            case Domain::tetra:
                type_cell=VTK_TETRA;
                break;
            case Domain::prism6:
                type_cell=VTK_WEDGE;
                break;
            case Domain::hexa:
                type_cell=VTK_HEXAHEDRON;
                break;
            case Domain::polygone:
                type_cell=VTK_POLYGON;
                break;
            case Domain::polyedre:
                type_cell= elem_faces.dimension(0) > 0 ? VTK_POLYHEDRON : VTK_CONVEX_POINT_SET;
                break;
            default:
                type_cell=-1;
                cerr<<"avtlataFileFormat::GetMesh unknown elt type "<<endl;
                throw;
                break;
            }
            vtkIdType *verts = new vtkIdType[nverts];
            std::vector<vtkIdType> poly_p, poly_f;
            if (type_cell == VTK_VERTEX && ncells == 0) {
                // Cells are implicit. Create them:
                ugrid->Allocate(nnodes);
                for (i = 0; i < nnodes; i++) {
                    verts[0] = i;
                    ugrid->InsertNextCell(type_cell, nverts, verts);
                }
            } else {
                ugrid->Allocate(ncells);
                for (i = 0; i < ncells; i++) {
                    if (type_cell==VTK_QUAD) {
                        // Nodes order is different in visit than in trio_u
                        verts[0]=conn(i,0);
                        verts[1]=conn(i,1);
                        verts[2]=conn(i,3);
                        verts[3]=conn(i,2);
                    } else if (type_cell==VTK_HEXAHEDRON) {
                        // Nodes order is different in visit than in trio_u
                        verts[0]=conn(i,0);
                        verts[1]=conn(i,1);
                        verts[2]=conn(i,3);
                        verts[3]=conn(i,2);
                        verts[4]=conn(i,4);
                        verts[5]=conn(i,5);
                        verts[6]=conn(i,7);
                        verts[7]=conn(i,6);
                    } else if (type_cell==VTK_POLYHEDRON) {
                        //polyhedra, face by face
                        int k;
                        trustIdType nfaces = 0, npts = 0, i_f, s, f;
                        poly_p.resize(0), poly_f.resize(0);
                        for (int j = 0; j < (int)conn.dimension(1); j++)
                          if ((s = conn(i, j)) >= 0)
                            {
                              poly_p.push_back(s);
                              npts++;
                            }
                        for (int j = 0; j < (int)elem_faces.dimension(1); j++)
                          if ((f = elem_faces(i, j)) >= 0)
                            for (k = 0, nfaces++, i_f = poly_f.size(), poly_f.push_back(0); k < (int)faces.dimension(1) ; k++)
                              if ((s = faces(f, k)) >= 0)
                                {
                                  poly_f.push_back(s);
                                  poly_f[i_f]++;
                                }
                        ugrid->InsertNextCell(type_cell, npts, &poly_p[0], nfaces, &poly_f[0]);
                    } else if ((type_cell==VTK_CONVEX_POINT_SET)||(type_cell==VTK_POLYGON)) {
                        int nverts_loc=nverts;
                        for (int j = 0; j < nverts; j++)
                        {
                            verts[j] = conn(i,j);

                            if (verts[j]<=-1)
                            {
                                nverts_loc=j;
                                break;
                            }
                            /*            else
                            	{
                            	if (verts[j]<-1)
                            	{
                            	std::cerr<<i<<" iiiii "<< j<<" "<<verts[j]<<finl;
                            }

                            }	*/
                        }
                        int  nb_som_max_to_regularize=0;
                        if (filter_.get_options().regularize_polyedre!=0)
                        {
                            nb_som_max_to_regularize=8;
                            if (filter_.get_options().regularize_polyedre==-1)
                                nb_som_max_to_regularize=32000;
                        }
                        if ( geom.elt_type_==Domain::polygone)
                            nb_som_max_to_regularize=-1;
                        if ((nb_som_max_to_regularize>=6) && (nverts_loc==6))
                            ugrid->InsertNextCell(VTK_WEDGE, nverts_loc, verts);
                        else if ((nb_som_max_to_regularize>=12)&&(nverts_loc==12))
                            ugrid->InsertNextCell(VTK_HEXAGONAL_PRISM, nverts_loc, verts);
                        else if ((nb_som_max_to_regularize>=8)&&(nverts_loc==8))
                        {
                            // Nodes order is different in visit than in trio_u
                            verts[0]=conn(i,0);
                            verts[1]=conn(i,1);
                            verts[2]=conn(i,3);
                            verts[3]=conn(i,2);
                            verts[4]=conn(i,4);
                            verts[5]=conn(i,5);
                            verts[6]=conn(i,7);
                            verts[7]=conn(i,6);
                            ugrid->InsertNextCell(VTK_HEXAHEDRON, nverts_loc, verts);

                        }
                        else
                            ugrid->InsertNextCell(type_cell, nverts_loc, verts);
                    }
                    else {
                        for (int j = 0; j < nverts; j++)
                            verts[j] = conn(i,j);
                    }
                    if ((type_cell!=VTK_POLYHEDRON) &&(type_cell!=VTK_CONVEX_POINT_SET) && (type_cell!=VTK_POLYGON))

                        ugrid->InsertNextCell(type_cell, nverts, verts);
                }
            }
            delete [] verts;
            verts = nullptr;
            // Declare ghost elements:
            const trustIdType n = geom.nb_virt_items(LataField_base::ELEM);
            if (n > 0) {
                unsigned char realVal = 0;
                unsigned char ghost   = 0; // Sera modifie par AddGhostZoneType
                avtGhostData::AddGhostZoneType(ghost, DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);
                vtkUnsignedCharArray *ghostcells = vtkUnsignedCharArray::New();
                ghostcells->SetName("avtGhostZones");
                ghostcells->SetNumberOfTuples(ncells);
                unsigned char *dat = (unsigned char *) ghostcells->GetVoidPointer(0);
                for (i = 0; i < ncells - n; i++)
                    dat[i] = realVal;
                for (i = ncells - n; i < ncells; i++)
                    dat[i] = ghost;
                ugrid->GetCellData()->AddArray(ghostcells);
                ugrid->GetInformation()->Set(
                    vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_GHOST_LEVELS(), 0);
                ghostcells->Delete();
            }
            return_value = ugrid;

        } else if (ijk_ptr) {
            const DomainIJK & geom = *ijk_ptr;

            // Maillage regulier : on transmet la grille ijk
            vtkRectilinearGrid *sgrid = vtkRectilinearGrid::New();

            const int dim = geom.coord_.size();
            ArrOfInt ncoord(3);
            ncoord = 1;
            for (int i = 0; i < dim; i++)
                ncoord[i] = geom.coord_[i].size_array();
            sgrid->SetDimensions(ncoord[0], ncoord[1], ncoord[2]);

            for (int i = 0; i < 3; i++) {
                float *data;
                vtkFloatArray *c;
                c = vtkFloatArray::New();
                const int n = ncoord[i];
                c->SetNumberOfTuples(n);
                data = (float *) c->GetVoidPointer(0);
                if (i < dim) {
                    const ArrOfFloat & coord = geom.coord_[i];
                    for (int j = 0; j < n; j++)
                        data[j] = coord[j];
                } else {
                    data[0] = 0.;
                }
                switch(i) {
                case 0:
                    sgrid->SetXCoordinates(c);
                    break;
                case 1:
                    sgrid->SetYCoordinates(c);
                    break;
                case 2:
                    sgrid->SetZCoordinates(c);
                    break;
                default:
                    ;
                }
                c->Delete();
            }
            // Create "invalid cells" data (GettingDataIntoVisit.pdf, page 136)
            // and "ghost cells"
            const trustIdType n = geom.invalid_connections_.size_array();
            if (n > 0 || geom.virtual_layer_begin_ || geom.virtual_layer_end_) {
                const trustIdType ncells = geom.nb_elements();
                unsigned char realVal = 0;
                unsigned char invalid = 0; // Sera modifie par AddGhostZoneType
                unsigned char ghost   = 0;
                avtGhostData::AddGhostZoneType(invalid, ZONE_NOT_APPLICABLE_TO_PROBLEM);
                avtGhostData::AddGhostZoneType(ghost, DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);
                vtkUnsignedCharArray *ghostcells = vtkUnsignedCharArray::New();
                ghostcells->SetName("avtGhostZones");
                ghostcells->SetNumberOfTuples(ncells);
                unsigned char *dat = (unsigned char *) ghostcells->GetVoidPointer(0);

                for (trustIdType ii = 0; ii < ncells; ii++)
                    dat[ii] = realVal;

                if (n > 0) {
                    // invalid cells
                    for (trustIdType ii = 0; ii < ncells; ii++) {
                        if (geom.invalid_connections_[ii])
                            dat[ii] = invalid;
                    }
                }

                // ghost cells
                trustIdType ij = 1;
                for (int i = 0; i < dim-1; i++)
                    ij *= ncoord[i]-1;
                if (geom.virtual_layer_begin_) {
                    // first layer of cells is ghost
                    for (int i = 0; i < ij * geom.virtual_layer_begin_; i++)
                        dat[i] += ghost;
                }
                if (geom.virtual_layer_end_) {
                    // last layer of cells is ghost
                    for (trustIdType ii = ncells - ij * (trustIdType)geom.virtual_layer_end_; ii < ncells; ii++)
                        dat[ii] += ghost;
                }

                sgrid->GetCellData()->AddArray(ghostcells);
                sgrid->GetInformation()->Set(
                    vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_GHOST_LEVELS(), 0);
                ghostcells->Delete();
            }

            return_value = sgrid;
        } else {
            cerr << "Error in avtlataFileFormat::GetMesh: unknown geometry type" << endl;
            throw;
        }

        filter_.release_geometry(geometry);
    }
    catch (LataDBError& err) {
        cerr << "Error in getmesh " << timestate << " " << block << " " << meshname << " " << err.describe() << endl;
        throw;
    }

    return return_value;
}


// ****************************************************************************
//  Method: avtlataFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: fauchet -- generated by xml2avt
//
// ****************************************************************************

vtkDataArray *
avtlataFileFormat::GetVar(int timestate, int block, const char *varname)
{
    vtkDataArray * return_value = 0;
    try {
        // visit -debug 1 : activate debug1
        debug1 << "Getvar time:" << timestate
               << " block:" << block
               << " varname:" << varname << endl;

        if (filter_.get_nb_timesteps() > 1)
            timestate++;

        Field_UName field_uname;
        int component;
        get_field_info_from_visitname(varname, field_uname, component);

        if (component < 0) {
            cerr << "Error: avtlataFileFormat::GetVar called for vector field" << endl;
            throw;
        }

        Field_Id id(field_uname, timestate, block);

        const LataField_base & field = filter_.get_field(id);

        const Field<BigFloatTab> * float_field_ptr = dynamic_cast<const Field<BigFloatTab>*>(&field);
        const Field<BigIntTab> * int_field_ptr = dynamic_cast<const Field<BigIntTab>*>(&field);
        const Field<BigTIDTab> * tid_field_ptr = dynamic_cast<const Field<BigTIDTab>*>(&field);

        if (float_field_ptr) {
            vtkFloatArray *rv = vtkFloatArray::New();
            const Field<BigFloatTab> & fld = *float_field_ptr;
            const BigFloatTab & values = fld.data_;
            trustIdType ntuples = values.dimension(0);
            rv->SetNumberOfTuples(ntuples);
            float * data = rv->GetPointer(0);
            for (trustIdType i = 0; i < ntuples; i++)
                data[i] = values(i, component);
            return_value = rv;
        } else if (int_field_ptr) {
            vtkIntArray *rv = vtkIntArray::New();
            const Field<BigIntTab> & fld = *int_field_ptr;
            const BigIntTab & values = fld.data_;
            trustIdType ntuples = values.dimension(0);
            rv->SetNumberOfTuples(ntuples);
            int * data = rv->GetPointer(0);
            for (trustIdType i = 0; i < ntuples; i++)
                data[i] = values(i, component);
            return_value = rv;
        } else if (tid_field_ptr) {
            vtkLongArray *rv = vtkLongArray::New();
            const Field<BigTIDTab> & fld = *tid_field_ptr;
            const BigTIDTab & values = fld.data_;
            trustIdType ntuples = values.dimension(0);
            rv->SetNumberOfTuples(ntuples);
            long * data = rv->GetPointer(0);
            for (trustIdType i = 0; i < ntuples; i++)
                data[i] = values(i, component);
            return_value = rv;
        } else {
            cerr << "Error in avtlataFileFormat::GetVar: unknown data type" << endl;
            throw;
        }
        filter_.release_field(field);
    }
    catch (LataDBError& err) {
        cerr << "Error in getvar " << timestate << " " << block << " " << varname << " " << err.describe() << endl;
        throw;
    }
    return return_value;
}


// ****************************************************************************
//  Method: avtlataFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: fauchet -- generated by xml2avt
//
// ****************************************************************************

vtkDataArray *
avtlataFileFormat::GetVectorVar(int timestate, int block, const char *varname)
{
    vtkDataArray * return_value = 0;
    try {
        debug1 << "Getvectorvar time:" << timestate
               << " block:" << block
               << " varname:" << varname << endl;

        if (filter_.get_nb_timesteps() > 1)
            timestate++;

        Field_UName field_uname;
        int component;
        get_field_info_from_visitname(varname, field_uname, component);

        if (component >= 0) {
            cerr << "Error: avtlataFileFormat::GetVectorVar called for scalar field" << endl;
            throw;
        }

        Field_Id id(field_uname, timestate, block);

        const LataField_base & field = filter_.get_field(id);

        const Field<BigFloatTab> * float_field_ptr = dynamic_cast<const Field<BigFloatTab>*>(&field);
        const Field<BigIntTab> * int_field_ptr = dynamic_cast<const Field<BigIntTab>*>(&field);
        const Field<BigTIDTab> * tid_field_ptr = dynamic_cast<const Field<BigTIDTab>*>(&field);

        if (float_field_ptr) {
            vtkFloatArray *rv = vtkFloatArray::New();
            const Field<BigFloatTab> & fld = *float_field_ptr;
            const BigFloatTab & values = fld.data_;
            trustIdType ntuples = values.dimension(0);
            int dim = (int)values.dimension(1);
            rv->SetNumberOfComponents(3);
            rv->SetNumberOfTuples(ntuples);
            float* data= rv->WritePointer(0,3*ntuples);
            for (trustIdType i = 0; i < ntuples; i++)
                for (int j = 0; j < 3; j++)
                    data[i*3+j] = (j<dim) ? values(i, j) : 0.f;
            return_value = rv;
        } else if (int_field_ptr) {
            vtkIntArray *rv = vtkIntArray::New();
            const Field<BigIntTab> & fld = *int_field_ptr;
            const BigIntTab & values = fld.data_;
            trustIdType ntuples = values.dimension(0);
            int dim = (int)values.dimension(1);
            rv->SetNumberOfComponents(3);
            rv->SetNumberOfTuples(ntuples);
            int* data= rv->WritePointer(0,3*ntuples);
            for (trustIdType i = 0; i < ntuples; i++)
                for (int j = 0; j < 3; j++)
                    data[i*3+j] = (j<dim) ? values(i, j) : 0;
            return_value = rv;
        } else if (tid_field_ptr) {
            vtkLongArray *rv = vtkLongArray::New();
            const Field<BigTIDTab> & fld = *tid_field_ptr;
            const BigTIDTab & values = fld.data_;
            trustIdType ntuples = values.dimension(0);
            int dim = (int)values.dimension(1);
            rv->SetNumberOfComponents(3);
            rv->SetNumberOfTuples(ntuples);
            long* data= rv->WritePointer(0,3*ntuples);
            for (trustIdType i = 0; i < ntuples; i++)
                for (int j = 0; j < 3; j++)
                    data[i*3+j] = (j<dim) ? values(i, j) : 0;
            return_value = rv;
        } else {
            cerr << "Error in avtlataFileFormat::GetVectorVar: unknown data type" << endl;
            throw;
        }
        filter_.release_field(field);
    }
    catch (LataDBError& err) {
        cerr << "Error in getvectorvar " << timestate << " " << block << " " << varname << " " << err.describe() << endl;
        throw;
    }
    return return_value;
}

void avtlataFileFormat::get_field_info_from_visitname(const char *varname, Field_UName & uname, int & component) const
{
    const int k = field_username_.rang(varname);
    if (k < 0) {
        cerr << "Error in avtlataFileFormat::get_field_info_from_visitname: field " << varname << " not found" << endl;
        throw  ;
    }
    uname = field_uname_[k];
    component = field_component_[k];
}
