comment objet_u # 0 Comments in a data file.
  attr comm chaine comm 0 Text to be commented.
bloc_comment objet_u /* 0 bloc of Comment in a data file.
  attr comm chaine comm 0 Text to be commented.
interprete objet_u interprete 0 Basic class for interpreting a data file. Interpretors allow some operations to be carried out on objects.
read interprete lire 0 Interpretor to read the a_object objet defined between the braces.
  attr a_object chaine a_object 0 Object to be read.
  attr bloc chaine bloc 0 Definition of the object.
associate interprete associer -1 This interpretor allows one object to be associated with another. The order of the two objects in this instruction is not important. The object objet_2 is associated to objet_1 if this makes sense; if not either objet_1 is associated to objet_2 or the program exits with error because it cannot execute the Associate (Associer) instruction. For example, to calculate water flow in a pipe, a Pb_Hydraulique type object needs to be defined. But also a Domaine type object to represent the pipe, a Scheme_euler_explicit type object for time discretization, a discretization type object (VDF or VEF) and a Fluide_Incompressible type object which will contain the water properties. These objects must then all be associated with the problem.
  attr objet_1 chaine objet_1 0 Objet_1
  attr objet_2 chaine objet_2 0 Objet_2
listobj listobj_impl listobj -1 List of objects.
objet_lecture objet_u objet_lecture -1 Auxiliary class for reading.
bloc_lecture objet_lecture nul 0 to read between two braces
  attr bloc_lecture chaine bloc_lecture 0 not_set
deuxmots objet_lecture nul 0 Two words.
  attr mot_1 chaine mot_1 0 First word.
  attr mot_2 chaine mot_2 0 Second word.
troismots objet_lecture nul 0 Three words.
  attr mot_1 chaine mot_1 0 First word.
  attr mot_2 chaine mot_2 0 Snd word.
  attr mot_3 chaine mot_3 0 Third word.
format_file objet_lecture nul 0 File formatted.
  attr format chaine(into=["binaire","formatte","xyz","single_hdf"]) format 1 Type of file (the file format).
  attr name_file chaine name_file 0 Name of file.
deuxentiers objet_lecture nul 0 Two integers.
  attr int1 entier int1 0 First integer.
  attr int2 entier int2 0 Second integer.
floatfloat objet_lecture nul 0 Two reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
entierfloat objet_lecture nul 0 An integer and a real.
  attr the_int entier the_int 0 Integer.
  attr the_float floattant the_float 0 Real.
champ_a_post objet_lecture nul 0 Field to be post-processed.
  attr champ chaine champ 0 Name of the post-processed field.
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field values: The two available values are elem, som, or faces (LATA format only) used respectively to select field values at mesh centres (CHAMPMAILLE type field in the lml file) or at mesh nodes (CHAMPPOINT type field in the lml file). If no selection is made, localisation is set to som by default.
field_base objet_u champ_base -1 Basic class of fields.
champs_a_post listobj nul -1 champ_a_post 0 Fields to be post-processed.
champs_posts objet_lecture nul 0 Field\'s write mode.
  attr format chaine(into=["binaire","formatte"]) format 1 Type of file.
  attr mot chaine(into=["dt_post","nb_pas_dt_post"]) mot 0 Keyword to set the kind of the field\'s write frequency. Either a time period or a time step period.
  attr period chaine period 0 Value of the period which can be like (2.*t).
  attr champs|fields champs_a_post champs 0 Post-processed fields.
stat_post_deriv objet_lecture stat_post_deriv 0 not_set
stat_post_t_deb stat_post_deriv t_deb 0 not_set
  attr val floattant val 0 not_set
stat_post_t_fin stat_post_deriv t_fin 0 not_set
  attr val floattant val 0 not_set
stat_post_moyenne stat_post_deriv moyenne 0 not_set
  attr field chaine field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
stat_post_ecart_type stat_post_deriv ecart_type 0 not_set
  attr field chaine field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
stat_post_correlation stat_post_deriv correlation 0 not_set
  attr first_field chaine first_field 0 not_set
  attr second_field chaine second_field 0 not_set
  attr localisation chaine(into=["elem","som","faces"]) localisation 1 Localisation of post-processed field value
list_stat_post listobj nul -1 stat_post_deriv 0 Post-processing for statistics
stats_posts objet_lecture nul 0 Field\'s write mode. \input{{statistiques}}
  attr mot chaine(into=["dt_post","nb_pas_dt_post"]) mot 0 Keyword to set the kind of the field\'s write frequency. Either a time period or a time step period.
  attr period chaine period 0 Value of the period which can be like (2.*t).
  attr champs|fields list_stat_post champs 0 Post-processed fields.
stats_serie_posts objet_lecture nul 0 Post-processing for statistics. \input{{statistiquesseries}}
  attr mot chaine(into=["dt_integr"]) mot 0 Keyword is used to set the statistics period of integration and write period.
  attr dt_integr floattant dt_integr 0 Average on dt_integr time interval is post-processed every dt_integr seconds.
  attr stat list_stat_post stat 0 not_set
sonde_base objet_lecture sonde_base 0 Basic probe. Probes refer to sensors that allow a value or several points of the domain to be monitored over time. The probes may be a set of points defined one by one (keyword Points) or a set of points evenly distributed over a straight segment (keyword Segment) or arranged according to a layout (keyword Plan) or according to a parallelepiped (keyword Volume). The fields allow all the values of a physical value on the domain to be known at several moments in time.
un_point objet_lecture nul 0 A point.
  attr pos listf pos 0 Point coordinates.
listpoints listobj nul 0 un_point 0 Points.
points sonde_base points 0 Keyword to define the number of probe points. The file is arranged in columns.
  attr points listpoints points 0 Probe points.
point points point 0 Point as class-daughter of Points.
numero_elem_sur_maitre sonde_base numero_elem_sur_maitre 0 Keyword to define a probe at the special element. Useful for min/max sonde.
  attr numero entier numero 0 element number
segmentpoints points segmentpoints 0 This keyword is used to define a probe segment from specifics points. The nom_champ field is sampled at ns specifics points.
position_like sonde_base position_like 0 Keyword to define a probe at the same position of another probe named autre_sonde.
  attr autre_sonde chaine autre_sonde 0 Name of the other probe.
segment sonde_base segment 0 Keyword to define the number of probe segment points. The file is arranged in columns.
  attr nbr entier nbr 0 Number of probe points of the segment, evenly distributed.
  attr point_deb un_point point_deb 0 First outer probe segment point.
  attr point_fin un_point point_fin 0 Second outer probe segment point.
plan sonde_base plan 0 Keyword to set the number of probe layout points. The file format is type .lml
  attr nbr entier nbr 0 Number of probes in the first direction.
  attr nbr2 entier nbr2 0 Number of probes in the second direction.
  attr point_deb un_point point_deb 0 First point defining the angle. This angle should be positive.
  attr point_fin un_point point_fin 0 Second point defining the angle. This angle should be positive.
  attr point_fin_2 un_point point_fin_2 0 Third point defining the angle. This angle should be positive.
volume sonde_base volume 0 Keyword to define the probe volume in a parallelepiped passing through 4 points and the number of probes in each direction.
  attr nbr entier nbr 0 Number of probes in the first direction.
  attr nbr2 entier nbr2 0 Number of probes in the second direction.
  attr nbr3 entier nbr3 0 Number of probes in the third direction.
  attr point_deb un_point point_deb 0 Point of origin.
  attr point_fin un_point point_fin 0 Point defining the first direction (from point of origin).
  attr point_fin_2 un_point point_fin_2 0 Point defining the second direction (from point of origin).
  attr point_fin_3 un_point point_fin_3 0 Point defining the third direction (from point of origin).
circle sonde_base circle 0 Keyword to define several probes located on a circle.
  attr nbr entier nbr 0 Number of probes between teta1 and teta2 (angles given in degrees).
  attr point_deb un_point point_deb 0 Center of the circle.
  attr direction entier(into=[0,1,2]) direction 1 Axis normal to the circle plane (0:x axis, 1:y axis, 2:z axis).
  attr radius floattant radius 0 Radius of the circle.
  attr theta1 floattant theta1 0 First angle.
  attr theta2 floattant theta2 0 Second angle.
circle_3 sonde_base circle_3 0 Keyword to define several probes located on a circle (in 3-D space).
  attr nbr entier nbr 0 Number of probes between teta1 and teta2 (angles given in degrees).
  attr point_deb un_point point_deb 0 Center of the circle.
  attr direction entier(into=[0,1,2]) direction 0 Axis normal to the circle plane (0:x axis, 1:y axis, 2:z axis).
  attr radius floattant radius 0 Radius of the circle.
  attr theta1 floattant theta1 0 First angle.
  attr theta2 floattant theta2 0 Second angle.
sondes listobj nul 1 sonde 0 List of probes.
champ_generique_base objet_u champ_generique_base 1 not_set
listchamp_generique listobj nul 1 champ_generique_base 1 XXX
champ_post_de_champs_post champ_generique_base champ_post_de_champs_post -1 not_set
  attr source champ_generique_base source 1 the source field.
  attr nom_source chaine nom_source 1 To name a source field with the nom_source keyword
  attr source_reference chaine source_reference 1 not_set
  attr sources_reference list_nom_virgule sources_reference 1 not_set
  attr sources listchamp_generique sources 1 sources { Champ_Post.... { ... } Champ_Post.. { ... }}
champ_post_operateur_eqn champ_post_de_champs_post operateur_eqn 1 not_set
  attr numero_op entier numero_op 1 not_set
  attr numero_source entier numero_source 1 not_set
  attr sans_solveur_masse rien sans_solveur_masse 1 not_set
  attr compo entier compo 1 If you want to post-process only one component of a vector field, you can specify the number of the component after compo keyword. By default, it is set to -1 which means that all the components will be post-processed. This feature is not available in VDF disretization.
transformation champ_post_de_champs_post transformation -1 To create a field with a transformation.
  attr methode chaine(into=["produit_scalaire","norme","vecteur","formule","composante"]) methode 0 methode norme : will calculate the norm of a vector given by a source field NL2 methode produit_scalaire : will calculate the dot product of two vectors given by two sources fields NL2 methode composante numero integer : will create a field by extracting the integer component of a field given by a source field NL2 methode formule expression 1 : will create a scalar field located to elements using expressions with x,y,z,t parameters and field names given by a source field or several sources fields. NL2 methode vecteur expression N f1(x,y,z,t) fN(x,y,z,t) : will create a vector field located to elements by defining its N components with N expressions with x,y,z,t parameters and field names given by a source field or several sources fields.
  attr expression listchaine expression 1 see methodes formule and vecteur
  attr numero entier numero 1 see methode composante
  attr localisation chaine localisation 1 type_loc indicate where is done the interpolation (elem for element or som for node). The optional keyword methode is limited to calculer_champ_post for the moment
refchamp champ_generique_base refchamp -1 Field of prolem
  attr pb_champ deuxmots pb_champ 0 { Pb_champ nom_pb nom_champ } : nom_pb is the problem name and nom_champ is the selected field name.
  attr nom_source chaine nom_source 1 The alias name for the field
champ_post_operateur_base champ_post_de_champs_post champ_post_operateur_base -1 not_set
gradient champ_post_operateur_base gradient -1 To calculate gradient of a given field.
divergence champ_post_operateur_base divergence -1 To calculate divergency of a given field.
champ_post_statistiques_base champ_post_de_champs_post champ_post_statistiques_base -1 not_set
  attr t_deb floattant t_deb 0 Start of integration time
  attr t_fin floattant t_fin 0 End of integration time
correlation champ_post_statistiques_base correlation -1 to calculate the correlation between the two fields.
moyenne champ_post_statistiques_base moyenne -1 to calculate the average of the field over time
  attr moyenne_convergee field_base moyenne_convergee 1 This option allows to read a converged time averaged field in a .xyz file in order to calculate, when resuming the calculation, the statistics fields (rms, correlation) which depend on this average. In that case, the time averaged field is not updated during the resume of calculation. In this case, the time averaged field must be fully converged to avoid errors when calculating high order statistics.
ecart_type champ_post_statistiques_base ecart_type -1 to calculate the standard deviation (statistic rms) of the field nom_champ.
extraction champ_post_de_champs_post extraction -1 To create a surface field (values at the boundary) of a volume field
  attr domaine ref_domaine domaine 0 name of the volume field
  attr nom_frontiere chaine nom_frontiere 0 boundary name where the values of the volume field will be picked
  attr methode chaine(into=["trace","champ_frontiere"]) methode 1 name of the extraction method (trace by_default or champ_frontiere)
morceau_equation champ_post_de_champs_post morceau_equation 1 To calculate a field related to a piece of equation. For the moment, the field which can be calculated is the stability time step of an operator equation. The problem name and the unknown of the equation should be given by Source refChamp { Pb_Champ problem_name unknown_field_of_equation }
  attr type chaine type 0 can only be operateur for equation operators.
  attr numero entier numero 0 numero will be 0 (diffusive operator) or 1 (convective operator).
  attr option chaine(into=["stabilite","flux_bords","flux_surfacique_bords"]) option 0 option is stability for time steps or flux_bords for boundary fluxes or flux_surfacique_bords for boundary surfacic fluxes
  attr compo entier compo 1 compo will specify the number component of the boundary flux (for boundary fluxes, in this case compo permits to specify the number component of the boundary flux choosen).
definition_champ objet_lecture nul 0 Keyword to create new complex field for advanced postprocessing.
  attr name chaine name 0 The name of the new created field.
  attr champ_generique champ_generique_base champ_generique 0 not_set
definition_champs listobj nul 1 definition_champ 0 List of definition champ
postraitement_base objet_lecture postraitement_base -1 not_set
corps_postraitement postraitement nul -1 not_set
un_postraitement objet_lecture nul 0 An object of post-processing (with name).
  attr nom chaine nom 0 Name of the post-processing.
  attr post corps_postraitement post 0 Definition of the post-processing.
postraitements listobj postraitements -1 un_postraitement 0 Keyword to use several results files. List of objects of post-processing (with name).
type_un_post objet_lecture nul 0 not_set
  attr type chaine(into=["postraitement","post_processing"]) type 0 not_set
  attr post un_postraitement post 0 not_set
type_postraitement_ft_lata objet_lecture nul 0 not_set
  attr type chaine(into=["postraitement_ft_lata","postraitement_lata"]) type 0 not_set
  attr nom chaine nom 0 Name of the post-processing.
  attr bloc chaine bloc 0 not_set
un_postraitement_spec objet_lecture nul 0 An object of post-processing (with type +name).
  attr type_un_post type_un_post type_un_post 1 not_set
  attr type_postraitement_ft_lata type_postraitement_ft_lata type_postraitement_ft_lata 1 not_set
liste_post listobj liste_post -1 un_postraitement_spec 0 Keyword to use several results files. List of objects of post-processing (with name)
nom_postraitement objet_lecture nul 0 
  attr nom chaine nom 0 Name of the post-processing.
  attr post postraitement_base post 0 the post
liste_post_ok listobj liste_post_ok -1 nom_postraitement 0 Keyword to use several results files. List of objects of post-processing (with name)
pb_gen_base objet_u pb_gen_base -1 Basic class for problems.
discretize interprete discretiser -1 Keyword to discretise a problem problem_name according to the discretization dis. NL2 IMPORTANT: A number of objects must be already associated (a domain, time scheme, central object) prior to invoking the Discretize (Discretiser) keyword. The physical properties of this central object must also have been read.
  attr problem_name ref_pb_gen_base problem_name 0 Name of problem.
  attr dis ref_discretisation_base dis 0 Name of the discretization object.
condinit objet_lecture nul 0 Initial condition.
  attr nom chaine nom 0 Name of initial condition field.
  attr ch field_base ch 0 Type field and the initial values.
condinits listobj condinits -1 condinit 0 Initial conditions.
condlim_base objet_u condlim_base 0 Basic class of boundary conditions.
condlimlu objet_lecture nul 0 Boundary condition specified.
  attr bord chaine bord 0 Name of the edge where the boundary condition applies.
  attr cl condlim_base cl 0 Boundary condition at the boundary called bord (edge).
condlims listobj condlims -1 condlimlu 0 Boundary conditions.
source_base objet_u source_base -1 Basic class of source terms introduced in the equation.
source_generique source_base source_generique 0 to define a source term depending on some discrete fields of the problem and (or) analytic expression. It is expressed by the way of a generic field usually used for post-processing.
  attr champ champ_generique_base champ 0 the source field
sources listobj sources -1 source_base -1 The sources.
nom objet_u nom 0 Class to name the TRUST objects.
  attr mot chaine mot 1 Chain of characters.
nom_anonyme nom nul -1 not_set
vect_nom listobj vect_nom 0 nom_anonyme 0 Vect of name.
list_nom listobj list_nom 1 nom_anonyme 0 List of name.
list_nom_virgule listobj list_nom_virgule 1 nom_anonyme 1 List of name.
mailler_base objet_lecture mailler_base -1 Basic class to mesh.
defbord objet_lecture nul 0 Class to define an edge.
defbord_2 defbord nul -1 1-D edge (straight line) in the 2-D space.
  attr dir chaine(into=["X","Y"]) dir 0 Edge is perpendicular to this direction.
  attr eq chaine(into=["="]) eq 0 Equality sign.
  attr pos floattant pos 0 Position value.
  attr pos2_min floattant pos2_min 0 Minimal value.
  attr inf1 chaine(into=["<="]) inf1 0 Less than or equal to sign.
  attr dir2 chaine(into=["X","Y"]) dir2 0 Edge is parallel to this direction.
  attr inf2 chaine(into=["<="]) inf2 0 Less than or equal to sign.
  attr pos2_max floattant pos2_max 0 Maximal value.
defbord_3 defbord nul -1 2-D edge (plane) in the 3-D space.
  attr dir chaine(into=["X","Y","Z"]) dir 0 Edge is perpendicular to this direction.
  attr eq chaine(into=["="]) eq 0 Equality sign.
  attr pos floattant pos 0 Position value.
  attr pos2_min floattant pos2_min 0 Minimal value.
  attr inf1 chaine(into=["<="]) inf1 0 Less than or equal to sign.
  attr dir2 chaine(into=["X","Y"]) dir2 0 Edge is parallel to this direction.
  attr inf2 chaine(into=["<="]) inf2 0 Less than or equal to sign.
  attr pos2_max floattant pos2_max 0 Maximal value.
  attr pos3_min floattant pos3_min 0 Minimal value.
  attr inf3 chaine(into=["<="]) inf3 0 Less than or equal to sign.
  attr dir3 chaine(into=["Y","Z"]) dir3 0 Edge is parallel to this direction.
  attr inf4 chaine(into=["<="]) inf4 0 Less than or equal to sign.
  attr pos3_max floattant pos3_max 0 Maximal value.
bord_base objet_lecture bord_base -1 Basic class for block sides. Block sides that are neither edges nor connectors are not specified. The duplicate nodes of two blocks in contact are automatically recognized and deleted.
bord bord_base bord 0 The block side is not in contact with another block and boundary conditions are applied to it.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
raccord bord_base raccord 0 The block side is in contact with the block of another domain (case of two coupled problems).
  attr type1 chaine(into=["local","distant"]) type1 0 Contact type.
  attr type2 chaine(into=["homogene"]) type2 0 Contact type.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
internes bord_base internes 0 To indicate that the block has a set of internal faces (these faces will be duplicated automatically by the program and will be processed in a manner similar to edge faces). NL2 Two boundaries with the same boundary conditions may have the same name (whether or not they belong to the same block). NL2 The keyword Internes (Internal) must be used to execute a calculation with plates, followed by the equation of the surface area covered by the plates.
  attr nom chaine nom 0 Name of block side.
  attr defbord defbord defbord 0 Definition of block side.
list_bord listobj list_bord 1 bord_base 0 The block sides.
pave mailler_base pave 0 Class to create a pave (block) with boundaries.
  attr name chaine name 0 Name of the pave (block).
  attr bloc bloc_pave bloc 0 Definition of the pave (block).
  attr list_bord list_bord list_bord 0 Domain boundaries definition.
epsilon mailler_base epsilon 0 Two points will be confused if the distance between them is less than eps. By default, eps is set to 1e-12. The keyword Epsilon allows an alternative value to be assigned to eps.
  attr eps floattant eps 0 New value of precision.
domain mailler_base domain 0 Class to reuse a domain.
  attr domain_name ref_domaine domain_name 0 Name of domain.
list_bloc_mailler listobj list_bloc_mailler 1 mailler_base 1 List of block mesh.
mailler interprete mailler -1 The Mailler (Mesh) interpretor allows a Domain type object domaine to be meshed with objects objet_1, objet_2, etc...
  attr domaine ref_domaine domaine 0 Name of domain.
  attr bloc list_bloc_mailler bloc 0 Instructions to mesh.
maillerparallel interprete maillerparallel 1 creates a parallel distributed hexaedral mesh of a parallelipipedic box. It is equivalent to creating a mesh with a single Pave, splitting it with Decouper and reloading it in parallel with Scatter. It only works in 3D at this time. It can also be used for a sequential computation (with all NPARTS=1)}
  attr domain ref_domaine domain 0 the name of the domain to mesh (it must be an empty domain object).
  attr nb_nodes listentier nb_nodes 0 dimension defines the spatial dimension (currently only dimension=3 is supported), and nX, nY and nZ defines the total number of nodes in the mesh in each direction.
  attr splitting listentier splitting 0 dimension is the spatial dimension and npartsX, npartsY and npartsZ are the number of parts created. The product of the number of parts must be equal to the number of processors used for the computation.
  attr ghost_thickness entier ghost_thickness 0 he number of ghost cells (equivalent to the epaisseur_joint parameter of Decouper.
  attr perio_x rien perio_x 1 change the splitting method to provide a valid mesh for periodic boundary conditions.
  attr perio_y rien perio_y 1 change the splitting method to provide a valid mesh for periodic boundary conditions.
  attr perio_z rien perio_z 1 change the splitting method to provide a valid mesh for periodic boundary conditions.
  attr function_coord_x chaine function_coord_x 1 By default, the meshing algorithm creates nX nY nZ coordinates ranging between 0 and 1 (eg a unity size box). If function_coord_x} is specified, it is used to transform the [0,1] segment to the coordinates of the nodes. funcX must be a function of the x variable only.
  attr function_coord_y chaine function_coord_y 1 like function_coord_x for y
  attr function_coord_z chaine function_coord_z 1 like function_coord_x for z
  attr file_coord_x chaine file_coord_x 1 Keyword to read the Nx floating point values used as nodes coordinates in the file.
  attr file_coord_y chaine file_coord_y 1 idem file_coord_x for y
  attr file_coord_z chaine file_coord_z 1 idem file_coord_x for z
  attr boundary_xmin chaine boundary_xmin 1 the name of the boundary at the minimum X direction. If it not provided, the default boundary names are xmin, xmax, ymin, ymax, zmin and zmax. If the mesh is periodic in a given direction, only the MIN boundary name is used, for both sides of the box.
  attr boundary_xmax chaine boundary_xmax 1 not_set
  attr boundary_ymin chaine boundary_ymin 1 not_set
  attr boundary_ymax chaine boundary_ymax 1 not_set
  attr boundary_zmin chaine boundary_zmin 1 not_set
  attr boundary_zmax chaine boundary_zmax 1 not_set
write_file interprete ecrire_fichier -1 Keyword to write the object of name name_obj to a file filename. Since the v1.6.3, the default format is now binary format file.
  attr name_obj chaine name_obj 0 Name of the object to be written.
  attr filename chaine filename 0 Name of the file.
ecrire_fichier_formatte write_file ecrire_fichier_formatte -1 Keyword to write the object of name name_obj to a file filename in ASCII format.
write interprete ecrire -1 Keyword to write the object of name name_obj to a standard outlet.
  attr name_obj chaine name_obj 0 Name of the object to be written.
read_file interprete lire_fichier -1 Keyword to read the object name_obj contained in the file filename. NL2 This is notably used when the calculation domain has already been meshed and the mesh contains the file filename, simply write read_file dom filename (where dom is the name of the meshed domain). NL2 If the filename is ;, is to execute a data set given in the file of name name_obj (a space must be entered between the semi-colon and the file name).
  attr name_obj chaine name_obj 0 Name of the object to be read.
  attr filename chaine filename 0 Name of the file.
read_unsupported_ascii_file_from_icem read_file read_unsupported_ascii_file_from_icem -1 not_set
read_file_bin read_file lire_fichier_bin -1 Keyword to read an object name_obj in the unformatted type file filename.
read_tgrid interprete lire_tgrid -1 Keyword to reaf Tgrid/Gambit mesh files. 2D (triangles or quadrangles) and 3D (tetra or hexa elements) meshes, may be read by TRUST.
  attr dom ref_domaine dom 0 Name of domaine.
  attr filename chaine filename 0 Name of file containing the mesh.
discretisation_base objet_u discretisation_base -1 Basic class for space discretization of thermohydraulic turbulent problems.
vdf discretisation_base vdf -1 Finite difference volume discretization.
vef discretisation_base vef -1 Finite element volume discretization (P1NC/P0 element) NL2 Warning: it becomes an obsolete discretization.
covimac discretisation_base covimac|polymac_p0 -1 covimac discretization.
polymac discretisation_base polymac -1 polymac discretization.
vefprep1b vef vefprep1b -1 Finite element volume discretization (P1NC/P1-bubble element). Since the 1.5.5 version, several new discretizations are available thanks to the optional keyword Read. By default, the VEFPreP1B keyword is equivalent to the former VEFPreP1B formulation (v1.5.4 and sooner). P0P1 (if used with the strong formulation for imposed pressure boundary) is equivalent to VEFPreP1B but the convergence is slower. VEFPreP1B dis is equivalent to VEFPreP1B dis Read dis { P0 P1 Changement_de_base_P1Bulle 1 Cl_pression_sommet_faible 0 }
  attr p0 rien p0 1 Pressure nodes are added on element centres
  attr p1 rien p1 1 Pressure nodes are added on vertices
  attr pa rien pa 1 Only available in 3D, pressure nodes are added on bones
  attr changement_de_base_p1bulle entier(into=[0,1]) changement_de_base_p1bulle 1 This option may be used to have the P1NC/P0P1 formulation (value set to 0) or the P1NC/P1Bulle formulation (value set to 1, the default).
  attr cl_pression_sommet_faible entier(into=[0,1]) cl_pression_sommet_faible 1 This option is used to specify a strong formulation (value set to 0, the default) or a weak formulation (value set to 1) for an imposed pressure boundary condition. The first formulation converges quicker and is stable in general cases. The second formulation should be used if there are several outlet boundaries with Neumann condition (see Ecoulement_Neumann test case for example).
  attr modif_div_face_dirichlet entier(into=[0,1]) modif_div_face_dirichlet 1 This option (by default 0) is used to extend control volumes for the momentum equation.
solve interprete resoudre -2 Interpretor to start calculation with TRUST.
  attr pb ref_pb_gen_base pb 0 Name of problem to be solved.
execute_parallel interprete execute_parallel 1 This keyword allows to run several computations in parallel on processors allocated to TRUST. The set of processors is split in N subsets and each subset will read and execute a different data file. Error messages usualy written to stderr and stdout are redirected to .log files (journaling must be activated).
  attr liste_cas listchaine liste_cas 0 N datafile1 ... datafileN. datafileX the name of a TRUST data file without the .data extension.
  attr nb_procs listentier nb_procs 1 nb_procs is the number of processors needed to run each data file. If not given, TRUST assumes that computations are sequential.
fin interprete fin -1 Keyword which must complete the data file. The execution of the data file stops when reaching this keyword.
dimension interprete dimension -1 Keyword allowing calculation dimensions to be set (2D or 3D), where dim is an integer set to 2 or 3. This instruction is mandatory.
  attr dim entier(into=[2,3]) dim 0 Number of dimensions.
bidim_axi interprete bidim_axi -1 Keyword allowing a 2D calculation to be executed using axisymetric coordinates (R, Z). If this instruction is not included, calculations are carried out using Cartesian coordinates.
axi interprete axi -1 This keyword allows a 3D calculation to be executed using cylindrical coordinates (R,$\jolitheta$,Z). If this instruction is not included, calculations are carried out using Cartesian coordinates.
domaine objet_u domaine -1 Keyword to create a domain.
transformer interprete transformer -1 Keyword to transform the coordinates of the geometry. NL2 Exemple to rotate your mesh by a 90o rotation and to scale the z coordinates by a factor 2: Transformer domain_name -y -x 2*z
  attr domain_name ref_domaine domain_name 0 Name of domain.
  attr formule listchainef formule 0 Function_for_x Function_for_y \[ Function_for z \]
rotation interprete rotation -1 Keyword to rotate the geometry of an arbitrary angle around an axis aligned with Ox, Oy or Oz axis.
  attr domain_name ref_domaine domain_name 0 Name of domain to wich the transformation is applied.
  attr dir chaine(into=["X","Y","Z"]) dir 0 X, Y or Z to indicate the direction of the rotation axis
  attr coord1 floattant coord1 0 coordinates of the center of rotation in the plane orthogonal to the rotation axis. These coordinates must be specified in the direct triad sense.
  attr coord2 floattant coord2 0 not_set
  attr angle floattant angle 0 angle of rotation (in degrees)
dilate interprete dilate -1 Keyword to multiply the whole coordinates of the geometry.
  attr domain_name ref_domaine domain_name 0 Name of domain.
  attr alpha floattant alpha 0 Value of dilatation coefficient.
class_generic objet_u class_generic -1 not_set
dt_start class_generic dt_start 0 not_set
dt_calc_dt_calc dt_start dt_calc 0 The time step at first iteration is calculated in agreement with CFL condition.
dt_calc_dt_min dt_start dt_min 0 The first iteration is based on dt_min.
dt_calc_dt_fixe dt_start dt_fixe 0 The first time step is fixed by the user (recommended when resuming calculation with Crank Nicholson temporal scheme to ensure continuity).
  attr value floattant value 0 first time step.
scheme_euler_explicit schema_temps_base schema_euler_explicite -1 This is the Euler explicit scheme.
schema_predictor_corrector schema_temps_base schema_predictor_corrector -1 This is the predictor-corrector scheme (second order). It is more accurate and economic than MacCormack scheme. It gives best results with a second ordre convective scheme like quick, centre (VDF).
solveur_implicite_base objet_u solveur_implicite_base -1 Class for solver in the situation where the time scheme is the implicit scheme. Solver allows equation diffusion and convection operators to be set as implicit terms.
solveur_sys_base class_generic solveur_sys_base -1 Basic class to solve the linear system.
Sch_CN_iteratif schema_temps_base Sch_CN_iteratif -1 The Crank-Nicholson method of second order accuracy. A mid-point rule formulation is used (Euler-centered scheme). The basic scheme is: $$u(t+1) = u(t) + du/dt(t+1/2)*dt$$ The estimation of the time derivative du/dt at the level (t+1/2) is obtained either by iterative process. The time derivative du/dt at the level (t+1/2) is calculated iteratively with a simple under-relaxations method. Since the method is implicit, neither the cfl nor the fourier stability criteria must be respected. The time step is calculated in a way that the iterative procedure converges with the less iterations as possible. NL2 Remark : for stationary or RANS calculations, no limitation can be given for time step through high value of facsec_max parameter (for instance : facsec_max 1000). In counterpart, for LES calculations, high values of facsec_max may engender numerical instabilities.
  attr niter_min entier niter_min 1 minimal number of p-iterations to satisfy convergence criteria (2 by default)
  attr niter_max entier niter_max 1 number of maximum p-iterations allowed to satisfy convergence criteria (6 by default)
  attr niter_avg entier niter_avg 1 threshold of p-iterations (3 by default). If the number of p-iterations is greater than niter_avg, facsec is reduced, if lesser than niter_avg, facsec is increased (but limited by the facsec_max value).
  attr facsec_max floattant facsec_max 1 maximum ratio allowed between dynamical time step returned by iterative process and stability time returned by CFL condition (2 by default).
  attr seuil floattant seuil 1 criteria for ending iterative process (Max( || u(p) - u(p-1)||/Max || u(p) ||) < seuil) (0.001  by default)
Sch_CN_EX_iteratif Sch_CN_iteratif Sch_CN_EX_iteratif -1 This keyword also describes a Crank-Nicholson method of second order accuracy but here, for scalars, because of instablities encountered when dt>dt_CFL, the Crank Nicholson scheme is not applied to scalar quantities. Scalars are treated according to Euler-Explicite scheme at the end of the CN treatment for velocity flow fields (by doing p Euler explicite under-iterations at dt<=dt_CFL). Parameters are the sames (but default values may change) compare to the Sch_CN_iterative scheme plus a relaxation keyword: niter_min (2 by default), niter_max (6 by default), niter_avg (3 by default), facsec_max (20 by default), seuil (0.05 by default)
  attr omega floattant omega 1 relaxation factor (0.1 by default)
leap_frog schema_temps_base leap_frog -1 This is the leap-frog scheme.
solveur_lineaire_std solveur_implicite_base solveur_lineaire_std 1 not_set
  attr solveur solveur_sys_base solveur 1 not_set
simpler solveur_implicite_base simpler 1 Simpler method for incompressible systems.
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 0 Keyword to set the value of the convergence criteria for the resolution of the implicit system build to solve either the Navier_Stokes equation (only for Simple and Simpler algorithms) or a scalar equation. It is adviced to use the default value (1e6) to solve the implicit system only once by time step. This value must be decreased when a coupling between problems is considered.
  attr seuil_convergence_solveur floattant seuil_convergence_solveur 1 value of the convergence criteria for the resolution of the implicit system build by solving several times per time step the Navier_Stokes equation and the scalar equations if any. This value MUST be used when a coupling between problems is considered (should be set to a value typically of 0.1 or 0.01).
  attr seuil_generation_solveur floattant seuil_generation_solveur 1 Option to create a GMRES solver and use vrel as the convergence threshold (implicit linear system Ax=B will be solved if residual error ||Ax-B|| is lesser than vrel).
  attr seuil_verification_solveur floattant seuil_verification_solveur 1 Option to check if residual error ||Ax-B|| is lesser than vrel after the implicit linear system Ax=B has been solved.
  attr seuil_test_preliminaire_solveur floattant seuil_test_preliminaire_solveur 1 Option to decide if the implicit linear system Ax=B should be solved by checking if the residual error ||Ax-B|| is bigger than vrel.
  attr solveur solveur_sys_base solveur 1 Method (different from the default one, Gmres with diagonal preconditioning) to solve the linear system.
  attr no_qdm rien no_qdm 1 Keyword to not solve qdm equation (and turbulence models of these equation).
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gmres.
  attr controle_residu rien controle_residu 1 Keyword of Boolean type (by default 0). If set to 1, the convergence occurs if the residu suddenly increases.
piso simpler piso -1 Piso (Pressure Implicit with Split Operator) - method to solve N_S.
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 1 Convergence criteria.
  attr nb_corrections_max entier nb_corrections_max 1 Maximum number of corrections performed by the PISO algorithm to achieve the projection of the velocity field. The algorithm may perform less corrections then nb_corrections_max if the accuracy of the projection is sufficient. (By default nb_corrections_max is set to 21).
implicite piso implicite -1 similar to PISO, but as it looks like a simplified solver, it will use fewer timesteps. But it may run faster because the pressure matrix is not re-assembled and thus provides CPU gains.
simple piso simple -1 SIMPLE type algorithm
  attr relax_pression floattant relax_pression 1 Value between 0 and 1 (by default 1), this keyword is used only by the SIMPLE algorithm for relaxing the increment of pressure.
solveur_u_p simple solveur_u_p 1 similar to simple.
schema_implicite_base schema_temps_base schema_implicite_base -1 Basic class for implicite time scheme.
  attr max_iter_implicite entier max_iter_implicite 1 Maximum number of iterations allowed for the solver (by default 200).
  attr solveur solveur_implicite_base solveur 0 This keyword is used to designate the solver selected in the situation where the time scheme is an implicit scheme. solver is the name of the solver that allows equation diffusion and convection operators to be set as implicit terms. Keywords corresponding to this functionality are Simple (SIMPLE type algorithm), Simpler (SIMPLER type algorithm) for incompressible systems, Piso (Pressure Implicit with Split Operator), and Implicite (similar to PISO, but as it looks like a simplified solver, it will use fewer timesteps, and ICE (for PB_multiphase). But it may run faster because the pressure matrix is not re-assembled and thus provides CPU gains. NL2 Advice: Since the 1.6.0 version, we recommend to use first the Implicite or Simple, then Piso, and at least Simpler. Because the two first give a fastest convergence (several times) than Piso and the Simpler has not been validated. It seems also than Implicite and Piso schemes give better results than the Simple scheme when the flow is not fully stationary. Thus, if the solution obtained with Simple is not stationary, it is recommended to switch to Piso or Implicite scheme.
un_pb objet_lecture nul 0 pour les groupes
  attr mot ref_Pb_base mot 0 the string
list_un_pb listobj nul 1 un_pb 1 pour les groupes
list_list_nom listobj nul 1 list_un_pb 1 pour les groupes
coupled_problem pb_gen_base probleme_couple -1 This instruction causes a probleme_couple type object to be created. This type of object has an associated problem list, that is, the coupling of n problems among them may be processed. Coupling between these problems is carried out explicitly via conditions at particular contact limits. Each problem may be associated either with the Associate keyword or with the Read/groupes keywords. The difference is that in the first case, the four problems exchange values then calculate their timestep, rather in the second case, the same strategy is used for all the problems listed inside one group, but the second group of problem exchange values with the first group of problems after the first group did its timestep. So, the first case may then also be written like this: NL2 Probleme_Couple pbc NL2 Read pbc { groupes { { pb1 , pb2 , pb3 , pb4 } } } NL2 There is a physical environment per problem (however, the same physical environment could be common to several problems). NL2 Each problem is resolved in a domain. NL2 Warning : Presently, coupling requires coincident meshes. In case of non-coincident meshes, boundary condition \'paroi_contact\' in VEF returns error message (see paroi_contact for correcting procedure).
  attr groupes list_list_nom groupes 1 { groupes { { pb1 , pb2 } , { pb3 , pb4 } } }
  ref domaine_2 domaine
  ref pb_1 Pb_base
  ref pb_2 Pb_base
  ref pb_3 Pb_base
  ref pb_4 Pb_base
  ref scheme_2 schema_temps_base
mor_eqn objet_u mor_eqn -1 Class of equation pieces (morceaux d\'equation).
bords_ecrire objet_lecture nul 0 not_set
  attr chaine chaine(into=["bords"]) chaine 0 not_set
  attr bords listchaine bords 0 Keyword to post-process only on some boundaries : NL2 bords nb_bords boundary1 ... boundaryn NL2 where NL2 nb_bords : number of boundaries NL2 boundary1 ... boundaryn : name of the boundaries.
ecrire_fichier_xyz_valeur_param objet_lecture nul 0 To write the values of a field for some boundaries in a text file. NL2 The name of the files is pb_name_field_name_time.dat NL2 Several Ecrire_fichier_xyz_valeur keywords may be written into an equation to write several fields. This kind of files may be read by Champ_don_lu or Champ_front_lu for example.
  attr name chaine name 0 Name of the field to write (Champ_Inc, Champ_Fonc or a post_processed field).
  attr dt_ecrire_fic floattant dt_ecrire_fic 0 Time period for printing in the file.
  attr bords bords_ecrire bords 1 to post-process only on some boundaries
convection_deriv objet_lecture convection_deriv 0 not_set
bloc_convection objet_lecture nul 0 not_set
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr operateur convection_deriv operateur 0 not_set
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
diffusion_deriv objet_lecture diffusion_deriv 0 not_set
op_implicite objet_lecture nul 0 not_set
  attr implicite chaine(into=["implicite"]) implicite 0 not_set
  attr mot chaine(into=["solveur"]) mot 0 not_set
  attr solveur solveur_sys_base solveur 0 not_set
bloc_diffusion objet_lecture nul 0 not_set
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr operateur diffusion_deriv operateur 1 if none is specified, the diffusive scheme used is a 2nd-order scheme.
  attr op_implicite op_implicite op_implicite 1 To have diffusive implicitation, it use Uzawa algorithm. Very useful when viscosity has large variations.
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
traitement_particulier_base objet_lecture traitement_particulier_base 1 Basic class to post-process particular values.
traitement_particulier objet_lecture nul 0 Auxiliary class to post-process particular values.
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr trait_part traitement_particulier_base trait_part 0 Type of traitement_particulier.
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
navier_stokes_standard eqn_base navier_stokes_standard -1 Navier-Stokes equations.
  attr methode_calcul_pression_initiale chaine(into=["avec_les_cl","avec_sources","avec_sources_et_operateurs","sans_rien"]) methode_calcul_pression_initiale 1 Keyword to select an option for the pressure calculation before the fist time step. Options are : avec_les_cl (default option lapP=0 is solved with Neuman boundary conditions on pressure if any), avec_sources (lapP=f is solved with Neuman boundaries conditions and f integrating the source terms of the Navier-Stokes equations) and avec_sources_et_operateurs (lapP=f is solved as with the previous option avec_sources but f integrating also some operators of the Navier-Stokes equations). The two last options are useful and sometime necessary when source terms are implicited when using an implicit time scheme to solve the Navier-Stokes equations.
  attr projection_initiale entier projection_initiale 1 Keyword to suppress, if boolean equals 0, the initial projection which checks DivU=0. By default, boolean equals 1.
  attr solveur_pression solveur_sys_base solveur_pression 1 Linear pressure system resolution method.
  attr solveur_bar solveur_sys_base solveur_bar 1 This keyword is used to define when filtering operation is called (typically for EF convective scheme, standard diffusion operator and Source_Qdm_lambdaup ). A file (solveur.bar) is then created and used for inversion procedure. Syntax is the same then for pressure solver (GCP is required for multi-processor calculations and, in a general way, for big meshes).
  attr dt_projection deuxmots dt_projection 1 nb value : This keyword checks every nb time-steps the equality of velocity divergence to zero. value is the criteria convergency for the solver used.
  attr seuil_divU floatfloat seuil_divU 1 value factor : this keyword is intended to minimise the number of iterations during the pressure system resolution. The convergence criteria during this step (\'seuil\' in solveur_pression) is dynamically adapted according to the mass conservation. At tn , the linear system Ax=B is considered as solved if the residual ||Ax-B||<seuil(tn). For tn+1, the threshold value seuil(tn+1) will be evualated as: NL2 If ( |max(DivU)*dt|<value ) NL2 Seuil(tn+1)= Seuil(tn)*factor NL2 Else NL2 Seuil(tn+1)= Seuil(tn)*factor NL2 Endif NL2 The first parameter (value) is the mass evolution the user is ready to accept per timestep, and the second one (factor) is the factor of evolution for \'seuil\' (for example 1.1, so 10% per timestep). Investigations has to be lead to know more about the effects of these two last parameters on the behaviour of the simulations.
  attr traitement_particulier traitement_particulier traitement_particulier 1 Keyword to post-process particular values.
  attr correction_matrice_projection_initiale entier correction_matrice_projection_initiale 1 (IBM advanced) fix matrix of initial projection for PDF
  attr correction_calcul_pression_initiale entier correction_calcul_pression_initiale 1 (IBM advanced) fix initial pressure computation for PDF
  attr correction_vitesse_projection_initiale entier correction_vitesse_projection_initiale 1 (IBM advanced) fix initial velocity computation for PDF
  attr correction_matrice_pression entier correction_matrice_pression 1 (IBM advanced) fix pressure matrix for PDF
  attr correction_vitesse_modifie entier correction_vitesse_modifie 1 (IBM advanced) fix velocity for PDF
  attr gradient_pression_qdm_modifie entier gradient_pression_qdm_modifie 1 (IBM advanced) fix pressure gradient
  attr correction_pression_modifie entier correction_pression_modifie 1 (IBM advanced) fix pressure for PDF
  attr postraiter_gradient_pression_sans_masse rien postraiter_gradient_pression_sans_masse 1 (IBM advanced) avoid mass matrix multiplication for the gradient postprocessing
penalisation_l2_ftd_lec objet_lecture nul 0 not_set
  attr postraiter_gradient_pression_sans_masse entier postraiter_gradient_pression_sans_masse 1 (IBM advanced) avoid mass matrix multiplication for the gradient postprocessing
  attr correction_matrice_projection_initiale entier correction_matrice_projection_initiale 1 (IBM advanced) fix matrix of initial projection for PDF
  attr correction_calcul_pression_initiale entier correction_calcul_pression_initiale 1 (IBM advanced) fix initial pressure computation for PDF
  attr correction_vitesse_projection_initiale entier correction_vitesse_projection_initiale 1 (IBM advanced) fix initial velocity computation for PDF
  attr correction_matrice_pression entier correction_matrice_pression 1 (IBM advanced) fix pressure matrix for PDF
  attr matrice_pression_penalisee_H1 entier matrice_pression_penalisee_H1 1 (IBM advanced) fix pressure matrix for PDF
  attr correction_vitesse_modifie entier correction_vitesse_modifie 1 (IBM advanced) fix velocity for PDF
  attr correction_pression_modifie entier correction_pression_modifie 1 (IBM advanced) fix pressure for PDF
  attr gradient_pression_qdm_modifie entier gradient_pression_qdm_modifie 1 (IBM advanced) fix pressure gradient
  attr bord chaine bord 0 not_set
  attr val list val 0 not_set
penalisation_l2_ftd listobj pp 1 penalisation_l2_ftd_lec 0 not_set
convection_diffusion_temperature eqn_base convection_diffusion_temperature -1 Energy equation (temperature diffusion convection).
  attr penalisation_l2_ftd penalisation_l2_ftd penalisation_l2_ftd 1 to activate or not (the default is Direct Forcing method) the Penalized Direct Forcing method to impose the specified temperature on the solid-fluid interface.
turbulence_paroi_base objet_u turbulence_paroi_base -1 Basic class for wall laws for Navier-Stokes equations.
dt_impr_ustar_mean_only objet_lecture nul 1 not_set
  attr dt_impr floattant dt_impr 0 not_set
  attr boundaries listchaine boundaries 1 not_set
modele_turbulence_hyd_deriv objet_lecture modele_turbulence_hyd_deriv -1 Basic class for turbulence model for Navier-Stokes equations.
  attr correction_visco_turb_pour_controle_pas_de_temps rien correction_visco_turb_pour_controle_pas_de_temps 1 Keyword to set a limitation to low time steps due to high values of turbulent viscosity. The limit for turbulent viscosity is calculated so that diffusive time-step is equal or higher than convective time-step. For a stationary flow, the correction for turbulent viscosity should apply only during the first time steps and not when permanent state is reached. To check that, we could post process the corr_visco_turb field which is the correction of turbulent viscosity: it should be 1. on the whole domain.
  attr correction_visco_turb_pour_controle_pas_de_temps_parametre floattant correction_visco_turb_pour_controle_pas_de_temps_parametre 1 Keyword to set a limitation to low time steps due to high values of turbulent viscosity. The limit for turbulent viscosity is the ratio between diffusive time-step and convective time-step is higher or equal to the given value [0-1]
  attr turbulence_paroi turbulence_paroi_base turbulence_paroi 1 Keyword to set the wall law.
  attr dt_impr_ustar floattant dt_impr_ustar 1 This keyword is used to print the values (U +, d+, u$\star$) obtained with the wall laws into a file named datafile_ProblemName_Ustar.face and periode refers to the printing period, this value is expressed in seconds.
  attr dt_impr_ustar_mean_only dt_impr_ustar_mean_only dt_impr_ustar_mean_only 1 This keyword is used to print the mean values of u* ( obtained with the wall laws) on each boundary, into a file named datafile_ProblemName_Ustar_mean_only.out. periode refers to the printing period, this value is expressed in seconds. If you don\'t use the optional keyword boundaries, all the boundaries will be considered. If you use it, you must specify nb_boundaries which is the number of boundaries on which you want to calculate the mean values of u*, then you have to specify their names.
  attr nut_max floattant nut_max 1 Upper limitation of turbulent viscosity (default value 1.e8).
turbulence_paroi_scalaire_base objet_u turbulence_paroi_scalaire_base -1 Basic class for wall laws for energy equation.
modele_turbulence_scal_base objet_u modele_turbulence_scal_base -1 Basic class for turbulence model for energy equation.
  attr turbulence_paroi turbulence_paroi_scalaire_base turbulence_paroi 0 Keyword to set the wall law.
  attr dt_impr_nusselt floattant dt_impr_nusselt 1 Keyword to print local values of Nusselt number and temperature near a wall during a turbulent calculation. The values will be printed in the _Nusselt.face file each dt_impr_nusselt time period. The local Nusselt expression is as follows : Nu = ((lambda+lambda_t)/lambda)*d_wall/d_eq where d_wall is the distance from the first mesh to the wall and d_eq is given by the wall law. This option also gives the value of d_eq and h = (lambda+lambda_t)/d_eq and the fluid temperature of the first mesh near the wall. NL2 For the Neumann boundary conditions (flux_impose), the <<equivalent>> wall temperature given by the wall law is also printed (Tparoi equiv.) preceded for VEF calculation by the edge temperature <<T face de bord>>.
paroi_fixe condlim_base paroi_fixe -1 Keyword to designate a situation of adherence to the wall called bord (edge) (normal and tangential velocity at the edge is zero).
symetrie condlim_base symetrie -1 1). For Navier-Stokes equations, this keyword is used to designate a symmetry condition concerning the velocity at the boundary called bord (edge) (normal velocity at the edge equal to zero and tangential velocity gradient at the edge equal to zero); 2). For scalar transport equation, this keyword is used to set a symmetry condition on scalar on the boundary named bord (edge).
periodic condlim_base periodique -1 1). For Navier-Stokes equations, this keyword is used to indicate that the horizontal inlet velocity values are the same as the outlet velocity values, at every moment. As regards meshing, the inlet and outlet edges bear the same name.; 2). For scalar transport equation, this keyword is used to set a periodic condition on scalar. The two edges dealing with this periodic condition bear the same name.
paroi_adiabatique condlim_base paroi_adiabatique -1 Normal zero flux condition at the wall called bord (edge).
front_field_base objet_u champ_front_base -1 Basic class for fields at domain boundaries.
dirichlet condlim_base dirichlet -1 Dirichlet condition at the boundary called bord (edge) : 1). For Navier-Stokes equations, velocity imposed at the boundary; 2). For scalar transport equation, scalar imposed at the boundary.
paroi_defilante dirichlet paroi_defilante -1 Keyword to designate a condition where tangential velocity is imposed on the wall called bord (edge). If the velocity components set by the user is not tangential, projection is used.
  attr ch front_field_base ch 0 Boundary field type.
paroi_knudsen_non_negligeable dirichlet paroi_knudsen_non_negligeable -1 Boundary condition for number of Knudsen (Kn) above 0.001 where slip-flow condition appears: the velocity near the wall depends on the shear stress : Kn=l/L with l is the mean-free-path of the molecules and L a characteristic length scale. NL2 U(y=0)-Uwall=k(dU/dY) NL2 Where k is a coefficient given by several laws: NL2 Mawxell : k=(2-s)*l/s NL2 Bestok\&Karniadakis :k=(2-s)/s*L*Kn/(1+Kn) NL2 Xue\&Fan :k=(2-s)/s*L*tanh(Kn) NL2 s is a value between 0 and 2 named accomodation coefficient. s=1 seems a good value. NL2 Warning : The keyword is available for VDF calculation only for the moment.
  attr name_champ_1 chaine(into=["vitesse_paroi","k"]) name_champ_1 0 Field name.
  attr champ_1 front_field_base champ_1 0 Boundary field type.
  attr name_champ_2 chaine(into=["vitesse_paroi","k"]) name_champ_2 0 Field name.
  attr champ_2 front_field_base champ_2 0 Boundary field type.
neumann condlim_base neumann -1 Neumann condition at the boundary called bord (edge) : 1). For Navier-Stokes equations, constraint imposed at the boundary; 2). For scalar transport equation, flux imposed at the boundary.
frontiere_ouverte_vitesse_imposee dirichlet frontiere_ouverte_vitesse_imposee -1 Class for velocity-inlet boundary condition. The imposed velocity field at the inlet is vectorial and the imposed velocity values are expressed in m.s-1.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_vitesse_imposee_sortie frontiere_ouverte_vitesse_imposee frontiere_ouverte_vitesse_imposee_sortie -1 Sub-class for velocity boundary condition. The imposed velocity field at the open boundary is vectorial and the imposed velocity values are expressed in m.s-1.
frontiere_ouverte_rho_u_impose frontiere_ouverte_vitesse_imposee_sortie frontiere_ouverte_rho_u_impose -1 This keyword is used to designate a condition of imposed mass rate at an open boundary called bord (edge). The imposed mass rate field at the inlet is vectorial and the imposed velocity values are expressed in kg.s-1. This boundary condition can be used only with the Quasi compressible model.
frontiere_ouverte_gradient_pression_libre_vef neumann frontiere_ouverte_gradient_pression_libre_vef -1 Class for outlet boundary condition in VEF like Orlansky. There is no reference for pressure for theses boundary conditions so it is better to add pressure condition (with Frontiere_ouverte_pression_imposee) on one or two cells (for symmetry in a channel) of the boundary where Orlansky conditions are imposed.
frontiere_ouverte_gradient_pression_libre_vefprep1b neumann frontiere_ouverte_gradient_pression_libre_vefprep1b -1 Class for outlet boundary condition in VEF P1B/P1NC like Orlansky.
frontiere_ouverte_gradient_pression_impose neumann frontiere_ouverte_gradient_pression_impose -1 Normal imposed pressure gradient condition on the open boundary called bord (edge). This boundary condition may be only used in VDF discretization. The imposed $\partial P/\partial n$ value is expressed in Pa.m-1.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_pression_imposee neumann frontiere_ouverte_pression_imposee -1 Imposed pressure condition at the open boundary called bord (edge). The imposed pressure field is expressed in Pa.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_pression_imposee_orlansky neumann frontiere_ouverte_pression_imposee_orlansky -1 This boundary condition may only be used with VDF discretization. There is no reference for pressure for this boundary condition so it is better to add pressure condition (with Frontiere_ouverte_pression_imposee) on one or two cells (for symetry in a channel) of the boundary where Orlansky conditions are imposed.
frontiere_ouverte_pression_moyenne_imposee neumann frontiere_ouverte_pression_moyenne_imposee 0 Class for open boundary with pressure mean level imposed.
  attr pext floattant pext 0 Mean pressure.
frontiere_ouverte neumann frontiere_ouverte -1 Boundary outlet condition on the boundary called bord (edge) (diffusion flux zero). This condition must be associated with a boundary outlet hydraulic condition.
  attr var_name chaine(into=["T_ext","C_ext","Y_ext","K_Eps_ext","Fluctu_Temperature_ext","Flux_Chaleur_Turb_ext","V2_ext","a_ext","tau_ext","k_ext","omega_ext"]) var_name 0 Field name.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_temperature_imposee dirichlet frontiere_ouverte_temperature_imposee -1 Imposed temperature condition at the open boundary called bord (edge) (in the case of fluid inlet). This condition must be associated with an imposed inlet velocity condition. The imposed temperature value is expressed in oC or K.
  attr ch front_field_base ch 0 Boundary field type.
frontiere_ouverte_concentration_imposee dirichlet frontiere_ouverte_concentration_imposee -1 Imposed concentration condition at an open boundary called bord (edge) (situation corresponding to a fluid inlet). This condition must be associated with an imposed inlet velocity condition.
  attr ch front_field_base ch 0 Boundary field type.
paroi_contact condlim_base paroi_contact -1 Thermal condition between two domains. Important: the name of the boundaries in the two domains should be the same. (Warning: there is also an old limitation not yet fixed on the sequential algorithm in VDF to detect the matching faces on the two boundaries: faces should be ordered in the same way). The kind of condition depends on the discretization. In VDF, it is a heat exchange condition, and in VEF, a temperature condition. NL2 Such a coupling requires coincident meshes for the moment. In case of non-coincident meshes, run is stopped and two external files are automatically generated in VEF (connectivity_failed_boundary_name and connectivity_failed_pb_name.med). In 2D, the keyword Decouper_bord_coincident associated to the connectivity_failed_boundary_name file allows to generate a new coincident mesh. NL2 In 3D, for a first preliminary cut domain with HOMARD (fluid for instance), the second problem associated to pb_name (solide in a fluid/solid coupling problem) has to be submitted to HOMARD cutting procedure with connectivity_failed_pb_name.med. NL2 Such a procedure works as while the primary refined mesh (fluid in our example) impacts the fluid/solid interface with a compact shape as described below (values 2 or 4 indicates the number of division from primary faces obtained in fluid domain at the interface after HOMARD cutting): NL2 2-2-2-2-2-2 NL2 2-4-4-4-4-4-2 \\; 2-2-2 NL2 2-4-4-4-4-2 \\; 2-4-2 NL2 2-2-2-2-2 \\; 2-2 NL2 OK NL2 NL2 2-2 \\; \\; 2-2-2 NL2 2-4-2 \\; 2-2 NL2 2-2 \\; 2-2 NL2 NOT OK
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 boundary name of the remote problem which should be the same than the local name
paroi_contact_fictif condlim_base paroi_contact_fictif -1 This keyword is derivated from paroi_contact and is especially dedicated to compute coupled fluid/solid/fluid problem in case of thin material. Thanks to this option, solid is considered as a fictitious media (no mesh, no domain associated), and coupling is performed by considering instantaneous thermal equilibrium in it (for the moment).
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 Name of bord.
  attr conduct_fictif floattant conduct_fictif 0 thermal conductivity
  attr ep_fictive floattant ep_fictive 0 thickness of the fictitious media
paroi_echange_contact_vdf condlim_base paroi_echange_contact_vdf -1 Boundary condition type to model the heat flux between two problems. Important: the name of the boundaries in the two problems should be the same.
  attr autrepb ref_Pb_base autrepb 0 Name of other problem.
  attr nameb chaine nameb 0 Name of bord.
  attr temp chaine temp 0 Name of field.
  attr h floattant h 0 Value assigned to a coefficient (expressed in W.K-1m-2) that characterises the contact between the two mediums. In order to model perfect contact, h must be taken to be infinite. This value must obviously be the same in both the two problems blocks. NL2 The surface thermal flux exchanged between the two mediums is represented by : NL2 fi = h (T1-T2) where 1/h = d1/lambda1 + 1/val_h_contact + d2/lambda2 NL2 where di : distance between the node where Ti and the wall is found.
paroi_echange_externe_impose condlim_base paroi_echange_externe_impose -1 External type exchange condition with a heat exchange coefficient and an imposed external temperature.
  attr h_imp chaine h_imp 0 Heat exchange coefficient value (expressed in W.m-2.K-1).
  attr himpc front_field_base himpc 0 Boundary field type.
  attr text chaine text 0 External temperature value (expressed in oC or K).
  attr ch front_field_base ch 0 Boundary field type.
paroi_echange_global_impose condlim_base paroi_echange_global_impose -1 Global type exchange condition (internal) that is to say that diffusion on the first fluid mesh is not taken into consideration.
  attr h_imp chaine h_imp 0 Global exchange coefficient value. The global exchange coefficient value is expressed in W.m-2.K-1.
  attr himpc front_field_base himpc 0 Boundary field type.
  attr text chaine text 0 External temperature value. The external temperature value is expressed in oC or K.
  attr ch front_field_base ch 0 Boundary field type.
boussinesq_temperature source_base boussinesq_temperature -1 Class to describe a source term that couples the movement quantity equation and energy equation with the Boussinesq hypothesis.
  attr t0 chaine t0 0 Reference temperature value (oC or K). It can also be a time dependant function since the 1.6.6 version.
  attr verif_boussinesq entier verif_boussinesq 1 Keyword to check (1) or not (0) the reference temperature in comparison with the mean temperature value in the domain. It is set to 1 by default.
boussinesq_concentration source_base boussinesq_concentration -1 Class to describe a source term that couples the movement quantity equation and constituent transport equation with the Boussinesq hypothesis.
  attr c0 list c0 0 Reference concentration field type. The only field type currently available is Champ_Uniforme (Uniform field).
  attr verif_boussinesq entier verif_boussinesq 1 Keyword to check (1) or not (0) the reference concentration in comparison with the mean concentration value in the domain. It is set to 1 by default.
dirac source_base dirac 0 Class to define a source term corresponding to a volume power release in the energy equation.
  attr position list position 0 not_set
  attr ch field_base ch 0 Thermal power field type. To impose a volume power on a domain sub-area, the Champ_Uniforme_Morceaux (partly_uniform_field) type must be used. NL2 Warning : The volume thermal power is expressed in W.m-3.
puissance_thermique source_base puissance_thermique 0 Class to define a source term corresponding to a volume power release in the energy equation.
  attr ch field_base ch 0 Thermal power field type. To impose a volume power on a domain sub-area, the Champ_Uniforme_Morceaux (partly_uniform_field) type must be used. NL2 Warning : The volume thermal power is expressed in W.m-3 in 3D (in W.m-2 in 2D). It is a power per volume unit (in a porous media, it is a power per fluid volume unit).
source_qdm_lambdaup source_base source_qdm_lambdaup 1 This source term is a dissipative term which is intended to minimise the energy associated to non-conformscales u\' (responsible for spurious oscillations in some cases). The equation for these scales can be seen as: du\'/dt= -lambda. u\' + grad P\' where -lambda. u\' represents the dissipative term, with lambda = a/Delta t For Crank-Nicholson temporal scheme, recommended value for a is 2. NL2 Remark : This method requires to define a filtering operator.
  attr lambda floattant lambda_u 0 value of lambda
  attr lambda_min floattant lambda_min 1 value of lambda_min
  attr lambda_max floattant lambda_max 1 value of lambda_max
  attr ubar_umprim_cible floattant ubar_umprim_cible 1 value of ubar_umprim_cible
source_th_tdivu source_base source_th_tdivu 0 This term source is dedicated for any scalar (called T) transport. Coupled with upwind (amont) or muscl scheme, this term gives for final expression of convection : div(U.T)-T.div (U)=U.grad(T) This ensures, in incompressible flow when divergence free is badly resolved, to stay in a better way in the physical boundaries. NL2 Warning: Only available in VEF discretization.
source_robin source_base source_robin 0 This source term should be used when a Paroi_decalee_Robin boundary condition is set in a hydraulic equation. The source term will be applied on the N specified boundaries. To post-process the values of tauw, u_tau and Reynolds_tau into the files tauw_robin.dat, reynolds_tau_robin.dat and u_tau_robin.dat, you must add a block Traitement_particulier { canal { } }
  attr bords vect_nom bords 0 not_set
source_robin_scalaire source_base source_robin_scalaire 0 This source term should be used when a Paroi_decalee_Robin boundary condition is set in a an energy equation. The source term will be applied on the N specified boundaries. The values temp_wall_valueI are the temperature specified on the Ith boundary. The last value dt_impr is a printing period which is mandatory to specify in the data file but has no effect yet.
  attr bords listdeuxmots_sacc bords 0 not_set
canal_perio source_base canal_perio 1 Momentum source term to maintain flow rate. The expression of the source term is: NL2 S(t) = (2*(Q(0) - Q(t))-(Q(0)-Q(t-dt))/(coeff*dt*area) NL2 NL2 Where: NL2 coeff=damping coefficient NL2 area=area of the periodic boundary NL2 Q(t)=flow rate at time t NL2 dt=time step NL2 NL2 Three files will be created during calculation on a datafile named DataFile.data. The first file contains the flow rate evolution. The second file is useful for resuming a calculation with the flow rate of the previous stopped calculation, and the last one contains the pressure gradient evolution: NL2 -DataFile_Channel_Flow_Rate_ProblemName_BoundaryName NL2 -DataFile_Channel_Flow_Rate_repr_ProblemName_BoundaryName NL2 -DataFile_Pressure_Gradient_ProblemName_BoundaryName
  attr bord chaine bord 0 The name of the (periodic) boundary normal to the flow direction.
  attr h floattant h 1 Half heigth of the channel.
  attr coeff floattant coeff 1 Damping coefficient (optional, default value is 10).
  attr debit_impose floattant debit_impose 1 Optional option to specify the aimed flow rate Q(0). If not used, Q(0) is computed by the code after the projection phase, where velocity initial conditions are slighlty changed to verify incompressibility.
champ_don_base field_base champ_don_base -1 Basic class for data fields (not calculated), p.e. physics properties.
uniform_field champ_don_base champ_uniforme 0 Field that is constant in space and stationary.
  attr val list val 0 Values of field components.
champ_uniforme_morceaux champ_don_base champ_uniforme_morceaux 0 Field which is partly constant in space and stationary.
  attr nom_dom ref_domaine nom_dom 0 Name of the domain to which the sub-areas belong.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr data bloc_lecture data 0 { Defaut val_def sous_zone_1 val_1 ... sous_zone_i val_i } By default, the value val_def is assigned to the field. It takes the sous_zone_i identifier Sous_Zone (sub_area) type object value, val_i. Sous_Zone (sub_area) type objects must have been previously defined if the operator wishes to use a Champ_Uniforme_Morceaux(partly_uniform_field) type object.
champ_uniforme_morceaux_tabule_temps champ_uniforme_morceaux champ_uniforme_morceaux_tabule_temps -1 this type of field is constant in space on one or several sub_zones and tabulated as a function of time.
testeur interprete testeur 0 not_set
  attr data bloc_lecture data 0 not_set
valeur_totale_sur_volume champ_uniforme_morceaux valeur_totale_sur_volume -1 Similar as Champ_Uniforme_Morceaux with the same syntax. Used for source terms when we want to specify a source term with a value given for the volume (eg: heat in Watts) and not a value per volume unit (eg: heat in Watts/m3).
field_func_xyz champ_don_base champ_fonc_xyz 0 Field defined by analytical functions. It makes it possible the definition of a field that depends on (x,y,z).
  attr dom ref_domaine dom 0 Name of domain of calculation.
  attr val listchaine val 0 List of functions on (x,y,z).
field_func_txyz champ_don_base champ_fonc_txyz 0 Field defined by analytical functions. It makes it possible the definition of a field that depends on the time and the space.
  attr dom ref_domaine dom 0 Name of domain of calculation.
  attr val listchaine val 0 List of functions on (t,x,y,z).
champ_don_lu champ_don_base champ_don_lu 0 Field to read a data field (values located at the center of the cells) in a file.
  attr dom ref_domaine dom 0 Name of the domain.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr file chaine file 0 Name of the file. NL2 This file has the following format: NL2 nb_val_lues -> Number of values readen in th file NL2 Xi Yi Zi -> Coordinates readen in the file NL2 Ui Vi Wi -> Value of the field
init_par_partie champ_don_base init_par_partie 0 ne marche que pour n_comp=1
  attr n_comp entier(into=[1]) n_comp 0 not_set
  attr val1 floattant val1 0 not_set
  attr val2 floattant val2 0 not_set
  attr val3 floattant val3 0 not_set
champ_front_uniforme front_field_base champ_front_uniforme 0 Boundary field which is constant in space and stationary.
  attr val list val 0 Values of field components.
champ_front_fonc_pois_ipsn front_field_base champ_front_fonc_pois_ipsn 0 Boundary field champ_front_fonc_pois_ipsn.
  attr r_tube floattant r_tube 0 not_set
  attr umoy list umoy 0 not_set
  attr r_loc listf r_loc 0 not_set
champ_front_fonc_pois_tube front_field_base champ_front_fonc_pois_tube 0 Boundary field champ_front_fonc_pois_tube.
  attr r_tube floattant r_tube 0 not_set
  attr umoy list umoy 0 not_set
  attr r_loc listf r_loc 0 not_set
  attr r_loc_mult listentierf r_loc_mult 0 not_set
champ_front_tangentiel_vef front_field_base champ_front_tangentiel_vef 0 Field to define the tangential velocity vector field standard at the boundary in VEF discretization.
  attr mot chaine(into=["vitesse_tangentielle"]) mot 0 Name of vector field.
  attr vit_tan floattant vit_tan 0 Vector field standard [m/s].
champ_front_lu front_field_base champ_front_lu 0 boundary field which is given from data issued from a read file. The format of this file has to be the same that the one generated by Ecrire_fichier_xyz_valeur NL2 Example for K and epsilon quantities to be defined for inlet condition in a boundary named \'entree\': NL2entree frontiere_ouverte_K_Eps_impose Champ_Front_lu dom 2pb_K_EPS_PERIO_1006.306198.dat
  attr domaine ref_domaine domain 0 Name of domain
  attr dim entier dim 0 number of components
  attr file chaine file 0 path for the read file
boundary_field_inward front_field_base boundary_field_inward 1 this field is used to define the normal vector field standard at the boundary in VDF or VEF discretization.
  attr normal_value chaine normal_value 0 normal vector value (positive value for a vector oriented outside to inside) which can depend of the time.
constituant milieu_base constituant -1 Constituent.
  attr rho field_base rho 1 Density (kg.m-3).
  attr cp field_base cp 1 Specific heat (J.kg-1.K-1).
  attr lambda field_base lambda_u 1 Conductivity (W.m-1.K-1).
  attr coefficient_diffusion field_base coefficient_diffusion 1 Constituent diffusion coefficient value (m2.s-1). If a multi-constituent problem is being processed, the diffusivite will be a vectorial and each components will be the diffusion of the constituent.
  ref gravite field_base
champ_front_pression_from_u front_field_base champ_front_pression_from_u 0 this field is used to define a pressure field depending of a velocity field.
  attr expression chaine expression 0 value depending of a velocity (like $2*u_moy^2$).
source_constituant source_base source_constituant 0 Keyword to specify source rates, in [[C]/s], for each one of the nb constituents. [C] is the concentration unit.
  attr ch field_base ch 0 Field type.
radioactive_decay source_base radioactive_decay 0 Radioactive decay source term of the form $-\lambda_i c_i$, where $0 \leq i \leq N$, N is the number of component of the constituent, $c_i$ and $\lambda_i$ are the concentration and the decay constant of the i-th component of the constituant.
  attr val list val 0 n is the number of decay constants to read (int), and val1, val2... are the decay constants (double)
form_a_nb_points objet_lecture nul 0 The structure fonction is calculated on nb points and we should add the 2 directions (0:OX, 1:OY, 2:OZ) constituting the homegeneity planes. Example for channel flows, planes parallel to the walls.
  attr nb entier(into=[4]) nb 0 Number of points.
  attr dir1 entier(max=2) dir1 0 First direction.
  attr dir2 entier(max=2) dir2 0 Second direction.
tparoi_vef champ_post_de_champs_post tparoi_vef -1 This keyword is used to post process (only for VEF discretization) the temperature field with a slight difference on boundaries with Neumann condition where law of the wall is applied on the temperature field. nom_pb is the problem name and field_name is the selected field name. A keyword (temperature_physique) is available to post process this field without using Definition_champs.
fourfloat objet_lecture nul 0 Four reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
  attr c floattant c 0 Third real.
  attr d floattant d 0 Fourth real.
twofloat objet_lecture nul 0 two reals.
  attr a floattant a 0 First real.
  attr b floattant b 0 Second real.
sonde_tble objet_lecture nul 0 not_set
  attr name chaine name 0 not_set
  attr point un_point point 0 not_set
liste_sonde_tble listobj nul 0 sonde_tble 0 not_set
Paroi condlim_base Paroi 0 Impermeability condition at a wall called bord (edge) (standard flux zero). This condition must be associated with a wall type hydraulic condition.
precond_base objet_u precond_base -1 Basic class for preconditioning.
ssor precond_base ssor 1 Symmetric successive over-relaxation algorithm.
  attr omega floattant omega 1 Over-relaxation facteur (between 1 and 2, default value 1.6).
ssor_bloc precond_base ssor_bloc -1 not_set
  attr alpha_0 floattant alpha_0 1 not_set
  attr precond0 precond_base precond0 1 not_set
  attr alpha_1 floattant alpha_1 1 not_set
  attr precond1 precond_base precond1 1 not_set
  attr alpha_a floattant alpha_a 1 not_set
  attr preconda precond_base preconda 1 not_set
precondsolv precond_base precondsolv 0 not_set
  attr solveur solveur_sys_base solveur 0 Solver type.
optimal solveur_sys_base optimal 1 Optimal is a solver which tests several solvers of the previous list to choose the fastest one for the considered linear system.
  attr seuil floattant seuil 0 Convergence threshold
  attr impr rien impr 1 To print the convergency of the fastest solver
  attr quiet rien quiet 1 To disable printing of information
  attr save_matrice|save_matrix rien save_matrice 1 To save the linear system (A, x, B) into a file
  attr frequence_recalc entier frequence_recalc 1 To set a time step period (by default, 100) for re-checking the fatest solver
  attr nom_fichier_solveur chaine nom_fichier_solveur 1 To specify the file containing the list of the tested solvers
  attr fichier_solveur_non_recree rien fichier_solveur_non_recree 1 To avoid the creation of the file containing the list
test_solveur interprete test_solveur 1 To test several solvers
  attr fichier_secmem chaine fichier_secmem 1 Filename containing the second member B
  attr fichier_matrice chaine fichier_matrice 1 Filename containing the matrix A
  attr fichier_solution chaine fichier_solution 1 Filename containing the solution x
  attr nb_test entier nb_test 1 Number of tests to measure the time resolution (one preconditionnement)
  attr impr rien impr 1 To print the convergence solver
  attr solveur solveur_sys_base solveur 1 To specify a solver
  attr fichier_solveur chaine fichier_solveur 1 To specify a file containing a list of solvers
  attr genere_fichier_solveur floattant genere_fichier_solveur 1 To create a file of the solver with a threshold convergence
  attr seuil_verification floattant seuil_verification 1 Check if the solution satisfy ||Ax-B||<precision
  attr pas_de_solution_initiale rien pas_de_solution_initiale 1 Resolution isn\'t initialized with the solution x
  attr ascii rien ascii 1 Ascii files
ilu precond_base ilu -1 This preconditionner can be only used with the generic GEN solver. 
  attr type entier type 1 values can be 0|1|2|3 for null|left|right|left-and-right preconditionning (default value = 2)
  attr filling entier filling 1 default value = 1.
gen solveur_sys_base gen -1 not_set
  attr solv_elem chaine solv_elem 0 To specify a solver among gmres or bicgstab.
  attr precond precond_base precond 0 The only preconditionner that we can specify is ilu.
  attr seuil floattant seuil 1 Value of the final residue. The solver ceases iterations when the Euclidean residue standard ||Ax-B|| is less than this value. default value 1e-12.
  attr impr rien impr 1 Keyword which is used to request display of the Euclidean residue standard each time this iterates through the conjugated gradient (display to the standard outlet).
  attr save_matrice|save_matrix rien save_matrice 1 To save the matrix in a file.
  attr quiet rien quiet 1 To not displaying any outputs of the solver.
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the GEN solver.
  attr force rien force 1 Keyword to set ipar[5]=-1 in the GEN solver. This is helpful if you notice that the solver does not perform more than 100 iterations. If this keyword is specified in the datafile, you should provide nb_it_max.
petsc solveur_sys_base petsc 0 Solver via Petsc API NL2 \input{{solvpetsc}}
  attr solveur chaine solveur 0 not_set
  attr option_solveur bloc_lecture option_solveur 0 not_set
  attr atol floattant atol 1 Absolute threshold for convergence (same as seuil option)
  attr rtol floattant rtol 1 Relative threshold for convergence
amgx petsc amgx 0 Solver via AmgX API
  attr solveur chaine solveur 0 not_set
  attr option_solveur bloc_lecture option_solveur 0 not_set
rocalution petsc rocalution 0 Solver via rocALUTION API
  attr solveur chaine solveur 0 not_set
  attr option_solveur bloc_lecture option_solveur 0 not_set
solv_gcp solveur_sys_base gcp 1 Preconditioned conjugated gradient.
  attr precond precond_base precond 1 Keyword to define system preconditioning in order to accelerate resolution by the conjugated gradient. Many parallel preconditioning methods are not equivalent to their sequential counterpart, and you should therefore expect differences, especially when you select a high value of the final residue (seuil). The result depends on the number of processors and on the mesh splitting. It is sometimes useful to run the solver with no preconditioning at all. In particular: NL2 - when the solver does not converge during initial projection, NL2 - when comparing sequential and parallel computations. NL2 With no preconditioning, except in some particular cases (no open boundary), the sequential and the parallel computations should provide exactly the same results within fpu accuracy. If not, there might be a coding error or the system of equations is singular.
  attr precond_nul rien precond_nul 1 Keyword to not use a preconditioning method.
  attr seuil floattant seuil 0 Value of the final residue. The gradient ceases iteration when the Euclidean residue standard ||Ax-B|| is less than this value.
  attr impr rien impr 1 Keyword which is used to request display of the Euclidean residue standard each time this iterates through the conjugated gradient (display to the standard outlet).
  attr quiet rien quiet 1 To not displaying any outputs of the solver.
  attr save_matrice|save_matrix rien save_matrice 1 to save the matrix in a file.
  attr optimized rien optimized 1 This keyword triggers a memory and network optimized algorithms useful for strong scaling (when computing less than 100 000 elements per processor). The matrix and the vectors are duplicated, common items removed and only virtual items really used in the matrix are exchanged.NL2 Warning: this is experimental and known to fail in some VEF computations (L2 projection step will not converge). Works well in VDF.
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gcp.
gcp_ns solv_gcp gcp_ns -1 not_set
  attr solveur0 solveur_sys_base solveur0 0 Solver type.
  attr solveur1 solveur_sys_base solveur1 0 Solver type.
cholesky solveur_sys_base cholesky -1 Cholesky direct method.
  attr impr rien impr 1 Keyword which may be used to print the resolution time.
  attr quiet rien quiet 1 To disable printing of information
gmres solveur_sys_base gmres -1 Gmres method (for non symetric matrix).
  attr impr rien impr 1 Keyword which may be used to print the convergence.
  attr quiet rien quiet 1 To disable printing of information
  attr seuil floattant seuil 1 Convergence value.
  attr diag rien diag 1 Keyword to use diagonal preconditionner (in place of pilut that is not parallel).
  attr nb_it_max entier nb_it_max 1 Keyword to set the maximum iterations number for the Gmres.
  attr controle_residu entier(into=["0","1"]) controle_residu 1 Keyword of Boolean type (by default 0). If set to 1, the convergence occurs if the residu suddenly increases.
  attr save_matrice|save_matrix rien save_matrice 1 to save the matrix in a file.
  attr dim_espace_krilov entier dim_espace_krilov 1 not_set
postraiter_domaine interprete postraiter_domaine 1 To write one or more domains in a file with a specified format (MED,LML,LATA).
  attr format chaine(into=["lml","lata","lata_v2","med"]) format 0 File format.
  attr fichier|file chaine fichier 1 The file name can be changed with the fichier option.
  attr domaine ref_domaine domain 1 Name of domain
  attr sous_zone ref_sous_zone sous_zone 1 Name of the sub_zone
  attr domaines bloc_lecture domaines 1 Names of domains : { name1 name2 }
  attr joints_non_postraites entier(into=[0,1]) joints_non_postraites 1 The joints_non_postraites (1 by default) will not write the boundaries between the partitioned mesh.
  attr binaire entier(into=[0,1]) binaire 1 Binary (binaire 1) or ASCII (binaire 0) may be used. By default, it is 0 for LATA and only ASCII is available for LML and only binary is available for MED.
  attr ecrire_frontiere entier(into=[0,1]) ecrire_frontiere 1 This option will write (if set to 1, the default) or not (if set to 0) the boundaries as fields into the file (it is useful to not add the boundaries when writing a domain extracted from another domain)
modif_bord_to_raccord interprete modif_bord_to_raccord -1 Keyword to convert a boundary of domain_name domain of kind Bord to a boundary of kind Raccord (named boundary_name). It is useful when using meshes with boundaries of kind Bord defined and to run a coupled calculation.
  attr domaine ref_domaine domain 0 Name of domain
  attr nom_bord chaine nom_bord 0 Name of the boundary to transform.
remove_elem_bloc objet_lecture nul 1 not_set
  attr liste listentier liste 1 not_set
  attr fonction chaine fonction 1 not_set
remove_elem interprete remove_elem -1 Keyword to remove element from a VDF mesh (named domaine_name), either from an explicit list of elements or from a geometric condition defined by a condition f(x,y)>0 in 2D and f(x,y,z)>0 in 3D. All the new borders generated are gathered in one boundary called : newBord (to rename it, use RegroupeBord keyword. To split it to different boundaries, use DecoupeBord_Pour_Rayonnement keyword). Example of a removed zone of radius 0.2 centered at (x,y)=(0.5,0.5): NL2 Remove_elem dom { fonction $0.2*0.2-(x-0.5)^2-(y-0.5)^2>0$ } NL2 Warning : the thickness of removed zone has to be large enough to avoid singular nodes as decribed below : \includepng{{removeelem.png}}{{11.234}}
  attr domaine ref_domaine domain 0 Name of domain
  attr bloc remove_elem_bloc bloc 0 not_set
regroupebord interprete regroupebord -1 Keyword to build one boundary new_bord with several boundaries of the domain named domaine.
  attr domaine ref_domaine domain 0 Name of domain
  attr new_bord chaine new_bord 0 Name of the new boundary
  attr bords bloc_lecture bords 0 { Bound1 Bound2 }
supprime_bord interprete supprime_bord -1 Keyword to remove boundaries (named Boundary_name1 Boundary_name2 ) of the domain named domain_name.
  attr domaine ref_domaine domain 0 Name of domain
  attr bords list_nom bords 0 { Boundary_name1 Boundaray_name2 }
lecture_bloc_moment_base objet_lecture nul 0 Auxiliary class to compute and print the moments.
calcul lecture_bloc_moment_base calcul -1 The centre of gravity will be calculated.
centre_de_gravite lecture_bloc_moment_base centre_de_gravite -1 To specify the centre of gravity.
  attr point un_point point 0 A centre of gravity.
calculer_moments interprete calculer_moments -1 Calculates and prints the torque (moment of force) exerted by the fluid on each boundary in output files (.out) of the domain nom_dom.
  attr nom_dom ref_domaine nom_dom 0 Name of domain.
  attr mot lecture_bloc_moment_base mot 0 Keyword.
imprimer_flux interprete imprimer_flux -1 This keyword prints the flux per face at the specified domain boundaries in the data set. The fluxes are written to the .face files at a frequency defined by dt_impr, the evaluation printing frequency (refer to time scheme keywords). By default, fluxes are incorporated onto the edges before being displayed.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr noms_bord bloc_lecture noms_bord 0 List of boundaries, for ex: { Bord1 Bord2 }
imprimer_flux_sum imprimer_flux imprimer_flux_sum -1 This keyword prints the sum of the flux per face at the domain boundaries defined by the user in the data set. The fluxes are written into the .out files at a frequency defined by dt_impr, the evaluation printing frequency (refer to time scheme keywords).
bloc_origine_cotes objet_lecture nul 0 Class to create a rectangle (or a box).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the origin of the rectangle (or the box).
  attr origin listf origine 0 Coordinates of the origin of the rectangle (or the box).
  attr name2 chaine(into=["Cotes"]) name2 0 Keyword to define the length along the axes.
  attr cotes listf cotes 0 Length along the axes.
bloc_couronne objet_lecture nul 0 Class to create a couronne (2D).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the center of the circle.
  attr origin listf origine 0 Center of the circle.
  attr name3 chaine(into=["ri"]) name3 0 Keyword to define the interior radius.
  attr ri floattant ri 0 Interior radius.
  attr name4 chaine(into=["re"]) name4 0 Keyword to define the exterior radius.
  attr re floattant re 0 Exterior radius.
bloc_tube objet_lecture nul 0 Class to create a tube (3D).
  attr name chaine(into=["Origine"]) name 0 Keyword to define the center of the tube.
  attr origin listf origine 0 Center of the tube.
  attr name2 chaine(into=["dir"]) name2 0 Keyword to define the direction of the main axis.
  attr direction chaine(into=["X","Y","Z"]) direction 0 direction of the main axis X, Y or Z
  attr name3 chaine(into=["ri"]) name3 0 Keyword to define the interior radius.
  attr ri floattant ri 0 Interior radius.
  attr name4 chaine(into=["re"]) name4 0 Keyword to define the exterior radius.
  attr re floattant re 0 Exterior radius.
  attr name5 chaine(into=["hauteur"]) name5 0 Keyword to define the heigth of the tube.
  attr h floattant h 0 Heigth of the tube.
sous_zone objet_u sous_zone 1 It is an object type describing a domain sub-set. NL2 A Sous_Zone (Sub-area) type object must be associated with a Domaine type object. The Read (Lire) interpretor is used to define the items comprising the sub-area. NL2 Caution: The Domain type object nom_domaine must have been meshed (and triangulated or tetrahedralised in VEF) prior to carrying out the Associate (Associer) nom_sous_zone nom_domaine instruction; this instruction must always be preceded by the read instruction.
  attr restriction ref_sous_zone restriction 1 The elements of the sub-area nom_sous_zone must be included into the other sub-area named nom_sous_zone2. This keyword should be used first in the Read keyword.
  attr rectangle bloc_origine_cotes rectangle 1 The sub-area will include all the domain elements whose centre of gravity is within the Rectangle (in dimension 2).
  attr segment bloc_origine_cotes segment 1 not_set
  attr boite bloc_origine_cotes box 1 The sub-area will include all the domain elements whose centre of gravity is within the Box (in dimension 3).
  attr liste listentier liste 1 The sub-area will include n domain items, numbers No. 1 No. i No. n.
  attr fichier chaine filename 1 The sub-area is read into the file filename.
  attr intervalle deuxentiers intervalle 1 The sub-area will include domain items whose number is between n1 and n2 (where n1<=n2).
  attr polynomes bloc_lecture polynomes 1 A REPRENDRE
  attr couronne bloc_couronne couronne 1 In 2D case, to create a couronne.
  attr tube bloc_tube tube 1 In 3D case, to create a tube.
  attr fonction_sous_zone chaine fonction_sous_domaine 1 Keyword to build a sub-area with the the elements included into the area defined by fonction>0.
  attr union ref_sous_zone union_with 1 The elements of the sub-area nom_sous_zone3 will be added to the sub-area nom_sous_zone. This keyword should be used last in the Read keyword.
  ref domaine domaine
decouper_bord_coincident interprete decouper_bord_coincident -1 In case of non-coincident meshes and a paroi_contact condition, run is stopped and two external files are automatically generated in VEF (connectivity_failed_boundary_name and connectivity_failed_pb_name.med). In 2D, the keyword Decouper_bord_coincident associated to the connectivity_failed_boundary_name file allows to generate a new coincident mesh.
  attr domain_name ref_domaine domain_name 0 Name of domain.
  attr bord chaine bord 0 connectivity_failed_boundary_name
raffiner_anisotrope interprete raffiner_anisotrope -1 Only for VEF discretizations, allows to cut triangle elements in 3, or tetrahedra in 4 parts, by defining a new summit located at the center of the element: \includepng{{raffineranisotri.pdf}}{{4}} \includepng{{raffineranisotetra.jpeg}}{{6}} NL2 Note that such a cut creates flat elements (anisotropic).
  attr domain_name ref_domaine domain_name 0 Name of domain.
raffiner_isotrope interprete raffiner_isotrope -1 For VDF and VEF discretizations, allows to cut triangles/quadrangles or tetrahedral/hexaedras elements respectively in 4 or 8 new ones by defining new summits located at the middle of edges (and center of faces and elements for quadrangles and hexaedra). Such a cut preserves the shape of original elements (isotropic). For 2D elements: \includetabfig{{raffinerisotri.pdf}}{{4}}{{raffinerisorect.pdf}}{{4}} For 3D elements: \includetabfig{{raffinerisotetra.jpeg}}{{6}}{{raffinerisohexa.jpeg}}{{5}}.
  attr domain_name ref_domaine domain_name 0 Name of domain.
triangulate interprete trianguler -1 To achieve a triangular mesh from a mesh comprising rectangles (2 triangles per rectangle). Should be used in VEF discretization. Principle: NL2 \includepng{{trianguler.pdf}}{{10}}
  attr domain_name ref_domaine domain_name 0 Name of domain.
trianguler_h triangulate trianguler_h -1 To achieve a triangular mesh from a mesh comprising rectangles (4 triangles per rectangle). Should be used in VEF discretization. Principle: NL2 \includepng{{triangulerh.pdf}}{{10}}
trianguler_fin triangulate trianguler_fin -1 Trianguler_fin is the recommended option to triangulate rectangles. NL2 As an extension (subdivision) of Triangulate_h option, this one cut each initial rectangle in 8 triangles (against 4, previously). This cutting ensures : NL2 - a correct cutting in the corners (in respect to pressure discretization PreP1B). NL2 - a better isotropy of elements than with Trianguler_h option. NL2 - a better alignment of summits (this could have a benefit effect on calculation near walls since first elements in contact with it are all contained in the same constant thickness, and, by this way, a 2D cartesian grid based on summits can be engendered and used to realize statistical analysis in plane channel configuration for instance). Principle: NL2 \includepng{{triangulerfin.pdf}}{{10}}
tetraedriser interprete tetraedriser -1 To achieve a tetrahedral mesh based on a mesh comprising blocks, the Tetraedriser (Tetrahedralise) interpretor is used in VEF discretization. Initial block is divided in 6 tetrahedra: \includepng{{tetraedriser.jpeg}}{{5}}
  attr domain_name ref_domaine domain_name 0 Name of domain.
orientefacesbord interprete orientefacesbord -1 Keyword to modify the order of the boundary vertices included in a domain, such that the surface normals are outer pointing.
  attr domain_name ref_domaine domain_name 0 Name of domain.
reorienter_tetraedres interprete reorienter_tetraedres -1 This keyword is mandatory for front-tracking computations with the VEF discretization. For each tetrahedral element of the domain, it checks if it has a positive volume. If the volume (determinant of the three vectors) is negative, it swaps two nodes to reverse the orientation of this tetrahedron.
  attr domain_name ref_domaine domain_name 0 Name of domain.
reorienter_triangles interprete reorienter_triangles -1 not_set
  attr domain_name ref_domaine domain_name 0 Name of domain.
tetraedriser_homogene tetraedriser tetraedriser_homogene -1 Use the Tetraedriser_homogene (Homogeneous_Tetrahedralisation) interpretor in VEF discretization to mesh a block in tetrahedrals. Each block hexahedral is no longer divided into 6 tetrahedrals (keyword Tetraedriser (Tetrahedralise)), it is now broken down into 40 tetrahedrals. Thus a block defined with 11 nodes in each X, Y, Z direction will contain 10*10*10*40=40,000 tetrahedrals. This also allows problems in the mesh corners with the P1NC/P1iso/P1bulle or P1/P1 discretization items to be avoided. Initial block is divided in 40 tetrahedra: \includepng{{tetraedriserhomogene.jpeg}}{{5}}
tetraedriser_homogene_fin tetraedriser tetraedriser_homogene_fin -1 Tetraedriser_homogene_fin is the recommended option to tetrahedralise blocks. As an extension (subdivision) of Tetraedriser_homogene_compact, this last one cut each initial block in 48 tetrahedra (against 24, previously). This cutting ensures : NL2 - a correct cutting in the corners (in respect to pressure discretization PreP1B), NL2 - a better isotropy of elements than with Tetraedriser_homogene_compact, NL2 - a better alignment of summits (this could have a benefit effect on calculation near walls since first elements in contact with it are all contained in the same constant thickness and ii/ by the way, a 3D cartesian grid based on summits can be engendered and used to realise spectral analysis in HIT for instance). Initial block is divided in 48 tetrahedra: \includepng{{tetraedriserhomogenefin.jpeg}}{{5}}
tetraedriser_homogene_compact tetraedriser tetraedriser_homogene_compact -1 This new discretization generates tetrahedral elements from cartesian or non-cartesian hexahedral elements. The process cut each hexahedral in 6 pyramids, each of them being cut then in 4 tetrahedral. So, in comparison with tetra_homogene, less elements (*24 instead of*40) with more homogeneous volumes are generated. Moreover, this process is done in a faster way. Initial block is divided in 24 tetrahedra: \includepng{{tetraedriserhomogenecompact.jpeg}}{{5}}
tetraedriser_par_prisme tetraedriser tetraedriser_par_prisme -1 Tetraedriser_par_prisme generates 6 iso-volume tetrahedral element from primary hexahedral one (contrarily to the 5 elements ordinarily generated by tetraedriser). This element is suitable for calculation of gradients at the summit (coincident with the gravity centre of the jointed elements related with) and spectra (due to a better alignment of the points). \includetabfig{{tetraedriserparprisme.jpeg}}{{5}}{{tetraedriserparprisme2.jpeg}}{{5}} Initial block is divided in 6 prismes.
verifiercoin interprete verifiercoin -1 This keyword subdivides inconsistent 2D/3D cells used with VEFPreP1B discretization. Must be used before the mesh is discretized. NL The Read_file option can be used only if the file.decoupage_som was previously created by TRUST. This option, only in 2D, reverses the common face at two cells (at least one is inconsistent), through the nodes opposed. In 3D, the option has no effect. NL2 The expert_only option deactivates, into the VEFPreP1B divergence operator, the test of inconsistent cells.
  attr dom ref_domaine dom 0 Name of domain.
paroi_flux_impose condlim_base paroi_flux_impose 0 Normal flux condition at the wall called bord (edge). The surface area of the flux (W.m-1 in 2D or W.m-2 in 3D) is imposed at the boundary according to the following convention: a positive flux is a flux that enters into the domain according to convention.
  attr ch front_field_base ch 0 Boundary field type.
paroi_temperature_imposee dirichlet paroi_temperature_imposee 0 Imposed temperature condition at the wall called bord (edge).
  attr ch front_field_base ch 0 Boundary field type.
temperature_imposee_paroi paroi_temperature_imposee temperature_imposee_paroi 0 Imposed temperature condition at the wall called bord (edge).
champ_front_contact_vef front_field_base champ_front_contact_vef 0 This field is used on a boundary between a solid and fluid domain to exchange a calculated temperature at the contact face of the two domains according to the flux of the two problems.
  attr local_pb ref_Pb_base local_pb 0 Name of the problem.
  attr local_boundary chaine local_boundary 0 Name of the boundary.
  attr remote_pb ref_Pb_base remote_pb 0 Name of the second problem.
  attr remote_boundary chaine remote_boundary 0 Name of the boundary in the second problem.
bloc_lecture_poro objet_lecture nul 1 Surface and volume porosity values.
  attr volumique floattant volumique 0 Volume porosity value.
  attr surfacique list surfacique 0 Surface porosity values (in X, Y, Z directions).
porosites objet_u porosites 0 To define the volume porosity and surface porosity that are uniform in every direction in space on a sub-area. NL2 Porosity was only usable in VDF discretization, and now available for VEF P1NC/P0. NL2 Observations : NL2 - Surface porosity values must be given in every direction in space (set this value to 1 if there is no porosity), NL2 - Prior to defining porosity, the problem must have been discretized.NL2 Can \'t be used in VEF discretization, use Porosites_champ instead.
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr sous_zone|sous_zone1 chaine sous_zone 0 Name of the sub-area to which porosity are allocated.
  attr bloc bloc_lecture_poro bloc 0 Surface and volume porosity values.
  attr sous_zone2 chaine sous_zone2 1 Name of the 2nd sub-area to which porosity are allocated.
  attr bloc2 bloc_lecture_poro bloc2 1 Surface and volume porosity values.
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
discretiser_domaine interprete discretiser_domaine 0 Useful to discretize the domain domain_name (faces will be created) without defining a problem.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
champ_front_calc front_field_base champ_front_calc 0 This keyword is used on a boundary to get a field from another boundary. The local and remote boundaries should have the same mesh. If not, the Champ_front_recyclage keyword could be used instead. It is used in the condition block at the limits of equation which itself refers to a problem called pb1. We are working under the supposition that pb1 is coupled to another problem.
  attr problem_name ref_Pb_base problem_name 0 Name of the other problem to which pb1 is coupled.
  attr bord chaine bord 0 Name of the side which is the boundary between the 2 domains in the domain object description associated with the problem_name object.
  attr field_name chaine field_name 0 Name of the field containing the value that the user wishes to use at the boundary. The field_name object must be recognized by the problem_name object.
champ_tabule_temps champ_don_base champ_tabule_temps 0 Field that is constant in space and tabulated as a function of time.
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lecture bloc 0 Values as a table. The value of the field at any time is calculated by linear interpolation from this table.
champ_fonc_t champ_don_base champ_fonc_t 0 Field that is constant in space and is a function of time.
  attr val listchaine val 0 Values of field components (time dependant functions).
champ_fonc_fonction champ_fonc_tabule champ_fonc_fonction 0 Field that is a function of another field.
  attr dim suppress_param dim 1 del
  attr bloc suppress_param bloc 1 del
  attr inco suppress_param inco 1 del
  attr problem_name ref_Pb_base problem_name 0 Name of problem.
  attr inco chaine inco 0 Name of the field (for example: temperature).
  attr expression listchaine expression 0 Number of field components followed by the analytical expression for each field component.
frontiere_ouverte_gradient_pression_impose_vefprep1b frontiere_ouverte_gradient_pression_impose frontiere_ouverte_gradient_pression_impose_vefprep1b -1 Keyword for an outlet boundary condition in VEF P1B/P1NC on the gradient of the pressure.
bloc_lec_champ_init_canal_sinal objet_lecture nul 1 Parameters for the class champ_init_canal_sinal. NL2 in 2D: NL2 U=ucent*y(2h-y)/h/h NL2 V=ampli_bruit*rand+ampli_sin*sin(omega*x) NL2 rand: unpredictable value between -1 and 1. NL2 in 3D: NL2 U=ucent*y(2h-y)/h/h NL2 V=ampli_bruit*rand1+ampli_sin*sin(omega*x) NL2 W=ampli_bruit*rand2 NL2 rand1 and rand2: unpredictables values between -1 and 1.
  attr ucent floattant ucent 0 Velocity value at the center of the channel.
  attr h floattant h 0 Half hength of the channel.
  attr ampli_bruit floattant ampli_bruit 0 Amplitude for the disturbance.
  attr ampli_sin floattant ampli_sin 1 Amplitude for the sinusoidal disturbance (by default equals to ucent/10).
  attr omega floattant omega 0 Value of pulsation for the of the sinusoidal disturbance.
  attr dir_flow entier(into=[0,1,2]) dir_flow 1 Flow direction for the initialization of the flow in a channel. NL2 - if dir_flow=0, the flow direction is X NL2 - if dir_flow=1, the flow direction is Y NL2 - if dir_flow=2, the flow direction is Z NL2 Default value for dir_flow is 0
  attr dir_wall entier(into=[0,1,2]) dir_wall 1 Wall direction for the initialization of the flow in a channel. NL2 - if dir_wall=0, the normal to the wall is in X direction NL2 - if dir_wall=1, the normal to the wall is in Y direction NL2 - if dir_wall=2, the normal to the wall is in Z direction NL2 Default value for dir_flow is 1
  attr min_dir_flow floattant min_dir_flow 1 Value of the minimum coordinate in the flow direction for the initialization of the flow in a channel. Default value for dir_flow is 0.
  attr min_dir_wall floattant min_dir_wall 1 Value of the minimum coordinate in the wall direction for the initialization of the flow in a channel. Default value for dir_flow is 0.
champ_init_canal_sinal champ_don_base champ_init_canal_sinal 0 For a parabolic profile on U velocity with an unpredictable disturbance on V and W and a sinusoidal disturbance on V velocity.
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lec_champ_init_canal_sinal bloc 0 Parameters for the class champ_init_canal_sinal.
champ_som_lu_vdf champ_don_base champ_som_lu_vdf 0 Keyword to read in a file values located at the nodes of a mesh in VDF discretization.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr dim entier dim 0 Value of the dimension of the field.
  attr tolerance floattant tolerance 0 Value of the tolerance to check the coordinates of the nodes.
  attr file chaine file 0 name of the file NL2 This file has the following format: NL2 Xi Yi Zi -> Coordinates of the node NL2 Ui Vi Wi -> Value of the field on this node NL2 Xi+1 Yi+1 Zi+1 -> Next point NL2 Ui+1 Vi+1 Zi+1 -> Next value ...
champ_som_lu_vef champ_don_base champ_som_lu_vef 0 Keyword to read in a file values located at the nodes of a mesh in VEF discretization.
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr dim entier dim 0 Value of the dimension of the field.
  attr tolerance floattant tolerance 0 Value of the tolerance to check the coordinates of the nodes.
  attr file chaine file 0 Name of the file. NL2 This file has the following format: NL2 Xi Yi Zi -> Coordinates of the node NL2 Ui Vi Wi -> Value of the field on this node NL2 Xi+1 Yi+1 Zi+1 -> Next point NL2 Ui+1 Vi+1 Zi+1 -> Next value ...
acceleration source_base acceleration 1 Momentum source term to take in account the forces due to rotation or translation of a non Galilean referential R\' (centre 0\') into the Galilean referential R (centre 0).
  attr vitesse field_base vitesse 1 Keyword for the velocity of the referential R\' into the R referential (dOO\'/dt term [m.s-1]). The velocity is mandatory when you want to print the total cinetic energy into the non-mobile Galilean referential R (see Ec_dans_repere_fixe keyword).
  attr acceleration field_base acceleration 1 Keyword for the acceleration of the referential R\' into the R referential (d2OO\'/dt2 term [m.s-2]). field_base is a time dependant field (eg: Champ_Fonc_t).
  attr omega field_base omega 1 Keyword for a rotation of the referential R\' into the R referential [rad.s-1]. field_base is a 3D time dependant field specified for example by a Champ_Fonc_t keyword. The time_field field should have 3 components even in 2D (In 2D: 0 0 omega).
  attr domegadt field_base domegadt 1 Keyword to define the time derivative of the previous rotation [rad.s-2]. Should be zero if the rotation is constant. The time_field field should have 3 components even in 2D (In 2D: 0 0 domegadt).
  attr centre_rotation field_base centre_rotation 1 Keyword to specify the centre of rotation (expressed in R\' coordinates) of R\' into R (if the domain rotates with the R\' referential, the centre of rotation is 0\'=(0,0,0)). The time_field should have 2 or 3 components according the dimension 2 or 3.
  attr option chaine(into=["terme_complet","coriolis_seul","entrainement_seul"]) option 1 Keyword to specify the kind of calculation: terme_complet (default option) will calculate both the Coriolis and centrifugal forces, coriolis_seul will calculate the first one only, entrainement_seul will calculate the second one only.
coriolis source_base coriolis 0 Keyword for a Coriolis term in hydraulic equation. Warning: Only available in VDF.
  attr omega chaine omega 0 Value of omega.
champ_front_recyclage front_field_base champ_front_recyclage 0 \input{{champfrontrecyclage}}
  attr bloc chaine bloc 0 not_set
paroi_echange_externe_impose_h paroi_echange_externe_impose paroi_echange_externe_impose_h -1 Particular case of class paroi_echange_externe_impose for enthalpy equation.
entree_temperature_imposee_h frontiere_ouverte_temperature_imposee entree_temperature_imposee_h -1 Particular case of class frontiere_ouverte_temperature_imposee for enthalpy equation.
sortie_libre_temperature_imposee_h neumann sortie_libre_temperature_imposee_h 0 Open boundary for heat equation with enthalpy as unknown.
  attr ch front_field_base ch 0 Boundary field type.
champ_ostwald field_base champ_ostwald 0 This keyword is used to define the viscosity variation law: NL2 Mu(T)= K(T)*(D:D/2)**((n-1)/2)
tayl_green champ_don_base tayl_green 0 Class Tayl_green.
  attr dim entier dim 0 Dimension.
fonction_champ_reprise objet_lecture nul 0 not_set
  attr mot chaine(into=["fonction"]) mot 0 not_set
  attr fonction listchaine fonction 0 n f1(val) f2(val) ... fn(val)] time
source_qdm source_base source_qdm 0 Momentum source term in the Navier-Stokes equations.
  attr ch field_base champ 0 Field type.
perte_charge_singuliere source_base perte_charge_singuliere 1 Source term that is used to model a pressure loss over a surface area (transition through a grid, sudden enlargement) defined by the faces of elements located on the intersection of a subzone named subzone_name and a X,Y, or Z plane located at X,Y or Z = location.
  attr dir chaine(into=["kx","ky","kz","K"]) dir 0 KX, KY or KZ designate directional pressure loss coefficients for respectively X, Y or Z direction. Or in the case where you chose a target flow rate with regul. Use K for isotropic pressure loss coefficient
  attr coeff floattant coeff 1 Value (float) of friction coefficient (KX, KY, KZ).
  attr regul bloc_lecture regul 1 option to have adjustable K with flowrate target  NL2 { K0 valeur_initiale_de_k deb debit_cible eps intervalle_variation_mutiplicatif}.
  attr surface bloc_lecture surface 0 Three syntaxes are possible for the surface definition block: NL2 For VDF and VEF: { X|Y|Z = location subzone_name } NL2 Only for VEF: { Surface surface_name }. NL2 For polymac { Surface surface_name Orientation champ_uniforme }
DP_Impose source_base DP_Impose 1 Source term to impose a pressure difference according to the formula : DP = A + B * (Q - Q0)
  attr dp field_base dp 0 the parameters of the previous formula champ_uniforme 3 A B Q0 where Q0 is a volume flow (m3/s).
  attr surface bloc_lecture surface 0 Three syntaxes are possible for the surface definition block: NL2 For VDF and VEF: { X|Y|Z = location subzone_name } NL2 Only for VEF: { Surface surface_name }. NL2 For polymac { Surface surface_name Orientation champ_uniforme }.
perte_charge_directionnelle source_base perte_charge_directionnelle 1 Directional pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_isotrope source_base perte_charge_isotrope 1 Isotropic pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_anisotrope source_base perte_charge_anisotrope 1 Anisotropic pressure loss.
  attr lambda chaine lambda_u 0 Function for loss coefficient which may be Reynolds dependant (Ex: 64/Re).
  attr lambda_ortho chaine lambda_ortho 0 Function for loss coefficient in transverse direction which may be Reynolds dependant (Ex: 64/Re).
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
perte_charge_circulaire source_base perte_charge_circulaire 1 New pressure loss.
  attr lambda chaine lambda_u 0 Function f(Re_tot, Re_long, t, x, y, z) for loss coefficient in the longitudinal direction
  attr lambda_ortho chaine lambda_ortho 0 function: Function f(Re_tot, Re_ortho, t, x, y, z) for loss coefficient in transverse direction
  attr diam_hydr champ_don_base diam_hydr 0 Hydraulic diameter value.
  attr diam_hydr_ortho champ_don_base diam_hydr_ortho 0 Transverse hydraulic diameter value.
  attr direction champ_don_base direction 0 Field which indicates the direction of the pressure loss.
  attr sous_zone chaine sous_zone 1 Optional sub-area where pressure loss applies.
convection_diffusion_concentration eqn_base convection_diffusion_concentration -1 Constituent transport vectorial equation (concentration diffusion convection).
  attr nom_inconnue chaine nom_inconnue 1 Keyword Nom_inconnue will rename the unknown of this equation with the given name. In the postprocessing part, the concentration field will be accessible with this name. This is usefull if you want to track more than one concentration (otherwise, only the concentration field in the first concentration equation can be accessed).
  attr masse_molaire floattant masse_molaire 1 not_set
  attr alias chaine alias 1 not_set
darcy source_base darcy 0 Class for calculation in a porous media with source term of Darcy -nu/K*V. This keyword must be used with a permeability model. For the moment there are two models : permeability constant or Ergun\'s law. Darcy source term is available for quasi compressible calculation. A new keyword is aded for porosity (porosite).
  attr bloc bloc_lecture bloc 0 Description.
forchheimer source_base forchheimer 0 Class to add the source term of Forchheimer -Cf/sqrt(K)*V2 in the Navier-Stokes equations. We must precise a permeability model : constant or Ergun\'s law. Moreover we can give the constant Cf : by default its value is 1. Forchheimer source term is available also for quasi compressible calculation. A new keyword is aded for porosity (porosite).
  attr bloc bloc_lecture bloc 0 Description.
debut_bloc interprete { 0 Block\'s beginning.
fin_bloc interprete } 0 Block\'s end.
export interprete export 0 Class to make the object have a global range, if not its range will apply to the block only (the associated object will be destroyed on exiting the block).
debog interprete debog 0 Class to debug some differences between two TRUST versions on a same data file. NL2 If you want to compare the results of the same code in sequential and parallel calculation, first run (mode=0) in sequential mode (the files fichier1 and fichier2 will be written first) then the second run in parallel calculation (mode=1). NL2 During the first run (mode=0), it prints into the file DEBOG, values at different points of the code thanks to the C++ instruction call. see for example in Kernel/Framework/Resoudre.cpp file the instruction: Debog::verifier(msg,value); Where msg is a string and value may be a double, an integer or an array. NL2 During the second run (mode=1), it prints into a file Err_Debog.dbg the same messages than in the DEBOG file and checks if the differences between results from both codes are less than a given value (error). If not, it prints Ok else show the differences and the lines where it occured.
  attr pb ref_pb_gen_base pb 0 Name of the problem to debug.
  attr fichier1 chaine file1 0 Name of the file where domain will be written in sequential calculation.
  attr fichier2 chaine file2 0 Name of the file where faces will be written in sequential calculation.
  attr seuil floattant seuil 0 Minimal value (by default 1.e-20) for the differences between the two codes.
  attr mode entier mode 0 By default -1 (nothing is written in the different files), you will set 0 for the sequential run, and 1 for the parallel run.
pilote_icoco interprete pilote_icoco 1 not_set
  attr pb_name chaine pb_name 0 not_set
  attr main chaine main 0 not_set
ch_front_input front_field_base ch_front_input 1 not_set
  attr nb_comp entier nb_comp 0 not_set
  attr nom chaine nom 0 not_set
  attr initial_value list initial_value 1 not_set
  attr probleme chaine probleme 0 not_set
  attr sous_zone ref_sous_zone sous_zone 1 not_set
ch_front_input_uniforme ch_front_input ch_front_input_uniforme -1 for coupling, you can use ch_front_input_uniforme which is a champ_front_uniforme, which use an external value. It must be used with Problem.setInputField.
champ_input_base field_base champ_input_base 1 not_set
  attr nb_comp entier nb_comp 0 not_set
  attr nom chaine nom 0 not_set
  attr initial_value list initial_value 1 not_set
  attr probleme chaine probleme 0 not_set
  attr sous_zone ref_sous_zone sous_zone 1 not_set
champ_input_p0 champ_input_base champ_input_p0 1 not_set
moyenne_volumique interprete moyenne_volumique 1 This keyword should be used after Resoudre keyword. It computes the convolution product of one or more fields with a given filtering function.
  attr nom_pb ref_Pb_base nom_pb 0 name of the problem where the source fields will be searched.
  attr nom_domaine ref_domaine nom_domaine 0 name of the destination domain (for example, it can be a coarser mesh, but for optimal performance in parallel, the domain should be split with the same algorithm as the computation mesh, eg, same tranche parameters for example)
  attr noms_champs listchaine noms_champs 0 name of the source fields (these fields must be accessible from the postraitement) N source_field1 source_field2 ... source_fieldN
  attr nom_fichier_post chaine nom_fichier_post 1 indicates the filename where the result is written
  attr format_post chaine format_post 1 gives the fileformat for the result (by default : lata)
  attr localisation chaine(into=["elem","som"]) localisation 1 indicates where the convolution product should be computed: either on the elements or on the nodes of the destination domain.
  attr fonction_filtre bloc_lecture fonction_filtre 0 to specify the given filter NL2 Fonction_filtre {NL2 type filter_typeNL2 demie-largeur lNL2 [ omega w ] NL2 [ expression string ]NL2 } NL2 NL2 type filter_type : This parameter specifies the filtering function. Valid filter_type are:NL2 Boite is a box filter, $f(x,y,z)=(abs(x)<l)*(abs(y) <l)*(abs(z) <l) / (8 l^3)$NL2 Chapeau is a hat filter (product of hat filters in each direction) centered on the origin, the half-width of the filter being l and its integral being 1.NL2 Quadra is a 2nd order filter.NL2 Gaussienne is a normalized gaussian filter of standard deviation sigma in each direction (all field elements outside a cubic box defined by clipping_half_width are ignored, hence, taking clipping_half_width=2.5*sigma yields an integral of 0.99 for a uniform unity field).NL2 Parser allows a user defined function of the x,y,z variables. All elements outside a cubic box defined by clipping_half_width are ignored. The parser is much slower than the equivalent c++ coded function...NL2 NL2 demie-largeur l : This parameter specifies the half width of the filterNL2 [ omega w ] : This parameter must be given for the gaussienne filter. It defines the standard deviation of the gaussian filter.NL2 [ expression string] : This parameter must be given for the parser filter type. This expression will be interpreted by the math parser with the predefined variables x, y and z.
lire_ideas interprete lire_ideas -1 Read a geom in a unv file. 3D tetra mesh elements only may be read by TRUST.
  attr nom_dom ref_domaine nom_dom 0 Name of domain.
  attr file chaine file 0 Name of file.
system interprete system -1 To run Unix commands from the data file. Example: System \'echo The End | mail trust@cea.fr\'
  attr cmd chaine cmd 0 command to execute.
redresser_hexaedres_vdf interprete redresser_hexaedres_vdf -1 Keyword to convert a domain (named domain_name) with quadrilaterals/VEF hexaedras which looks like rectangles/VDF hexaedras into a domain with real rectangles/VDF hexaedras.
  attr domain_name ref_domaine domain_name 0 Name of domain to resequence.
analyse_angle interprete analyse_angle -1 Keyword Analyse_angle prints the histogram of the largest angle of each mesh elements of the domain named name_domain. nb_histo is the histogram number of bins. It is called by default during the domain discretization with nb_histo set to 18. Useful to check the number of elements with angles above 90 degrees.
  attr domain_name ref_domaine domain_name 0 Name of domain to resequence.
  attr nb_histo entier nb_histo 0 not_set
remove_invalid_internal_boundaries interprete remove_invalid_internal_boundaries -1 Keyword to suppress an internal boundary of the domain_name domain. Indeed, some mesh tools may define internal boundaries (eg: for post processing task after the calculation) but TRUST does not support it yet.
  attr domain_name ref_domaine domain_name 0 Name of domain.
resequencing interprete reordonner -1 The Reordonner interpretor is required sometimes for a VDF mesh which is not produced by the internal mesher. Example where this is used: NL2 Read_file dom fichier.geom NL2 Reordonner dom NL2 Observations: This keyword is redundant when the mesh that is read is correctly sequenced in the TRUST sense. This significant mesh operation may take some time... The message returned by TRUST is not explicit when the Reordonner (Resequencing) keyword is required but not included in the data set...
  attr domain_name ref_domaine domain_name 0 Name of domain to resequence.
precisiongeom interprete precisiongeom 0 Class to change the way floating-point number comparison is done. By default, two numbers are equal if their absolute difference is smaller than 1e-10. The keyword is useful to modify this value. Moreover, nodes coordinates will be written in .geom files with this same precision.
  attr precision floattant precision 0 New value of precision.
nettoiepasnoeuds interprete nettoiepasnoeuds 0 Keyword NettoiePasNoeuds does not delete useless nodes (nodes without elements) from a domain.
  attr domain_name ref_domaine domain_name 0 Name of domain.
scatter interprete scatter 0 Class to read a partionned mesh in the files during a parallel calculation. The files are in binary format.
  attr file chaine file 0 Name of file.
  attr domaine ref_domaine domaine 0 Name of domain.
scattermed scatter scattermed 0 This keyword will read the partition of the domain_name domain into a the MED format files file.med created by Medsplitter.
listdeuxmots_sacc listobj nul 0 deuxmots 0 List of groups of two words (without curly brackets).
partitionneur_deriv objet_u partitionneur_deriv -1 not_set
  attr nb_parts entier nb_parts 1 The number of non empty parts that must be generated (generally equal to the number of processors in the parallel run).
partitionneur_metis partitionneur_deriv metis -1 Metis is an external partitionning library. It is a general algorithm that will generate a partition of the domain.
  attr kmetis rien kmetis 1 The default values are pmetis, default parameters are automatically chosen by Metis. \'kmetis\' is faster than pmetis option but the last option produces better partitioning quality. In both cases, the partitioning quality may be slightly improved by increasing the nb_essais option (by default N=1). It will compute N partitions and will keep the best one (smallest edge cut number). But this option is CPU expensive, taking N=10 will multiply the CPU cost of partitioning by 10. NL2 Experiments show that only marginal improvements can be obtained with non default parameters.
  attr use_weights rien use_weights 1 If use_weights is specified, weighting of the element-element links in the graph is used to force metis to keep opposite periodic elements on the same processor. This option can slightly improve the partitionning quality but it consumes more memory and takes more time. It is not mandatory since a correction algorithm is always applied afterwards to ensure a correct partitionning for periodic boundaries.
partitionneur_sous_zones partitionneur_deriv sous_zones -1 This algorithm will create one part for each specified subzone. All elements contained in the first subzone are put in the first part, all remaining elements contained in the second subzone in the second part, etc... NL2 If all elements of the domain are contained in the specified subzones, then N parts are created, otherwise, a supplemental part is created with the remaining elements. NL2 If no subzone is specified, all subzones defined in the domain are used to split the mesh.
  attr sous_zones listchaine sous_zones 0 N SUBZONE_NAME_1 SUBZONE_NAME_2 ...
partitionneur_tranche partitionneur_deriv tranche -1 This algorithm will create a geometrical partitionning by slicing the mesh in the two or three axis directions, based on the geometric center of each mesh element. nz must be given if dimension=3. Each slice contains the same number of elements (slices don\'t have the same geometrical width, and for VDF meshes, slice boundaries are generally not flat except if the number of mesh elements in each direction is an exact multiple of the number of slices). First, nx slices in the X direction are created, then each slice is split in ny slices in the Y direction, and finally, each part is split in nz slices in the Z direction. The resulting number of parts is nx*ny*nz. If one particular direction has been declared periodic, the default slicing (0, 1, 2, ..., n-1)is replaced by (0, 1, 2, ... n-1, 0), each of the two \'0\' slices having twice less elements than the other slices.
  attr tranches listentierf tranches 1 Partitioned by nx in the X direction, ny in the Y direction, nz in the Z direction. Works only for structured meshes. No warranty for unstructured meshes.
partitionneur_partition partitionneur_deriv partition -1 This algorithm re-use the partition of the domain named DOMAINE_NAME. It is useful to partition for example a post processing domain. The partition should match with the calculation domain.
  attr domaine ref_domaine domaine 0 domain name
partitionneur_fichier_decoupage partitionneur_deriv fichier_decoupage -1 This algorithm reads an array of integer values on the disc, one value for each mesh element. Each value is interpreted as the target part number n>=0 for this element. The number of parts created is the highest value in the array plus one. Empty parts can be created if some values are not present in the array. NL2 The file format is ASCII, and contains space, tab or carriage-return separated integer values. The first value is the number nb_elem of elements in the domain, followed by nb_elem integer values (positive or zero). NL2 This algorithm has been designed to work together with the \'ecrire_decoupage\' option. You can generate a partition with any other algorithm, write it to disc, modify it, and read it again to generate the .Zone files. NL2 Contrary to other partitioning algorithms, no correction is applied by default to the partition (eg. element 0 on processor 0 and corrections for periodic boundaries). If \'corriger_partition\' is specified, these corrections are applied.
  attr fichier chaine fichier 0 FILENAME
  attr corriger_partition rien corriger_partition 1 not_set
distance_paroi interprete distance_paroi 0 Class to generate external file Wall_length.xyz devoted for instance, for mixing length modelling. In this file, are saved the coordinates of each element (center of gravity) of dom domain and minimum distance between this point and boundaries (specified bords) that user specifies in data file (typically, those associated to walls). A field Distance_paroi is available to post process the distance to the wall.
  attr dom ref_domaine dom 0 Name of domain.
  attr bords listchaine bords 0 Boundaries.
  attr format chaine(into=["binaire","formatte"]) format 0 Value for format may be binaire (a binary file Wall_length.xyz is written) or formatte (moreover, a formatted file Wall_length_formatted.xyz is written).
troisf objet_lecture nul 0 Auxiliary class to extrude.
  attr lx floattant lx 0 X direction of the extrude operation.
  attr ly floattant ly 0 Y direction of the extrude operation.
  attr lz floattant lz 0 Z direction of the extrude operation.
extruder interprete extruder 1 Class to create a 3D tetrahedral/hexahedral mesh (a prism is cut in 14) from a 2D triangular/quadrangular mesh.
  attr domaine ref_domaine domain_name 0 Name of the domain.
  attr direction troisf direction 0 Direction of the extrude operation.
  attr nb_tranches entier nb_tranches 0 Number of elements in the extrusion direction.
extract_2d_from_3d interprete extract_2d_from_3d -1 Keyword to extract a 2D mesh by selecting a boundary of the 3D mesh. To generate a 2D axisymmetric mesh prefer Extract_2Daxi_from_3D keyword.
  attr dom3D ref_domaine dom3D 0 Domain name of the 3D mesh
  attr bord chaine bord 0 Boundary name. This boundary becomes the new 2D mesh and all the boundaries, in 3D, attached to the selected boundary, give their name to the new boundaries, in 2D.
  attr dom2D chaine dom2D 0 Domain name of the new 2D mesh
extract_2daxi_from_3d extract_2d_from_3d extract_2daxi_from_3d -1 Keyword to extract a 2D axisymetric mesh by selecting a boundary of the 3D mesh.
extruder_en3 extruder extruder_en3 1 Class to create a 3D tetrahedral/hexahedral mesh (a prism is cut in 3) from a 2D triangular/quadrangular mesh. The names of the boundaries (by default, devant (front) and derriere (back)) may be edited by the keyword nom_cl_devant and nom_cl_derriere. If NULL is written for nom_cl, then no boundary condition is generated at this place. NL2 Recommendation : to ensure conformity between meshes (in case of fluid/solid coupling) it is recommended to extrude all the domains at the same time.
  attr domaine listchaine domain_name 0 List of the domains
  attr nom_cl_devant chaine nom_cl_devant 1 New name of the first boundary.
  attr nom_cl_derriere chaine nom_cl_derriere 1 New name of the second boundary.
extruder_en20 interprete extruder_en20 1 It does the same task as Extruder except that a prism is cut into 20 tetraedra instead of 3. The name of the boundaries will be devant (front) and derriere (back). But you can change these names with the keyword RegroupeBord.
  attr domaine ref_domaine domain_name 0 Name of the domain.
  attr direction troisf direction 1 0 Direction of the extrude operation.
  attr nb_tranches entier nb_tranches 0 Number of elements in the extrusion direction.
extrudeparoi interprete extrudeparoi 1 Keyword dedicated in 3D (VEF) to create prismatic layer at wall. Each prism is cut into 3 tetraedra.
  attr domaine ref_domaine domain_name 0 Name of the domain.
  attr nom_bord chaine nom_bord 0 Name of the (no-slip) boundary for creation of prismatic layers.
  attr epaisseur list epaisseur 1 n r1 r2 .... rn : (relative or absolute) width for each layer.
  attr critere_absolu entier critere_absolu 1 relative (0, the default) or absolute (1) width for each layer.
  attr projection_normale_bord rien projection_normale_bord 1 keyword to project layers on the same plane that contiguous boundaries. defaut values are : epaisseur_relative 1 0.5 projection_normale_bord 1
frontiere_ouverte_fraction_massique_imposee condlim_base frontiere_ouverte_fraction_massique_imposee -1 not_set
  attr ch front_field_base ch 0 Boundary field type.
paroi_echange_contact_correlation_vdf condlim_base paroi_echange_contact_correlation_vdf 1 Class to define a thermohydraulic 1D model which will apply to a boundary of 2D or 3D domain. NL2 Warning : For parallel calculation, the only possible partition will be according the axis of the model with the keyword Tranche.
  attr dir entier dir 0 Direction (0 : axis X, 1 : axis Y, 2 : axis Z) of the 1D model.
  attr tinf floattant tinf 0 Inlet fluid temperature of the 1D model (oC or K).
  attr tsup floattant tsup 0 Outlet fluid temperature of the 1D model (oC or K).
  attr lambda chaine lambda_u 0 Thermal conductivity of the fluid (W.m-1.K-1).
  attr rho chaine rho 0 Mass density of the fluid (kg.m-3) which may be a function of the temperature T.
  attr cp floattant cp 0 Calorific capacity value at a constant pressure of the fluid (J.kg-1.K-1).
  attr dt_impr floattant dt_impr 0 Printing period in name_of_data_file_time.dat files of the 1D model results.
  attr mu chaine mu 0 Dynamic viscosity of the fluid (kg.m-1.s-1) which may be a function of thetemperature T.
  attr debit floattant debit 0 Surface flow rate (kg.s-1.m-2) of the fluid into the channel.
  attr dh floattant dh 0 Hydraulic diameter may be a function f(x) with x position along the 1D axis (xinf <= x <= xsup)
  attr volume chaine volume 0 Exact volume of the 1D domain (m3) which may be a function of the hydraulic diameter (Dh) and the lateral surface (S) of the meshed boundary.
  attr nu chaine nu 0 Nusselt number which may be a function of the Reynolds number (Re) and the Prandtl number (Pr).
  attr reprise_correlation rien reprise_correlation 1 Keyword in the case of a resuming calculation with this correlation.
paroi_echange_contact_correlation_vef condlim_base paroi_echange_contact_correlation_vef 1 Class to define a thermohydraulic 1D model which will apply to a boundary of 2D or 3D domain. NL2 Warning : For parallel calculation, the only possible partition will be according the axis of the model with the keyword Tranche_geom.
  attr dir entier dir 0 Direction (0 : axis X, 1 : axis Y, 2 : axis Z) of the 1D model.
  attr tinf floattant tinf 0 Inlet fluid temperature of the 1D model (oC or K).
  attr tsup floattant tsup 0 Outlet fluid temperature of the 1D model (oC or K).
  attr lambda chaine lambda_u 0 Thermal conductivity of the fluid (W.m-1.K-1).
  attr rho chaine rho 0 Mass density of the fluid (kg.m-3) which may be a function of the temperature T.
  attr cp floattant cp 0 Calorific capacity value at a constant pressure of the fluid (J.kg-1.K-1).
  attr dt_impr floattant dt_impr 0 Printing period in name_of_data_file_time.dat files of the 1D model results.
  attr mu chaine mu 0 Dynamic viscosity of the fluid (kg.m-1.s-1) which may be a function of thetemperature T.
  attr debit floattant debit 0 Surface flow rate (kg.s-1.m-2) of the fluid into the channel.
  attr dh floattant dh 0 Hydraulic diameter may be a function f(x) with x position along the 1D axis (xinf <= x <= xsup)
  attr n entier n 0 Number of 1D cells of the 1D mesh.
  attr surface chaine surface 0 Section surface of the channel which may be function f(Dh,x) of the hydraulic diameter (Dh) and x position along the 1D axis (xinf <= x <= xsup)
  attr nu chaine nu 0 Nusselt number which may be a function of the Reynolds number (Re) and the Prandtl number (Pr).
  attr xinf floattant xinf 0 Position of the inlet of the 1D mesh on the axis direction.
  attr xsup floattant xsup 0 Position of the outlet of the 1D mesh on the axis direction.
  attr emissivite_pour_rayonnement_entre_deux_plaques_quasi_infinies floattant emissivite_pour_rayonnement_entre_deux_plaques_quasi_infinies 1 Coefficient of emissivity for radiation between two quasi infinite plates.
  attr reprise_correlation rien reprise_correlation 1 Keyword in the case of a resuming calculation with this correlation.
spec_pdcr_base objet_lecture spec_pdcr_base 0 Class to read the source term modelling the presence of a bundle of tubes in a flow. Cf=A Re-B.
  attr ch_a chaine(into=["a","cf"]) ch_a 0 Keyword to be used to set law coefficient values for the coefficient of regular pressure losses.
  attr a floattant a 0 Value of a law coefficient for regular pressure losses.
  attr ch_b chaine(into=["b"]) ch_b 1 Keyword to be used to set law coefficient values for regular pressure losses.
  attr b floattant b 1 Value of a law coefficient for regular pressure losses.
longitudinale spec_pdcr_base longitudinale 0 Class to define the pressure loss in the direction of the tube bundle.
  attr dir chaine(into=["x","y","z"]) dir 0 Direction.
  attr dd floattant dd 0 Tube bundle hydraulic diameter value. This value is expressed in m.
transversale spec_pdcr_base transversale 0 Class to define the pressure loss in the direction perpendicular to the tube bundle.
  attr dir chaine(into=["x","y","z"]) dir 0 Direction.
  attr dd floattant dd 0 Value of the tube bundle step.
  attr chaine_d chaine(into=["d"]) chaine_d 0 Keyword to be used to set the value of the tube external diameter.
  attr d floattant d 0 Value of the tube external diameter.
perte_charge_reguliere source_base perte_charge_reguliere 0 Source term modelling the presence of a bundle of tubes in a flow.
  attr spec spec_pdcr_base spec 0 Description of longitudinale or transversale type.
  attr zone_name chaine name_of_zone 0 Name of the sub-area occupied by the tube bundle. A Sous_Zone (Sub-area) type object called zone_name should have been previously created.
pb_post Pb_base nul -1 not_set
info_med objet_lecture nul 0 not_set
  attr file_med chaine file_med 0 Name of the MED file.
  attr domaine chaine domaine 0 Name of domain.
  attr pb_post pb_post pb_post 0 not_set
list_info_med listobj nul -1 info_med 1 not_set
pbc_med pb_gen_base pbc_med 0 Allows to read med files and post-process them.
  attr list_info_med list_info_med list_info_med 0 not_set
decoupebord_pour_rayonnement interprete decoupebord_pour_rayonnement 1 To subdivide the external boundary of a domain into several parts (may be useful for better accuracy when using radiation model in transparent medium). To specify the boundaries of the fine_domain_name domain to be splitted. These boundaries will be cut according the coarse mesh defined by either the keyword domaine_grossier (each boundary face of the coarse mesh coarse_domain_name will be used to group boundary faces of the fine mesh to define a new boundary), either by the keyword nb_parts_naif (each boundary of the fine mesh is splitted into a partition with nx*ny*nz elements), either by a geometric condition given by a formulae with the keyword condition_geometrique. If used, the coarse_domain_name domain should have the same boundaries name of the fine_domain_name domain. NL2 A mesh file (ASCII format, except if binaire option is specified) named by default newgeom (or specified by the nom_fichier_sortie keyword) will be created and will contain the fine_domain_name domain with the splitted boundaries named boundary_name%I (where I is between from 0 and n-1). Furthermore, several files named boundary_name%I and boundary_name_xv will be created, containing the definition of the subdived boundaries. newgeom will be used to calculate view factors with geom2ansys script whereas only the boundary_name_xv files will be necessary for the radiation calculation. The file listb will contain the list of the boundaries boundary_name%I.
  attr domaine ref_domaine domaine 0 not_set
  attr domaine_grossier ref_domaine domaine_grossier 1 not_set
  attr nb_parts_naif listentier nb_parts_naif 1 not_set
  attr nb_parts_geom listentier nb_parts_geom 1 not_set
  attr bords_a_decouper listchaine bords_a_decouper 0 not_set
  attr nom_fichier_sortie chaine nom_fichier_sortie 1 not_set
  attr condition_geometrique listchaine condition_geometrique 1 not_set
  attr binaire entier binaire 1 not_set
methode_transport_deriv objet_lecture methode_transport_deriv 0 Basic class for method of transport of interface.
loi_horaire objet_u loi_horaire 1 to define the movement with a time-dependant law for the solid interface.
  attr position listchaine position 0 not_set
  attr vitesse listchaine vitesse 0 not_set
  attr rotation listchaine rotation 1 not_set
  attr derivee_rotation listchaine derivee_rotation 1 not_set
methode_loi_horaire methode_transport_deriv loi_horaire -1 not_set
  attr nom_loi ref_loi_horaire nom_loi 0 not_set
problem_read_generic Pb_base problem_read_generic -1 The probleme_read_generic differs rom the rest of the TRUST code : The problem does not state the number of equations that are enclosed in the problem. As the list of equations to be solved in the generic read problem is declared in the data file and not pre-defined in the structure of the problem, each equation has to be distinctively associated with the problem with the Associate keyword.
  ref eqn1 eqn_base
  ref eqn2 eqn_base
  ref eqn3 eqn_base
  ref eqn4 eqn_base
  ref eqn5 eqn_base
  ref eqn6 eqn_base
  ref eqn7 eqn_base
  ref eqn8 eqn_base
  ref eqn9 eqn_base
  ref eqn10 eqn_base
temperature traitement_particulier_base temperature -1 not_set
  attr bord chaine bord 0 not_set
  attr direction entier direction 0 not_set
canal traitement_particulier_base canal -1 Keyword for statistics on a periodic plane channel.
  attr dt_impr_moy_spat floattant dt_impr_moy_spat 1 Period to print the spatial average (default value is 1e6).
  attr dt_impr_moy_temp floattant dt_impr_moy_temp 1 Period to print the temporal average (default value is 1e6).
  attr debut_stat floattant debut_stat 1 Time to start the temporal averaging (default value is 1e6).
  attr fin_stat floattant fin_stat 1 Time to end the temporal averaging (default value is 1e6).
  attr pulsation_w floattant pulsation_w 1 Pulsation for phase averaging (in case of pulsating forcing term) (no default value).
  attr nb_points_par_phase entier nb_points_par_phase 1 Number of samples to represent phase average all along a period (no default value).
  attr reprise chaine reprise 1 val_moy_temp_xxxxxx.sauv : Keyword to resume a calculation with previous averaged quantities. NL2 Note that for thermal and turbulent problems, averages on temperature and turbulent viscosity are automatically calculated. To resume a calculation with phase averaging, val_moy_temp_xxxxxx.sauv_phase file is required on the directory where the job is submitted (this last file will be then automatically loaded by TRUST).
ec traitement_particulier_base ec -1 Keyword to print total kinetic energy into the referential linked to the domain (keyword Ec). In the case where the domain is moving into a Galilean referential, the keyword Ec_dans_repere_fixe will print total kinetic energy in the Galilean referential whereas Ec will print the value calculated into the moving referential linked to the domain
  attr Ec rien Ec 1 not_set
  attr Ec_dans_repere_fixe rien Ec_dans_repere_fixe 1 not_set
  attr periode floattant periode 1 periode is the keyword to set the period of printing into the file datafile_Ec.son or datafile_Ec_dans_repere_fixe.son.
thi traitement_particulier_base thi -1 Keyword for a THI (Homogeneous Isotropic Turbulence) calculation.
  attr init_Ec entier init_Ec 0 Keyword to renormalize initial velocity so that kinetic energy equals to the value given by keyword val_Ec.
  attr val_Ec floattant val_Ec 1 Keyword to impose a value for kinetic energy by velocity renormalizated if init_Ec value is 1.
  attr facon_init entier(into=["0","1"]) facon_init 1 Keyword to specify how kinetic energy is computed (0 or 1).
  attr calc_spectre entier(into=["0","1"]) calc_spectre 1 Calculate or not the spectrum of kinetic energy. NL2 Files called Sorties_THI are written with inside four columns : NL2 time:t global_kinetic_energy:Ec enstrophy:D skewness:S NL2 If calc_spectre is set to 1, a file Sorties_THI2_2 is written with three columns : NL2 time:t kinetic_energy_at_kc=32 enstrophy_at_kc=32 NL2 If calc_spectre is set to 1, a file spectre_xxxxx is written with two columns at each time xxxxx : NL2 frequency:k energy:E(k).
  attr periode_calc_spectre floattant periode_calc_spectre 1 Period for calculating spectrum of kinetic energy
  attr spectre_3D entier(into=["0","1"]) flag3D 1 Calculate or not the 3D spectrum
  attr spectre_1D entier(into=["0","1"]) flag1D 1 Calculate or not the 1D spectrum
  attr conservation_Ec rien conservation_Ec 1 If set to 1, velocity field will be changed as to have a constant kinetic energy (default 0)
  attr longueur_boite floattant longueur_boite 1 Length of the calculation domain
chmoy_faceperio traitement_particulier_base chmoy_faceperio 0 non documente
  attr bloc bloc_lecture bloc 0 not_set
extraire_plan interprete extraire_plan -3 This keyword extracts a plane mesh named domain_name (this domain should have been declared before) from the mesh of the pb_name problem. The plane can be either a triangle (defined by the keywords Origine, Point1, Point2 and Triangle), either a regular quadrangle (with keywords Origine, Point1 and Point2), or either a generalized quadrangle (with keywords Origine, Point1, Point2, Point3). The keyword Epaisseur specifies the thickness of volume around the plane which contains the faces of the extracted mesh. The keyword via_extraire_surface will create a plan and use Extraire_surface algorithm. Inverse_condition_element keyword then will be used in the case where the plane is a boundary not well oriented, and avec_certains_bords_pour_extraire_surface is the option related to the Extraire_surface option named avec_certains_bords.
  attr domaine ref_domaine domaine 0 domain_namme
  attr probleme ref_Pb_base probleme 0 pb_name
  attr epaisseur floattant epaisseur 0 not_set
  attr origine list origine 0 not_set
  attr point1 list point1 0 not_set
  attr point2 list point2 0 not_set
  attr point3 list point3 1 not_set
  attr triangle rien triangle 1 not_set
  attr via_extraire_surface rien via_extraire_surface 1 not_set
  attr inverse_condition_element rien inverse_condition_element 1 not_set
  attr avec_certains_bords_pour_extraire_surface listchaine avec_certains_bords_pour_extraire_surface 1 not_set
extraire_domaine interprete extraire_domaine -3 Keyword to create a new domain built with the domain elements of the pb_name problem verifying the two conditions given by Condition_elements. The problem pb_name should have been discretized.
  attr domaine ref_domaine domaine 0 Domain in which faces are saved
  attr probleme ref_Pb_base probleme 0 Problem from which faces should be extracted
  attr condition_elements chaine condition_elements 1 not_set
  attr sous_zone ref_sous_zone sous_zone 1 not_set
extraire_surface interprete extraire_surface -3 This keyword extracts a surface mesh named domain_name (this domain should have been declared before) from the mesh of the pb_name problem. The surface mesh is defined by one or two conditions. The first condition is about elements with Condition_elements. For example: Condition_elements x*x+y*y+z*z<1 NL2 Will define a surface mesh with external faces of the mesh elements inside the sphere of radius 1 located at (0,0,0). The second condition Condition_faces is useful to give a restriction.NL2 By default, the faces from the boundaries are not added to the surface mesh excepted if option avec_les_bords is given (all the boundaries are added), or if the option avec_certains_bords is used to add only some boundaries.
  attr domaine ref_domaine domaine 0 Domain in which faces are saved
  attr probleme ref_Pb_base probleme 0 Problem from which faces should be extracted
  attr condition_elements chaine condition_elements 1 not_set
  attr condition_faces chaine condition_faces 1 not_set
  attr avec_les_bords rien avec_les_bords 1 not_set
  attr avec_certains_bords listchaine avec_certains_bords 1 not_set
integrer_champ_med interprete integrer_champ_med 1 his keyword is used to calculate a flow rate from a velocity MED field read before. The method is either debit_total to calculate the flow rate on the whole surface, either integrale_en_z to calculate flow rates between z=zmin and z=zmax on nb_tranche surfaces. The output file indicates first the flow rate for the whole surface and then lists for each tranche : the height z, the surface average value, the surface area and the flow rate. For the debit_total method, only one tranche is considered.NL2 file :z Sum(u.dS)/Sum(dS) Sum(dS) Sum(u.dS)
  attr champ_med ref_champ_fonc_med champ_med 0 not_set
  attr methode chaine(into=["integrale_en_z","debit_total"]) methode 0 to choose between the integral following z or over the entire height (debit_total corresponds to zmin=-DMAXFLOAT, ZMax=DMAXFLOAT, nb_tranche=1)
  attr zmin floattant zmin 1 not_set
  attr zmax floattant zmax 1 not_set
  attr nb_tranche entier nb_tranche 1 not_set
  attr fichier_sortie chaine fichier_sortie 1 name of the output file, by default: integrale.
convection_amont convection_deriv amont 0 Keyword for upwind scheme for VDF or VEF discretizations. In VEF discretization equivalent to generic amont for TRUST version 1.5 or later. The previous upwind scheme can be used with the obsolete in future amont_old keyword.
convection_amont_old convection_deriv amont_old 0 Only for VEF discretization, obsolete keyword, see amont.
convection_centre convection_deriv centre 0 For VDF and VEF discretizations.
convection_centre4 convection_deriv centre4 0 For VDF and VEF discretizations.
convection_centre_old convection_deriv centre_old 0 Only for VEF discretization.
convection_di_l2 convection_deriv di_l2 0 Only for VEF discretization.
bloc_ef objet_lecture nul 0 not_set
  attr mot1 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot1 0 not_set
  attr val1 entier(into=[0,1]) val1 0 not_set
  attr mot2 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot2 0 not_set
  attr val2 entier(into=[0,1]) val2 0 not_set
  attr mot3 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot3 0 not_set
  attr val3 entier(into=[0,1]) val3 0 not_set
  attr mot4 chaine(into=["transportant_bar","transporte_bar","filtrer_resu","antisym"]) mot4 0 not_set
  attr val4 entier(into=[0,1]) val4 0 not_set
convection_ef convection_deriv ef 0 For VEF calculations, a centred convective scheme based on Finite Elements formulation can be called through the following data:NL2 NL2 Convection { EF transportant_bar val transporte_bar val antisym val filtrer_resu val }NL2 NL2 This scheme is 2nd order accuracy (and get better the property of kinetic energy conservation). Due to possible problems of instabilities phenomena, this scheme has to be coupled with stabilisation process (see Source_Qdm_lambdaup).These two last data are equivalent from a theoretical point of view in variationnal writing to : div(( u. grad ub , vb) - (u. grad vb, ub)), where vb corresponds to the filtered reference test functions.NL2 NL2 Remark:NL2 This class requires to define a filtering operator : see solveur_bar
  attr mot1 chaine(into=["defaut_bar"]) mot1 1 equivalent to transportant_bar 0 transporte_bar 1 filtrer_resu 1 antisym 1
  attr bloc_ef bloc_ef bloc_ef 1 not_set
convection_muscl3 convection_deriv muscl3 1 Keyword for a scheme using a ponderation between muscl and center schemes in VEF.
  attr alpha floattant alpha 1 To weight the scheme centering with the factor double (between 0 (full centered) and 1 (muscl), by default 1).
sous_zone_valeur objet_lecture nul 0 Two words.
  attr sous_zone ref_sous_zone sous_zone 0 sous zone
  attr valeur floattant valeur 0 value
listsous_zone_valeur listobj nul 0 sous_zone_valeur 0 List of groups of two words.
convection_ef_stab convection_deriv ef_stab 1 Keyword for a VEF convective scheme.
  attr alpha floattant alpha 1 To weight the scheme centering with the factor double (between 0 (full centered) and 1 (mix between upwind and centered), by default 1). For scalar equation, it is adviced to use alpha=1 and for the momentum equation, alpha=0.2 is adviced.
  attr test entier test 1 Developer option to compare old and new version of EF_stab
  attr tdivu rien tdivu 1 To have the convective operator calculated as div(TU)-TdivU(=UgradT).
  attr old rien old 1 To use old version of EF_stab scheme (default no).
  attr volumes_etendus rien volumes_etendus 1 Option for the scheme to use the extended volumes (default, yes).
  attr volumes_non_etendus rien volumes_non_etendus 1 Option for the scheme to not use the extended volumes (default, no).
  attr amont_sous_zone ref_sous_zone amont_sous_zone 1 Option to degenerate EF_stab scheme into Amont (upwind) scheme in the sub zone of name sz_name. The sub zone may be located arbitrarily in the domain but the more often this option will be activated in a zone where EF_stab scheme generates instabilities as for free outlet for example.
  attr alpha_sous_zone listsous_zone_valeur alpha_sous_zone 1 Option to change locally the alpha value on N sub-zones named sub_zone_name_I. Generally, it is used to prevent from a local divergence by increasing locally the alpha parameter.
convection_generic convection_deriv generic 0 Keyword for generic calling of upwind and muscl convective scheme in VEF discretization. For muscl scheme, limiters and order for fluxes calculations have to be specified. The available limiters are : minmod - vanleer -vanalbada - chakravarthy - superbee, and the order of accuracy is 1 or 2. Note that chakravarthy is a non-symmetric limiter and superbee may engender results out of physical limits. By consequence, these two limiters are not recommended. NL2 Examples: NL2 convection { generic amont }NL2 convection { generic muscl minmod 1 }NL2 convection { generic muscl vanleer 2 }NL2 NL2 In case of results out of physical limits with muscl scheme (due for instance to strong non-conformal velocity flow field), user can redefine in data file a lower order and a smoother limiter, as : convection { generic muscl minmod 1 }
  attr type chaine(into=["amont","muscl","centre"]) type 0 type of scheme
  attr limiteur chaine(into=["minmod","vanleer","vanalbada","chakravarthy","superbee"]) limiteur 1 type of limiter
  attr ordre entier(into=[1,2,3]) ordre 1 order of accuracy
  attr alpha floattant alpha 1 alpha
convection_kquick convection_deriv kquick 0 Only for VEF discretization.
convection_muscl convection_deriv muscl 0 Keyword for muscl scheme in VEF discretization equivalent to generic muscl vanleer 2 for the 1.5 version or later. The previous muscl scheme can be used with the obsolete in future muscl_old keyword.
convection_muscl_old convection_deriv muscl_old 0 Only for VEF discretization.
convection_muscl_new convection_deriv muscl_new 0 Only for VEF discretization.
convection_negligeable convection_deriv negligeable 0 For VDF and VEF discretizations. Suppresses the convection operator.
convection_quick convection_deriv quick 0 Only for VDF discretization.
diffusion_negligeable diffusion_deriv negligeable 0 the diffusivity will not taken in count
bloc_diffusion_standard objet_lecture nul 0 grad_Ubar 1 makes the gradient calculated through the filtered values of velocity (P1-conform).NL2 nu 1 (respectively nut 1) takes the molecular viscosity (eddy viscosity) into account in the velocity gradient part of the diffusion expression. NL2 nu_transp 1 (respectively nut_transp 1) takes the molecular viscosity (eddy viscosity) into account according in the TRANSPOSED velocity gradient part of the diffusion expression.NL2 filtrer_resu 1 allows to filter the resulting diffusive fluxes contribution.
  attr mot1 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot1 0 not_set
  attr val1 entier(into=[0,1]) val1 0 not_set
  attr mot2 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot2 0 not_set
  attr val2 entier(into=[0,1]) val2 0 not_set
  attr mot3 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot3 0 not_set
  attr val3 entier(into=[0,1]) val3 0 not_set
  attr mot4 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot4 0 not_set
  attr val4 entier(into=[0,1]) val4 0 not_set
  attr mot5 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot5 0 not_set
  attr val5 entier(into=[0,1]) val5 0 not_set
  attr mot6 chaine(into=["grad_Ubar","nu","nut","nu_transp","nut_transp","filtrer_resu"]) mot6 0 not_set
  attr val6 entier(into=[0,1]) val6 0 not_set
difusion_p1b diffusion_deriv p1b 0 not_set
diffusion_p1ncp1b diffusion_deriv p1ncp1b 1 not_set
diffusion_stab diffusion_deriv stab 1 keyword allowing consistent and stable calculations even in case of obtuse angle meshes.
  attr standard entier standard 1 to recover the same results as calculations made by standard laminar diffusion operator. However, no stabilization technique is used and calculations may be unstable when working with obtuse angle meshes (by default 0)
  attr info entier info 1 developer option to get the stabilizing ratio (by default 0)
  attr new_jacobian entier new_jacobian 1 when implicit time schemes are used, this option defines a new jacobian that may be more suitable to get stationary solutions (by default 0)
  attr nu entier nu 1 (respectively nut 1) takes the molecular viscosity (resp. eddy viscosity) into account in the velocity gradient part of the diffusion expression (by default nu=1 and nut=1)
  attr nut entier nut 1 not_set
  attr nu_transp entier nu_transp 1 (respectively nut_transp 1) takes the molecular viscosity (resp. eddy viscosity) into account in the transposed velocity gradient part of the diffusion expression (by default nu_transp=0 and nut_transp=1)
  attr nut_transp entier nut_transp 1 not_set
diffusion_standard diffusion_deriv standard 0 A new keyword, intended for LES calculations, has been developed to optimise and parameterise each term of the diffusion operator. Remark:NL2 NL2 1. This class requires to define a filtering operator : see solveur_barNL2 2. The former (original) version: diffusion { } -which omitted some of the term of the diffusion operator- can be recovered by using the following parameters in the new class :NL2 diffusion { standard grad_Ubar 0 nu 1 nut 1 nu_transp 0 nut_transp 1 filtrer_resu 0}.
  attr mot1 chaine(into=["defaut_bar"]) mot1 1 equivalent to grad_Ubar 1 nu 1 nut 1 nu_transp 1 nut_transp 1 filtrer_resu 1
  attr bloc_diffusion_standard bloc_diffusion_standard bloc_diffusion_standard 1 not_set
reaction objet_lecture nul 1 Keyword to describe reaction: NL2 w =K pow(T,beta) exp(-Ea/( R T)) $\Pi$ pow(Reactif_i,activitivity_i). NL2 If K_inv >0, NL2 w= K pow(T,beta) exp(-Ea/( R T)) ( $\Pi$ pow(Reactif_i,activitivity_i) - Kinv/exp(-c_r_Ea/(R T)) $\Pi$ pow(Produit_i,activitivity_i ))
  attr reactifs chaine reactifs 0 LHS of equation (ex CH4+2*O2)
  attr produits chaine produits 0 RHS of equation (ex CO2+2*H20)
  attr constante_taux_reaction floattant constante_taux_reaction 1 constante of cinetic K
  attr coefficients_activites bloc_lecture coefficients_activites 1 coefficients od ativity (exemple { CH4 1 O2 2 })
  attr enthalpie_reaction floattant enthalpie_reaction 0 DH
  attr energie_activation floattant energie_activation 0 Ea
  attr exposant_beta floattant exposant_beta 0 Beta
  attr contre_reaction floattant contre_reaction 1 K_inv
  attr contre_energie_activation floattant contre_energie_activation 1 c_r_Ea
reactions listobj nul 1 reaction 1 list of reactions
chimie objet_u chimie 1 Keyword to describe the chmical reactions
  attr reactions reactions reactions 0 list of reactions
  attr modele_micro_melange entier modele_micro_melange 1 modele_micro_melange (0 by default)
  attr constante_modele_micro_melange floattant constante_modele_micro_melange 1 constante of modele (1 by default)
  attr espece_en_competition_micro_melange chaine espece_en_competition_micro_melange 1 espece in competition in reactions
rectify_mesh interprete rectify_mesh -1 Keyword to raffine a mesh
  attr domain_name ref_domaine domain_name 0 Name of domain.
verifier_simplexes interprete verifier_simplexes -1 Keyword to raffine a simplexes
  attr domain_name ref_domaine domain_name 0 Name of domain.
verifier_qualite_raffinements interprete verifier_qualite_raffinements 0 not_set
  attr domain_names vect_nom domain_names 0 not_set
schema_adams_bashforth_order_2 schema_temps_base schema_adams_bashforth_order_2 -1 not_set
schema_adams_bashforth_order_3 schema_temps_base schema_adams_bashforth_order_3 -1 not_set
schema_adams_moulton_order_2 schema_implicite_base schema_adams_moulton_order_2 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_adams_moulton_order_3 schema_implicite_base schema_adams_moulton_order_3 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_backward_differentiation_order_2 schema_implicite_base schema_backward_differentiation_order_2 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
schema_backward_differentiation_order_3 schema_implicite_base schema_backward_differentiation_order_3 -1 not_set
  attr facsec_max floattant facsec_max 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
ef discretisation_base ef -1 Element Finite discretization.
diffusion_option diffusion_deriv option 0 not_set
  attr bloc_lecture bloc_lecture bloc_lecture 0 not_set
testeur_medcoupling interprete testeur_medcoupling 0 not_set
  attr pb_name chaine pb_name 0 Name of domain.
  attr field_name chaine filed_name 0 Name of domain.
champ_front_normal_vef front_field_base champ_front_normal_vef 0 Field to define the normal vector field standard at the boundary in VEF discretization.
  attr mot chaine(into=["valeur_normale"]) mot 0 Name of vector field.
  attr vit_tan floattant vit_tan 0 normal vector value (positive value for a vector oriented outside to inside).
loi_fermeture_test loi_fermeture_base loi_fermeture_test -1 Loi for test only 
  attr coef floattant coef 1 coefficient
loi_fermeture_base objet_u loi_fermeture_base -3 Class for appends fermeture to problem 
scalaire_impose_paroi dirichlet scalaire_impose_paroi 0 Imposed temperature condition at the wall called bord (edge). 
  attr ch front_field_base ch 0 Boundary field type.
bloc_pdf_model objet_lecture nul 1 not_set
  attr eta floattant eta 0 penalization coefficient
  attr temps_relaxation_coefficient_PDF floattant temps_relaxation_coefficient_PDF 1 time relaxation on the forcing term to help   
  attr echelle_relaxation_coefficient_PDF floattant echelle_relaxation_coefficient_PDF 1 time relaxation on the forcing term to help convergence
  attr local rien local 1 rien whether the prescribed velocity is expressed in the global or local basis
  attr vitesse_imposee_data field_base vitesse_imposee_data 1 Prescribed velocity as a field
  attr vitesse_imposee_fonction troismots vitesse_imposee_fonction 1 Prescribed velocity as a set of ananlytical component
interpolation_ibm_base objet_u interpolation_ibm_base 0 Base class for all the interpolation methods available in the Immersed Boundary Method (IBM).
interpolation_ibm_elem_fluid interpolation_ibm_base ibm_element_fluide 1 Immersed Boundary Method (IBM): fluid element interpolation.
  attr points_fluides field_base points_fluides 0 Node field giving the projection of the point below (points_solides) falling into the pure cell fluid
  attr points_solides field_base points_solides 1 Node field giving the projection of the node on the immersed boundary
  attr elements_fluides field_base elements_fluides 1 Node field giving the number of the element (cell) containing the pure fluid point
  attr correspondance_elements field_base correspondance_elements 1 Cell field giving the SALOME cell number
create_domain_from_sous_zone Create_domain_from_sub_domain create_domain_from_sous_zone -1 kept for backward compatibility. please use Create_domain_from_sub_domain
parametre_implicite parametre_equation_base parametre_implicite -1 Keyword to change for this equation only the parameter of the implicit scheme used to solve the problem. 
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 1 Keyword to change for this equation only the value of seuil_convergence_implicite used in the implicit scheme.
  attr seuil_convergence_solveur floattant seuil_convergence_solveur 1 Keyword to change for this equation only the value of seuil_convergence_solveur used in the implicit scheme
  attr solveur solveur_sys_base solveur 1 Keyword to change for this equation only the solver used in the implicit scheme
  attr resolution_explicite rien resolution_explicite 1 To solve explicitly the equation whereas the scheme is an implicit scheme.
  attr equation_non_resolue rien equation_non_resolue 1 Keyword to specify that the equation is not solved.
  attr equation_frequence_resolue chaine equation_frequence_resolue 1 Keyword to specify that the equation is solved only every n time steps (n is an integer or given by a time-dependent function f(t)).
parametre_diffusion_implicite parametre_equation_base parametre_diffusion_implicite -1 To specify additional parameters for the equation when using impliciting diffusion 
  attr crank entier(into=[0,1]) crank 1 Use (1) or not (0, default) a Crank Nicholson method for the diffusion implicitation algorithm. Setting crank to 1 increases the order of the algorithm from 1 to 2.
  attr preconditionnement_diag entier(into=[0,1]) preconditionnement_diag 1 The CG used to solve the implicitation of the equation diffusion operator is not preconditioned by default. If this option is set to 1, a diagonal preconditionning is used. Warning: this option is not necessarily more efficient, depending on the treated case.
  attr niter_max_diffusion_implicite entier niter_max_diffusion_implicite 1 Change the maximum number of iterations for the CG (Conjugate Gradient) algorithm when solving the diffusion implicitation of the equation.
  attr seuil_diffusion_implicite floattant seuil_diffusion_implicite 1 Change the threshold convergence value used by default for the CG resolution for the diffusion implicitation of this equation.
  attr solveur solveur_sys_base solveur 1 Method (different from the default one, Conjugate Gradient) to solve the linear system.
runge_kutta_ordre_2_classique schema_temps_base runge_kutta_ordre_2_classique -1 This is a classical Runge-Kutta scheme of second order that uses 2 integration points. 
runge_kutta_ordre_3_classique schema_temps_base runge_kutta_ordre_3_classique -1 This is a classical Runge-Kutta scheme of third order that uses 3 integration points. 
runge_kutta_ordre_4_classique schema_temps_base runge_kutta_ordre_4_classique -1 This is a classical Runge-Kutta scheme of fourth order that uses 4 integration points. 
runge_kutta_ordre_4_classique_3_8 schema_temps_base runge_kutta_ordre_4_classique_3_8 -1 This is a classical Runge-Kutta scheme of fourth order that uses 4 integration points and the 3/8 rule. 
schema_euler_implicite schema_implicite_base scheme_euler_implicit -1 This is the Euler implicit scheme. 
  attr facsec_max floattant facsec_max 1 1 Maximum ratio allowed between time step and stability time returned by CFL condition. The initial ratio given by facsec keyword is changed during the calculation with the implicit scheme but it couldn\'t be higher than facsec_max value.NL2 Warning: Some implicit schemes do not permit high facsec_max, example Schema_Adams_Moulton_order_3 needs facsec=facsec_max=1. NL2 Advice:NL2 The calculation may start with a facsec specified by the user and increased by the algorithm up to the facsec_max limit. But the user can also choose to specify a constant facsec (facsec_max will be set to facsec value then). Faster convergence has been seen and depends on the kind of calculation: NL2-Hydraulic only or thermal hydraulic with forced convection and low coupling between velocity and temperature (Boussinesq value beta low), facsec between 20-30NL2-Thermal hydraulic with forced convection and strong coupling between velocity and temperature (Boussinesq value beta high), facsec between 90-100 NL2-Thermohydralic with natural convection, facsec around 300NL2 -Conduction only, facsec can be set to a very high value (1e8) as if the scheme was unconditionally stableNL2These values can also be used as rule of thumb for initial facsec with a facsec_max limit higher.
  attr resolution_monolithique bloc_lecture resolution_monolithique 1 Activate monolithic resolution for coupled problems. Solves together the equations corresponding to the application domains in the given order. All aplication domains of the coupled equations must be given to determine the order of resolution. If the monolithic solving is not wanted for a specific application domain, an underscore can be added as prefix. For example, resolution_monolithique { dom1 { dom2 dom3 } _dom4 } will solve in a single matrix the equations having dom1 as application domain, then the equations having dom2 or dom3 as application domain in a single matrix, then the equations having dom4 as application domain in a sequential way (not in a single matrix).
runge_kutta_rationnel_ordre_2 schema_temps_base runge_kutta_rationnel_ordre_2 -1 This is the Runge-Kutta rational scheme of second order. The method is described in the note: Wambeck - Rational Runge-Kutta methods for solving systems of ordinary differential equations, at the link: https://link.springer.com/article/10.1007/BF02252381. Although rational methods require more computational work than linear ones, they can have some other properties, such as a stable behaviour with explicitness, which make them preferable. The CFD application of this RRK2 scheme is described in the note: https://link.springer.com/content/pdf/10.1007\%2F3-540-13917-6_112.pdf. 
runge_kutta_ordre_2 schema_temps_base runge_kutta_ordre_2 -1 This is a low-storage Runge-Kutta scheme of second order that uses 2 integration points. The method is presented by Williamson (case 1) in https://www.sciencedirect.com/science/article/pii/0021999180900339 
runge_kutta_ordre_3 schema_temps_base runge_kutta_ordre_3 -1 This is a low-storage Runge-Kutta scheme of third order that uses 3 integration points. The method is presented by Williamson (case 7) in https://www.sciencedirect.com/science/article/pii/0021999180900339 
runge_kutta_ordre_4 schema_temps_base runge_kutta_ordre_4 -1 This is a low-storage Runge-Kutta scheme of fourth order that uses 3 integration points. The method is presented by Williamson (case 17) in https://www.sciencedirect.com/science/article/pii/0021999180900339 
DomaineAxi1d domaine DomaineAxi1d -1 1D domain 
bloc_pave objet_lecture nul -1 Class to create a pave. 
  attr Origine listf Origine 1 Keyword to define the pave (block) origin, that is to say one of the 8 block points (or 4 in a 2D coordinate system).
  attr longueurs listf longueurs 1 Keyword to define the block dimensions, that is to say knowing the origin, length along the axes.
  attr nombre_de_noeuds listentierf nombre_de_noeuds 1 Keyword to define the discretization (nodenumber) in each direction.
  attr facteurs listf facteurs 1 Keyword to define stretching factors for mesh discretization in each direction. This is a real number which must be positive (by default 1.0). A stretching factor other than 1 allows refinement on one edge in one direction.
  attr symx rien symx 1 Keyword to define a block mesh that is symmetrical with respect to the YZ plane (respectively Y-axis in 2D) passing through the block centre.
  attr symy rien symy 1 Keyword to define a block mesh that is symmetrical with respect to the XZ plane (respectively X-axis in 2D) passing through the block centre.
  attr symz rien symz 1 Keyword defining a block mesh that is symmetrical with respect to the XY plane passing through the block centre.
  attr xtanh floattant xtanh 1 Keyword to generate mesh with tanh (hyperbolic tangent) variation in the X-direction.
  attr xtanh_dilatation entier(into=[-1,0,1]) xtanh_dilatation 1 Keyword to generate mesh with tanh (hyperbolic tangent) variation in the X-direction. xtanh_dilatation: The value may be -1,0,1 (0 by default): 0: coarse mesh at the middle of the channel and smaller near the walls -1: coarse mesh at the left side of the channel and smaller at the right side 1: coarse mesh at the right side of the channel and smaller near the left side of the channel.
  attr xtanh_taille_premiere_maille floattant xtanh_taille_premiere_maille 1 Size of the first cell of the mesh with tanh (hyperbolic tangent) variation in the X-direction.
  attr ytanh floattant ytanh 1 Keyword to generate mesh with tanh (hyperbolic tangent) variation in the Y-direction.
  attr ytanh_dilatation entier(into=[-1,0,1]) ytanh_dilatation 1 Keyword to generate mesh with tanh (hyperbolic tangent) variation in the Y-direction. ytanh_dilatation: The value may be -1,0,1 (0 by default): 0: coarse mesh at the middle of the channel and smaller near the walls -1: coarse mesh at the bottom of the channel and smaller near the top 1: coarse mesh at the top of the channel and smaller near the bottom.
  attr ytanh_taille_premiere_maille floattant ytanh_taille_premiere_maille 1 Size of the first cell of the mesh with tanh (hyperbolic tangent) variation in the Y-direction.
  attr ztanh floattant ztanh 1 Keyword to generate mesh with tanh (hyperbolic tangent) variation in the Z-direction.
  attr ztanh_dilatation entier(into=[-1,0,1]) ztanh_dilatation 1 Keyword to generate mesh with tanh (hyperbolic tangent) variation in the Z-direction. tanh_dilatation: The value may be -1,0,1 (0 by default): 0: coarse mesh at the middle of the channel and smaller near the walls -1: coarse mesh at the back of the channel and smaller near the front 1: coarse mesh at the front of the channel and smaller near the back.
  attr ztanh_taille_premiere_maille floattant ztanh_taille_premiere_maille 1 Size of the first cell of the mesh with tanh (hyperbolic tangent) variation in the Z-direction.
polyedriser interprete polyedriser -1 cast hexahedra into polyhedra so that the indexing of the mesh vertices is compatible with PolyMAC discretization. Must be used in PolyMAC discretization if a hexahedral mesh has been produced with TRUST\'s internal mesh generator. 
  attr domain_name ref_domaine domain_name 0 Name of domain.
Raffiner_isotrope_parallele interprete Raffiner_isotrope_parallele 1 Refine parallel mesh in parallel 
  attr name_of_initial_domaines|name_of_initial_zones chaine name_of_initial_domaines 0 name of initial Domaines
  attr name_of_new_domaines|name_of_new_zones chaine name_of_new_domaines 0 name of new Domaines
  attr ascii rien ascii 1 writing Domaines in ascii format
  attr single_hdf rien single_hdf 1 writing Domaines in hdf format
Create_domain_from_sub_domain interprete_geometrique_base Create_domain_from_sub_domain 1 This keyword fills the domain domaine_final with the subdomaine par_sous_zone from the domain domaine_init. It is very useful when meshing several mediums with Gmsh. Each medium will be defined as a subdomaine into Gmsh. A MED mesh file will be saved from Gmsh and read with Lire_Med keyword by the TRUST data file. And with this keyword, a domain will be created for each medium in the TRUST data file. 
  attr domaine_final ref_domaine domaine_final 1 new domain in which faces are stored
  attr par_sous_zone chaine par_sous_zone 1 a sub-area allowing to choose the elements
  attr domaine_init ref_domaine domaine_init 0 initial domain
modifydomaineAxi1d interprete modifydomaineAxi1d 0 Convert a 1D mesh to 1D axisymmetric mesh 
  attr dom chaine dom 0 not_set
  attr bloc bloc_lecture bloc 0 not_set
extrudebord interprete extrudebord 1 Class to generate an extruded mesh from a boundary of a tetrahedral or an hexahedral mesh. NL2 Warning: If the initial domain is a tetrahedral mesh, the boundary will be moved in the XY plane then extrusion will be applied (you should maybe use the Transformer keyword on the final domain to have the domain you really want). You can use the keyword Ecrire_Fichier_Meshtv to generate a meshtv file to visualize your initial and final meshes. NL2 This keyword can be used for example to create a periodic box extracted from a boundary of a tetrahedral or a hexaedral mesh. This periodic box may be used then to engender turbulent inlet flow condition for the main domain.NL2 Note that ExtrudeBord in VEF generates 3 or 14 tetrahedra from extruded prisms. 
  attr domaine_init ref_domaine domaine_init 0 Initial domain with hexaedras or tetrahedras.
  attr direction listf direction 0 Directions for the extrusion.
  attr nb_tranches entier nb_tranches 0 Number of elements in the extrusion direction.
  attr domaine_final chaine domaine_final 0 Extruded domain.
  attr nom_bord chaine nom_bord 0 Name of the boundary of the initial domain where extrusion will be applied.
  attr hexa_old rien hexa_old 1 Old algorithm for boundary extrusion from a hexahedral mesh.
  attr trois_tetra rien trois_tetra 1 To extrude in 3 tetrahedras instead of 14 tetrahedras.
  attr vingt_tetra rien vingt_tetra 1 To extrude in 20 tetrahedras instead of 14 tetrahedras.
  attr sans_passer_par_le2d entier sans_passer_par_le2d 1 Only for non-regression
interprete_geometrique_base interprete interprete_geometrique_base -1 Class for interpreting a data file 
corriger_frontiere_periodique interprete corriger_frontiere_periodique 1 The Corriger_frontiere_periodique keyword is mandatory to first define the periodic boundaries, to reorder the faces and eventually fix unaligned nodes of these boundaries. Faces on one side of the periodic domain are put first, then the faces on the opposite side, in the same order. It must be run in sequential before mesh splitting. 
  attr domaine chaine domaine 0 Name of domain.
  attr bord chaine bord 0 the name of the boundary (which must contain two opposite sides of the domain)
  attr direction list direction 1 defines the periodicity direction vector (a vector that points from one node on one side to the opposite node on the other side). This vector must be given if the automatic algorithm fails, that is:NL2 - when the node coordinates are not perfectly periodic NL2 - when the periodic direction is not aligned with the normal vector of the boundary faces
  attr fichier_post chaine fichier_post 1 .
refine_mesh interprete refine_mesh 0 not_set 
  attr domaine ref_domaine domaine 0 not_set
partition_multi interprete decouper_multi 0 allows to partition multiple domains in contact with each other in parallel: necessary for resolution monolithique in implicit schemes and for all coupled problems using PolyMAC. By default, this keyword is commented in the reference test cases. 
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr domaine1 chaine(into=["domaine"]) domaine1 0 not set.
  attr dom ref_domaine dom 0 Name of the first domain to be cut.
  attr blocdecoupdom1 bloc_decouper blocdecoupdom1 0 Partition bloc for the first domain.
  attr domaine2 chaine(into=["domaine"]) domaine2 0 not set.
  attr dom2 ref_domaine dom2 0 Name of the second domain to be cut.
  attr blocdecoupdom2 bloc_decouper blocdecoupdom2 0 Partition bloc for the second domain.
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
partitionneur_sous_domaines partitionneur_deriv partitionneur_sous_domaines -1 This algorithm will create one part for each specified subdomaine/domain. All elements contained in the first subdomaine/domain are put in the first part, all remaining elements contained in the second subdomaine/domain in the second part, etc... NL2 If all elements of the current domain are contained in the specified subdomaines/domain, then N parts are created, otherwise, a supplemental part is created with the remaining elements. NL2 If no subdomaine is specified, all subdomaines defined in the domain are used to split the mesh. 
  attr sous_zones listchaine sous_zones 1 N SUBZONE_NAME_1 SUBZONE_NAME_2 ...
  attr domaines listchaine domaines 1 N DOMAIN_NAME_1 DOMAIN_NAME_2 ...
Partitionneur_Fichier_MED partitionneur_deriv fichier_med -1 Partitioning a domain using a MED file containing an integer field providing for each element the processor number on which the element should be located. 
  attr file chaine file 0 file name of the MED file to load
  attr field chaine field 0 field name of the integer field to load
partition interprete decouper -1 Class for parallel calculation to cut a domain for each processor. By default, this keyword is commented in the reference test cases. 
  attr domaine ref_domaine domaine 0 Name of the domain to be cut.
  attr bloc_decouper bloc_decouper bloc_decouper 0 Description how to cut a domain.
bloc_decouper objet_lecture nul 1 Auxiliary class to cut a domain. 
  attr partitionneur|Partition_tool partitionneur_deriv partitionneur 1 Defines the partitionning algorithm (the effective C++ object used is \'Partitionneur_ALGORITHM_NAME\').
  attr larg_joint entier larg_joint 1 This keyword specifies the thickness of the virtual ghost domaine (data known by one processor though not owned by it). The default value is 1 and is generally correct for all algorithms except the QUICK convection scheme that require a thickness of 2. Since the 1.5.5 version, the VEF discretization imply also a thickness of 2 (except VEF P0). Any non-zero positive value can be used, but the amount of data to store and exchange between processors grows quickly with the thickness.
  attr nom_zones chaine zones_name 1 Name of the files containing the different partition of the domain. The files will be : NL2 name_0001.Zones NL2 name_0002.Zones NL2 ... NL2 name_000n.Zones. If this keyword is not specified, the geometry is not written on disk (you might just want to generate a \'ecrire_decoupage\' or \'ecrire_lata\').
  attr ecrire_decoupage chaine ecrire_decoupage 1 After having called the partitionning algorithm, the resulting partition is written on disk in the specified filename. See also partitionneur Fichier_Decoupage. This keyword is useful to change the partition numbers: first, you write the partition into a file with the option ecrire_decoupage. This file contains the domaine number for each element\'s mesh. Then you can easily permute domaine numbers in this file. Then read the new partition to create the .Zones files with the Fichier_Decoupage keyword.
  attr ecrire_lata chaine ecrire_lata 1 not_set
  attr nb_parts_tot entier nb_parts_tot 1 Keyword to generates N .Domaine files, instead of the default number M obtained after the partitionning algorithm. N must be greater or equal to M. This option might be used to perform coupled parallel computations. Supplemental empty domaines from M to N-1 are created. This keyword is used when you want to run a parallel calculation on several domains with for example, 2 processors on a first domain and 10 on the second domain because the first domain is very small compare to second one. You will write Nb_parts 2 and Nb_parts_tot 10 for the first domain and Nb_parts 10 for the second domain.
  attr periodique listchaine periodique 1 N BOUNDARY_NAME_1 BOUNDARY_NAME_2 ... : N is the number of boundary names given. Periodic boundaries must be declared by this method. The partitionning algorithm will ensure that facing nodes and faces in the periodic boundaries are located on the same processor.
  attr reorder entier reorder 1 If this option is set to 1 (0 by default), the partition is renumbered in order that the processes which communicate the most are nearer on the network. This may slighlty improves parallel performance.
  attr single_hdf rien single_hdf 1 Optional keyword to enable you to write the partitioned domaines in a single file in hdf5 format.
  attr print_more_infos entier print_more_infos 1 If this option is set to 1 (0 by default), print infos about number of remote elements (ghosts) and additional infos about the quality of partitionning. Warning, it slows down the cutting operations.
partitionneur_sous_domaine partitionneur_deriv sous_domainE -1 Given a global partition of a global domain, \'sous-domaine\' allows to produce a conform partition of a sub-domain generated from the bigger one using the keyword create_domain_from_sous_domaine. The sub-domain will be partitionned in a conform fashion with the global domain. 
  attr fichier chaine fichier 0 fichier
  attr fichier_ssz chaine fichier_ssz 0 fichier sous zonne
partitionneur_union partitionneur_deriv union 0 Let several local domains be generated from a bigger one using the keyword create_domain_from_sous_domaine, and let their partitions be generated in the usual way. Provided the list of partition files for each small domain, the keyword \'union\' will partition the global domain in a conform fashion with the smaller domains. 
  attr liste bloc_lecture liste 0 List of the partition files with the following syntaxe: {sous_domaine1 decoupage1 ... sous_domaineim decoupageim } where sous_domaine1 ... sous_zomeim are small domains names and decoupage1 ... decoupageim are partition files.
interpolation_ibm_mean_gradient interpolation_ibm_base ibm_gradient_moyen 1 Immersed Boundary Method (IBM): mean gradient interpolation. 
  attr points_solides field_base points_solides 0 Node field giving the projection of the node on the immersed boundary
  attr est_dirichlet field_base est_dirichlet 0 Node field of booleans indicating whether the node belong to an element where the interface is
  attr correspondance_elements field_base correspondance_elements 0 Cell field giving the SALOME cell number
  attr elements_solides field_base elements_solides 0 Node field giving the element number containing the solid point
interpolation_ibm_hybride interpolation_ibm_elem_fluid ibm_hybride 1 Immersed Boundary Method (IBM): hybrid (fluid/mean gradient) interpolation. 
  attr est_dirichlet field_base est_dirichlet 0 Node field of booleans indicating whether the node belong to an element where the interface is
  attr elements_solides field_base elements_solides 0 Node field giving the element number containing the solid point
interpolation_ibm_aucune interpolation_ibm_base ibm_aucune 0 Immersed Boundary Method (IBM): no interpolation. 
interpolation_ibm_elem_fluid interpolation_ibm_base ibm_element_fluide 1 Immersed Boundary Method (IBM): fluid element interpolation. 
  attr points_fluides field_base points_fluides 0 Node field giving the projection of the point below (points_solides) falling into the pure cell fluid
  attr points_solides field_base points_solides 0 Node field giving the projection of the node on the immersed boundary
  attr elements_fluides field_base elements_fluides 0 Node field giving the number of the element (cell) containing the pure fluid point
  attr correspondance_elements field_base correspondance_elements 0 Cell field giving the SALOME cell number
Interpolation_IBM_power_law_tbl_u_star interpolation_ibm_base IBM_power_law_tbl_u_star 1 Immersed Boundary Method (IBM): power law tbl u_star interpolation 
  attr points_solides field_base points_solides 0 Node field giving the projection of the node on the immersed boundary
  attr est_dirichlet rien est_dirichlet 0 Node field of booleans indicating whether the node belong to an element where the interface is
  attr correspondance_elements field_base correspondance_elements 0 Cell field giving the SALOME cell number
  attr elements_solides field_base elements_solides 0 Node field giving the element number containing the solid point
interpolation_ibm_power_law_tbl interpolation_ibm_elem_fluid ibm_power_law_tbl 1 Immersed Boundary Method (IBM): power law interpolation. 
  attr formulation_linear_pwl entier formulation_linear_pwl 1 Choix formulation lineaire ou non
interpolation_ibm_base objet_u interpolation_ibm_base 0 Base class for all the interpolation methods available in the Immersed Boundary Method (IBM). 
  attr impr rien impr 1 To print IBM-related data
  attr nb_histo_boxes_impr entier nb_histo_boxes_impr 1 number of histogram boxes for printed data
loi_fermeture_test loi_fermeture_base loi_fermeture_test -1 Loi for test only 
  attr coef floattant coef 1 coefficient
postraitement postraitement_base postraitement -1 An object of post-processing (without name). 
  attr fichier chaine fichier 1 Name of file.
  attr format chaine(into=["lml","lata","lata_v2","med","med_major"]) format 1 This optional parameter specifies the format of the output file. The basename used for the output file is the basename of the data file. For the fmt parameter, choices are lml or lata. A short description of each format can be found below. The default value is lml.
  attr domaine chaine domaine 1 This optional parameter specifies the domain on which the data should be interpolated before it is written in the output file. The default is to write the data on the domain of the current problem (no interpolation).
  attr sous_domaine|sous_zone chaine sous_domaine 1 This optional parameter specifies the sub_domaine on which the data should be interpolated before it is written in the output file. It is only available for sequential computation.
  attr parallele chaine(into=["simple","multiple","mpi-io"]) parallele 1 Select simple (single file, sequential write), multiple (several files, parallel write), or mpi-io (single file, parallel write) for LATA format
  attr definition_champs definition_champs definition_champs 1 Keyword to create new or more complex field for advanced postprocessing.
  attr definition_champs_fichier|definition_champs_file Definition_champs_fichier definition_champs_fichier 1 Definition_champs read from file.
  attr sondes|probes sondes sondes 1 Probe.
  attr sondes_mobiles|mobile_probes sondes sondes_mobiles 1 Mobile probes useful for ALE, their positions will be updated in the mesh.
  attr sondes_fichier|probes_file sondes_fichier sondes_fichier 1 Probe read in a file.
  attr deprecatedkeepduplicatedprobes entier deprecatedkeepduplicatedprobes 1 Flag to not remove duplicated probes in .son files (1: keep duplicate probes, 0: remove duplicate probes)
  attr champs|fields champs_posts champs 1 Field\'s write mode.
  attr statistiques stats_posts statistiques 1 Statistics between two points fixed : start of integration time and end of integration time.
  attr statistiques_en_serie stats_serie_posts statistiques_en_serie 1 Statistics between two points not fixed : on period of integration.
sondes_fichier objet_lecture nul 1 not_set 
  attr fichier|file chaine fichier 0 name of file
Definition_champs_fichier objet_lecture nul 1 Keyword to read definition_champs from a file 
  attr fichier|file chaine fichier 0 name of file containing the definition of advanced fields
loi_fermeture_base objet_u loi_fermeture_base -3 Class for appends fermeture to problem 
Pb_base pb_gen_base Pb_base -3 Resolution of equations on a domain. A problem is defined by creating an object and assigning the problem type that the user wishes to resolve. To enter values for the problem objects created, the Lire (Read) interpretor is used with a data block. 
  attr milieu milieu_base milieu 1 The medium associated with the problem.
  attr constituant constituant constituant 1 Constituent.
  attr postraitement|Post_processing corps_postraitement postraitement 1 One post-processing (without name).
  attr postraitements|Post_processings postraitements postraitements 1 List of Postraitement objects (with name).
  attr liste_de_postraitements liste_post_ok liste_de_postraitements 1 This
  attr liste_postraitements liste_post liste_postraitements 1 This block defines the output files to be written during the computation. The output format is lata in order to use OpenDX to draw the results. This block can be divided in one or several sub-blocks that can be written at different frequencies and in different directories. Attention. The directory lata used in this example should be created before running the computation or the lata files will be lost.
  attr sauvegarde format_file sauvegarde 1 Keyword used when calculation results are to be backed up. When a coupling is performed, the backup-recovery file name must be well specified for each problem. In this case, you must save to different files and correctly specify these files when resuming the calculation.
  attr sauvegarde_simple format_file sauvegarde_simple 1 The same keyword than Sauvegarde except, the last time step only is saved.
  attr reprise format_file reprise 1 Keyword to resume a calculation based on the name_file file (see the class format_file). If format_reprise is xyz, the name_file file should be the .xyz file created by the previous calculation. With this file, it is possible to resume a parallel calculation on P processors, whereas the previous calculation has been run on N (N<>P) processors. Should the calculation be resumed, values for the tinit (see schema_temps_base) time fields are taken from the name_file file. If there is no backup corresponding to this time in the name_file, TRUST exits in error.
  attr resume_last_time format_file resume_last_time 1 Keyword to resume a calculation based on the name_file file, resume the calculation at the last time found in the file (tinit is set to last time of saved files).
  ref domaine domaine
  ref scheme schema_temps_base
  ref loi1 loi_fermeture_base
  ref loi2 loi_fermeture_base
  ref loi3 loi_fermeture_base
  ref loi4 loi_fermeture_base
  ref loi5 loi_fermeture_base
milieu_base objet_u milieu_base -1 Basic class for medium (physics properties of medium). 
  attr gravite field_base gravite 1 Gravity field (optional).
  attr porosites_champ field_base porosites_champ 1 The porosity is given at each element and the porosity at each face, Psi(face), is calculated by the average of the porosities of the two neighbour elements Psi(elem1), Psi(elem2) : Psi(face)=2/(1/Psi(elem1)+1/Psi(elem2)). This keyword is optional.
  attr diametre_hyd_champ field_base diametre_hyd_champ 1 Hydraulic diameter field (optional).
  attr porosites porosites porosites 1 Porosities.
eqn_base mor_eqn eqn_base -3 Basic class for equations. 
  attr disable_equation_residual chaine disable_equation_residual 1 The equation residual will not be used for the problem residual used when checking time convergence or computing dynamic time-step
  attr convection bloc_convection convection 1 Keyword to alter the convection scheme.
  attr diffusion bloc_diffusion diffusion 1 Keyword to specify the diffusion operator.
  attr conditions_limites|boundary_conditions condlims conditions_limites 1 Boundary conditions.
  attr conditions_initiales|initial_conditions condinits conditions_initiales 1 Initial conditions.
  attr sources sources sources 1 To introduce a source term into an equation (in case of several source terms into the same equation, the blocks corresponding to the various terms need to be separated by a comma)
  attr ecrire_fichier_xyz_valeur_bin ecrire_fichier_xyz_valeur_param ecrire_fichier_xyz_valeur_bin 1 This keyword is used to write the values of a field only for some boundaries in a binary file with the following format: n_valeur NL2 x_1 y_1 [z_1] val_1 NL2 ... NL2 x_n y_n [z_n] val_n NL2 The created files are named : pbname_fieldname_[boundaryname]_time.dat
  attr ecrire_fichier_xyz_valeur ecrire_fichier_xyz_valeur_param ecrire_fichier_xyz_valeur 1 This keyword is used to write the values of a field only for some boundaries in a text file with the following format: n_valeur NL2 x_1 y_1 [z_1] val_1 NL2 ... NL2 x_n y_n [z_n] val_n NL2 The created files are named : pbname_fieldname_[boundaryname]_time.dat
  attr parametre_equation parametre_equation_base parametre_equation 1 Keyword used to specify additional parameters for the equation
  attr equation_non_resolue chaine equation_non_resolue 1 The equation will not be solved while condition(t) is verified if equation_non_resolue keyword is used. Exemple: The Navier-Stokes equations are not solved between time t0 and t1. NL2 Navier_Sokes_Standard NL2 { equation_non_resolue (t>t0)*(t<t1) }
schema_temps_base objet_u schema_temps_base -1 Basic class for time schemes. This scheme will be associated with a problem and the equations of this problem. 
  attr tinit floattant tinit 1 Value of initial calculation time (0 by default).
  attr tmax floattant tmax 1 Time during which the calculation will be stopped (1e30s by default).
  attr tcpumax floattant tcpumax 1 CPU time limit (must be specified in hours) for which the calculation is stopped (1e30s by default).
  attr dt_min floattant dt_min 1 Minimum calculation time step (1e-16s by default).
  attr dt_max chaine dt_max 1 Maximum calculation time step as function of time (1e30s by default).
  attr dt_sauv floattant dt_sauv 1 Save time step value (1e30s by default). Every dt_sauv, fields are saved in the .sauv file. The file contains all the information saved over time. If this instruction is not entered, results are saved only upon calculation completion. To disable the writing of the .sauv files, you must specify 0. Note that dt_sauv is in terms of physical time (not cpu time).
  attr dt_impr floattant dt_impr 1 Scheme parameter printing time step in time (1e30s by default). The time steps and the flux balances are printed (incorporated onto every side of processed domains) into the .out file.
  attr facsec floattant facsec 1 Value assigned to the safety factor for the time step (1. by default). The time step calculated is multiplied by the safety factor. The first thing to try when a calculation does not converge with an explicit time scheme is to reduce the facsec to 0.5. NL2 Warning: Some schemes needs a facsec lower than 1 (0.5 is a good start), for example Schema_Adams_Bashforth_order_3.
  attr seuil_statio floattant seuil_statio 1 Value of the convergence threshold (1e-12 by default). Problems using this type of time scheme converge when the derivatives dGi/dt NL1 of all the unknown transported values Gi have a combined absolute value less than this value. This is the keyword used to set the permanent rating threshold.
  attr residuals residuals residuals 1 To specify how the residuals will be computed (default max norm, possible to choose L2-norm instead).
  attr diffusion_implicite entier diffusion_implicite 1 Keyword to make the diffusive term in the Navier-Stokes equations implicit (in this case, it should be set to 1). The stability time step is then only based on the convection time step (dt=facsec*dt_convection). Thus, in some circumstances, an important gain is achieved with respect to the time step (large diffusion with respect to convection on tightened meshes). Caution: It is however recommended that the user avoids exceeding the convection time step by selecting a too large facsec value. Start with a facsec value of 1 and then increase it gradually if you wish to accelerate calculation. In addition, for a natural convection calculation with a zero initial velocity, in the first time step, the convection time is infinite and therefore dt=facsec*dt_max.
  attr seuil_diffusion_implicite floattant seuil_diffusion_implicite 1 This keyword changes the default value (1e-6) of convergency criteria for the resolution by conjugate gradient used for implicit diffusion.
  attr impr_diffusion_implicite entier impr_diffusion_implicite 1 Unactivate (default) or not the printing of the convergence during the resolution of the conjugate gradient.
  attr impr_extremums entier impr_extremums 1 Print unknowns extremas
  attr no_error_if_not_converged_diffusion_implicite entier no_error_if_not_converged_diffusion_implicite 1 not_set
  attr no_conv_subiteration_diffusion_implicite entier no_conv_subiteration_diffusion_implicite 1 not_set
  attr dt_start dt_start dt_start 1 dt_start dt_min : the first iteration is based on dt_min. NL2 dt_start dt_calc : the time step at first iteration is calculated in agreement with CFL condition. NL2 dt_start dt_fixe value : the first time step is fixed by the user (recommended when resuming calculation with Crank Nicholson temporal scheme to ensure continuity). NL2 By default, the first iteration is based on dt_calc.
  attr nb_pas_dt_max entier nb_pas_dt_max 1 Maximum number of calculation time steps (1e9 by default).
  attr niter_max_diffusion_implicite entier niter_max_diffusion_implicite 1 This keyword changes the default value (number of unknowns) of the maximal iterations number in the conjugate gradient method used for implicit diffusion.
  attr precision_impr entier precision_impr 1 Optional keyword to define the digit number for flux values printed into .out files (by default 3).
  attr periode_sauvegarde_securite_en_heures floattant periode_sauvegarde_securite_en_heures 1 To change the default period (23 hours) between the save of the fields in .sauv file.
  attr no_check_disk_space rien no_check_disk_space 1 To disable the check of the available amount of disk space during the calculation.
  attr disable_progress rien disable_progress 1 To disable the writing of the .progress file.
  attr disable_dt_ev rien disable_dt_ev 1 To disable the writing of the .dt_ev file.
  attr gnuplot_header entier gnuplot_header 1 Optional keyword to modify the header of the .out files. Allows to use the column title instead of columns number.
residuals interprete nul 1 To specify how the residuals will be computed. 
  attr norm chaine(into=["L2","max"]) norm 1 allows to choose the norm we want to use (max norm by default). Possible to specify L2-norm.
  attr relative chaine(into=["0","1","2"]) relative 1 This is the old keyword seuil_statio_relatif_deconseille. If it is set to 1, it will normalize the residuals with the residuals of the first 5 timesteps (default is 0). if set to 2, residual will be computed as R/(max-min).
sonde objet_lecture nul 0 Keyword is used to define the probes. Observations: the probe coordinates should be given in Cartesian coordinates (X, Y, Z), including axisymmetric. 
  attr nom_sonde chaine nom_sonde 0 Name of the file in which the values taken over time will be saved. The complete file name is nom_sonde.son.
  attr special chaine(into=["grav","som","nodes","chsom","gravcl"]) special 1 Option to change the positions of the probes. Several options are available: NL2 grav : each probe is moved to the nearest cell center of the mesh; NL2 som : each probe is moved to the nearest vertex of the mesh NL2 nodes : each probe is moved to the nearest face center of the mesh; NL2 chsom : only available for P1NC sampled field. The values of the probes are calculated according to P1-Conform corresponding field. NL2 gravcl : Extend to the domain face boundary a cell-located segment probe in order to have the boundary condition for the field. For this type the extreme probe point has to be on the face center of gravity.
  attr nom_inco chaine nom_inco 0 Name of the sampled field.
  attr mperiode chaine(into=["periode"]) mperiode 0 Keyword to set the sampled field measurement frequency.
  attr prd floattant prd 0 Period value. Every prd seconds, the field value calculated at the previous time step is written to the nom_sonde.son file.
  attr type sonde_base type 0 Type of probe.
segmentfacesx sonde_base segmentfacesx 0 Segment probe where points are moved to the nearest x faces 
  attr nbr entier nbr 0 Number of probe points of the segment, evenly distributed.
  attr point_deb un_point point_deb 0 First outer probe segment point.
  attr point_fin un_point point_fin 0 Second outer probe segment point.
segmentfacesy sonde_base segmentfacesy 0 Segment probe where points are moved to the nearest y faces 
  attr nbr entier nbr 0 Number of probe points of the segment, evenly distributed.
  attr point_deb un_point point_deb 0 First outer probe segment point.
  attr point_fin un_point point_fin 0 Second outer probe segment point.
segmentfacesz sonde_base segmentfacesz 0 Segment probe where points are moved to the nearest z faces 
  attr nbr entier nbr 0 Number of probe points of the segment, evenly distributed.
  attr point_deb un_point point_deb 0 First outer probe segment point.
  attr point_fin un_point point_fin 0 Second outer probe segment point.
radius sonde_base radius 0 not_set 
  attr nbr entier nbr 0 Number of probe points of the segment, evenly distributed.
  attr point_deb un_point point_deb 0 First outer probe segment point.
  attr radius floattant radius 0 not_set
  attr teta1 floattant teta1 0 not_set
  attr teta2 floattant teta2 0 not_set
parametre_equation_base objet_lecture parametre_equation_base -1 Basic class for parametre_equation 
MultipleFiles interprete MultipleFiles -1 Change MPI rank limit for multiple files during I/O 
  attr type entier type 0 New MPI rank limit
disable_TU interprete disable_TU -1 Flag to disable the writing of the .TU files 
Champ_Fonc_Interp champ_don_base Champ_Fonc_Interp 1 Field that is interpolated from a distant domain via MEDCoupling (remapper). 
  attr nom_champ chaine nom_champ 0 Name of the field (for example: temperature).
  attr pb_loc chaine pb_loc 0 Name of the local problem.
  attr pb_dist chaine pb_dist 0 Name of the distant problem.
  attr dom_loc chaine dom_loc 1 Name of the local domain.
  attr dom_dist chaine dom_dist 1 Name of the distant domain.
  attr nature chaine nature 0 Nature of the field (knowledge from MEDCoupling is required; IntensiveMaximum, IntensiveConservation, ...).
scalaire_impose_paroi dirichlet scalaire_impose_paroi 0 Imposed temperature condition at the wall called bord (edge). 
  attr ch front_field_base ch 0 Boundary field type.
Neumann_homogene condlim_base Neumann_homogene -1 Homogeneous neumann boundary condition 
champ_front_MED front_field_base champ_front_MED 0 Field allowing the loading of a boundary condition from a MED file using Champ_fonc_med 
  attr champ_fonc_med field_base champ_fonc_med 0 a champ_fonc_med loading the values of the unknown on a domain boundary
format_lata_to_med objet_lecture nul 0 not_set 
  attr mot chaine(into=["format_post_sup"]) mot 0 not_set
  attr format chaine(into=["lml","lata","lata_v2","med"]) format 1 generated file post_med.data use format (MED or LATA or LML keyword).
lata_to_other interprete lata_to_other -1 To convert results file written with LATA format to MED or LML format. Warning: Fields located at faces are not supported yet. 
  attr format chaine(into=["lml","lata","lata_v2","med"]) format 1 Results format (MED or LATA or LML keyword).
  attr file chaine file 0 LATA file to convert to the new format.
  attr file_post chaine file_post 0 Name of file post.
lata_to_med interprete lata_to_med -1 To convert results file written with LATA format to MED file. Warning: Fields located on faces are not supported yet. 
  attr format format_lata_to_med format 1 generated file post_med.data use format (MED or LATA or LML keyword).
  attr file chaine file 0 LATA file to convert to the new format.
  attr file_med chaine file_med 0 Name of the MED file.
Read_MED interprete lire_med 1 Keyword to read MED mesh files where \'domain\' corresponds to the domain name, \'file\' corresponds to the file (written in the MED format) containing the mesh named mesh_name. NL2 Note about naming boundaries: When reading \'file\', TRUST will detect boundaries between domains (Raccord) when the name of the boundary begins by type_raccord_. For example, a boundary named type_raccord_wall in \'file\' will be considered by TRUST as a boundary named \'wall\' between two domains. NL2 NB: To read several domains from a mesh issued from a MED file, use Read_Med to read the mesh then use Create_domain_from_sub_domain keyword. NL2 NB: If the MED file contains one or several subdomaine defined as a group of volumes, then Read_MED will read it and will create two files domain_name_ssz.geo and domain_name_ssz_par.geo defining the subdomaines for sequential and/or parallel calculations. These subdomaines will be read in sequential in the datafile by including (after Read_Med keyword) something like: NL2 Read_Med .... NL2 Read_file domain_name_ssz.geo ; NL2 During the parallel calculation, you will include something: NL2 Scatter { ... } NL2 Read_file domain_name_ssz_par.geo ; 
  attr convertalltopoly rien convertalltopoly 1 Option to convert mesh with mixed cells into polyhedral/polygonal cells
  attr no_family_names_from_group_names rien no_family_names_from_group_names 1 Awful option just to keep naked family names from MED file. Rarely used, to be removed very soon.
  attr domain|domaine ref_domaine domain 0 Corresponds to the domain name.
  attr file|fichier chaine file 0 File (written in the MED format, with extension \'.med\') containing the mesh
  attr mesh|maillage chaine mesh 1 Name of the mesh in med file. If not specified, the first mesh will be read.
  attr exclude_groups|exclure_groupes listchaine exclude_groups 1 List of face groups to skip in the MED file.
  attr include_internal_face_groups|inclure_groupes_faces_internes listchaine include_internal_face_groups 1 List of face groups to read and register in the MED file.
Ecrire_MED interprete Write_MED -1 Write a domain to MED format into a file. 
  attr nom_dom ref_domaine nom_dom 0 Name of domain.
  attr file chaine file 0 Name of file.
Champ_Fonc_MED_Tabule champ_fonc_med Champ_Fonc_MED_Tabule -1 not_set 
Merge_MED interprete Merge_MED 0 This keyword allows to merge multiple MED files produced during a parallel computation into a single MED file. 
  attr med_files_base_name chaine med_files_base_name 0 Base name of multiple med files that should appear as base_name_xxxxx.med, where xxxxx denotes the MPI rank number. If you specify NOM_DU_CAS, it will automatically take the basename from your datafile\'s name.
  attr time_iterations chaine(into=["all_times","last_time"]) time_iterations 0 Identifies whether to merge all time iterations present in the MED files or only the last one.
champ_fonc_med field_base champ_fonc_med 1 Field to read a data field in a MED-format file .med at a specified time. It is very useful, for example, to resume a calculation with a new or refined geometry. The field post-processed on the new geometry at med format is used as initial condition for the resume. 
  attr use_existing_domain rien use_existing_domain 1 whether to optimize the field loading by indicating that the field is supported by the same mesh that was initially loaded as the domain
  attr last_time rien last_time 1 to use the last time of the MED file instead of the specified time. Mutually exclusive with \'time\' parameter.
  attr decoup chaine decoup 1 specify a partition file.
  attr domain chaine domain 0 Name of the domain supporting the field. This is the name of the mesh in the MED file, and if this mesh was also used to create the TRUST domain, loading can be optimized with option \'use_existing_domain\'.
  attr file chaine file 0 Name of the .med file.
  attr field chaine field 0 Name of field to load.
  attr loc chaine(into=["som","elem"]) loc 1 To indicate where the field is localised. Default to \'elem\'.
  attr time floattant time 1 Timestep to load from the MED file. Mutually exclusive with \'last_time\' flag.
ecrire_champ_med interprete ecrire_champ_med -1 Keyword to write a field to MED format into a file. 
  attr nom_dom ref_domaine nom_dom 0 domain name
  attr nom_chp ref_field_base nom_chp 0 field name
  attr file chaine file 0 file name
champ_front_tabule front_field_base champ_front_tabule 0 Constant field on the boundary, tabulated as a function of time. 
  attr nb_comp entier nb_comp 0 Number of field components.
  attr bloc bloc_lecture bloc 0 {nt1 t2 t3 ....tn u1 [v1 w1 ...] u2 [v2 w2 ...] u3 [v3 w3 ...] ... un [vn wn ...] } NL2 Values are entered into a table based on n couples (ti, ui) if nb_comp value is 1. The value of a field at a given time is calculated by linear interpolation from this table.
champ_front_debit front_field_base champ_front_debit 0 This field is used to define a flow rate field instead of a velocity field for a Dirichlet boundary condition on Navier-Stokes equations. 
  attr ch front_field_base ch 0 uniform field in space to define the flow rate. It could be, for example, champ_front_uniforme, ch_front_input_uniform or champ_front_fonc_txyz that depends only on time.
champ_fonc_fonction_txyz champ_fonc_fonction champ_fonc_fonction_txyz -1 this refers to a field that is a function of another field and time and/or space coordinates 
champ_fonc_tabule champ_don_base champ_fonc_tabule 0 Field that is tabulated as a function of another field. 
  attr inco chaine inco 0 Name of the field (for example: temperature).
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lecture bloc 0 Values (the table (the value of the field at any time is calculated by linear interpolation from this table) or the analytical expression (with keyword expression to use an analytical expression)).
champ_front_xyz_debit front_field_base champ_front_xyz_debit 1 This field is used to define a flow rate field with a velocity profil which will be normalized to match the flow rate chosen. 
  attr velocity_profil front_field_base velocity_profil 1 velocity_profil 0 velocity field to define the profil of velocity.
  attr flow_rate front_field_base flow_rate 0 flow_rate 1 uniform field in space to define the flow rate. It could be, for example, champ_front_uniforme, ch_front_input_uniform or champ_front_fonc_t
Champ_Front_xyz_Tabule champ_front_fonc_txyz Champ_Front_xyz_Tabule 0 Space dependent field on the boundary, tabulated as a function of time. 
  attr val listchaine val 0 Values of field components (mathematical expressions).
  attr bloc bloc_lecture bloc 0 {nt1 t2 t3 ....tn u1 [v1 w1 ...] u2 [v2 w2 ...] u3 [v3 w3 ...] ... un [vn wn ...] } NL2 Values are entered into a table based on n couples (ti, ui) if nb_comp value is 1. The value of a field at a given time is calculated by linear interpolation from this table.
champ_input_p0_composite champ_input_base champ_input_p0_composite 1 Field used to define a classical champ input p0 field (for ICoCo), but with a predefined field for the initial state. 
  attr initial_field field_base initial_field 1 The field used for initialization
  attr input_field champ_input_p0 input_field 1 The input field for ICoCo
predefini champ_generique_base predefini -1 This keyword is used to post process predefined postprocessing fields. 
  attr pb_champ deuxmots pb_champ 0 { Pb_champ nom_pb nom_champ } : nom_pb is the problem name and nom_champ is the selected field name. The available keywords for the field name are: energie_cinetique_totale, energie_cinetique_elem, viscosite_turbulente, viscous_force_x, viscous_force_y, viscous_force_z, pressure_force_x, pressure_force_y, pressure_force_z, total_force_x, total_force_y, total_force_z, viscous_force, pressure_force, total_force
champ_front_debit_massique front_field_base champ_front_debit_massique 0 This field is used to define a flow rate field using the density 
  attr ch front_field_base ch 0 uniform field in space to define the flow rate. It could be, for example, champ_front_uniforme, ch_front_input_uniform or champ_front_fonc_txyz that depends only on time.
champ_front_musig champ_front_composite champ_front_musig 0 MUSIG front field. Used in multiphase problems to associate data to each phase. 
  attr dim suppress_param dim 1 del
  attr bloc bloc_lecture bloc 0 Not set
champ_front_composite front_field_base champ_front_composite 0 Composite front field. Used in multiphase problems to associate data to each phase. 
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lecture bloc 0 Values Various pieces of the field, defined per phase. Part 1 goes to phase 1, etc...
champ_front_bruite front_field_base champ_front_bruite 0 Field which is variable in time and space in a random manner. 
  attr nb_comp entier nb_comp 0 Number of field components.
  attr bloc bloc_lecture bloc 0 { [N val L val ] Moyenne m_1.....[m_i ] Amplitude A_1.....[A_ i ]}: Random nois: If N and L are not defined, the ith component of the field varies randomly around an average value m_i with a maximum amplitude A_i. NL2 White noise: If N and L are defined, these two additional parameters correspond to L, the domain length and N, the number of nodes in the domain. Noise frequency will be between 2*Pi/L and 2*Pi*N/(4*L). NL2 For example, formula for velocity: u=U0(t) v=U1(t)Uj(t)=Mj+2*Aj*bruit_blanc where bruit_blanc (white_noise) is the formula given in the mettre_a_jour (update) method of the Champ_front_bruite (noise_boundary_field) (Refer to the Champ_front_bruite.cpp file).
champ_front_fonction front_field_base champ_front_fonction 0 boundary field that is function of another field 
  attr dim entier dim 0 Number of field components.
  attr inco chaine inco 0 Name of the field (for example: temperature).
  attr expression chaine expression 0 keyword to use a analytical expression like 10.*EXP(-0.1*val) where val be the keyword for the field.
champ_front_fonc_txyz front_field_base champ_front_fonc_txyz 0 Boundary field which is not constant in space and in time. 
  attr val listchaine val 0 Values of field components (mathematical expressions).
champ_front_fonc_t front_field_base champ_front_fonc_t 0 Boundary field that depends only on time. 
  attr val listchaine val 0 Values of field components (mathematical expressions).
champ_front_tabule_lu champ_front_tabule champ_front_tabule_lu 0 Constant field on the boundary, tabulated from a specified column file. Lines starting with # are ignored. 
  attr nb_comp entier nb_comp 0 Number of field components.
  attr column_file chaine column_file 0 Name of the column file.
  attr bloc suppress_param bloc 0 del
reduction_0d champ_post_de_champs_post reduction_0d -1 To calculate the min, max, sum, average, weighted sum, weighted average, weighted sum by porosity, weighted average by porosity, euclidian norm, normalized euclidian norm, L1 norm, L2 norm of a field. 
  attr methode chaine(into=["min","max","moyenne","average","moyenne_ponderee","weighted_average","somme","sum","somme_ponderee","weighted_sum","somme_ponderee_porosite","weighted_sum_porosity","euclidian_norm","normalized_euclidian_norm","L1_norm","L2_norm","valeur_a_gauche","left_value"]) methode 0 name of the reduction method: NL2 - min for the minimum value, NL2 - max for the maximum value, NL2 - average (or moyenne) for a mean, NL2 - weighted_average (or moyenne_ponderee) for a mean ponderated by integration volumes, e.g: cell volumes for temperature and pressure in VDF, volumes around faces for velocity and temperature in VEF, NL2 - sum (or somme) for the sum of all the values of the field, NL2 - weighted_sum (or somme_ponderee) for a weighted sum (integral), NL2 - weighted_average_porosity (or moyenne_ponderee_porosite) and weighted_sum_porosity (or somme_ponderee_porosite) for the mean and sum weighted by the volumes of the elements, only for ELEM localisation, NL2 - euclidian_norm for the euclidian norm, NL2 - normalized_euclidian_norm for the euclidian norm normalized, NL2 - L1_norm for norm L1, NL2 - L2_norm for norm L2
interpolation champ_post_de_champs_post interpolation -1 To create a field which is an interpolation of the field given by the keyword source. 
  attr localisation chaine localisation 0 type_loc indicate where is done the interpolation (elem for element or som for node).
  attr methode chaine methode 1 The optional keyword methode is limited to calculer_champ_post for the moment.
  attr domaine chaine domaine 1 the domain name where the interpolation is done (by default, the calculation domain)
  attr optimisation_sous_maillage chaine(into=["default","yes","no",]) optimisation_sous_maillage 1 not_set
champ_composite champ_don_base champ_composite 0 Composite field. Used in multiphase problems to associate data to each phase. 
  attr dim entier dim 0 Number of field components.
  attr bloc bloc_lecture bloc 0 Values Various pieces of the field, defined per phase. Part 1 goes to phase 1, etc...
Champ_Fonc_Tabule_Morceaux_Interp Champ_Fonc_Tabule_Morceaux Champ_Fonc_Tabule_Morceaux_Interp 0 Field defined by tabulated data in each sub-domaine. It makes possible the definition of a field which is a function of other fields. Here we use MEDCoupling to interpolate fields between the two domains. 
  attr domain_name suppress_param domain_name 0 del.
  attr problem_name ref_Pb_base problem_name 0 Name of the problem.
champ_musig champ_composite champ_musig 0 MUSIG field. Used in multiphase problems to associate data to each phase. 
  attr dim suppress_param dim 1 del
  attr bloc bloc_lecture bloc 0 Not set
champ_fonc_fonction_txyz_morceaux champ_don_base champ_fonc_fonction_txyz_morceaux 0 Field defined by analytical functions in each sub-domaine. It makes possible the definition of a field that depends on the time and the space. 
  attr problem_name ref_Pb_base problem_name 0 Name of the problem.
  attr inco chaine inco 0 Name of the field (for example: temperature).
  attr nb_comp entier nb_comp 0 Number of field components.
  attr data bloc_lecture data 0 { Defaut val_def sous_domaine_1 val_1 ... sous_domaine_i val_i } By default, the value val_def is assigned to the field. It takes the sous_domaine_i identifier Sous_Domaine (sub_area) type object function, val_i. Sous_Domaine (sub_area) type objects must have been previously defined if the operator wishes to use a champ_fonc_fonction_txyz_morceaux type object.
Champ_Fonc_Tabule_Morceaux champ_don_base Champ_Tabule_Morceaux 0 Field defined by tabulated data in each sub-domaine. It makes possible the definition of a field which is a function of other fields. 
  attr domain_name ref_domaine domain_name 0 Name of the domain.
  attr nb_comp entier nb_comp 0 Number of field components.
  attr data bloc_lecture data 0 { Defaut val_def sous_domaine_1 val_1 ... sous_domaine_i val_i } By default, the value val_def is assigned to the field. It takes the sous_domaine_i identifier Sous_Domaine (sub_area) type object function, val_i. Sous_Domaine (sub_area) type objects must have been previously defined if the operator wishes to use a champ_fonc_tabule_morceaux type object.
ecriturelecturespecial interprete ecriturelecturespecial -1 Class to write or not to write a .xyz file on the disk at the end of the calculation. 
  attr type chaine type 0 If set to 0, no xyz file is created. If set to EFichierBin, it uses prior 1.7.0 way of reading xyz files (now LecFicDiffuseBin). If set to EcrFicPartageBin, it uses prior 1.7.0 way of writing xyz files (now EcrFicPartageMPIIO).
champ_fonc_reprise champ_don_base champ_fonc_reprise 0 This field is used to read a data field in a save file (.xyz or .sauv) at a specified time. It is very useful, for example, to run a thermohydraulic calculation with velocity initial condition read into a save file from a previous hydraulic calculation. 
  attr format chaine(into=["binaire","formatte","xyz","single_hdf"]) format 1 Type of file (the file format). If xyz format is activated, the .xyz file from the previous calculation will be given for filename, and if formatte or binaire is choosen, the .sauv file of the previous calculation will be specified for filename. In the case of a parallel calculation, if the mesh partition does not changed between the previous calculation and the next one, the binaire format should be preferred, because is faster than the xyz format. If single_hdf is used, the same constraints/advantages as binaire apply, but a single (HDF5) file is produced on the filesystem instead of having one file per processor.
  attr filename chaine filename 0 Name of the save file.
  attr pb_name ref_Pb_base pb_name 0 Name of the problem.
  attr champ chaine champ 0 Name of the problem unknown. It may also be the temporal average of a problem unknown (like moyenne_vitesse, moyenne_temperature,...)
  attr fonction fonction_champ_reprise fonction 1 Optional keyword to apply a function on the field being read in the save file (e.g. to read a temperature field in Celsius units and convert it for the calculation on Kelvin units, you will use: fonction 1 273.+val )
  attr temps chaine time 0 Time of the saved field in the save file or last_time. If you give the keyword last_time instead, the last time saved in the save file will be used.
champ_front_fonc_xyz front_field_base champ_front_fonc_xyz 0 Boundary field which is not constant in space. 
  attr val listchaine val 0 Values of field components (mathematical expressions).
source_pdf source_pdf_base source_pdf 1 Source term for Penalised Direct Forcing (PDF) method. 
paroi_fixe_iso_Genepi2_sans_contribution_aux_vitesses_sommets paroi_fixe paroi_fixe_iso_Genepi2_sans_contribution_aux_vitesses_sommets -1 Boundary condition to obtain iso Geneppi2, without interest 
convection_supg convection_deriv supg 1 Only for EF discretization. 
  attr facteur floattant facteur 0 not_set
convection_btd convection_deriv btd 1 Only for EF discretization. 
  attr btd floattant btd 0 not_set
  attr facteur floattant facteur 0 not_set
Echange_interne_global_parfait condlim_base Paroi_echange_interne_global_parfait -1 Internal heat exchange boundary condition with perfect (infinite) exchange coefficient. 
Conduction eqn_base Conduction -1 Heat equation. 
Echange_interne_global_impose condlim_base Paroi_echange_interne_global_impose -1 Internal heat exchange boundary condition with global exchange coefficient. 
  attr h_imp chaine h_imp 0 Global exchange coefficient value. The global exchange coefficient value is expressed in W.m-2.K-1.
  attr ch front_field_base ch 0 Boundary field type.
Pb_Conduction Pb_base Pb_Conduction -1 Resolution of the heat equation. 
  attr solide solide solide 1 The medium associated with the problem.
  attr Conduction Conduction Conduction 1 Heat equation.
solide milieu_base solide -1 Solid with cp and/or rho non-uniform. 
  attr rho field_base rho 1 Density (kg.m-3).
  attr cp field_base cp 1 Specific heat (J.kg-1.K-1).
  attr lambda field_base lambda_u 1 Conductivity (W.m-1.K-1).
  attr user_field field_base user_field 1 user defined field.
Echange_couplage_thermique paroi_echange_global_impose Echange_couplage_thermique 1 Thermal coupling boundary condition 
  attr text suppress_param text 1 suppress
  attr h_imp suppress_param h_imp 1 suppress
  attr himpc suppress_param himpc 1 suppress
  attr ch suppress_param ch 1 suppress
  attr temperature_paroi field_base temperature_paroi 1 Temperature
  attr flux_paroi field_base flux_paroi 1 Wall heat flux
convection_ale convection_deriv ale 0 A convective scheme for ALE (Arbitrary Lagrangian-Eulerian)  framework. 
  attr opconv bloc_convection opconv 0 Choice between: amont and muscl NL2 Example: convection { ALE { amont } }
pb_thermohydraulique Pb_base pb_thermohydraulique -1 Resolution of thermohydraulic problem. 
  attr fluide_incompressible fluide_incompressible fluide_incompressible 1 The fluid medium associated with the problem (only one possibility).
  attr fluide_ostwald fluide_ostwald fluide_ostwald 1 The fluid medium associated with the problem (only one possibility).
  attr fluide_sodium_liquide fluide_sodium_liquide fluide_sodium_liquide 1 The fluid medium associated with the problem (only one possibility).
  attr fluide_sodium_gaz fluide_sodium_gaz fluide_sodium_gaz 1 The fluid medium associated with the problem (only one possibility).
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 Navier-Stokes equations.
  attr convection_diffusion_temperature convection_diffusion_temperature convection_diffusion_temperature 1 Energy equation (temperature diffusion convection).
listeqn listobj nul 1 eqn_base 0 List of equations. 
pb_avec_passif Pb_base pb_avec_passif -1 Class to create a classical problem with a scalar transport equation (e.g: temperature or concentration) and an additional set of passive scalars (e.g: temperature or concentration) equations. 
  attr equations_scalaires_passifs listeqn equations_scalaires_passifs 0 Passive scalar equations. The unknowns of the passive scalar equation number N are named temperatureN or concentrationN or fraction_massiqueN. This keyword is used to define initial conditions and the post processing fields. This kind of problem is very useful to test in only one data file (and then only one calculation) different schemes or different boundary conditions for the scalar transport equation.
pb_thermohydraulique_concentration_scalaires_passifs pb_avec_passif pb_thermohydraulique_concentration_scalaires_passifs -1 Resolution of Navier-Stokes/energy/multiple constituent transport equations, with the additional passive scalar equations. 
  attr fluide_incompressible fluide_incompressible fluide_incompressible 0 The fluid medium associated with the problem.
  attr constituant constituant constituant 1 Constituents.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 Navier-Stokes equations.
  attr convection_diffusion_concentration convection_diffusion_concentration convection_diffusion_concentration 1 Constituent transport equations (concentration diffusion convection).
  attr convection_diffusion_temperature convection_diffusion_temperature convection_diffusion_temperature 1 Energy equations (temperature diffusion convection).
pb_thermohydraulique_scalaires_passifs pb_avec_passif pb_thermohydraulique_scalaires_passifs -1 Resolution of thermohydraulic problem, with the additional passive scalar equations. 
  attr fluide_incompressible fluide_incompressible fluide_incompressible 0 The fluid medium associated with the problem.
  attr constituant constituant constituant 1 Constituents.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 Navier-Stokes equations.
  attr convection_diffusion_temperature convection_diffusion_temperature convection_diffusion_temperature 1 Energy equations (temperature diffusion convection).
pb_hydraulique_concentration_scalaires_passifs pb_avec_passif pb_hydraulique_concentration_scalaires_passifs -1 Resolution of Navier-Stokes/multiple constituent transport equations with the additional passive scalar equations. 
  attr fluide_incompressible fluide_incompressible fluide_incompressible 0 The fluid medium associated with the problem.
  attr constituant constituant constituant 1 Constituents.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 Navier-Stokes equations.
  attr convection_diffusion_concentration convection_diffusion_concentration convection_diffusion_concentration 1 Constituent transport equations (concentration diffusion convection).
pb_hydraulique Pb_base pb_hydraulique -1 Resolution of the Navier-Stokes equations. 
  attr fluide_incompressible fluide_incompressible fluide_incompressible 0 The fluid medium associated with the problem.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 0 Navier-Stokes equations.
pb_thermohydraulique_concentration Pb_base pb_thermohydraulique_concentration -1 Resolution of Navier-Stokes/energy/multiple constituent transport equations. 
  attr fluide_incompressible fluide_incompressible fluide_incompressible 0 The fluid medium associated with the problem.
  attr constituant constituant constituant 1 Constituents.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 Navier-Stokes equations.
  attr convection_diffusion_concentration convection_diffusion_concentration convection_diffusion_concentration 1 Constituent transport equations (concentration diffusion convection).
  attr convection_diffusion_temperature convection_diffusion_temperature convection_diffusion_temperature 1 Energy equation (temperature diffusion convection).
pb_hydraulique_concentration Pb_base pb_hydraulique_concentration -1 Resolution of Navier-Stokes/multiple constituent transport equations. 
  attr fluide_incompressible fluide_incompressible fluide_incompressible 0 The fluid medium associated with the problem.
  attr constituant constituant constituant 1 Constituents.
  attr navier_stokes_standard navier_stokes_standard navier_stokes_standard 1 Navier-Stokes equations.
  attr convection_diffusion_concentration convection_diffusion_concentration convection_diffusion_concentration 1 Constituent transport vectorial equation (concentration diffusion convection).
source_pdf_base source_base source_pdf_base 1 Base class of the source term for the Immersed Boundary Penalized Direct Forcing method (PDF) 
  attr aire field_base aire 0 volumic field: a boolean for the cell (0 or 1) indicating if the obstacle is in the cell
  attr rotation field_base rotation 0 volumic field with 9 components representing the change of basis on cells (local to global). Used for rotating cases for example.
  attr transpose_rotation rien transpose_rotation 1 whether to transpose the basis change matrix.
  attr modele bloc_pdf_model modele 0 model used for the Penalized Direct Forcing
  attr interpolation interpolation_ibm_base interpolation 1 interpolation method
terme_puissance_thermique_echange_impose source_base terme_puissance_thermique_echange_impose 1 Source term to impose thermal power according to formula : P = himp * (T - Text). Where T is the Trust temperature, Text is the outside temperature with which energy is exchanged via an exchange coefficient himp 
  attr himp field_base himp 0 the exchange coefficient
  attr Text field_base Text 0 the outside temperature
  attr PID_controler_on_targer_power bloc_lecture PID_controler_on_targer_power 1 PID_controler_on_targer_power bloc with parameters target_power (required), Kp, Ki and Kd (at least one of them should be provided)
Neumann_paroi_adiabatique Neumann_homogene Neumann_paroi_adiabatique -1 Adiabatic wall neumann boundary condition 
fluide_base milieu_base fluide_base -3 Basic class for fluids. 
  attr indice field_base indice 1 Refractivity of fluid.
  attr kappa field_base kappa 1 Absorptivity of fluid (m-1).
fluide_incompressible fluide_base fluide_incompressible -1 Class for non-compressible fluids. 
  attr beta_th field_base beta_th 1 Thermal expansion (K-1).
  attr mu field_base mu 1 Dynamic viscosity (kg.m-1.s-1).
  attr beta_co field_base beta_co 1 Volume expansion coefficient values in concentration.
  attr rho field_base rho 1 Density (kg.m-3).
  attr cp field_base cp 1 Specific heat (J.kg-1.K-1).
  attr lambda field_base lambda_u 1 Conductivity (W.m-1.K-1).
  attr porosites bloc_lecture porosites 1 Porosity (optional)
fluide_ostwald fluide_incompressible fluide_ostwald -1 Non-Newtonian fluids governed by Ostwald\'s law. The law applicable to stress tensor is: NL2 tau=K(T)*(D:D/2)**((n-1)/2)*D Where: NL2 D refers to the deformation tensor NL2 K refers to fluid consistency (may be a function of the temperature T) NL2 n refers to the fluid structure index n=1 for a Newtonian fluid, n<1 for a rheofluidifier fluid, n>1 for a rheothickening fluid. 
  attr k field_base k 1 Fluid consistency.
  attr n field_base n 1 Fluid structure index.
Pb_Multiphase Pb_base Pb_Multiphase -1 A problem that allows the resolution of N-phases with 3*N equations 
  attr milieu_composite bloc_lecture milieu_composite 1 The composite medium associated with the problem.
  attr Milieu_MUSIG bloc_lecture Milieu_MUSIG 1 The composite medium associated with the problem.
  attr correlations bloc_lecture correlations 1 List of correlations used in specific source terms (i.e. interfacial flux, interfacial friction, ...)
  attr QDM_Multiphase QDM_Multiphase QDM_Multiphase 0 Momentum conservation equation for a multi-phase problem where the unknown is the velocity
  attr Masse_Multiphase Masse_Multiphase Masse_Multiphase 0 Mass consevation equation for a multi-phase problem where the unknown is the alpha (void fraction)
  attr Energie_Multiphase Energie_Multiphase Energie_Multiphase 0 Internal energy conservation equation for a multi-phase problem where the unknown is the temperature
  attr Energie_cinetique_turbulente Energie_cinetique_turbulente Energie_cinetique_turbulente 1 Turbulent kinetic Energy conservation equation for a turbulent mono/multi-phase problem (available in TrioCFD)
  attr Echelle_temporelle_turbulente Echelle_temporelle_turbulente Echelle_temporelle_turbulente 1 Turbulent Dissipation time scale equation for a turbulent mono/multi-phase problem (available in TrioCFD)
  attr Energie_cinetique_turbulente_WIT Energie_cinetique_turbulente_WIT Energie_cinetique_turbulente_WIT 1 Bubble Induced Turbulent kinetic Energy equation for a turbulent multi-phase problem (available in TrioCFD)
  attr Taux_dissipation_turbulent Taux_dissipation_turbulent Taux_dissipation_turbulent 1 Turbulent Dissipation frequency equation for a turbulent mono/multi-phase problem (available in TrioCFD)
Energie_cinetique_turbulente eqn_base Energie_cinetique_turbulente 1 Turbulent kinetic Energy conservation equation for a turbulent mono/multi-phase problem (available in TrioCFD) 
Echelle_temporelle_turbulente eqn_base Echelle_temporelle_turbulente -1 Turbulent Dissipation time scale equation for a turbulent mono/multi-phase problem (available in TrioCFD) 
Energie_cinetique_turbulente_WIT eqn_base Energie_cinetique_turbulente_WIT -1 Bubble Induced Turbulent kinetic Energy equation for a turbulent multi-phase problem (available in TrioCFD) 
Taux_dissipation_turbulent eqn_base Taux_dissipation_turbulent -1 Turbulent Dissipation frequency equation for a turbulent mono/multi-phase problem (available in TrioCFD) 
Pb_HEM Pb_Multiphase Pb_HEM -1 A problem that allows the resolution of 2-phases mechanicaly and thermally coupled with 3 equations 
Energie_Multiphase eqn_base Energie_Multiphase -1 Internal energy conservation equation for a multi-phase problem where the unknown is the temperature 
QDM_Multiphase eqn_base QDM_Multiphase -1 Momentum conservation equation for a multi-phase problem where the unknown is the velocity 
  attr solveur_pression solveur_sys_base solveur_pression 1 Linear pressure system resolution method.
  attr evanescence bloc_lecture evanescence 1 Management of the vanishing phase (when alpha tends to 0 or 1)
Masse_Multiphase eqn_base Masse_Multiphase -1 Mass consevation equation for a multi-phase problem where the unknown is the alpha (void fraction) 
sets simpler sets -1 Stability-Enhancing Two-Step solver which is useful for a multiphase problem. Ref : J. H. MAHAFFY, A stability-enhancing two-step method for fluid flow calculations, Journal of Computational Physics, 46, 3, 329 (1982). 
  attr criteres_convergence bloc_criteres_convergence criteres_convergence 1 Set the convergence thresholds for each unknown (i.e: alpha, temperature, velocity and pressure). The default values are respectively 0.01, 0.1, 0.01 and 100
  attr iter_min entier iter_min 1 Number of minimum iterations
  attr seuil_convergence_implicite floattant seuil_convergence_implicite 1 Convergence criteria.
  attr nb_corrections_max entier nb_corrections_max 1 Maximum number of corrections performed by the PISO algorithm to achieve the projection of the velocity field. The algorithm may perform less corrections then nb_corrections_max if the accuracy of the projection is sufficient. (By default nb_corrections_max is set to 21).
bloc_criteres_convergence bloc_lecture nul 0 Not set 
ice sets ice -1 Implicit Continuous-fluid Eulerian solver which is useful for a multiphase problem. Robust pressure reduction resolution. 
  attr pression_degeneree entier pression_degeneree 1 Set to 1 if the pressure field is degenerate (ex. : incompressible fluid with no imposed-pressure BCs). Default: autodetected
  attr reduction_pression|pressure_reduction entier reduction_pression 1 Set to 1 if the user wants a resolution with a pressure reduction. Otherwise, the rien is to be set to 0 so that the complete matrix is considered. The default value of this rien is 1.
criteres_convergence interprete nul 0 convergence criteria 
  attr aco chaine(into=["{"]) aco 0 Opening curly bracket.
  attr inco chaine inco 1 Unknown (i.e: alpha, temperature, velocity and pressure)
  attr val floattant val 1 Convergence threshold
  attr acof chaine(into=["}"]) acof 0 Closing curly bracket.
Source_Travail_pression_Elem_base source_base Source_Travail_pression_Elem_base 0 Source term which corresponds to the additional pressure work term that appears when dealing with compressible multiphase fluids 
flux_interfacial source_base flux_interfacial 0 Source term of mass transfer between phases connected by the saturation object defined in saturation_xxxx 
frottement_interfacial source_base frottement_interfacial 1 Source term which corresponds to the phases friction at the interface 
  attr a_res floattant a_res 1 void fraction at which the gas velocity is forced to approach liquid velocity (default alpha_evanescence*100)
  attr dv_min floattant dv_min 1 minimal relative velocity used to linearize interfacial friction at low velocities
  attr exp_res entier exp_res 1 exponent that callibrates intensity of velocity convergence (default 2)
vitesse_relative_base source_base vitesse_relative_base 0 Basic class for drift-velocity source term between a liquid and a gas phase 
vitesse_derive_base vitesse_relative_base vitesse_derive_base 0 Source term which corresponds to the drift-velocity between a liquid and a gas phase 
travail_pression source_base travail_pression 0 Source term which corresponds to the additional pressure work term that appears when dealing with compressible multiphase fluids 
fluide_sodium_liquide fluide_reel_base fluide_sodium_liquide -1 Class for Fluide_sodium_liquide 
  attr P_ref floattant P_ref 1 Use to set the pressure value in the closure law. If not specified, the value of the pressure unknown will be used
  attr T_ref floattant T_ref 1 Use to set the temperature value in the closure law. If not specified, the value of the temperature unknown will be used
liste_mil listobj liste_mil -1 milieu_base 0 Composite medium made of several sub mediums. 
saturation_sodium saturation_base saturation_sodium -1 Class for saturation sodium 
  attr P_ref floattant P_ref 1 Use to fix the pressure value in the closure law. If not specified, the value of the pressure unknown will be used
  attr T_ref floattant T_ref 1 Use to fix the temperature value in the closure law. If not specified, the value of the temperature unknown will be used
fluide_sodium_gaz fluide_reel_base fluide_sodium_gaz -1 Class for Fluide_sodium_liquide 
  attr P_ref floattant P_ref 1 Use to set the pressure value in the closure law. If not specified, the value of the pressure unknown will be used
  attr T_ref floattant T_ref 1 Use to set the temperature value in the closure law. If not specified, the value of the temperature unknown will be used
saturation_constant saturation_base saturation_constant -1 Class for saturation constant 
  attr P_sat floattant P_sat 1 Define the saturation pressure value (this is a required parameter)
  attr T_sat floattant T_sat 1 Define the saturation temperature value (this is a required parameter)
  attr Lvap floattant Lvap 1 Latent heat of vaporization
  attr Hlsat floattant Hlsat 1 Liquid saturation enthalpy
  attr Hvsat floattant Hvsat 1 Vapor saturation enthalpy
saturation_base objet_u saturation_base -1 fluide-gas interface with phase change (used in pb_multiphase) 
fluide_reel_base fluide_base fluide_reel_base -1 Class for real fluids. 
fluide_stiffened_gas fluide_reel_base fluide_stiffened_gas -1 Class for Stiffened Gas 
  attr gamma floattant gamma 1 Heat capacity ratio (Cp/Cv)
  attr pinf floattant pinf 1 Stiffened gas pressure constant (if set to zero, the state law becomes identical to that of perfect gases)
  attr mu floattant mu 1 Dynamic viscosity
  attr lambda floattant lambda 1 Thermal conductivity
  attr Cv floattant Cv 1 Thermal capacity at constant volume
  attr q floattant q 1 Reference energy
  attr q_prim floattant q_prim 1 Model constant
pb_thermohydraulique_especes_QC pb_avec_passif pb_thermohydraulique_especes_QC -1 Resolution of thermo-hydraulic problem for a multi-species quasi-compressible fluid. 
  attr fluide_quasi_compressible fluide_quasi_compressible fluide_quasi_compressible 0 The fluid medium associated with the problem.
  attr navier_stokes_QC navier_stokes_QC navier_stokes_QC 0 Navier-Stokes equation for a quasi-compressible fluid.
  attr convection_diffusion_chaleur_QC convection_diffusion_chaleur_QC convection_diffusion_chaleur_QC 0 Temperature equation for a quasi-compressible fluid.
pb_thermohydraulique_especes_WC pb_avec_passif pb_thermohydraulique_especes_WC -1 Resolution of thermo-hydraulic problem for a multi-species weakly-compressible fluid. 
  attr fluide_weakly_compressible fluide_weakly_compressible fluide_weakly_compressible 0 The fluid medium associated with the problem.
  attr navier_stokes_WC navier_stokes_WC navier_stokes_WC 0 Navier-Stokes equation for a weakly-compressible fluid.
  attr convection_diffusion_chaleur_WC convection_diffusion_chaleur_WC convection_diffusion_chaleur_WC 0 Temperature equation for a weakly-compressible fluid.
loi_etat_gaz_parfait_base loi_etat_base loi_etat_gaz_parfait_base -1 Basic class for perfect gases state laws used with a dilatable fluid. 
loi_etat_gaz_reel_base loi_etat_base loi_etat_gaz_reel_base -1 Basic class for real gases state laws used with a dilatable fluid. 
loi_etat_base objet_u loi_etat_base -1 Basic class for state laws used with a dilatable fluid. 
fluide_dilatable_base fluide_base fluide_dilatable_base -1 Basic class for dilatable fluids. 
pb_thermohydraulique_WC Pb_base pb_thermohydraulique_WC -1 Resolution of thermo-hydraulic problem for a weakly-compressible fluid. NL2 Keywords for the unknowns other than pressure, velocity, temperature are : NL2 masse_volumique : density NL2 pression : reduced pressure NL2 pression_tot : total pressure NL2 pression_hydro : hydro-static pressure NL2 pression_eos : pressure used in state equation. 
  attr fluide_weakly_compressible fluide_weakly_compressible fluide_weakly_compressible 0 The fluid medium associated with the problem.
  attr navier_stokes_WC navier_stokes_WC navier_stokes_WC 0 Navier-Stokes equation for a weakly-compressible fluid.
  attr convection_diffusion_chaleur_WC convection_diffusion_chaleur_WC convection_diffusion_chaleur_WC 0 Temperature equation for a weakly-compressible fluid.
pb_hydraulique_melange_binaire_WC Pb_base pb_hydraulique_melange_binaire_WC -1 Resolution of a binary mixture problem for a weakly-compressible fluid with an iso-thermal condition. NL2 Keywords for the unknowns other than pressure, velocity, fraction_massique are : NL2 masse_volumique : density NL2 pression : reduced pressure NL2 pression_tot : total pressure NL2 pression_hydro : hydro-static pressure NL2 pression_eos : pressure used in state equation. 
  attr fluide_weakly_compressible fluide_weakly_compressible fluide_weakly_compressible 0 The fluid medium associated with the problem.
  attr navier_stokes_WC navier_stokes_WC navier_stokes_WC 0 Navier-Stokes equation for a weakly-compressible fluid.
  attr convection_diffusion_espece_binaire_WC convection_diffusion_espece_binaire_WC convection_diffusion_espece_binaire_WC 0 Species conservation equation for a binary weakly-compressible fluid.
convection_diffusion_chaleur_WC eqn_base convection_diffusion_chaleur_WC -1 Temperature equation for a weakly-compressible fluid. 
navier_stokes_WC navier_stokes_standard navier_stokes_WC -1 Navier-Stokes equation for a weakly-compressible fluid. 
convection_diffusion_espece_binaire_WC eqn_base convection_diffusion_espece_binaire_WC -1 Species conservation equation for a binary weakly-compressible fluid. 
convection_diffusion_espece_multi_WC eqn_base convection_diffusion_espece_multi_WC -1 Species conservation equation for a multi-species weakly-compressible fluid. 
binaire_gaz_parfait_WC loi_etat_gaz_parfait_base binaire_gaz_parfait_WC -1 Class for perfect gas binary mixtures state law used with a weakly-compressible fluid under the iso-thermal and iso-bar assumptions. 
  attr molar_mass1 floattant molar_mass1 0 Molar mass of species 1 (in kg/mol).
  attr molar_mass2 floattant molar_mass2 0 Molar mass of species 2 (in kg/mol).
  attr mu1 floattant mu1 0 Dynamic viscosity of species 1 (in kg/m.s).
  attr mu2 floattant mu2 0 Dynamic viscosity of species 2 (in kg/m.s).
  attr temperature floattant temperature 0 Temperature (in Kelvin) which will be constant during the simulation since this state law only works for iso-thermal conditions.
  attr diffusion_coeff floattant diffusion_coeff 0 Diffusion coefficient assumed the same for both species (in m2/s).
perfect_gaz_WC loi_etat_gaz_parfait_base gaz_parfait_WC 1 Class for perfect gas state law used with a weakly-compressible fluid. 
  attr Cp floattant Cp 0 Specific heat at constant pressure (J/kg/K).
  attr Cv floattant Cv 1 Specific heat at constant volume (J/kg/K).
  attr gamma floattant gamma 1 Cp/Cv
  attr Prandtl floattant Prandtl 0 Prandtl number of the gas Pr=mu*Cp/lambda
multi_gaz_parfait_WC loi_etat_gaz_parfait_base multi_gaz_parfait_WC -1 Class for perfect gas multi-species mixtures state law used with a weakly-compressible fluid. 
  attr species_number entier species_number 0 Number of species you are considering in your problem.
  attr diffusion_coeff field_base diffusion_coeff 0 Diffusion coefficient of each species, defined with a Champ_uniforme of dimension equals to the species_number.
  attr molar_mass field_base molar_mass 0 Molar mass of each species, defined with a Champ_uniforme of dimension equals to the species_number.
  attr mu field_base mu 0 Dynamic viscosity of each species, defined with a Champ_uniforme of dimension equals to the species_number.
  attr cp field_base cp 0 Specific heat at constant pressure of the gas Cp, defined with a Champ_uniforme of dimension equals to the species_number..
  attr prandtl floattant prandtl 0 Prandtl number of the gas Pr=mu*Cp/lambda.
fluide_weakly_compressible fluide_dilatable_base fluide_weakly_compressible -1 Weakly-compressible flow with a low mach number assumption; this means that the thermo-dynamic pressure (used in state law) can vary in space. 
  attr loi_etat loi_etat_base loi_etat 1 The state law that will be associated to the Weakly-compressible fluid.
  attr sutherland bloc_sutherland sutherland 1 Sutherland law for viscosity and for conductivity.
  attr traitement_pth chaine(into=["constant"]) traitement_pth 1 Particular treatment for the thermodynamic pressure Pth ; there is currently one possibility: NL2 1) the keyword \'constant\' makes it possible to have a constant Pth but not uniform in space ; it\'s the good choice when the flow is open (e.g. with pressure boundary conditions).
  attr lambda field_base lambda_u 1 Conductivity (W.m-1.K-1).
  attr mu field_base mu 1 Dynamic viscosity (kg.m-1.s-1).
  attr pression_thermo floattant pression_thermo 1 Initial thermo-dynamic pressure used in the assosciated state law.
  attr pression_xyz field_base pression_xyz 1 Initial thermo-dynamic pressure used in the assosciated state law. It should be defined with as a Champ_Fonc_xyz.
  attr use_total_pressure entier use_total_pressure 1 Flag (0 or 1) used to activate and use the total pressure in the assosciated state law. The default value of this Flag is 0.
  attr use_hydrostatic_pressure entier use_hydrostatic_pressure 1 Flag (0 or 1) used to activate and use the hydro-static pressure in the assosciated state law. The default value of this Flag is 0.
  attr use_grad_pression_eos entier use_grad_pression_eos 1 Flag (0 or 1) used to specify whether or not the gradient of the thermo-dynamic pressure will be taken into account in the source term of the temperature equation (case of a non-uniform pressure). The default value of this Flag is 1 which means that the gradient is used in the source.
  attr time_activate_ptot floattant time_activate_ptot 1 Time (in seconds) at which the total pressure will be used in the assosciated state law.
pb_thermohydraulique_QC Pb_base pb_thermohydraulique_QC -1 Resolution of thermo-hydraulic problem for a quasi-compressible fluid. NL2 Keywords for the unknowns other than pressure, velocity, temperature are : NL2 masse_volumique : density NL2 enthalpie : enthalpy NL2 pression : reduced pressure NL2 pression_tot : total pressure. 
  attr fluide_quasi_compressible fluide_quasi_compressible fluide_quasi_compressible 0 The fluid medium associated with the problem.
  attr navier_stokes_QC navier_stokes_QC navier_stokes_QC 0 Navier-Stokes equation for a quasi-compressible fluid.
  attr convection_diffusion_chaleur_QC convection_diffusion_chaleur_QC convection_diffusion_chaleur_QC 0 Temperature equation for a quasi-compressible fluid.
pb_hydraulique_melange_binaire_QC Pb_base pb_hydraulique_melange_binaire_QC -1 Resolution of a binary mixture problem for a quasi-compressible fluid with an iso-thermal condition. NL2 Keywords for the unknowns other than pressure, velocity, fraction_massique are : NL2 masse_volumique : density NL2 pression : reduced pressure NL2 pression_tot : total pressure. 
  attr fluide_quasi_compressible fluide_quasi_compressible fluide_quasi_compressible 0 The fluid medium associated with the problem.
  attr constituant constituant constituant 1 The various constituants associated to the problem.
  attr navier_stokes_QC navier_stokes_QC navier_stokes_QC 0 Navier-Stokes equation for a quasi-compressible fluid.
  attr convection_diffusion_espece_binaire_QC convection_diffusion_espece_binaire_QC convection_diffusion_espece_binaire_QC 0 Species conservation equation for a binary quasi-compressible fluid.
navier_stokes_QC navier_stokes_standard navier_stokes_QC -1 Navier-Stokes equation for a quasi-compressible fluid. 
convection_diffusion_espece_binaire_QC eqn_base convection_diffusion_espece_binaire_QC -1 Species conservation equation for a binary quasi-compressible fluid. 
convection_diffusion_espece_multi_QC eqn_base convection_diffusion_espece_multi_QC -1 Species conservation equation for a multi-species quasi-compressible fluid. 
  attr espece espece espece 1 Assosciate a species (with its properties) to the equation
convection_diffusion_chaleur_QC eqn_base convection_diffusion_chaleur_QC -1 Temperature equation for a quasi-compressible fluid. 
  attr mode_calcul_convection chaine(into=["ancien","divuT_moins_Tdivu","divrhouT_moins_Tdivrhou"]) mode_calcul_convection 1 Option to set the form of the convective operatorNL2 divrhouT_moins_Tdivrhou (the default since 1.6.8): rho.u.gradT = div(rho.u.T )- Tdiv(rho.u.1) NL2ancien: u.gradT = div(u.T) - T.div(u) NL2 divuT_moins_Tdivu : u.gradT = div(u.T) - Tdiv(u.1)
multi_gaz_parfait_QC loi_etat_gaz_parfait_base multi_gaz_parfait_QC -1 Class for perfect gas multi-species mixtures state law used with a quasi-compressible fluid. 
  attr sc floattant sc 0 Schmidt number of the gas Sc=nu/D (D: diffusion coefficient of the mixing).
  attr prandtl floattant prandtl 0 Prandtl number of the gas Pr=mu*Cp/lambda
  attr cp floattant cp 1 Specific heat at constant pressure of the gas Cp.
  attr dtol_fraction floattant dtol_fraction 1 Delta tolerance on mass fractions for check testing (default value 1.e-6).
  attr correction_fraction rien correction_fraction 1 To force mass fractions between 0. and 1.
  attr ignore_check_fraction rien ignore_check_fraction 1 Not to check if mass fractions between 0. and 1.
rhoT_gaz_reel_QC loi_etat_gaz_reel_base rhoT_gaz_reel_QC 0 Class for real gas state law used with a quasi-compressible fluid. 
  attr bloc bloc_lecture bloc 0 Description.
binaire_gaz_parfait_QC loi_etat_gaz_parfait_base binaire_gaz_parfait_QC -1 Class for perfect gas binary mixtures state law used with a quasi-compressible fluid under the iso-thermal and iso-bar assumptions. 
  attr molar_mass1 floattant molar_mass1 0 Molar mass of species 1 (in kg/mol).
  attr molar_mass2 floattant molar_mass2 0 Molar mass of species 2 (in kg/mol).
  attr mu1 floattant mu1 0 Dynamic viscosity of species 1 (in kg/m.s).
  attr mu2 floattant mu2 0 Dynamic viscosity of species 2 (in kg/m.s).
  attr temperature floattant temperature 0 Temperature (in Kelvin) which will be constant during the simulation since this state law only works for iso-thermal conditions.
  attr diffusion_coeff floattant diffusion_coeff 0 Diffusion coefficient assumed the same for both species (in m2/s).
rhoT_gaz_parfait_QC loi_etat_gaz_parfait_base rhoT_gaz_parfait_QC -1 Class for perfect gas used with a aquasi-compressible fluid where the state equation is defined as rho = f(T). 
  attr cp floattant cp 0 Specific heat at constant pressure of the gas Cp.
  attr prandtl floattant prandtl 1 Prandtl number of the gas Pr=mu*Cp/lambda
  attr rho_xyz field_base rho_xyz 1 Defined with a Champ_Fonc_xyz to define a constant rho with time (space dependent)
  attr rho_t chaine rho_t 1 Expression of T used to calculate rho. This can lead to a variable rho, both in space and in time.
perfect_gaz_QC loi_etat_gaz_parfait_base gaz_parfait_QC 1 Class for perfect gas state law used with a quasi-compressible fluid. 
  attr Cp floattant Cp 0 Specific heat at constant pressure (J/kg/K).
  attr Cv floattant Cv 1 Specific heat at constant volume (J/kg/K).
  attr gamma floattant gamma 1 Cp/Cv
  attr Prandtl floattant Prandtl 0 Prandtl number of the gas Pr=mu*Cp/lambda
  attr rho_constant_pour_debug field_base rho_constant_pour_debug 1 For developers to debug the code with a constant rho.
Champ_front_debit_QC_VDF front_field_base Champ_front_debit_QC_VDF 0 This keyword is used to define a flow rate field for quasi-compressible fluids in VDF discretization. The flow rate is kept constant during a transient. 
  attr dimension entier dim 0 Problem dimension
  attr liste bloc_lecture liste 0 List of the mass flow rate values [kg/s/m2] with the following syntaxe: { val1 ... valdim }
  attr moyen chaine moyen 1 Option to use rho mean value
  attr pb_name chaine pb_name 0 Problem name
Champ_front_debit_QC_VDF_fonc_t front_field_base Champ_front_debit_QC_VDF_fonc_t 0 This keyword is used to define a flow rate field for quasi-compressible fluids in VDF discretization. The flow rate could be constant or time-dependent. 
  attr dimension entier dim 0 Problem dimension
  attr liste bloc_lecture liste 0 List of the mass flow rate values [kg/s/m2] with the following syntaxe: { val1 ... valdim } where val1 ... valdim are constant or function of time.
  attr moyen chaine moyen 1 Option to use rho mean value
  attr pb_name chaine pb_name 0 Problem name
fluide_quasi_compressible fluide_dilatable_base fluide_quasi_compressible -1 Quasi-compressible flow with a low mach number assumption; this means that the thermo-dynamic pressure (used in state law) is uniform in space. 
  attr sutherland bloc_sutherland sutherland 1 Sutherland law for viscosity and for conductivity.
  attr pression floattant pression 1 Initial thermo-dynamic pressure used in the assosciated state law.
  attr loi_etat loi_etat_base loi_etat 1 The state law that will be associated to the Quasi-compressible fluid.
  attr traitement_pth chaine(into=["edo","constant","conservation_masse"]) traitement_pth 1 Particular treatment for the thermodynamic pressure Pth ; there are three possibilities: NL2 1) with the keyword \'edo\' the code computes Pth solving an O.D.E. ; in this case, the mass is not strictly conserved (it is the default case for quasi compressible computation): NL2 2) the keyword \'conservation_masse\' forces the conservation of the mass (closed geometry or with periodic boundaries condition) NL2 3) the keyword \'constant\' makes it possible to have a constant Pth ; it\'s the good choice when the flow is open (e.g. with pressure boundary conditions). NL2 It is possible to monitor the volume averaged value for temperature and density, plus Pth evolution in the .evol_glob file.
  attr traitement_rho_gravite chaine(into=["standard","moins_rho_moyen"]) traitement_rho_gravite 1 It may be :1) \`standard\` : the gravity term is evaluted with rho*g (It is the default). 2) \`moins_rho_moyen\` : the gravity term is evaluated with (rho-rhomoy) *g. Unknown pressure is then P*=P+rhomoy*g*z. It is useful when you apply uniforme pressure boundary condition like P*=0.
  attr temps_debut_prise_en_compte_drho_dt floattant temps_debut_prise_en_compte_drho_dt 1 While time<value, dRho/dt is set to zero (Rho, volumic mass). Useful for some calculation during the first time steps with big variation of temperature and volumic mass.
  attr omega_relaxation_drho_dt floattant omega_relaxation_drho_dt 1 Optional option to have a relaxed algorithm to solve the mass equation. value is used (1 per default) to specify omega.
  attr lambda field_base lambda_u 1 Conductivity (W.m-1.K-1).
  attr mu field_base mu 1 Dynamic viscosity (kg.m-1.s-1).
bloc_sutherland objet_lecture nul 0 Sutherland law for viscosity mu(T)=mu0*((T0+C)/(T+C))*(T/T0)**1.5 and (optional) for conductivity lambda(T)=mu0*Cp/Prandtl*((T0+Slambda)/(T+Slambda))*(T/T0)**1.5 
  attr problem_name ref_Pb_base problem_name 0 Name of problem.
  attr mu0 chaine(into=["mu0"]) mu0 0 not_set
  attr mu0_val floattant mu0_val 0 not_set
  attr t0 chaine(into=["T0"]) t0 0 not_set
  attr t0_val floattant t0_val 0 not_set
  attr Slambda chaine(into=["Slambda"]) Slambda 1 not_set
  attr s floattant s 1 not_set
  attr C chaine(into=["C"]) C 0 not_set
  attr c_val floattant c_val 0 not_set
espece interprete nul 1 not_set 
  attr mu field_base mu 0 Species dynamic viscosity value (kg.m-1.s-1).
  attr cp field_base cp 0 Species specific heat value (J.kg-1.K-1).
  attr masse_molaire floattant masse_molaire 0 Species molar mass.
option_vdf interprete option_vdf 1 Class of VDF options. 
  attr traitement_coins chaine(into=["oui","non"]) traitement_coins 1 Treatment of corners (yes or no). This option modifies slightly the calculations at the outlet of the plane channel. It supposes that the boundary continues after channel outlet (i.e. velocity vector remains parallel to the boundary).
  attr traitement_gradients chaine(into=["oui","non"]) traitement_gradients 1 Treatment of gradient calculations (yes or no). This option modifies slightly the gradient calculation at the corners and activates also the corner treatment option.
  attr p_imposee_aux_faces chaine(into=["oui","non"]) p_imposee_aux_faces 1 Pressure imposed at the faces (yes or no).
  attr all_options|toutes_les_options rien all_options 1 Activates all Option_VDF options. If used, must be used alone without specifying the other options, nor combinations.
Echange_interne_impose condlim_base Paroi_echange_interne_impose -1 Internal heat exchange boundary condition with exchange coefficient. 
  attr h_imp chaine h_imp 0 Exchange coefficient value expressed in W.m-2.K-1.
  attr ch front_field_base ch 0 Boundary field type.
Echange_interne_parfait condlim_base Paroi_echange_interne_parfait -1 Internal heat exchange boundary condition with perfect (infinite) exchange coefficient. 
Option_PolyMAC_P0 interprete Option_Covimac 1 Class of PolyMAC_P0 options. 
  attr interp_ve1 rien interp_ve1 1 Flag to enable a first order velocity face-to-element interpolation (the default value is 0 which means a second order interpolation)
Op_Conv_EF_Stab_PolyMAC_Elem interprete Op_Conv_EF_Stab_PolyMAC_Elem 1 Class Op_Conv_EF_Stab_PolyMAC_Elem 
  attr alpha floattant alpha 1 parametre ajustant la stabilisation de 0 (schema centre) a 1 (schema amont)
Op_Conv_EF_Stab_PolyMAC_P0_Face interprete Op_Conv_EF_Stab_PolyMAC_P0_Face 1 Class Op_Conv_EF_Stab_PolyMAC_P0_Face 
  attr alpha floattant alpha 1 parametre ajustant la stabilisation de 0 (schema centre) a 1 (schema amont)
Op_Conv_EF_Stab_PolyMAC_Face interprete Op_Conv_EF_Stab_PolyMAC_Face 1 Class Op_Conv_EF_Stab_PolyMAC_Face 
  attr alpha floattant alpha 1 parametre ajustant la stabilisation de 0 (schema centre) a 1 (schema amont)
Coarsen_Operator_Uniform objet_lecture nul 0 Object defining the uniform coarsening process of the given grid in IJK discretization 
  attr Coarsen_Operator_Uniform chaine Coarsen_Operator_Uniform 1 not_set
  attr aco chaine(into=["{"]) aco 0 opening curly brace
  attr coarsen_i chaine(into=["coarsen_i"]) coarsen_i 1 not_set
  attr coarsen_i_val entier coarsen_i_val 1 Integer indicating the number by which we will divide the number of elements in the I direction (in order to obtain a coarser grid)
  attr coarsen_j chaine(into=["coarsen_j"]) coarsen_j 1 not_set
  attr coarsen_j_val entier coarsen_j_val 1 Integer indicating the number by which we will divide the number of elements in the J direction (in order to obtain a coarser grid)
  attr coarsen_k chaine(into=["coarsen_k"]) coarsen_k 1 not_set
  attr coarsen_k_val entier coarsen_k_val 1 Integer indicating the number by which we will divide the number of elements in the K direction (in order to obtain a coarser grid)
  attr acof chaine(into=["}"]) acof 0 closing curly brace
coarsen_operators listobj nul 0 Coarsen_Operator_Uniform 0 not_set 
multigrid_solver interprete nul 1 Object defining a multigrid solver in IJK discretization 
  attr coarsen_operators coarsen_operators coarsen_operators 1 Definition of the number of grids that will be used, in addition to the finest (original) grid, followed by the list of the coarsen operators that will be applied to get those grids
  attr ghost_size entier ghost_size 1 Number of ghost cells known by each processor in each of the three directions
  attr relax_jacobi list relax_jacobi 1 Parameter between 0 and 1 that will be used in the Jacobi method to solve equation on each grid. Should be around 0.7
  attr pre_smooth_steps listentier pre_smooth_steps 1 First integer of the list indicates the numbers of integers that has to be read next. Following integers define the numbers of iterations done before solving the equation on each grid. For example, 2 7 8 means that we have a list of 2 integers, the first one tells us to perform 7 pre-smooth steps on the first grid, the second one tells us to perform 8 pre-smooth steps on the second grid. If there are more than 2 grids in the solver, then the remaining ones will have as many pre-smooth steps as the last mentionned number (here, 8)
  attr smooth_steps listentier smooth_steps 1 First integer of the list indicates the numbers of integers that has to be read next. Following integers define the numbers of iterations done after solving the equation on each grid. Same behavior as pre_smooth_steps
  attr nb_full_mg_steps listentier nb_full_mg_steps 1 Number of multigrid iterations at each level
  attr solveur_grossier solveur_sys_base solveur_grossier 1 Name of the iterative solver that will be used to solve the system on the coarsest grid. This resolution must be more precise than the ones occurring on the fine grids. The threshold of this solver must therefore be lower than seuil defined above.
  attr seuil floattant seuil 1 Define an upper bound on the norm of the final residue (i.e. the one obtained after applying the multigrid solver). With hybrid precision, as long as we have not obtained a residue whose norm is lower than the imposed threshold, we keep applying the solver
  attr impr rien impr 1 Flag to display some info on the resolution on eahc grid
  attr solver_precision chaine(into=["mixed","double"]) solver_precision 1 Precision with which the variables at stake during the resolution of the system will be stored. We can have a simple or floattant precision or both. In the case of a hybrid precision, the multigrid solver is launched in simple precision, but the residual is calculated in floattant precision.
  attr iterations_mixed_solver entier iterations_mixed_solver 1 Define the maximum number of iterations in mixed precision solver
Test_SSE_Kernels interprete Test_SSE_Kernels 1 Object to test the different kernel methods used in the multigrid solver in IJK discretization 
  attr nmax entier nmax 1 Number of tests we want to perform
Parallel_io_parameters interprete Parallel_io_parameters 1 Object to handle parallel files in IJK discretization 
  attr block_size_bytes entier block_size_bytes 1 File writes will be performed by chunks of this size (in bytes). This parameter will not be taken into account if block_size_megabytes has been defined
  attr block_size_megabytes entier block_size_megabytes 1 File writes will be performed by chunks of this size (in megabytes). The size should be a multiple of the GPFS block size or lustre stripping size (typically several megabytes)
  attr writing_processes entier writing_processes 1 This is the number of processes that will write concurrently to the file system (this must be set according to the capacity of the filesystem, set to 1 on small computers, can be up to 64 or 128 on very large systems).
  attr bench_ijk_splitting_write chaine bench_ijk_splitting_write 1 Name of the splitting object we want to use to run a parallel write bench (optional parameter)
  attr bench_ijk_splitting_read chaine bench_ijk_splitting_read 1 Name of the splitting object we want to use to run a parallel read bench (optional parameter)
IJK_Grid_Geometry domaine IJK_Grid_Geometry -1 Object to define the grid that will represent the domain of the simulation in IJK discretization 
  attr perio_i rien perio_i 1 rien to specify the border along the I direction is periodic
  attr perio_j rien perio_j 1 rien to specify the border along the J direction is periodic
  attr perio_k rien perio_k 1 rien to specify the border along the K direction is periodic
  attr nbelem_i entier nbelem_i 1 the number of elements of the grid in the I direction
  attr nbelem_j entier nbelem_j 1 the number of elements of the grid in the J direction
  attr nbelem_k entier nbelem_k 1 the number of elements of the grid in the K direction
  attr uniform_domain_size_i floattant uniform_domain_size_i 1 the size of the elements along the I direction
  attr uniform_domain_size_j floattant uniform_domain_size_j 1 the size of the elements along the J direction
  attr uniform_domain_size_k floattant uniform_domain_size_k 1 the size of the elements along the K direction
  attr origin_i floattant origin_i 1 I-coordinate of the origin of the grid
  attr origin_j floattant origin_j 1 J-coordinate of the origin of the grid
  attr origin_k floattant origin_k 1 K-coordinate of the origin of the grid
IJK_Splitting objet_u IJK_Splitting -1 Object to specify how the domain will be divided between processors in IJK discretization 
  attr ijk_grid_geometry ref_IJK_Grid_Geometry ijk_grid_geometry 0 the grid that will be splitted
  attr nproc_i entier nproc_i 0 the number of processors into which we will divide the grid following the I direction
  attr nproc_j entier nproc_j 0 the number of processors into which we will divide the grid following the J direction
  attr nproc_k entier nproc_k 0 the number of processors into which we will divide the grid following the K direction
verifiercoin interprete verifiercoin -1 This keyword subdivides inconsistent 2D/3D cells used with VEFPreP1B discretization. Must be used before the mesh is discretized. NL1 The Read_file option can be used only if the file.decoupage_som was previously created by TRUST. This option, only in 2D, reverses the common face at two cells (at least one is inconsistent), through the nodes opposed. In 3D, the option has no effect. NL2 The expert_only option deactivates, into the VEFPreP1B divergence operator, the test of inconsistent cells. 
  attr domain_name ref_domaine dom 0 Name of the domaine
  attr bloc verifiercoin_bloc bloc 0 not_set
verifiercoin_bloc objet_lecture nul 1 not_set 
  attr Read_file|Lire_fichier chaine filename 1 name of the *.decoupage_som file
  attr expert_only rien expert_only 1 to not check the mesh
vefprep1b vef vefprep1b -1 Finite element volume discretization (P1NC/P1-bubble element). Since the 1.5.5 version, several new discretizations are available thanks to the optional keyword Read. By default, the VEFPreP1B keyword is equivalent to the former VEFPreP1B formulation (v1.5.4 and sooner). P0P1 (if used with the strong formulation for imposed pressure boundary) is equivalent to VEFPreP1B but the convergence is slower. VEFPreP1B dis is equivalent to VEFPreP1B dis Read dis { P0 P1 Changement_de_base_P1Bulle 1 Cl_pression_sommet_faible 0 } 
  attr changement_de_base_p1bulle entier changement_de_base_p1bulle 1 (into=[0,1]) changement_de_base_p1bulle 1 This option may be used to have the P1NC/P0P1 formulation (value set to 0) or the P1NC/P1Bulle formulation (value set to 1, the default).
  attr p0 rien p0 1 Pressure nodes are added on element centres
  attr p1 rien p1 1 Pressure nodes are added on vertices
  attr pa rien pa 1 Only available in 3D, pressure nodes are added on bones
  attr modif_div_face_dirichlet entier modif_div_face_dirichlet 1 (into=[0,1]) This option (by default 0) is used to extend control volumes for the momentum equation.
  attr cl_pression_sommet_faible entier cl_pression_sommet_faible 1 (into=[0,1]) This option is used to specify a strong formulation (value set to 0, the default) or a weak formulation (value set to 1) for an imposed pressure boundary condition. The first formulation converges quicker and is stable in general cases. The second formulation should be used if there are several outlet boundaries with Neumann condition (see Ecoulement_Neumann test case for example).
  
