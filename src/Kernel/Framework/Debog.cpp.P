/****************************************************************************
* Copyright (c) 2021, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
//////////////////////////////////////////////////////////////////////////////
//
// File:        Debog.cpp
// Directory:   $TRUST_ROOT/src/Kernel/Framework
// Version:     /main/14
//
//////////////////////////////////////////////////////////////////////////////

#include <Debog_Pb.h>
#include <Debog.h>
#include <Probleme_base.h>
#include <Equation.h>
#include <Zone_VF.h>
#include <Domaine.h>
#include <Param.h>
#include <MD_Vector_std.h>
#include <MD_Vector_composite.h>
#include <MD_Vector_tools.h>
#include <Octree_Double.h>
#include <ConstDoubleTab_parts.h>
#include <PE_Groups.h>
#include <Interprete_bloc.h>
#include <EChaine.h>
#include <Old_Debog.h>
#include <Matrice_Base.h>
#include <communications.h>

REF(Debog_Pb) Debog_Pb::instance_debog_;

// Dans gdb: mettre le numero du message entre parentheses dans cette variable
// avec "set msg_debog_breakpoint=x"
// et un point d'arret dans la methode debog_breakpoint()
static int msg_debog_breakpoint = 0;
static void debog_breakpoint()
{
}

void debog_break_test(int msg)
{
  if (msg == msg_debog_breakpoint)
    debog_breakpoint();
}

// Description: methode appelee des qu'une erreur est trouvee dans l'espace reel.
//  (utile pour poser un breakpoint dans gdb)
void Debog_Pb::error_function()
{
  if (exit_on_error_)
    {
      Cerr << "Error found in Debog_Pb (see debog.log files)" << finl;
      exit();
    }
}

Implemente_instanciable(Debog_Pb,"Debog_pb",Objet_U);
// Interprete compatible avec l'ancienne syntaxe
Implemente_instanciable(Old_Debog,"Debog",Interprete);
Implemente_ref(Debog_Pb);

Sortie& Old_Debog::printOn(Sortie& os) const
{
  exit();
  return os;
}

Entree& Old_Debog::readOn(Entree& is)
{
  exit();
  return is;
}

Entree& Old_Debog::interpreter(Entree& is)
{
  Nom nom_pb;
  is >> nom_pb;
  Nom nom_fic, nom_fic_faces;
  Nom seuil;
  int mode_db;
  is >> nom_fic >> nom_fic_faces >> seuil >> mode_db;

  Nom n("Debog_pb debog Lire debog { nom_pb ");
  n += nom_pb;
  n += " fichier_domaine ";
  n += nom_fic;
  n += " fichier_faces ";
  n += nom_fic_faces;
  n += " fichier_debog DEBOG";
  n += " seuil_absolu ";
  n += Nom(seuil);
  n += " seuil_relatif ";
  n += Nom(seuil);
  n += " mode_db ";
  if (mode_db == 0)
    n += "write";
  else
    n += "read";
  n += "  }";

  if (je_suis_maitre())
    Cerr << "Old_Debog: convert to new syntax: " << finl << n << finl;

  EChaine echaine(n);
  Interprete_bloc::interprete_courant().interpreter_bloc(echaine, Interprete_bloc::BLOC_EOF,
      0 /* verifie_sans_interpreter */);
  return is;
}

Sortie& Debog_Pb::printOn(Sortie& os) const
{
  exit();
  return os;
}

Debog_Pb::Debog_Pb(const Debog_Pb&): Objet_U()
{
  exit(); // invalide
}

Entree& Debog_Pb::readOn(Entree& is)
{
  fichier_domaine_ = "dom.debog";
  fichier_faces_ = "faces.debog";
  fichier_debog_ = "DEBOG";
  seuil_relatif_ = 1e-10;
  seuil_absolu_ = 1e-10;
  exit_on_error_ = 0;
  {
    Param param(que_suis_je());
    param.ajouter("nom_pb", &nom_pb_, Param::REQUIRED);
    param.ajouter("fichier_domaine", &fichier_domaine_);
    param.ajouter("fichier_faces", &fichier_faces_);
    param.ajouter("fichier_debog", &fichier_debog_);
    param.ajouter("seuil_absolu", &seuil_absolu_);
    param.ajouter("seuil_relatif", &seuil_relatif_);
    param.ajouter("ignorer_messages", &msg_a_ignorer_);
    param.ajouter("mode_db", &mode_db_, Param::REQUIRED);
    param.dictionnaire("write", 0);
    param.dictionnaire("read", 1);
    param.ajouter("exit_on_error", &exit_on_error_);
    param.lire_avec_accolades(is);
  }

  Objet_U& obj = Interprete::objet(nom_pb_);
  if (!sub_type(Probleme_base, obj))
    {
      Cerr << "Error in Debog::interpreter: " << obj << " is not a Problem_base object" << finl;
      exit();
    }

  Probleme_base& pb = ref_cast(Probleme_base, obj);
  if (pb.domaine_dis().nombre_de_zones() == 0)
    {
      Cerr<<finl;
      Cerr<<"WARNING, problem in Debog"<<finl;
      Cerr<<"It's maybe because you have put"<<finl;
      Cerr<<"the command line Debog before to have associated"<<finl;
      Cerr<<"the discretization to the problem."<<finl;
    }
  ref_pb_ = pb;

  if (mode_db_ == 0)
    {
      // Ecriture:
      write_geometry_data();
      write_debog_data_file_.ouvrir(fichier_debog_);
      write_debog_data_file_.setf(ios::scientific);
      write_debog_data_file_.precision(20);
    }
  else
    {
      read_geometry_data();
      debog_data_file_.ouvrir(fichier_debog_);
      debog_data_file_.set_error_action(Entree::ERROR_EXIT);
    }

  if (Process::je_suis_maitre())
    log_file_.ouvrir("debog.log");
  detailed_log_file_.ouvrir("debog_detail.log");

  debog_msg_count_ = 0;

  instance_debog_ = *this;
  return is;
}


int Debog_Pb::test_ignore_msg(const char* const msg)
{
  return msg_a_ignorer_.rang(msg) >= 0;
}

void Debog_Pb::goto_msg(const char* const message)
{
  assert(mode_db_==1);
  Nom dummy;
  Nom n;
  int num;
  Nom msg(message); // copie sans les espaces avant/apres
  while (msg.debute_par(" "))
    msg.suffix(" ");
  while (msg.finit_par(" "))
    msg.prefix(" ");
  while(1)
    {
      // read until we find a "msg" word:
      do
        {
          debog_data_file_ >> dummy;
        }
      while (dummy != "msg");

      debog_data_file_ >> dummy;
      if (dummy != ":")
        {
          Cerr << "Error in Debog_Pb::goto_msg(" << msg << ")\n invalid data in DEBOG file" << finl;
          exit();
        }
      num = -1;
      debog_data_file_ >> num;
      debog_data_file_ >> dummy;
      if (dummy != ":")
        {
          Cerr << "Error in Debog_Pb::goto_msg(" << msg << ")\n invalid data in DEBOG file" << finl;
          exit();
        }
      n = "";
      while(1)
        {
          debog_data_file_ >> dummy;
          if (dummy == "FinMsg")
            break;
          n += dummy;
          n += " ";
        }
      if (n.debute_par(msg))
        break;
      if (Process::je_suis_maitre())
        {
          log_file_ << "Skipping message " << n << " (looking for " << msg << ")" << finl;
        }
    }
  if (Process::je_suis_maitre())
    {
      log_file_ << "Reading message " << num << "(file) "
                << debog_msg_count_ << "(current) " << msg << finl;
    }
  detailed_log_file_ << "Reading message " << num << "(file) "
                     << debog_msg_count_ << "(current) " << msg << finl;
}

void Debog_Pb::write_geometry_data()
{
  if (Process::nproc() > 1)
    {
      Cerr << "Error in Debog.cpp: cannot write geometry data in parallel." << finl;
      Process::exit();
    }
  const Domaine& dom = ref_pb_.valeur().domaine();
  const Zone_dis_base& zd = ref_pb_.valeur().domaine_dis().zone_dis(0).valeur();
  const Zone_VF& zvf = ref_cast(Zone_VF, zd);
  {
    SFichier f(fichier_domaine_);
    f.precision(20);
    f << dom;
  }
  {
    SFichier f(fichier_faces_);
    f.precision(20);
    f << zvf.elem_faces();
    f << zvf.xv();
    f << zvf.face_voisins();
    if (zvf.xa().dimension(0) > 0)
      f << zvf.xa();
  }
  register_item(dom.md_vector_sommets(), "SOM");
  register_item(dom.zone(0).md_vector_elements(), "ELEM");
  register_item(zvf.md_vector_faces(), "FACE");
  if (zvf.md_vector_aretes().non_nul())
    register_item(zvf.md_vector_aretes(), "ARETES");
}

void Debog_Pb::register_item(const MD_Vector& md,
                             const Nom& id)
{
  known_md_.add(md);
  renum_id_.add(id);
}

void Debog_Pb::add_renum_item(const DoubleTab& coord_ref,
                              const DoubleTab& coord_par,
                              const MD_Vector& md,
                              const Nom& id)
{
  register_item(md, id);

  const double epsilon = Objet_U::precision_geom;

  // On cree un octree contenant les points du domaine de reference
  // et on cherche chaque point du domaine local dans cet octree.
  Octree_Double octree;
  octree.build_nodes(coord_ref, 1 /* include_virtual_items */);

  // Add a new renum array:
  renum_array_.add(IntVect());
  IntVect& renum = renum_array_[renum_array_.size()-1];
  MD_Vector_tools::creer_tableau_distribue(md, renum, Array_base::NOCOPY_NOINIT);

  if (renum.size_totale() != coord_par.dimension_tot(0))
    {
      Cerr << "Internal error in Debog::add_renum_item: coordinate array does not match md descriptor" << finl;
      exit();
    }
  const int dim = coord_par.dimension(1);
  ArrOfDouble center(dim);
  ArrOfInt elements;
  elements.set_smart_resize(1);
  const int n = renum.size_totale();
  for (int i = 0; i < n; i++)
    {
      for (int j = 0; j < dim; j++)
        center[j] = coord_par(i,j);
      octree.search_elements_box(center, epsilon, elements);
      // la premiere recherche renvoie tous les sommets potentiellement proches.
      // il faut faire ensuite un test sur chaque sommet:
      octree.search_nodes_close_to(center, coord_ref, elements, epsilon);
      const int k = elements.size_array();
      if (k != 1)
        {
          Cerr << "Debog::add_renum_item: Error. Id=" << id
               << "\n Item with following coordinates was found " << k << " times within epsilon=" << epsilon
               << "\n in the reference geometry: " << center << finl;
          exit();
        }
      // renum[i] is the index of the i-th local item in the reference geometry
      renum[i] = elements[0];
    }
}

void Debog_Pb::read_geometry_data()
{
  const Domaine& dom = ref_pb_.valeur().domaine();
  const Zone_dis_base& zd = ref_pb_.valeur().domaine_dis().zone_dis(0).valeur();
  const Zone_VF& zvf = ref_cast(Zone_VF, zd);
  {
    DoubleTab coord_som_seq; // sommets
    DoubleTab xp_seq; // centres des elements
    // Il faut passer dans un groupe monoprocesseur pour Domaine::readOn:
    {
      DERIV(Comm_Group) group;
      ArrOfInt liste_procs(1); // Liste de 1 processeur contenant le proc 0
      PE_Groups::create_group(liste_procs, group, 1);
      if (PE_Groups::enter_group(group.valeur()))
        {
          EFichier f(fichier_domaine_);
          Domaine dom_seq;
          f >> dom_seq;
          coord_som_seq = dom_seq.coord_sommets();
          const Elem_geom_base& elem = dom_seq.zone(0).type_elem().valeur();
          elem.calculer_centres_gravite(xp_seq);
          PE_Groups::exit_group();
        }
    }
    // Tous les processeurs recoivent les coordonnees des sommets de reference
    // (detruire le descripteur sinon printOn refuse d'envoyer le vecteur)
    coord_som_seq.set_md_vector(MD_Vector());
    envoyer_broadcast(coord_som_seq, 0);
    // Idem avec les centres des elements
    xp_seq.set_md_vector(MD_Vector());
    envoyer_broadcast(xp_seq, 0);

    // Calculer les renumerotations:
    const DoubleTab& coord_som = dom.coord_sommets();
    const MD_Vector& md_som = dom.coord_sommets().get_md_vector();
    add_renum_item(coord_som_seq, coord_som, md_som, "SOM");
    const DoubleTab& xp = zvf.xp();
    // Le tableau xp n'a pas de structure parallele, on la prend dans les elements...
    const MD_Vector& md_elem = dom.zone(0).les_elems().get_md_vector();
    add_renum_item(xp_seq, xp, md_elem, "ELEM");
  }
  {
    DoubleTab xv_seq;
    DoubleTab xa_seq;
    int avec_aretes = 1;
    if (Process::je_suis_maitre())
      {
        EFichier f(fichier_faces_);
        f.precision(20);
        {
          IntTab elem_faces;
          f >> elem_faces; // non utilise
        }
        f >> xv_seq;
        {
          IntTab face_voisins;
          f >> face_voisins; // non utilise
        }
        f.set_error_action(Entree::ERROR_EXCEPTION);
        try
          {
            f >> xa_seq;
          }
        catch (Entree_Sortie_Error)
          {
            avec_aretes = 0;
          }
      }
    envoyer_broadcast(xv_seq, 0);
    const DoubleTab& xv = zvf.xv();
    const MD_Vector& md_face = zvf.md_vector_faces();
    add_renum_item(xv_seq, xv, md_face, "FACE");

    envoyer_broadcast(avec_aretes, 0);
    if (avec_aretes)
      {
        envoyer_broadcast(xa_seq, 0);
        const DoubleTab& xa = zvf.xa();
        const MD_Vector& md_arete = zvf.md_vector_aretes();
        add_renum_item(xa_seq, xa, md_arete, "ARETE");
      }
  }
}

enum Debog_Exceptions { RENUM_ARRAY_NOT_FOUND };

const IntVect& Debog_Pb::find_renum_vector(const MD_Vector& mdv, Nom& id) const
{
  const int n = renum_array_.size();
  for (int i = 0; i < n; i++)
    {
      const IntVect& renum = renum_array_[i];
      if (renum.get_md_vector() == mdv)
        {
          id = renum_id_[i];
          return renum;
        }
    }
  throw RENUM_ARRAY_NOT_FOUND;
}

void Debog_Pb::verifier(const char* const msg, double x, double *ref_value)
{
  if (nom_pb_ != nom_pb_actuel_)
    return;

  if (test_ignore_msg(msg))
    {
      // Ignorer ce test
      return;
    }
  debog_break_test(debog_msg_count_);
  if (mode_db_ == 0)
    {
      // write
      Sortie& os = write_debog_data_file_;
      Cerr << "DEBOG: writing scalar, message " << debog_msg_count_ << " : " << msg << finl;
      os << "msg : " << debog_msg_count_ << " : " << msg << " FinMsg " << finl;
      os << x << finl;
    }
  else
    {
      // read and compare
      goto_msg(msg);
      double y;
      debog_data_file_ >> y;
      const double adim = std::max(std::fabs(x), std::fabs(y));
      const double delta = std::fabs(x-y);
      double err = 0;
      if (delta >= seuil_absolu_ && delta / adim >= seuil_relatif_)
        {
          err = delta;
          detailed_log_file_ << " ECART (double) reference=" << y
                             << " calcul=" << x
                             << " relative error=" << delta
                             << " (adim=" << adim << ")" << finl;
        }
      err = mp_sum(err);
      if (Process::je_suis_maitre())
        {
          const char *ok = (err > 0.) ? " ERROR       " : " OK           ";
          log_file_ << ok << " : comparing double: reference=" << y << " deltamax=" << err << finl;
          if (err > 0.)
            error_function();
        }
      if (ref_value)
        {
          if (Process::je_suis_maitre())
            log_file_ << "                Request reference value" << finl;
          *ref_value = y;
        }
    }
  debog_msg_count_++;
}

void Debog_Pb::verifier(const char* const msg, int x, int *ref_value)
{
  if (nom_pb_ != nom_pb_actuel_)
    return;

  if (test_ignore_msg(msg))
    {
      // Ignorer ce test
      return;
    }
  debog_break_test(debog_msg_count_);
  if (mode_db_ == 0)
    {
      // write
      Sortie& os = write_debog_data_file_;
      Cerr << "DEBOG: writing scalar, message " << debog_msg_count_ << " : " << msg << finl;
      os << "msg : " << debog_msg_count_ << " : " << msg << " FinMsg " << finl;
      os << x << finl;
    }
  else
    {
      // read and compare
      goto_msg(msg);
      int y;
      debog_data_file_ >> y;
      int err = ((x - y) != 0);
      if (err)
        {
          detailed_log_file_ << " ECART (int) reference=" << y
                             << " calcul=" << x << finl;
        }
      err = mp_sum(err);
      if (Process::je_suis_maitre())
        {
          const char *ok = (err > 0.) ? " ERROR       " : " OK           ";
          log_file_ << ok << " : comparing int: reference=" << y << finl;
          if (err)
            error_function();
        }
      if (ref_value)
        {
          if (Process::je_suis_maitre())
            log_file_ << "                Request reference value" << finl;
          *ref_value = y;
        }
    }
  debog_msg_count_++;
}

void Debog_Pb::set_nom_pb_actuel(const Nom& nom)
{
  nom_pb_actuel_ = nom;
}

void Debog::verifier(const char* const msg, double x)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier(msg, x);
}

void Debog::verifier(const char* const msg, int x)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier(msg, x);
}

void Debog::verifier_bord(const char* const msg, const DoubleVect& arr, int num_deb)
{
  // Ne fait rien
}

void Debog::verifier(const char* const msg, const Champ_Inc& x)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier(msg, x.valeur().valeurs());
}

void Debog::verifier(const char* const msg, const Champ_Inc_base& x)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier(msg, x.valeurs());
}

void Debog::set_nom_pb_actuel(const Nom& nom)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().set_nom_pb_actuel(nom);
}

// Description: teste le contenu du vecteur v en supposant qu'il contient des
//  indices d'items associes au descripteur md. Exemple: face_keps_imposee_
//  Les valeurs negatives doivent etre identiques a la reference,
//  les valeurs positives ou nulles sont interpretees comme un indice et
//  doivent etre egale a l'indice de reference apres renumerotation.
void Debog::verifier_indices_items(const char* const msg, const MD_Vector& md, const IntVect& v)
{
  // pas code
}

// Description: renvoie 1 si on est en mode Debog, 0 sinon
int Debog::active()
{
  return Debog_Pb::get_debog_instance().non_nul();
}

// Description: like verifier(), but, in "read&compare" mode, put the reference
//  value found in the file in the ref variable.
void Debog::verifier_getref(const char* const msg, double x, double& ref)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier(msg, x, &ref);
}

// Description: like verifier(), but, in "read&compare" mode, put the reference
//  value found in the file in the ref variable.
void Debog::verifier_getref(const char* const msg, int x, int& ref)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier(msg, x, &ref);
}

void debog_break_test(int msg);


#Pmacro macrodebog(_TYPE_)
#Pif (_TYPE_=="SCALAR_DOUBLE")
#Pset(SCALAR double)
#Pset(ScalarVect DoubleVect)
#Pset(ConstScalarTab_parts ConstDoubleTab_parts)
#Pset(ScalarTab DoubleTab)
#Pset(ArrOfScalar ArrOfDouble)
#Pelse
#Pset(SCALAR int)
#Pset(ScalarVect IntVect)
#Pset(ConstScalarTab_parts ConstIntTab_parts)
#Pset(ScalarTab IntTab)
#Pset(ArrOfScalar ArrOfInt)
#Pendif

void Debog_Pb::ecrire_partie(const ScalarVect& arr)
{
  const MD_Vector_base& md = arr.get_md_vector().valeur();
  if (sub_type(MD_Vector_std, md))
    {
      const int ls = arr.line_size();
      write_debog_data_file_.put(arr.addr(), arr.size_array(), ls);
    }
  else if (sub_type(MD_Vector_composite, md))
    {
      // This way, each processor writes each part sequentially
      // part1proc1, part1proc2, ... part2proc1, part2proc2, etc...
      ConstScalarTab_parts parts(arr);
      const int n = parts.size();
      for (int i = 0; i < n; i++)
        {
          const ScalarTab& t = parts[i];
          ecrire_partie(t);
        }
    }
}

void Debog_Pb::ecrire_gen(const char* const msg, const ScalarVect& arr, int num_deb)
{
  if (!arr.get_md_vector().non_nul())
    {
      Cerr << "WARNING in Debog::ecrire: array has no parallel metadata" << finl;
      Cerr << " (message: " << msg << ")" << finl;
      return;
    }
  Sortie& os = write_debog_data_file_;
  const MD_Vector_base& md = arr.get_md_vector().valeur();
  const int ls = arr.line_size();
  if (Process::je_suis_maitre())
    {
      os << "msg : " << debog_msg_count_ << " : " << msg << " FinMsg " << finl;
      Cerr << "DEBOG: writing array, message " << debog_msg_count_ << " : " << msg << finl;
      if (num_deb >= 0)
        os << num_deb << finl;
      // Dump array header:

      const ScalarTab* tabb = dynamic_cast<const ScalarTab*>(&arr);
      if (tabb)
        {
          // Header for DoubleTab:
          const ScalarTab& tab = *tabb;
          const int n =  tab.nb_dim();
          os << n << finl;
          // total number of lines:
          os << md.nb_items_seq_tot();
          // other dimensions:
          for (int i = 1; i < n; i++)
            os << space << tab.dimension(i);
          os << finl;
        }
      // Header of ArrayOfDouble:
      os << md.nb_items_seq_tot() * ls << finl;
    }

  ecrire_partie(arr);
}

// Si arr_reference != 0, on ecrit dans ce tableau la valeur de reference renumerotee
// (il faut que arr_reference et arr aient meme descripteur et meme line_size)
void Debog_Pb::verifier_partie_std(const ScalarVect& reference,
                                   const ScalarVect& arr,
                                   ScalarVect *arr_reference)
{
  Nom identificateur;
  // Recherche du descripteur du tableau arr parmi les descripteurs connus
  const IntVect& renum = find_renum_vector(arr.get_md_vector(), identificateur);
#Pif(_TYPE_=="SCALAR_DOUBLE")
  // Calcul d'une valeur de reference pour adimensionnaliser:
  // Le tableau reference est sequentiel: tous les processeurs ont le meme
  const double adim1 = local_max_abs_vect(reference);
  // Le tableau arr est parallele. On calcule la reference en utilisant uniquement
  //  la partie reele (eventuellement la partie virtuelle a le droit de ne pas etre a jour)
  const double adim2 = mp_max_abs_vect(arr, VECT_REAL_ITEMS);
  const double adim = std::max(adim1, adim2);
  if (seuil_absolu_ <= 0.)
    {
      Cerr << "Error in Debog.cpp verifier_partie_std: seuil_absolu <= 0" << finl;
      Process::exit();
    }
  if (adim < seuil_absolu_)
    {
      // Toutes les valeurs sont inferieures au seuil absolu => ok
      if (Process::je_suis_maitre())
        {
          log_file_ << " OK            : All values below seuil_absolu_ ("
                    << seuil_absolu_ << ") id=" << identificateur << finl;
          detailed_log_file_ << " OK            : All values below seuil_absolu_ ("
                             << seuil_absolu_ << ") id=" << identificateur << finl;
        }
      return;
    }
#Pendif

  const int ls = arr.line_size();
  int i = 0;
  SCALAR max_err_items_reels = 0;
  SCALAR max_err_items_virt = 0;
  int outbounds = 0;
  // items reels, puis items virtuels
  for (int step = 0; step < 2; step++)
    {
      int n;
      const char * message;
      if (step == 0)
        {
          n = renum.size();
          message = " (item reel)";
        }
      else
        {
          n = renum.size_totale();
          message = " (item virtuel)";
        }
      SCALAR max_err = 0;
      const SCALAR *arr_ptr = arr.addr();
      for (; i < n; i++)
        {
          const int i1 = i * ls; // indice dans "arr"
          const int i2 = renum[i] * ls; // indice dans "reference"
          for (int j = 0; j < ls; j++)
            {
              const SCALAR x = arr_ptr[i1+j]; // ne pas passer par operator[] pour ne pas planter sur DMAXFLOAT
              const SCALAR y = reference[i2+j];
              // Comparaison de x et y
#Pif(_TYPE_!="SCALAR_DOUBLE")
              // For integers, values must match exactly !
              if (x != y)
                {
                  detailed_log_file_ << " ECART reference[" << i2+j << "]=" << y
                                     << " calcul[" << i1+j << "]=" << x << message << finl;
                  max_err = 1;
                }
#Pelse
              const SCALAR delta = std::fabs(x-y) / adim;
              max_err = std::max(max_err, delta);
              // pour les items reels, indiquer si on est hors bornes:
              if (step==0 && !(x>=-DMAXFLOAT && x<=DMAXFLOAT))
                outbounds = 1;
              if (delta > seuil_relatif_)
                {
                  detailed_log_file_ << " ECART reference[" << i2+j << "]=" << y
                                     << " calcul[" << i1+j << "]=" << x;
                  detailed_log_file_ << " relative error=" << delta
                                     << " (adim=" << adim << ")" << message << finl;
                }
#Pendif
            }
        }
#Pif (_TYPE_!="SCALAR_DOUBLE")
      max_err = ::mp_max(max_err);
#Pelse
      max_err = Process::mp_max(max_err);
#Pendif
      if (step == 0)
        max_err_items_reels = max_err;
      else
        max_err_items_virt = max_err;
    }

  const char * resu = 0;
  int call_error_function = 0;
#Pif (_TYPE_!="SCALAR_DOUBLE")
  int seuil = 0;
#Pelse
  double seuil = seuil_relatif_;
#Pendif
  if (max_err_items_reels <= seuil)
    {
      if (max_err_items_virt <= seuil)
        resu = "OK           ";
      else
        resu = "OK REAL ONLY ";
    }
  else
    {
      call_error_function = 1;
      if (!outbounds)
        resu = "ERROR        ";
      else
        resu = "ERROR(DMAXFLT)";
    }
#Pif (_TYPE_!="SCALAR_DOUBLE")
  if (Process::je_suis_maitre())
    {
      log_file_ << " " << resu << " : integer field " << identificateur << finl;
    }
  detailed_log_file_ << " " << resu << " : integer field " << identificateur << finl;
#Pelse
  if (Process::je_suis_maitre())
    {
      log_file_ << " " << resu << " : Max relative error " << max_err_items_reels
                << " (max ref value=" << adim << ") id=" << identificateur << finl;
    }
  detailed_log_file_ << " " << resu << " : Max relative error " << max_err_items_reels
                     << " (max ref value=" << adim << ") id=" << identificateur << finl;
#Pendif
  if (call_error_function)
    error_function();
  if (arr_reference)
    {
      ScalarVect& arr_ref = *arr_reference;
      if (arr_ref.line_size() != ls || !(arr_ref.get_md_vector() == arr.get_md_vector()))
        {
          Cerr << "Error in Debog_Pb::verifier_partie_std: the array provided to store the reference value\n"
               << " does not have the same size/descriptor as the source array" << finl;
          Process::exit();
        }
      if (Process::je_suis_maitre())
        log_file_ << "                 Return reference value (including virtual items)" << finl;
      const int n = renum.size_totale();
      SCALAR *arr_ptr = arr_ref.addr();
      for (int ibis = 0; ibis < n; ibis++)
        {
          const int i1 = ibis * ls; // indice dans "arr"
          const int i2 = renum[ibis] * ls; // indice dans "reference"
          for (int j = 0; j < ls; j++)
            {
              const SCALAR y = reference[i2+j];
              arr_ptr[i1+j] = y; // ne pas passer par operator[] pour ne pas planter sur DMAXFLOAT
            }
        }
    }
}

// arr_ref is passed to Debog_Pb::verifier_partie_std()
void Debog_Pb::verifier_partie(const ScalarVect& reference, const ScalarVect& arr, ScalarVect *arr_ref)
{
  const MD_Vector_base& md = arr.get_md_vector().valeur();
  if (sub_type(MD_Vector_std, md))
    {
      verifier_partie_std(reference, arr, arr_ref);
    }
  else if (sub_type(MD_Vector_composite, md))
    {
      // This way, each processor writes each part sequentially
      // part1proc1, part1proc2, ... part2proc1, part2proc2, etc...
      ConstScalarTab_parts parts(arr);
      ScalarTab ref_part;
      const int n = parts.size();
      int index = 0;
      for (int i = 0; i < n; i++)
        {
          // Construction de la sous-partie de reference:
          // (le tableau de reference contient toutes les valeurs sequentielles, sous-partie
          // par sous-partie, la taille de la sous-partie est egale au nombre total
          // d'items sequentiels multiplie par le linesize de la sous-partie)
          // Attention, toutes les sous-parties n'ont pas forcement la meme linesize
          const ScalarTab& part = parts[i];
          const int sequential_size = part.get_md_vector().valeur().nb_items_seq_tot();
          const int line_size = part.line_size();
          // ref_array() veut un tableau non const, mais on va l'utiliser uniquement en const...
          ArrOfScalar& cast_array = ref_cast_non_const(ArrOfScalar, reference);
          ref_part.ref_array(cast_array, index, sequential_size * line_size);
          // Appel recursif pour la sous-partie:
          verifier_partie(ref_part, part, arr_ref);
          index += sequential_size * line_size;
        }
    }
}

// arr_ref is passed to Debog_Pb::verifier_partie()
void Debog_Pb::verifier_gen(const char * const msg, const ScalarVect& arr, ScalarVect *arr_ref)
{
  if (!arr.get_md_vector().non_nul())
    {
      Cerr << "WARNING in Debog::verifier_gen: array has no parallel metadata. Not checked\n (message: " << msg << ")" << finl;
      if (Process::je_suis_maitre())
        log_file_ << "WARNING in Debog::verifier_gen: array has no parallel metadata. Not checked\n (message: " << msg << ")" << finl;
      detailed_log_file_ << "WARNING in Debog::verifier_gen: array has no parallel metadata. Not checked\n (message: " << msg << ")" << finl;
      return;
    }
  if (test_ignore_msg(msg))
    {
      // Ignorer ce test
      return;
    }
  goto_msg(msg);
  const ScalarTab* scalT = dynamic_cast<const ScalarTab*>(&arr);
  if (scalT)
    {
      // read tab header
      ArrOfInt dims;
      debog_data_file_ >> dims;
    }
  ScalarVect reference;
  debog_data_file_ >> reference;

  const int n = reference.size_array();
  const int nb_items_seq = arr.get_md_vector().valeur().nb_items_seq_tot();
  const int ls = arr.line_size();
  if (n != nb_items_seq * ls)
    {
      Cerr << "Error in Debog_Pb::verifier_gen : wrong sequential size " << n
           << " (expected " << nb_items_seq * ls << ")" << finl;
      exit();
    }

  verifier_partie(reference, arr, arr_ref);
}

// Description: if arr_ref is not null and if mode_db_ is "read&compare", we put the reference
//  value found in the file in arr_ref. arr_ref and arr can point to the same object.
void Debog_Pb::verifier(const char* const msg, const ScalarVect& arr, ScalarVect *arr_ref)
{
  if (nom_pb_ != nom_pb_actuel_)
    return;

  if (test_ignore_msg(msg))
    {
      // Ignorer ce test
      return;
    }
  debog_break_test(debog_msg_count_);
  if(mode_db_ == 0)
    {
      ecrire_gen(msg, arr);
    }
  else
    {
      verifier_gen(msg, arr, arr_ref);
    }
  debog_msg_count_++;
}

void Debog::verifier(const char* const msg, const ScalarVect& x)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier(msg, x);
}

// Description: like verifier(), but, in "read&compare" mode, put the reference
//  value found in the file in the ref variable. x and ref can point to the same object.
void Debog::verifier_getref(const char* const msg, const ScalarVect& x, ScalarVect& ref)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier(msg, x, &ref);
}

#Punset(SCALAR)
#Punset(ScalarVect)
#Punset(ConstScalarTab_parts)
#Punset(ScalarTab)
#Punset(ArrOfScalar)
#Pendmacro(macrodebog)


#Pusemacro(macrodebog)("SCALAR_DOUBLE")
#Pusemacro(macrodebog)("SCALAR_INT")

// Description:
//  md_lignes: descripteur des indices de lignes (cad descripteur du vecteur b dans A*x=b)
//  mb_colonnes: idem, indices colonnes (cad descripteur du vecteur x dans A*x=b)
void Debog_Pb::verifier_matrice(const char * const msg, const Matrice_Base& matrice,
                                const MD_Vector& md_lignes, const MD_Vector& md_colonnes)
{
  // Attention: cette implementation ne marche que pour les types md_colonnes enregistres dans renum_array_
  //  (cad types simples sommets, elements, faces, aretes, et pas les MD_Vector_composite)
  // et uniquement pour linesize==1 (une ligne et une colonne de la matrice par item)

  // Pour chaque colonne i de la matrice, ecriture du produit matrice * vecteur_i
  //  avec vecteur_i[j] = (i==j);
  DoubleVect vecteur_i;
  DoubleVect tmp;
  MD_Vector_tools::creer_tableau_distribue(md_colonnes, vecteur_i);
  MD_Vector_tools::creer_tableau_distribue(md_lignes, tmp);
  Nom id;

  // Boucle sur les items sequentiels du vecteur x de A*x=b
  const int nb_colonnes = md_colonnes.valeur().nb_items_seq_tot();

  for (int i = 0; i < nb_colonnes; i++)
    {
      int renum_i;
      if (mode_db_ == 0)
        {
          renum_i = i;
        }
      else
        {
          // Recherche l'indice local correspondant a l'indice sequentiel i
          // Si i est un item virtuel on le prend quand meme: vecteur_i aura son espace virtuel a jour
          // Si i n'existe pas sur ce processeur, on met -1
          renum_i = -1;
          // Renum_colonnes[j] est l'indice dans le vecteur de reference sequentiel de l'item j sur ce processeur
          const IntVect& renum_colonnes = find_renum_vector(md_colonnes, id);
          const int sz = renum_colonnes.size_totale();
          for (int j = 0; j < sz; j++)
            {
              if (renum_colonnes[j] == i)
                {
                  renum_i = j;
                  break;
                }
            }
        }
      if (renum_i >= 0)
        vecteur_i[renum_i] = 1.;
      matrice.multvect(vecteur_i, tmp);
      Nom msg2(msg);
      msg2 += " produit avec base ";
      msg2 += Nom(i);
      verifier(msg2, tmp);
      if (renum_i >= 0)
        vecteur_i[renum_i] = 0.;
    }
}

void Debog_Pb::verifier_Mat_elems(const char* const msg, const Matrice_Base& la_matrice)
{
  // Cherche le md_vecteur des elements

  const int n = renum_id_.size();
  int i;
  for (i = 0; i < n; i++)
    {
      if (renum_id_[i] == "ELEM")
        break;
    }
  if (i == n)
    {
      Cerr << "Error in Debog_Pb::verifier_Mat_elems no registered MD_Vector for ELEM type" << finl;
      exit();
    }
  const MD_Vector& md = known_md_[i];
  verifier_matrice(msg, la_matrice, md, md);
}

void Debog::verifier_Mat_elems(const char* const msg, const Matrice_Base& la_matrice)
{
  if (Debog_Pb::get_debog_instance().non_nul())
    Debog_Pb::get_debog_instance().valeur().verifier_Mat_elems(msg, la_matrice);
}
