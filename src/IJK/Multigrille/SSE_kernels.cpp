//TRUST_NO_INDENT
/****************************************************************************
* Copyright (c) 2015 - 2016, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
/////////////////////////////////////////////////////////////////////////////
//
// File      : SSE_kernels.cpp
// Directory : $IJK_ROOT/src/IJK/solveur_mg
//
/////////////////////////////////////////////////////////////////////////////
//
// WARNING: DO NOT EDIT THIS FILE! Only edit the template file SSE_kernels.cpp.P
//

#include <SSE_kernels.h>
#include <simd_tools.h>
#include <iostream>
#include <sys/time.h>
#include <IJK_Field.h>
#include <Param.h>

// Factors to apply to the number of iterations (0=>no performance check, 1=>check for 1 second or so)
#ifndef NDEBUG
static const double check_performance = 0.002;
#else
static const double check_performance = 0.2;
#endif

static inline double get_clock()
{
  struct timeval time;
  gettimeofday(& time, 0);
  return (double) time.tv_sec + 0.000001 * (double)time.tv_usec;
}
void fill_dummy(IJK_Field_local_float & tab, int seed)
{
  const int ghost = tab.ghost();
  const int imin = -ghost;
  const int imax = tab.ni() + ghost;
  const int jmin = -ghost;
  const int jmax = tab.nj() + ghost;
  const int kmin = -ghost;
  const int kmax = tab.nk() + ghost;
  if (tab.nb_compo() == 1) {
    for (int k = kmin; k < kmax; k++)
      for (int j = jmin; j < jmax; j++)
	for (int i = imin; i < imax; i++) {
	  double x = i * 0.2 + j * 0.9893 + k * 0.87987 + seed;
	  tab(i,j,k) = (float)(1. + 0.5 * sin(x));
	}
  } else {
    const int n = tab.nb_compo();
    for (int k = kmin; k < kmax; k++) 
      for (int compo = 0; compo < n; compo++)
	for (int j = jmin; j < jmax; j++)
	  for (int i = imin; i < imax; i++) {
	    double x = i * 0.2 + j * 0.9893 + k * 0.87987 + compo * 0.238768 + seed;
	    tab(i,j,k,compo) = (float)(1. + 0.5 * sin(x));
	  }
  }
}
void fill_dummy(IJK_Field_local_double & tab, int seed)
{
  const int ghost = tab.ghost();
  const int imin = -ghost;
  const int imax = tab.ni() + ghost;
  const int jmin = -ghost;
  const int jmax = tab.nj() + ghost;
  const int kmin = -ghost;
  const int kmax = tab.nk() + ghost;
  if (tab.nb_compo() == 1) {
    for (int k = kmin; k < kmax; k++)
      for (int j = jmin; j < jmax; j++)
	for (int i = imin; i < imax; i++) {
	  double x = i * 0.2 + j * 0.9893 + k * 0.87987 + seed;
	  tab(i,j,k) = (double)(1. + 0.5 * sin(x));
	}
  } else {
    const int n = tab.nb_compo();
    for (int k = kmin; k < kmax; k++) 
      for (int compo = 0; compo < n; compo++)
	for (int j = jmin; j < jmax; j++)
	  for (int i = imin; i < imax; i++) {
	    double x = i * 0.2 + j * 0.9893 + k * 0.87987 + compo * 0.238768 + seed;
	    tab(i,j,k,compo) = (double)(1. + 0.5 * sin(x));
	  }
  }
}


void reference_kernel_float(const IJK_Field_local_float & tab, const IJK_Field_local_float & coeffs, const IJK_Field_local_float & secmem, IJK_Field_local_float & resu, 
			     const float relax, const bool residue)
{
  const float one_minus_relax = (float)(1. - relax);

  const int kmin = - tab.ghost() + 1;
  const int kmax = tab.nk() + tab.ghost() - 1;
  const int jmin = - tab.ghost() + 1;
  const int jmax = tab.nj() + tab.ghost() - 1;
  const int imin = - tab.ghost() + 1;
  const int imax = tab.ni() + tab.ghost() - 1;
  int i, j, k;
  for (k = kmin; k < kmax; k++) {
    for (j = jmin; j < jmax; j++) {
      for (i = imin; i < imax; i++) {
	float x = 
	  coeffs(i,j,k,0) * tab(i-1,j,k)
	  + coeffs(i+1,j,k,0) * tab(i+1,j,k)
	  + coeffs(i,j,k,1) * tab(i,j-1,k)
	  + coeffs(i,j+1,k,1) * tab(i,j+1,k)
	  + coeffs(i,j,k,2) * tab(i,j,k-1)
	  + coeffs(i,j,k+1,2) * tab(i,j,k+1);
	float r;
	if (residue)
	  r = tab(i,j,k) * coeffs(i,j,k,3) - x - secmem(i,j,k);
	else
	  r = tab(i,j,k) * one_minus_relax + (x + secmem(i,j,k)) * relax / coeffs(i,j,k,3);
	resu(i,j,k) = r;
      }
    }
  }
}

float compute_difference(const IJK_Field_local_float & a, const IJK_Field_local_float & b)
{
  float diff = 0;
  const int ni = a.ni();
  const int nj = a.nj();
  const int nk = a.nk();
  int i, j, k;
  for (i = 0; i < ni; i++) {
    for (j = 0; j < nj; j++) {
      for (k = 0; k < nk; k++) {
       diff = std::max(diff, std::fabs(a(i,j,k) - b(i,j,k)));
	assert(std::fabs(a(i,j,k) - b(i,j,k)) < 1e-4);
      }
    }
  }
  return diff;
}
void reference_kernel_double(const IJK_Field_local_double & tab, const IJK_Field_local_double & coeffs, const IJK_Field_local_double & secmem, IJK_Field_local_double & resu, 
			     const double relax, const bool residue)
{
  const double one_minus_relax = (double)(1. - relax);

  const int kmin = - tab.ghost() + 1;
  const int kmax = tab.nk() + tab.ghost() - 1;
  const int jmin = - tab.ghost() + 1;
  const int jmax = tab.nj() + tab.ghost() - 1;
  const int imin = - tab.ghost() + 1;
  const int imax = tab.ni() + tab.ghost() - 1;
  int i, j, k;
  for (k = kmin; k < kmax; k++) {
    for (j = jmin; j < jmax; j++) {
      for (i = imin; i < imax; i++) {
	double x = 
	  coeffs(i,j,k,0) * tab(i-1,j,k)
	  + coeffs(i+1,j,k,0) * tab(i+1,j,k)
	  + coeffs(i,j,k,1) * tab(i,j-1,k)
	  + coeffs(i,j+1,k,1) * tab(i,j+1,k)
	  + coeffs(i,j,k,2) * tab(i,j,k-1)
	  + coeffs(i,j,k+1,2) * tab(i,j,k+1);
	double r;
	if (residue)
	  r = tab(i,j,k) * coeffs(i,j,k,3) - x - secmem(i,j,k);
	else
	  r = tab(i,j,k) * one_minus_relax + (x + secmem(i,j,k)) * relax / coeffs(i,j,k,3);
	resu(i,j,k) = r;
      }
    }
  }
}

double compute_difference(const IJK_Field_local_double & a, const IJK_Field_local_double & b)
{
  double diff = 0;
  const int ni = a.ni();
  const int nj = a.nj();
  const int nk = a.nk();
  int i, j, k;
  for (i = 0; i < ni; i++) {
    for (j = 0; j < nj; j++) {
      for (k = 0; k < nk; k++) {
       diff = std::max(diff, std::fabs(a(i,j,k) - b(i,j,k)));
	assert(std::fabs(a(i,j,k) - b(i,j,k)) < 1e-4);
      }
    }
  }
  return diff;
}




void Residue64x64_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue64x64_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi64x64_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi64x64_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue64x64_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue64x64_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi64x64_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi64x64_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi64x64_float(IJK_Field_local_float & x,
				     IJK_Field_local_float & residue,
				     const IJK_Field_local_float & coeffs,
				     const IJK_Field_local_float & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const float relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_float::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    float *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const float *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const float *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const float *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue64x64_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi64x64_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue64x64_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi64x64_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test64x64_float(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_float coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName64x64_float" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const float relax_coefficient = (float)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue64x64_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi64x64_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_float(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_float copy_tab(tab);
    Multipass_Jacobi64x64_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "64x64_float(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue64x64_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi64x64_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi64x64_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "64x64_float(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(float) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(float) 
	     << " = " << data_size * data_factor * sizeof(float) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue68x68_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue68x68_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi68x68_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi68x68_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue68x68_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue68x68_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi68x68_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi68x68_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi68x68_float(IJK_Field_local_float & x,
				     IJK_Field_local_float & residue,
				     const IJK_Field_local_float & coeffs,
				     const IJK_Field_local_float & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const float relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_float::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    float *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const float *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const float *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const float *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue68x68_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi68x68_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue68x68_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi68x68_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test68x68_float(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_float coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName68x68_float" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const float relax_coefficient = (float)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue68x68_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi68x68_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_float(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_float copy_tab(tab);
    Multipass_Jacobi68x68_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "68x68_float(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue68x68_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi68x68_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi68x68_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "68x68_float(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(float) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(float) 
	     << " = " << data_size * data_factor * sizeof(float) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue72x72_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue72x72_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi72x72_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi72x72_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue72x72_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue72x72_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi72x72_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi72x72_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi72x72_float(IJK_Field_local_float & x,
				     IJK_Field_local_float & residue,
				     const IJK_Field_local_float & coeffs,
				     const IJK_Field_local_float & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const float relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_float::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    float *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const float *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const float *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const float *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue72x72_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi72x72_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue72x72_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi72x72_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test72x72_float(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_float coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName72x72_float" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const float relax_coefficient = (float)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue72x72_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi72x72_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_float(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_float copy_tab(tab);
    Multipass_Jacobi72x72_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "72x72_float(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue72x72_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi72x72_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi72x72_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "72x72_float(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(float) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(float) 
	     << " = " << data_size * data_factor * sizeof(float) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue76x76_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue76x76_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi76x76_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi76x76_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue76x76_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue76x76_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi76x76_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi76x76_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi76x76_float(IJK_Field_local_float & x,
				     IJK_Field_local_float & residue,
				     const IJK_Field_local_float & coeffs,
				     const IJK_Field_local_float & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const float relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_float::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    float *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const float *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const float *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const float *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue76x76_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi76x76_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue76x76_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi76x76_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test76x76_float(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_float coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName76x76_float" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const float relax_coefficient = (float)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue76x76_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi76x76_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_float(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_float copy_tab(tab);
    Multipass_Jacobi76x76_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "76x76_float(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue76x76_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi76x76_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi76x76_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "76x76_float(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(float) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(float) 
	     << " = " << data_size * data_factor * sizeof(float) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue80x80_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue80x80_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi80x80_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi80x80_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue80x80_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue80x80_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi80x80_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi80x80_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi80x80_float(IJK_Field_local_float & x,
				     IJK_Field_local_float & residue,
				     const IJK_Field_local_float & coeffs,
				     const IJK_Field_local_float & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const float relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_float::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    float *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const float *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const float *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const float *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue80x80_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi80x80_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue80x80_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi80x80_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test80x80_float(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_float coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName80x80_float" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const float relax_coefficient = (float)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue80x80_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi80x80_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_float(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_float copy_tab(tab);
    Multipass_Jacobi80x80_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "80x80_float(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue80x80_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi80x80_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi80x80_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "80x80_float(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(float) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(float) 
	     << " = " << data_size * data_factor * sizeof(float) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residuegeneric_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residuegeneric_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobigeneric_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobigeneric_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residuegeneric_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residuegeneric_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobigeneric_float(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_float max_value(10000000000.0); 
  //Simd_float zero(0.0);
   
   const Simd_float relax = relax_coefficient;
   const Simd_float one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_float coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_float c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_float secmem = SimdGet(secmem_ptr);
    Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobigeneric_floatproto(const float *tab, const float *coeffs_ptr, const float *secmem_ptr,
			       float *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const float relax_coefficient
		     
			       , const float *fetch_tab
			       )
{
  const int vsize = Simd_float::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_float relax = relax_coefficient;
  const Simd_float one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_float coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_float c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_float coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_float secmem = SimdGet(secmem_ptr);
      Simd_float jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobigeneric_float(IJK_Field_local_float & x,
				     IJK_Field_local_float & residue,
				     const IJK_Field_local_float & coeffs,
				     const IJK_Field_local_float & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const float relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_float::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    float *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const float *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const float *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const float *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residuegeneric_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobigeneric_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  float *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residuegeneric_float(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobigeneric_float(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void testgeneric_float(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_float coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelNamegeneric_float" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const float relax_coefficient = (float)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residuegeneric_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobigeneric_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_float(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_float copy_tab(tab);
    Multipass_Jacobigeneric_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_float(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "generic_float(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residuegeneric_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobigeneric_float(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobigeneric_float(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "generic_float(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(float) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(float) 
	     << " = " << data_size * data_factor * sizeof(float) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue64x64_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue64x64_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi64x64_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi64x64_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue64x64_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue64x64_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi64x64_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi64x64_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 64*64;
  const int jstride = 64;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi64x64_double(IJK_Field_local_double & x,
				     IJK_Field_local_double & residue,
				     const IJK_Field_local_double & coeffs,
				     const IJK_Field_local_double & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const double relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_double::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    double *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const double *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const double *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const double *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue64x64_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi64x64_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue64x64_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi64x64_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test64x64_double(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_double coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName64x64_double" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const double relax_coefficient = (double)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue64x64_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi64x64_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_double(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_double copy_tab(tab);
    Multipass_Jacobi64x64_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "64x64_double(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue64x64_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi64x64_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi64x64_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "64x64_double(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(double) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(double) 
	     << " = " << data_size * data_factor * sizeof(double) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue68x68_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue68x68_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi68x68_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi68x68_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue68x68_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue68x68_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi68x68_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi68x68_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 68*68;
  const int jstride = 68;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi68x68_double(IJK_Field_local_double & x,
				     IJK_Field_local_double & residue,
				     const IJK_Field_local_double & coeffs,
				     const IJK_Field_local_double & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const double relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_double::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    double *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const double *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const double *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const double *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue68x68_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi68x68_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue68x68_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi68x68_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test68x68_double(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_double coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName68x68_double" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const double relax_coefficient = (double)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue68x68_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi68x68_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_double(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_double copy_tab(tab);
    Multipass_Jacobi68x68_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "68x68_double(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue68x68_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi68x68_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi68x68_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "68x68_double(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(double) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(double) 
	     << " = " << data_size * data_factor * sizeof(double) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue72x72_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue72x72_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi72x72_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi72x72_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue72x72_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue72x72_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi72x72_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi72x72_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 72*72;
  const int jstride = 72;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi72x72_double(IJK_Field_local_double & x,
				     IJK_Field_local_double & residue,
				     const IJK_Field_local_double & coeffs,
				     const IJK_Field_local_double & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const double relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_double::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    double *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const double *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const double *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const double *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue72x72_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi72x72_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue72x72_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi72x72_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test72x72_double(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_double coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName72x72_double" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const double relax_coefficient = (double)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue72x72_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi72x72_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_double(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_double copy_tab(tab);
    Multipass_Jacobi72x72_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "72x72_double(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue72x72_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi72x72_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi72x72_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "72x72_double(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(double) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(double) 
	     << " = " << data_size * data_factor * sizeof(double) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue76x76_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue76x76_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi76x76_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi76x76_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue76x76_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue76x76_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi76x76_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi76x76_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 76*76;
  const int jstride = 76;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi76x76_double(IJK_Field_local_double & x,
				     IJK_Field_local_double & residue,
				     const IJK_Field_local_double & coeffs,
				     const IJK_Field_local_double & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const double relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_double::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    double *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const double *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const double *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const double *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue76x76_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi76x76_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue76x76_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi76x76_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test76x76_double(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_double coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName76x76_double" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const double relax_coefficient = (double)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue76x76_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi76x76_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_double(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_double copy_tab(tab);
    Multipass_Jacobi76x76_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "76x76_double(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue76x76_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi76x76_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi76x76_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "76x76_double(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(double) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(double) 
	     << " = " << data_size * data_factor * sizeof(double) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residue80x80_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue80x80_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi80x80_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi80x80_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residue80x80_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residue80x80_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobi80x80_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobi80x80_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = 80*80;
  const int jstride = 80;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobi80x80_double(IJK_Field_local_double & x,
				     IJK_Field_local_double & residue,
				     const IJK_Field_local_double & coeffs,
				     const IJK_Field_local_double & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const double relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_double::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    double *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const double *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const double *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const double *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue80x80_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobi80x80_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residue80x80_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobi80x80_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void test80x80_double(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_double coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelName80x80_double" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const double relax_coefficient = (double)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residue80x80_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobi80x80_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_double(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_double copy_tab(tab);
    Multipass_Jacobi80x80_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "80x80_double(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residue80x80_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobi80x80_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobi80x80_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "80x80_double(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(double) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(double) 
	     << " = " << data_size * data_factor * sizeof(double) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}


void Residuegeneric_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residuegeneric_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobigeneric_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobigeneric_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Residuegeneric_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double residu = tab_center * coeff_sum - x1 - x2 - secmem;
    SimdPut(result_ptr, residu);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Residuegeneric_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double residu = tab_center * coeff_sum - x - secmem;
      SimdPut(result_ptr, residu);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

void Jacobigeneric_double(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  //Simd_double max_value(10000000000.0); 
  //Simd_double zero(0.0);
   
   const Simd_double relax = relax_coefficient;
   const Simd_double one_minus_relax = 1.f - relax_coefficient;
  for (int i = 0; i < nvectors; i++) {
    Simd_double coeff, x1, x2;
    coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x1 = SimdGet(tab + zlow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x2 = SimdGet(tab + zup_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x1 += SimdGet(tab + ylow_tab_offset) * coeff;
    coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x2 += SimdGet(tab + yup_tab_offset) * coeff;
    Simd_double c_left, c_right, tab_left, tab_center, tab_right;
    SimdGetCenterRight(coeffs_ptr, c_left, c_right);
    SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
    x1 += tab_left * c_left;  
    x2 += tab_right * c_right;

    //x1 = SimdSelect(Simd_absolute_value(x1), max_value, x1, zero);  
    //x2 = SimdSelect(Simd_absolute_value(x2), max_value, x2, zero);  
 
    Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
    Simd_double secmem = SimdGet(secmem_ptr);
    Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed( (x1 + x2 + secmem) * relax, coeff_sum);
    SimdPut(result_ptr, jacobi);
#if 0
    // 15 is for float, should take 7 for double precision...
    // no performance benefit on Harpertown.
    if ((i & 15) == 0) {
      _mm_prefetch(fetch_tab + i, _MM_HINT_T0);
    }
#endif
    coeffs_ptr += vsize;
    secmem_ptr += vsize;
    tab += vsize;
    result_ptr += vsize;
  }
  
  //flop_count += nmax * 14;
}
void Jacobigeneric_doubleproto(const double *tab, const double *coeffs_ptr, const double *secmem_ptr,
			       double *result_ptr,
			       const int kstride_input, const int jstride_input, const int nvalues,
			       const double relax_coefficient
		     
			       , const double *fetch_tab
			       )
{
  const int vsize = Simd_double::size();
  const int kstride = kstride_input;
  const int jstride = jstride_input;
  assert(kstride == kstride_input);
  assert(jstride == jstride_input);
  const int nvectors = (nvalues + vsize-1) / vsize;
  // Code version 1: perform all operations at once:
  // coeffs_ptr points to the x direction coefficient for the left face
  // coeffs_ptr + kstride = y direction coefficient
  // coeffs_ptr + 2 * kstride = z direction coefficient (lower face)
  // coeffs_ptr + 3 * kstride = sum of coefficients
  // coeffs_ptr + 6 * kstride = z direction coefficient (upper face)
  const int ylow_coeff_offset = kstride;
  const int yup_coeff_offset = kstride + jstride;
  const int zlow_coeff_offset = 2 * kstride;
  const int zup_coeff_offset = 6 * kstride;
  const int sum_coeff_offset = 3 * kstride;
  const int zlow_tab_offset = -kstride;
  const int zup_tab_offset = kstride;
  const int ylow_tab_offset = -jstride;
  const int yup_tab_offset = jstride;
  const Simd_double relax = relax_coefficient;
  const Simd_double one_minus_relax = 1.f - relax_coefficient;
  int i = 0;
  const int chunksize = 1024/vsize;
  while (i < nvectors) {
    int jmax = nvectors - i;
    if (jmax > chunksize)
      jmax = chunksize;

    // Part 1
    int j;
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      coeff = SimdGet(coeffs_ptr + zlow_coeff_offset); x = SimdGet(tab + zlow_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + zup_coeff_offset); x += SimdGet(tab + zup_tab_offset) * coeff;
      coeff = SimdGet(coeffs_ptr + ylow_coeff_offset); x += SimdGet(tab + ylow_tab_offset) * coeff;
      SimdPut(result_ptr, x);
      coeffs_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    coeffs_ptr -= vsize * jmax;
    tab -= vsize * jmax;
    result_ptr -= vsize * jmax;
    // Part 2
    for (j = 0; j < jmax; j++) {
      Simd_double coeff, x;
      x = SimdGet(result_ptr);
      coeff = SimdGet(coeffs_ptr + yup_coeff_offset); x += SimdGet(tab + yup_tab_offset) * coeff;
      Simd_double c_left, c_right, tab_left, tab_center, tab_right;
      SimdGetCenterRight(coeffs_ptr, c_left, c_right);
      SimdGetLeftCenterRight(tab, tab_left, tab_center, tab_right);
      x += tab_left * c_left;
      x += tab_right * c_right;
      Simd_double coeff_sum = SimdGet(coeffs_ptr + sum_coeff_offset);
      Simd_double secmem = SimdGet(secmem_ptr);
      Simd_double jacobi = tab_center * one_minus_relax + SimdDivideMed((x + secmem) * relax, coeff_sum);
      SimdPut(result_ptr, jacobi);
      coeffs_ptr += vsize;
      secmem_ptr += vsize;
      tab += vsize;
      result_ptr += vsize;
    }
    i += jmax;
  }
  //flop_count += nmax * 14;
}

// Realize npass simultaneous passes of jacobi smoother on the x field,
// if last_pass_is_residue, compute npass-1 iterations of jacobi smoothers and compute
// the residue into "residue".
// The algorithm relies on the fact that all data necessary to compute 
// the npass passes on npass layers can reside in cache memory, otherwise
// will have same performance than a trivial algorithm that performs independant
// passes.
// x, coeffs and secmem must have npass uptodate layers of ghost cells.
void Multipass_Jacobigeneric_double(IJK_Field_local_double & x,
				     IJK_Field_local_double & residue,
				     const IJK_Field_local_double & coeffs,
				     const IJK_Field_local_double & secmem,
				     const int npass,
				     const bool last_pass_is_residue,
				     const double relax_coefficient)
{
  // The result of jacobi iterations will be stored here:
  int final_k_shift;
  if (!last_pass_is_residue)
    final_k_shift = npass;
  else
    final_k_shift = npass - 1;
  assert(x.k_shift() >= final_k_shift);
  const int sweep_k_begin = - npass + 1;
  const int sweep_k_end   = x.nk() + npass - 1;
  const int jstart = - npass + 1;
  int istart = - npass + 1;
  // Align istart on SIMD vector size (might compute a few useless values at beginning,
  // must also take care that padding is ok)
  istart = istart & (~(Simd_double::size()-1));

  const int kstride = x.k_stride();
  const int jstride = x.j_stride();
  
  const int residue_pass = (last_pass_is_residue ? npass - 1 : npass);

  const int MAXPASS = 8; // 8 simultaneous passes is a reasonable max...
  if (npass > MAXPASS) {
    Cerr << "Error: MAXPASS too low, increase value and recompile..." << finl;
    Process::exit();
  }
  int nvalues[MAXPASS];
  for (int i = 0; i < npass; i++) {
    const int jstart_this_pass = jstart + i;
    const int iend = x.ni() + npass-i - 2; // i index of the last computed cell
    const int jend = x.nj() + npass-i - 2; // j index of the last computed cell
    const int end_index = jend * jstride + iend;
    const int start_index = jstart_this_pass * jstride + istart;
    nvalues[i] = end_index - start_index + 1;
  }

  // sweep_k_pos is the k layer of the first pass 
  for (int sweep_k_pos = sweep_k_begin; sweep_k_pos < sweep_k_end; sweep_k_pos++) {
    const int k_layer = sweep_k_pos;
    
    double *src_ptr = &x.get_in_allocated_area(istart, jstart, k_layer);
    const double *coeffs_ptr = &coeffs.get_in_allocated_area(istart, jstart, k_layer,0);
    const double *secmem_ptr = &secmem.get_in_allocated_area(istart, jstart, k_layer);

    for (int current_pass = 0; current_pass < npass; current_pass++) {
      // layer number (where to take rhs and coefficients for this pass
      const int k_layer_mpass = sweep_k_pos - current_pass;
      // The data is not ready yet for this pass (happens for the first layers)
		if (current_pass > k_layer_mpass - sweep_k_begin)
	continue;
	assert(src_ptr == &x.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass - current_pass));
	assert(coeffs_ptr == &coeffs.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass,0));
	assert(secmem_ptr == &secmem.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass));

      const double *fetch_tab = 0;
#if 0
      if (sweep_k_end - sweep_k_pos > 2) {
	switch(current_pass) {
	case 0: fetch_tab = &x.get_in_allocated_area(istart, jstart, sweep_k_pos+2); break;
	case 1: fetch_tab = &secmem.get_in_allocated_area(istart, jstart, sweep_k_pos+1); break;
	case 2: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,0); break;
	case 3: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,1); break;
	case 4: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+1,3); break;
	case 5: fetch_tab = &coeffs.get_in_allocated_area(istart, jstart, sweep_k_pos+2,2); break;
	}
      }
#endif
      if (fetch_tab) {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residuegeneric_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	} else {
	  Jacobigeneric_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient, fetch_tab);
	}
      } else {
	if (current_pass == residue_pass) {
	  double *residue_ptr = &residue.get_in_allocated_area(istart, jstart + current_pass, k_layer_mpass);
	  Residuegeneric_double(src_ptr, coeffs_ptr, secmem_ptr, residue_ptr /* where to store result */,
				 kstride, jstride, nvalues[current_pass], relax_coefficient);
	} else {
	  Jacobigeneric_double(src_ptr, coeffs_ptr, secmem_ptr, src_ptr - kstride /* where to store result */,
				kstride, jstride, nvalues[current_pass], relax_coefficient);
	}
      }

      // Shift source, result and coefficient data to layer for next pass.
      // Next pass requires one less row so add also "jstride"
      src_ptr = src_ptr - 2 * kstride + jstride;
      assert(coeffs.nb_compo() == 4);
      coeffs_ptr = coeffs_ptr - kstride * 4 + jstride;
      secmem_ptr = secmem_ptr - kstride + jstride;
    }

  }

  // The result is stored with shift in k direction:
  x.shift_k_origin(-final_k_shift);
}

// Tests the kernel (compares with reference implementation) and gives performance result.
// Can be run in parallel to test concurrency efficiency (memory and cache bandwidth).
// if npass==0, runs only single plane algorithm, otherwise runs multipass algorithm
void testgeneric_double(const int kstride_input, const int jstride_input, int nk, int npass, bool residue)
{
  IJK_Field_local_double coeffs, tab, secmem, resu, resu_reference;
  const int ghost = (npass == 0) ? 1 : npass;
  const int additional_layers = npass;
  const int ni = jstride_input - 2 * ghost;
  const int nj = kstride_input / jstride_input - 2 * ghost;
  if (npass == 0) {
    nk = 1;
  } else {
    if (npass < 0 || nk < 1) {
      Cerr << "Error ! in test_KernelNamegeneric_double" << finl;
      Process::exit();
    }
  }
  coeffs.allocate(ni, nj, nk, ghost, additional_layers, 4 /*nb compo*/);
  tab.allocate(ni, nj, nk, ghost, additional_layers);
  secmem.allocate(ni, nj, nk, ghost);
  resu.allocate(ni, nj, nk, ghost);
  resu_reference.allocate(ni, nj, nk, ghost);

  tab.shift_k_origin(additional_layers);
  // Fill with dummy data:
  fill_dummy(tab, 0);
  fill_dummy(coeffs, 1);
  fill_dummy(secmem, 2);
  fill_dummy(resu, 3);

  for (int i = -ghost + 1; i < ni + ghost - 1; i++) {
    for (int j = -ghost + 1; j < nj + ghost - 1; j++) {
      for (int k = -ghost + 1; k < nk + ghost - 1; k++) {
	coeffs(i,j,k,3) = coeffs(i,j,k,0) + coeffs(i,j,k,1) + coeffs(i,j,k,2)
	  + coeffs(i+1,j,k,0) + coeffs(i,j+1,k,1) + coeffs(i,j,k+1,2);
      }
    }
  }

  const double relax_coefficient = (double)0.65;
  const int nvalues = tab.j_stride() * (nj-1) + ni;

  Nom kernname;
  double diff;
  if (npass == 0) {
    // Unit test of the kernel for one plane:
    // Compute result:
    if (residue) {
      kernname = "residue";
      Residuegeneric_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			     kstride_input, jstride_input, nvalues,
			     relax_coefficient);
    } else {
      kernname = "jacobi";
      Jacobigeneric_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
			    kstride_input, jstride_input, nvalues,
			    relax_coefficient);
    }
    reference_kernel_double(tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    diff = compute_difference(resu_reference, resu);
  } else {
    kernname = "multipass_jacobi";
    IJK_Field_local_double copy_tab(tab);
    Multipass_Jacobigeneric_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);

    for (int i = 0; i < npass - 1; i++) {
      reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, false);
      copy_tab = resu_reference;
    }
    reference_kernel_double(copy_tab, coeffs, secmem, resu_reference, relax_coefficient, residue);
    if (residue)
      diff = compute_difference(resu_reference, resu);
    else
      diff = compute_difference(resu_reference, tab);
  }

  if (Process::je_suis_maitre())
    Cout << "Checking " << kernname << "generic_double(" << kstride_input << "," << jstride_input
	 << ") Maximum difference= " << diff << finl;
  if (diff > 1e-5) {
    Cerr << "Error: difference found in testing kernel." << finl;
    Process::exit();
  }
  if (check_performance) {
    int niter;
    double nflop = 0.;
    const double flops_per_cell_residue = 14.;
    const double flops_per_cell_jacobi = 17.;
    double usefull_flops = 0.;
    double dt = 0.;
    if (npass == 0) {
      niter = (int)floor(check_performance * 1e9/nvalues);
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	if (residue)
	  Residuegeneric_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				 kstride_input, jstride_input, nvalues,
				 relax_coefficient);
	else
	  Jacobigeneric_double(&tab(0,0,0), &coeffs(0,0,0,0), &secmem(0,0,0), &resu(0,0,0),
				kstride_input, jstride_input, nvalues,
				relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
      if (residue)
	nflop = flops_per_cell_residue * nvalues;
      else
	nflop = flops_per_cell_jacobi * nvalues;
    } else {
      for (int i = 0; i < npass; i++) {
	int ncells = (nk + 2 * i) * (nj + 2 * i) * jstride_input;
	if (i == 0 && residue) {
	  nflop += flops_per_cell_residue * ncells;
	  usefull_flops += flops_per_cell_residue * ni * nj * nk;
	} else {
	  nflop += flops_per_cell_jacobi * ncells;
	  usefull_flops += flops_per_cell_jacobi * ni * nj * nk; 
	}
      }
      niter = (int) floor(check_performance * 1e10 / nflop) + 1;
      Process::barrier();
      double t1 = get_clock();
      for (int i = 0; i < niter; i++) {
	// GF je remets a zero sinon cela diverge ???
        fill_dummy(tab, 0);
        
	tab.shift_k_origin(residue ? npass-1 : npass);
       
	Multipass_Jacobigeneric_double(tab, resu, coeffs, secmem, npass, residue, relax_coefficient);
      }
      Process::barrier();
      dt = get_clock()-t1;
    }
    double gflops = nflop * niter / dt * 1e-9;
    if (Process::je_suis_maitre()) {
      Cout << "Performance " << kernname << "generic_double(kstride=" << kstride_input 
	   << ",jstride=" << jstride_input << ",nk=" << nk << ",npass=" << npass << ",residue=" << (int)(residue?1:0);
	Cout   << ") niter=" << niter << " time=" << dt << " flops per iteration=" << nflop
	   << " gflops=" << gflops << finl;
      if (npass > 0) {
	double data_factor = 2 /* read/write tab */ + 1 /* secmem */ + 2 /* read/write resu */ + 4 /* coeffs */;
	double data_size = kstride_input * (nk + 2 * npass);
	double bandwidth = (double) data_size * data_factor * sizeof(double) * niter / dt; 

	Cout << " Amount of data read/write to RAM per iteration= " << data_size << " * " << data_factor << " * " << (int)sizeof(double) 
	     << " = " << data_size * data_factor * sizeof(double) << " MB" << finl;
	 Cout    << " Bandwidth per process if optimal caching(GB/s)=" << bandwidth << finl
	     << " Usefull GFlops=" << usefull_flops * niter / dt * 1e-9 << finl;
      }
    }
  }
}

Implemente_instanciable(Test_SSE_Kernels, "Test_SSE_Kernels", Interprete);

Sortie& Test_SSE_Kernels::printOn(Sortie& s ) const
{
  return s;
}

Entree& Test_SSE_Kernels::readOn(Entree& is )
{
  return is;
}

Entree & Test_SSE_Kernels::interpreter(Entree & is)
{
  int i=0;
  int nmax=1000;
  Param param(que_suis_je());
  param.ajouter("nmax", &nmax);
  param.lire_avec_accolades(is);
  test64x64_float(64*64,64,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_float(64*64,64,0,0,false);
  i++; if (i>nmax) return is;
  test68x68_float(68*68,68,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_float(68*68,68,0,0,false);
  i++; if (i>nmax) return is;
  test72x72_float(72*72,72,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_float(72*72,72,0,0,false);
  i++; if (i>nmax) return is;
  test76x76_float(76*76,76,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_float(76*76,76,0,0,false);
  i++; if (i>nmax) return is;
  test80x80_float(80*80,80,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_float(80*80,80,0,0,false);
  i++; if (i>nmax) return is;
  test64x64_double(64*64,64,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_double(64*64,64,0,0,false);
  i++; if (i>nmax) return is;
  test68x68_double(68*68,68,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_double(68*68,68,0,0,false);
  i++; if (i>nmax) return is;
  test72x72_double(72*72,72,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_double(72*72,72,0,0,false);
  i++; if (i>nmax) return is;
  test76x76_double(76*76,76,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_double(76*76,76,0,0,false);
  i++; if (i>nmax) return is;
  test80x80_double(80*80,80,0,0,false);
  i++; if (i>nmax) return is;
  testgeneric_double(80*80,80,0,0,false);
  i++; if (i>nmax) return is;
  test64x64_float(64*64,64,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_float(64*64,64,0,0,true);
  i++; if (i>nmax) return is;
  test68x68_float(68*68,68,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_float(68*68,68,0,0,true);
  i++; if (i>nmax) return is;
  test72x72_float(72*72,72,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_float(72*72,72,0,0,true);
  i++; if (i>nmax) return is;
  test76x76_float(76*76,76,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_float(76*76,76,0,0,true);
  i++; if (i>nmax) return is;
  test80x80_float(80*80,80,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_float(80*80,80,0,0,true);
  i++; if (i>nmax) return is;
  test64x64_double(64*64,64,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_double(64*64,64,0,0,true);
  i++; if (i>nmax) return is;
  test68x68_double(68*68,68,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_double(68*68,68,0,0,true);
  i++; if (i>nmax) return is;
  test72x72_double(72*72,72,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_double(72*72,72,0,0,true);
  i++; if (i>nmax) return is;
  test76x76_double(76*76,76,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_double(76*76,76,0,0,true);
  i++; if (i>nmax) return is;
  test80x80_double(80*80,80,0,0,true);
  i++; if (i>nmax) return is;
  testgeneric_double(80*80,80,0,0,true);
  i++; if (i>nmax) return is;
// suite
  testgeneric_float(68*68, 68, 128, (68-64)/2, true);
  i++; if (i>nmax) return is;
  test68x68_float(68*68, 68, 128, (68-64)/2, true);
  i++; if (i>nmax) return is;
  testgeneric_float(68*68, 68, 128, (68-64)/2, false);
  i++; if (i>nmax) return is;
  test68x68_float(68*68, 68, 128, (68-64)/2, false);
  i++; if (i>nmax) return is;
  testgeneric_float(72*72, 72, 128, (72-64)/2, true);
  i++; if (i>nmax) return is;
  test72x72_float(72*72, 72, 128, (72-64)/2, true);
  i++; if (i>nmax) return is;
  testgeneric_float(72*72, 72, 128, (72-64)/2, false);
  i++; if (i>nmax) return is;
  test72x72_float(72*72, 72, 128, (72-64)/2, false);
  i++; if (i>nmax) return is;
  testgeneric_float(76*76, 76, 128, (76-64)/2, true);
  i++; if (i>nmax) return is;
  test76x76_float(76*76, 76, 128, (76-64)/2, true);
  i++; if (i>nmax) return is;
  testgeneric_float(76*76, 76, 128, (76-64)/2, false);
  i++; if (i>nmax) return is;
  test76x76_float(76*76, 76, 128, (76-64)/2, false);
  i++; if (i>nmax) return is;
  testgeneric_float(80*80, 80, 128, (80-64)/2, true);
  i++; if (i>nmax) return is;
  test80x80_float(80*80, 80, 128, (80-64)/2, true);
  i++; if (i>nmax) return is;
  testgeneric_float(80*80, 80, 128, (80-64)/2, false);
  i++; if (i>nmax) return is;
  test80x80_float(80*80, 80, 128, (80-64)/2, false);
  i++; if (i>nmax) return is;
  return is;
}

#if 0
int main(void)
{
  const int bufsize = 66*64*(7+3+1);
  float *buffer = (float*) simd_malloc(bufsize * sizeof(float));
  float *coeffs = buffer;
  float *tab = coeffs + 66*64*7;
  float *secmem = tab + 66*64*3;

  for (int i = 0; i < bufsize; i++)
    buffer[i] = 1.f;

  for (int loop = 0; loop < 100000; loop++) 
    Residu_64x64_float(tab+64, coeffs+64, secmem+64, tab, 64*66, 64, 64*64);

  std::cout << (double) 100000*14*64*64 << std::endl;
  return 0;
}
#endif
