//TRUST_NO_INDENT
/****************************************************************************
* Copyright (c) 2015 - 2016, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
/////////////////////////////////////////////////////////////////////////////
//
// File      : simd_tools_sse.h
// Directory : $IJK_ROOT/src/IJK/solveur_mg
//
/////////////////////////////////////////////////////////////////////////////
//
// WARNING: DO NOT EDIT THIS FILE! Only edit the template file simd_tools_sse.h.P
//
// This is an Intel SSSE3 implementation of the SimdFloat SimdDouble etc... classes
// (requires -mssse3 flag on gcc)
// Simd vector types are of size 16 bytes (4 floats or 2 doubles).
#ifndef simd_tools_sse_included
#define simd_tools_sse_included

#include <emmintrin.h>
#include <xmmintrin.h>
#include <tmmintrin.h>
#include <assert.h>
#include <stdint.h>

// ToDo: remove it! Temporary way to respect trust rules (name of the file = name of the class)
   class simd_tools_sse
   {
public:
     simd_tools_sse() {}
    ~simd_tools_sse() {}
   };
   
/*! @brief returns the size in bytes of SIMD vectors on the current architecture (for memory alignment).
 *
 * On Intel, this is 16 bytes, or 4 floats or 2 doubles
 *
 */
inline int simd_getalign()
{
  return 16;
}
/*! @brief allocates a memory bloc of give size (in bytes) with proper alignment for SIMD.
 *
 */
inline void * simd_malloc (size_t size)
{
  return _mm_malloc(size, simd_getalign());
}
/*! @brief frees a memory bloc previously allocated with simd_malloc()
 *
 */
inline void simd_free(void * ptr)
{
  _mm_free(ptr);
}

// uintptr_t should be defined in stdint.h
//  (this type is the result of pointer operations like ptr1-ptr2)
typedef uintptr_t uintptr_type;
/*! @brief returns 1 if pointer is aligned on size bytes, 0 otherwise Warn: size must be a power of 2.
 *
 */
inline int aligned(const void *ptr, int size)
{
  return ((uintptr_type)ptr & (uintptr_type)(size-1)) == 0;
}

#define _SimdAligned_ __attribute__ ((aligned (16)))
// Implementation for single precision type
#define Simd_floatSIZE 4
/*! @brief This class provides a generic access to simd operations on IA32 and Intel 64 architecture.
 *
 * Functionalities provided by the class are designed to match those provided by common
 *  processor architectures (Altivec, SSE, etc):
 *   - load vector size aligned data from memory (SimdGet)
 *   - getting x[i-1] and x[i+1] efficiently for finite difference algorithms
 *     (SimdGetAtLeft, SimdGetAtRight, etc)
 *   - arithmetic operations (+ - * /)
 *   - conditional affectation (SimdSelect)
 *  See simd_malloc() and simd_free() to allocate aligned blocs of memory.
 *
 */
class Simd_float
{
public:
  typedef float value_type;
  Simd_float() {};
  // Size of the vector (depends on the architecture and scalar type)
  static int size() {
    return 4;
  }

  void operator+=(Simd_float a) {
    data_ = _mm_add_ps(data_, a.data_);
  }
  void operator*=(Simd_float a) {
    data_ = _mm_mul_ps(data_, a.data_);
  }
  void operator-=(Simd_float a) {
    data_ = _mm_sub_ps(data_, a.data_);
  }

  // The type below is architecture specific.
  // Code using it will be non portable.
  __m128 data_;
  // Commodity default constructor (provides implicit conversion)
  Simd_float(__m128 x) : data_(x) {};
    Simd_float(float x) { data_ = _mm_set1_ps(x); }
};

/*! @brief Returns the vector found at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_float SimdGet(const float *data)
{
  return _mm_load_ps(data);
}

/*! @brief Stores vector x at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdPut(float *data, Simd_float x)
{
  _mm_store_ps(data, x.data_);
}

/*! @brief Returns the vector x starting at adress data+1 data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs two vector loads and a shift operation.
 *
 */
inline Simd_float SimdGetAtRight(const float *data)
{
  return (__m128) _mm_alignr_epi8((__m128i)_mm_load_ps(data+4), (__m128i)_mm_load_ps(data), 4);
}

/*! @brief Returns the vector x starting at adress data-1 data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs two vector loads and a shift operation.
 *
 */
inline Simd_float SimdGetAtLeft(const float *data)
{
  return (__m128) _mm_alignr_epi8((__m128i)_mm_load_ps(data), (__m128i)_mm_load_ps(data-4), 12);
}

/*! @brief Returns the vector left and center starting at adress data-1 and data data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs two vector loads and a shift operation
 *
 */
inline void SimdGetLeftCenter(const float *data, Simd_float &left, Simd_float &center)
{
  // codage utilisant deux instructions load alignees et un decalage
  // (le plus efficace pour l'instant sur tous les processeurs)
  __m128 a = _mm_load_ps(data-4);
  __m128 b = _mm_load_ps(data);
  left = (__m128) _mm_alignr_epi8((__m128i) b, (__m128i) a, 12);
  center = (__m128) b;
}

/*! @brief Returns the vector center and right starting at adress data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs two vector loads and a shift operation
 *
 */
inline void SimdGetCenterRight(const float *data, 
				   Simd_float &center,
				   Simd_float &right)
{
  // meme remarque sur l'efficacite que ci-dessus
  __m128 b = _mm_load_ps(data);
  __m128 c = _mm_load_ps(data+4);
  center = (__m128) b;
  right = (__m128) _mm_alignr_epi8((__m128i) c, (__m128i) b, 4);
}

/*! @brief Returns the vectors left, center and right starting at adress data-1, data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs three vector loads and two shift operations
 *
 */
inline void SimdGetLeftCenterRight(const float *data, 
				   Simd_float &left,
				   Simd_float &center,
				   Simd_float &right)
{
  __m128 a = _mm_load_ps(data-4);
  __m128 b = _mm_load_ps(data);
  left = (__m128) _mm_alignr_epi8((__m128i) b, (__m128i) a, 12);
  center = (__m128) b;
  __m128 c = _mm_load_ps(data+4);
  right = (__m128) _mm_alignr_epi8((__m128i) c, (__m128i) b, 4);
}

inline void SimdGetLeftleftLeftCenterRight(const float *data, 
				       Simd_float &leftleft,
				       Simd_float &left,
				       Simd_float &center,
				       Simd_float &right)
{
  __m128 a = _mm_load_ps(data-4);
  __m128 b = _mm_load_ps(data);
  leftleft = (__m128) _mm_alignr_epi8((__m128i) b, (__m128i) a, 8);
  left = (__m128) _mm_alignr_epi8((__m128i) b, (__m128i) a, 12);
  center = (__m128) b;
  __m128 c = _mm_load_ps(data+4);
  right = (__m128) _mm_alignr_epi8((__m128i) c, (__m128i) b, 4);
}

inline Simd_float Simd_absolute_value(Simd_float a)
{
  static const __m128 SIGNMASK = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return _mm_andnot_ps(SIGNMASK, a.data_);
  

}

/*! @brief returns a+b
 *
 */
inline Simd_float operator+(Simd_float a, Simd_float b)
{
  return _mm_add_ps(a.data_, b.data_);
}

/*! @brief returns a-b
 *
 */
inline Simd_float operator-(Simd_float a, Simd_float b)
{
  return _mm_sub_ps(a.data_, b.data_);
}

/*! @brief returns a*b
 *
 */
inline Simd_float operator*(Simd_float a, Simd_float b)
{
  return _mm_mul_ps(a.data_, b.data_);
}


/*! @brief This function performs the following operation on the vectors for (i=0; i<size())
 *
 *    if (x1[i] < x2[i])
 *      result[i] = value_if_x1_lower_than_x2[i]
 *    else
 *      result[i] = value_otherwise[i]
 *
 */
inline Simd_float SimdSelect(Simd_float x1,
			       Simd_float x2,
			       Simd_float value_if_x1_lower_than_x2,
			       Simd_float value_otherwise)
{

  __m128 compare = _mm_cmplt_ps(x1.data_, x2.data_);
  return _mm_or_ps(_mm_and_ps(compare, value_if_x1_lower_than_x2.data_),
		   _mm_andnot_ps(compare, value_otherwise.data_));
}

// Returns a vector built with min(a[i],b[i]) (element wise)
inline Simd_float SimdMin(const Simd_float & a, const Simd_float  & b)
{
  return _mm_min_ps(a.data_, b.data_);
}

// Returns a vector built with max(a[i],b[i]) (element wise)
inline Simd_float SimdMax(const Simd_float & a, const Simd_float  & b)
{
  return _mm_max_ps(a.data_, b.data_);
}

// Returns a 12 bits accurate result of a/b
inline Simd_float SimdDivideLow(const Simd_float & a, const Simd_float & b)
{
  return _mm_rcp_ps(b.data_) * a.data_;
}

// Returns a 22 bits accurate result of a/b
inline Simd_float SimdDivideMed(const Simd_float & a, const Simd_float & b)
{
  __m128 x = _mm_rcp_ps(b.data_); // x = approximation de 1/b
  __m128 y = _mm_mul_ps(a.data_, x); // y = a * x
  // resu = (a - b * y) * x + y
  __m128 resu = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(a.data_, _mm_mul_ps(b.data_, y)), x), y);
  return resu;
}

// Returns a 22 bits accurate result of 1/b
inline Simd_float SimdReciprocalMed(const Simd_float & b)
{
  __m128 x = _mm_rcp_ps(b.data_); // x = approximation de 1/b
  // resu = (2 - b * x) * x
  __m128 resu = _mm_mul_ps(_mm_sub_ps(Simd_float(2.f).data_, _mm_mul_ps(b.data_, x)), x);
  return resu;
}

// Implementation for double precision type
#define Simd_doubleSIZE 2
/*! @brief This class provides a generic access to simd operations on IA32 and Intel 64 architecture.
 *
 * Functionalities provided by the class are designed to match those provided by common
 *  processor architectures (Altivec, SSE, etc):
 *   - load vector size aligned data from memory (SimdGet)
 *   - getting x[i-1] and x[i+1] efficiently for finite difference algorithms
 *     (SimdGetAtLeft, SimdGetAtRight, etc)
 *   - arithmetic operations (+ - * /)
 *   - conditional affectation (SimdSelect)
 *  See simd_malloc() and simd_free() to allocate aligned blocs of memory.
 *
 */
class Simd_double
{
public:
  typedef double value_type;
  Simd_double() {};
  // Size of the vector (depends on the architecture and scalar type)
  static int size() {
    return 2;
  }

  void operator+=(Simd_double a) {
    data_ = _mm_add_pd(data_, a.data_);
  }
  void operator*=(Simd_double a) {
    data_ = _mm_mul_pd(data_, a.data_);
  }
  void operator-=(Simd_double a) {
    data_ = _mm_sub_pd(data_, a.data_);
  }

  // The type below is architecture specific.
  // Code using it will be non portable.
  __m128d data_;
  // Commodity default constructor (provides implicit conversion)
  Simd_double(__m128d x) : data_(x) {};
    Simd_double(double x) { data_ = _mm_set1_pd(x); }
};

/*! @brief Returns the vector found at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_double SimdGet(const double *data)
{
  return _mm_load_pd(data);
}

/*! @brief Stores vector x at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdPut(double *data, Simd_double x)
{
  _mm_store_pd(data, x.data_);
}

/*! @brief Returns the vector x starting at adress data+1 data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs two vector loads and a shift operation.
 *
 */
inline Simd_double SimdGetAtRight(const double *data)
{
  return (__m128d) _mm_alignr_epi8((__m128i)_mm_load_pd(data+2), (__m128i)_mm_load_pd(data), 8);
}

/*! @brief Returns the vector x starting at adress data-1 data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs two vector loads and a shift operation.
 *
 */
inline Simd_double SimdGetAtLeft(const double *data)
{
  return (__m128d) _mm_alignr_epi8((__m128i)_mm_load_pd(data), (__m128i)_mm_load_pd(data-2), 8);
}

/*! @brief Returns the vector left and center starting at adress data-1 and data data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs two vector loads and a shift operation
 *
 */
inline void SimdGetLeftCenter(const double *data, Simd_double &left, Simd_double &center)
{
  // codage utilisant deux instructions load alignees et un decalage
  // (le plus efficace pour l'instant sur tous les processeurs)
  __m128d a = _mm_load_pd(data-2);
  __m128d b = _mm_load_pd(data);
  left = (__m128d) _mm_alignr_epi8((__m128i) b, (__m128i) a, 8);
  center = (__m128d) b;
}

/*! @brief Returns the vector center and right starting at adress data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs two vector loads and a shift operation
 *
 */
inline void SimdGetCenterRight(const double *data, 
				   Simd_double &center,
				   Simd_double &right)
{
  // meme remarque sur l'efficacite que ci-dessus
  __m128d b = _mm_load_pd(data);
  __m128d c = _mm_load_pd(data+2);
  center = (__m128d) b;
  right = (__m128d) _mm_alignr_epi8((__m128i) c, (__m128i) b, 8);
}

/*! @brief Returns the vectors left, center and right starting at adress data-1, data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 *   The implementation usually needs three vector loads and two shift operations
 *
 */
inline void SimdGetLeftCenterRight(const double *data, 
				   Simd_double &left,
				   Simd_double &center,
				   Simd_double &right)
{
  __m128d a = _mm_load_pd(data-2);
  __m128d b = _mm_load_pd(data);
  left = (__m128d) _mm_alignr_epi8((__m128i) b, (__m128i) a, 8);
  center = (__m128d) b;
  __m128d c = _mm_load_pd(data+2);
  right = (__m128d) _mm_alignr_epi8((__m128i) c, (__m128i) b, 8);
}

inline void SimdGetLeftleftLeftCenterRight(const double *data, 
				       Simd_double &leftleft,
				       Simd_double &left,
				       Simd_double &center,
				       Simd_double &right)
{
  __m128d a = _mm_load_pd(data-2);
  leftleft = a;
  __m128d b = _mm_load_pd(data);
  left = (__m128d) _mm_alignr_epi8((__m128i) b, (__m128i) a, 8);
  center = (__m128d) b;
  __m128d c = _mm_load_pd(data+2);
  right = (__m128d) _mm_alignr_epi8((__m128i) c, (__m128i) b, 8);
}

inline Simd_double Simd_absolute_value(Simd_double a)
{
  static const __m128d SIGNMASK = _mm_castsi128_pd(_mm_set1_epi32(0x80000000));
  return _mm_andnot_pd(SIGNMASK, a.data_);  

}

/*! @brief returns a+b
 *
 */
inline Simd_double operator+(Simd_double a, Simd_double b)
{
  return _mm_add_pd(a.data_, b.data_);
}

/*! @brief returns a-b
 *
 */
inline Simd_double operator-(Simd_double a, Simd_double b)
{
  return _mm_sub_pd(a.data_, b.data_);
}

/*! @brief returns a*b
 *
 */
inline Simd_double operator*(Simd_double a, Simd_double b)
{
  return _mm_mul_pd(a.data_, b.data_);
}


/*! @brief This function performs the following operation on the vectors for (i=0; i<size())
 *
 *    if (x1[i] < x2[i])
 *      result[i] = value_if_x1_lower_than_x2[i]
 *    else
 *      result[i] = value_otherwise[i]
 *
 */
inline Simd_double SimdSelect(Simd_double x1,
			       Simd_double x2,
			       Simd_double value_if_x1_lower_than_x2,
			       Simd_double value_otherwise)
{

  __m128d compare = _mm_cmplt_pd(x1.data_, x2.data_);
  return _mm_or_pd(_mm_and_pd(compare, value_if_x1_lower_than_x2.data_),
		   _mm_andnot_pd(compare, value_otherwise.data_));
}

// Returns a vector built with min(a[i],b[i]) (element wise)
inline Simd_double SimdMin(const Simd_double & a, const Simd_double  & b)
{
  return _mm_min_pd(a.data_, b.data_);
}

// Returns a vector built with max(a[i],b[i]) (element wise)
inline Simd_double SimdMax(const Simd_double & a, const Simd_double  & b)
{
  return _mm_max_pd(a.data_, b.data_);
}

// Returns a 22 bits accurate result of a/b
inline Simd_double SimdDivideMed(const Simd_double & a, const Simd_double & b)
{
  return _mm_div_pd(a.data_, b.data_);;
}
// According to Colfax_FLOPS.pdf
//  sse3 division, double precision => 0.7 GFlops, single precision => 1.4 GFlops
inline Simd_double SimdReciprocalMed(const Simd_double & b)
{
  Simd_double one(1.);
  return _mm_div_pd(one.data_, b.data_);
}


class Simd_int
{
public:
  typedef int value_type;
 
  Simd_int() {};
  static int size() {
    return 4;
  }
  void operator&=(Simd_int a) {
    data_ = _mm_and_si128(data_, a.data_);
  }
  void operator|=(Simd_int a) {
    data_ = _mm_or_si128(data_, a.data_);
  }

  // The type below is architecture specific.
  // Code using it will be non portable.
  __m128i data_;

  // Commodity default constructor (provides implicit conversion)
  Simd_int(__m128i x) : data_(x) {};
    Simd_int(int x) { data_ = _mm_set1_epi32(x); }
};

/*! @brief Returns the vector found at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_int SimdGet(const int *data)
{
  return _mm_load_si128((__m128i*)data);
}

/*! @brief Stores vector x at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdPut(int *data, Simd_int x)
{
  _mm_store_si128((__m128i*)data, x.data_);
}

// Returns 0 if x1!=x2 and value_if_equal if x1==x2
inline Simd_int SimdTestEqual(Simd_float x1, Simd_float x2, Simd_int value_if_equal)
{
  return _mm_and_si128(_mm_castps_si128(_mm_cmpeq_ps(x1.data_, x2.data_)), value_if_equal.data_);
}

inline Simd_int SimdTestEqual(Simd_float x1, Simd_float x2, 
			      Simd_int value_if_equal, Simd_int value_if_not_equal)
{
  __m128i compare = _mm_castps_si128(_mm_cmpeq_ps(x1.data_, x2.data_));
  return _mm_or_si128(_mm_and_si128(compare, value_if_equal.data_),
		      _mm_andnot_si128(compare, value_if_not_equal.data_));
}

inline Simd_int SimdSelect(Simd_float x1,
			   Simd_float x2,
			   Simd_int value_if_x1_lower_than_x2,
			   Simd_int value_otherwise)
{
  __m128i compare = _mm_castps_si128(_mm_cmplt_ps(x1.data_, x2.data_));
  return _mm_or_si128(_mm_and_si128(compare, value_if_x1_lower_than_x2.data_),
		      _mm_andnot_si128(compare, value_otherwise.data_));
}

inline void SimdCompareAndSetIfLower(const Simd_float & x_new, Simd_float & x, 
				     const Simd_int & i_new, Simd_int & i)
{
  x = SimdMin(x, x_new);
  i = SimdTestEqual(x, x_new, i_new, i);
  // The code does this for each vector element:
  //if (x_new < x) {
  //  x = x_new;
  //  i = i_new;
  //}
}

#endif


