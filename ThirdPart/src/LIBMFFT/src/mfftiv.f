      SUBROUTINE MFFTIV(C,IVSX,IESX,NVX,NEX,TABLES,IERR)
*
*   PURPOSE:
*       THIS SUBROUTINE PERFORMS AN INVERSE FOURIER TRANSFORM ALONG
*       ONE DIMENSION OF A 2-DIMENSIONAL MATRIX, USING THE
*       COOLEY-TUKEY ALGORITHM.
*       THE INPUT MATRIX IS ASSUMED TO HAVE BEEN SUBJECTED
*        TO A "BIT-REVERSAL" REORDERING ( THROUGH MFFTOV OR
*       BECAUSE IT IS THE OUTPUT OF MFFDV AND HAS NOT BEEN REORDERED)
*       THE SEQUENCE TO BE TRANSFORMED IS C[IVSX,NVX], WHOSE COMPONENTS
*       ARE THE VECTORS C(M)[IESX,NEX].
*       SEE REF.[1] FOR NOTATIONS.
*  EXAMPLE:
*       LET C BE A 2-D MATRIX C(N1,N2) DECLARED VIA
*                 DIMENSION C(ID,N2)
*       WITH ID.GE.N1.
*       THEN THE IDFT ALONG THE FIRST DIMENSION IS OBTAINED BY
*                 CALL MFFTIV(C,1,ID,N1,N2,TABLES,IERR)
*       THE IDFT ALONG THE SECOND DIMENSION IS OBTAINED BY
*                 CALL MFFTIV(C,ID,1,N2,N1,TABLES,IERR)
*  IMPLEMENTATION:
*       THE TRANSFORMATION IS IMPLEMENTED THROUGH REPEATED CALLS TO THE
*       "BUTTERFLY" TRANSFORMATION MFFT?5; PARAMETERS OF THE "BUTTERFLY"
*       ARE COMMUNICATED THROUGH THE COMMON BLOCK MFFTPA.
*  ARGUMENTS:
*       C : ARRAY TO BE TRANSFORMED.
*       IVSX,IESX,NVX,NEX: THESE ARGUMENTS DEFINE THE STRUCTURE OF
*           C ACCORDING TO THE DEFINITIONS ABOVE. THEY ARE UNCHANGED ON
*           OUTPUT;
*       TABLES : ARRAY PREPARED BY MFFTP. IT  IS NOT CHANGED ON OUTPUT.
*                IT SHOULD BE DECLARED INTEGER TABLES(4*NM+14);
*                IT MUST BE INITIALIZED BY MFFTP BEFORE USAGE.
*  OUTPUT:
*       C : TRANSFORM OF THE ORIGINAL ARRAY; "BIT REVERSED" ORDER
*       IERR : ERROR CODE : =0 : SUCCESSFUL
*                         : =3 :  'TABLES' NOT CORRECTLY INITIALIZED
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE COMPLEX C(*)
      INTEGER TABLES(-14:*)
      INTEGER IDERR,FACERR,TBERR
      PARAMETER (IDERR=1,FACERR=2,TBERR=3)
      COMMON /MFFTPA/  IMS,IVS,IES,NM,NV,NE,MX,LX,MLIM,MSTEP,LLIM,LSTEP,
     $ NUSTEP,IVLIM,ILIM,MD2LIM,LD2LIM
*  LOADING THE COMMON BLOCK : CONSTANTS
      IVS=IVSX
      IES=IESX
      NV=NVX
      NE=NEX
      ILIM=(NE-1)*IES
      LSTEP=IVS
*  LOADING THE COMMON BLOCK : ITERATION-DEPENDENT QUANTITIES: INITIALIZA
      LX=1
      MX=NV
*  SELECT THE HIGHEST FACTOR OF NV
      IFAC=TABLES(-1)
      IF(IFAC.GT.3)THEN
        IERR=TBERR
        RETURN
      ENDIF
*..  RADIX 2 LOOP
200   CONTINUE
      DO 210 IM=1,TABLES(-14)
        MX=MX/2
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        LD2LIM=NUSTEP/2-LSTEP
        MSTEP=NUSTEP*2
        MLIM=NV*LSTEP-MSTEP
        CALL MFFTA5(C,TABLES(0))
        LX=LX+LX
210   CONTINUE
      IF(IFAC.EQ.1)RETURN
*..  RADIX 3 LOOP
300   CONTINUE
      DO 310 IM=1,TABLES(-13)
        MX=MX/3
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        MSTEP=NUSTEP*3
        MLIM=NV*LSTEP-MSTEP
        CALL MFFTB5(C,TABLES(0))
        LX=LX*3
310   CONTINUE
      IF(IFAC.EQ.2)RETURN
*..   RADIX 5 LOOP
500   CONTINUE
      DO 510 IM=1,TABLES(-12)
        MX=MX/5
        NUSTEP=LX*LSTEP
        LLIM=NUSTEP-LSTEP
        MSTEP=NUSTEP*5
        MLIM=NV*LSTEP-MSTEP
        CALL MFFTC5(C,TABLES(0))
        LX=LX*5
510   CONTINUE
      END
