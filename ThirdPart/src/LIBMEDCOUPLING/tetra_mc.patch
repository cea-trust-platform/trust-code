diff --git a/src/INTERP_KERNEL/Log.hxx b/src/INTERP_KERNEL/Log.hxx
index 0c056c13..09e39744 100644
--- a/src/INTERP_KERNEL/Log.hxx
+++ b/src/INTERP_KERNEL/Log.hxx
@@ -28,10 +28,10 @@
  * LOG_LEVEL (which can be defined at compile-time for each file by passing option -DLOG_LEVEL=x to gcc)
  * than the message is logged.
  *
- *
- *
  */
 
+
+//#define LOG_LEVEL 4
 /// define LOG_LEVEL here if it is not already defined
 #ifndef LOG_LEVEL
 #define LOG_LEVEL 0
@@ -54,12 +54,4 @@
 
 
 
-
-
-
-
-
-
-
-
 #endif
diff --git a/src/INTERP_KERNEL/SplitterTetra.hxx b/src/INTERP_KERNEL/SplitterTetra.hxx
index 9ba8f7b0..80f70487 100644
--- a/src/INTERP_KERNEL/SplitterTetra.hxx
+++ b/src/INTERP_KERNEL/SplitterTetra.hxx
@@ -441,7 +441,7 @@ namespace INTERP_KERNEL
    * which indicates whether the points that have already been checked are all in a halfspace. For each halfspace, 
    * the corresponding array element will be true if and only if it was true when the method was called and pt lies in the halfspace.
    * 
-   * @param pt        double[3] containing the coordiantes of a transformed point
+   * @param pt        double[3] containing the coordinates of a transformed point
    * @param isOutside bool[8] which indicate the results of earlier checks. 
    */
   template<class MyMeshType>
diff --git a/src/INTERP_KERNEL/SplitterTetra.txx b/src/INTERP_KERNEL/SplitterTetra.txx
index 6ae42053..9b631fd7 100644
--- a/src/INTERP_KERNEL/SplitterTetra.txx
+++ b/src/INTERP_KERNEL/SplitterTetra.txx
@@ -216,12 +216,8 @@ namespace INTERP_KERNEL
     // halfspace filtering check
     // NB : might not be beneficial for caching of triangles
     for(int i = 0; i < 8; ++i)
-      {
-        if(isOutside[i])
-          {
-            isTargetOutside = true;
-          }
-      }
+      if(isOutside[i])
+        isTargetOutside = true;
 
     double totalVolume = 0.0;
 
@@ -873,6 +869,7 @@ namespace INTERP_KERNEL
         
         TransformedTriangle tri(nodes[faceNodes[0]], nodes[faceNodes[1]], nodes[faceNodes[2]]);
         double vol = tri.calculateIntersectionVolume();
+        LOG(1, "ii = " << ii << " Volume=" << vol)
         totalVolume += vol;
       }
       
diff --git a/src/INTERP_KERNEL/TransformedTriangle.cxx b/src/INTERP_KERNEL/TransformedTriangle.cxx
index fdaeb656..ac83c338 100644
--- a/src/INTERP_KERNEL/TransformedTriangle.cxx
+++ b/src/INTERP_KERNEL/TransformedTriangle.cxx
@@ -70,9 +70,15 @@ namespace INTERP_KERNEL
      */
     bool operator()(const double* pt1, const double* pt2)
     {
-      // calculate angles with the axis
-      const double ang1 = atan2(pt1[_aIdx] - _a, pt1[_bIdx] - _b);
-      const double ang2 = atan2(pt2[_aIdx] - _a, pt2[_bIdx] - _b);
+      // A ***much*** faster alternative to atan2 to get a pseudo-angle suitable for sorting:
+      // https://stackoverflow.com/questions/16542042/fastest-way-to-sort-vectors-by-angle-without-actually-computing-that-angle
+      const double dy1 = pt1[_aIdx] - _a, dx1 = pt1[_bIdx] - _b,
+                   dy2 = pt2[_aIdx] - _a, dx2 = pt2[_bIdx] - _b;
+      const double deno1 = std::fabs(dx1)+fabs(dy1),
+                   deno2 = std::fabs(dx2)+fabs(dy2);
+
+      const double ang1 = deno1 == 0.0 ? 0.0 : std::copysign(1. - dx1/deno1, dy1),
+                   ang2 = deno2 == 0.0 ? 0.0 : std::copysign(1. - dx2/deno2, dy2);
 
       return ang1 > ang2;
     }
@@ -122,13 +128,15 @@ namespace INTERP_KERNEL
     _coords[5*Q + 3] = 1 - q[0] - q[1] - q[2];
     _coords[5*R + 3] = 1 - r[0] - r[1] - r[2];
 
+    // Handle degenerated case where one of the seg of PQR is (almost) inside XYZ plane,
+    // and hence by extension when the whole PQR triangle is in the XYZ plane
+    handleDegenerateCases();
+
     // H coordinate
     _coords[5*P + 4] = 1 - p[0] - p[1];
     _coords[5*Q + 4] = 1 - q[0] - q[1];
     _coords[5*R + 4] = 1 - r[0] - r[1];
 
-    resetNearZeroCoordinates();
-
     // initialise rest of data
     preCalculateDoubleProducts();
 
@@ -147,14 +155,10 @@ namespace INTERP_KERNEL
   TransformedTriangle::~TransformedTriangle()
   {
     // delete elements of polygons
-    for(std::vector<double*>::iterator it = _polygonA.begin() ; it != _polygonA.end() ; ++it)
-      {
-        delete[] *it;
-      }
-    for(std::vector<double*>::iterator it = _polygonB.begin() ; it != _polygonB.end() ; ++it)
-      {
-        delete[] *it;
-      }    
+    for(auto& it: _polygonA)
+      delete[] it;
+    for(auto& it: _polygonB)
+      delete[] it;
   }
 
   /**
@@ -206,6 +210,11 @@ namespace INTERP_KERNEL
     if(_polygonA.size() > 2)
       {
         LOG(2, "---- Treating polygon A ... ");
+#if LOG_LEVEL > 0
+        LOG(3, "  --- Final points in polygon A");
+        for(const auto& pt:  _polygonA)
+          LOG(3,vToStr(pt));
+#endif
         calculatePolygonBarycenter(A, barycenter);
         sortIntersectionPolygon(A, barycenter);
         volA = calculateVolumeUnderPolygon(A, barycenter);
@@ -214,17 +223,27 @@ namespace INTERP_KERNEL
 
     double volB = 0.0;
     // if triangle is not in h = 0 plane, calculate volume under B
-    if(_polygonB.size() > 2 && !isTriangleInPlaneOfFacet(XYZ))
+    if(_polygonB.size() > 2 && !isTriangleInPlaneOfFacet(XYZ)) // second condition avoids double counting in case triangle fully included in h=0 facet
       {
         LOG(2, "---- Treating polygon B ... ");
-       
+#if LOG_LEVEL > 0
+        LOG(3, "  --- Final points in polygon B");
+        for(const auto& pt:  _polygonB)
+          LOG(3,vToStr(pt));
+#endif
         calculatePolygonBarycenter(B, barycenter);
         sortIntersectionPolygon(B, barycenter);
         volB = calculateVolumeUnderPolygon(B, barycenter);
         LOG(2, "Volume is " << sign * volB);
       }
 
-    LOG(2, "volA + volB = " << sign * (volA + volB) << std::endl << "***********");
+#if LOG_LEVEL >= 2
+    LOG(2, "############ Triangle :")
+    dumpCoords();
+    LOG(2, "vol A = " << volA);
+    LOG(2, "vol B = " << volB);
+    LOG(2, "TOTAL = " << sign*(volA+volB));
+#endif
   
     return _volume = sign * (volA + volB);
 
@@ -265,7 +284,7 @@ namespace INTERP_KERNEL
   }
 
   // ----------------------------------------------------------------------------------
-  // TransformedTriangle PRIVATE
+  // TransformedTriangle PROTECTED
   // ----------------------------------------------------------------------------------
 
   /**
@@ -278,6 +297,11 @@ namespace INTERP_KERNEL
    */
   void TransformedTriangle::calculateIntersectionAndProjectionPolygons()
   {
+#if LOG_LEVEL >= 3
+    std::cout << " @@@@@@@@ COORDS @@@@@@  " << std::endl;
+    dumpCoords();
+#endif
+
     assert(_polygonA.size() == 0);
     assert(_polygonB.size() == 0);
     // avoid reallocations in push_back() by pre-allocating enough memory
@@ -293,15 +317,15 @@ namespace INTERP_KERNEL
             double* ptA = new double[3];
             calcIntersectionPtSurfaceEdge(edge, ptA);
             _polygonA.push_back(ptA);
-            LOG(3,"Surface-edge : " << vToStr(ptA) << " added to A ");
+            LOG(3,"Surface-edge (edge " << strTE(edge) << "): " << vToStr(ptA) << " added to A ");
             if(edge >= XY)
               {
                 double* ptB = new double[3];
                 copyVector3(ptA, ptB);
                 _polygonB.push_back(ptB);
-                LOG(3,"Surface-edge : " << vToStr(ptB) << " added to B ");
+                LOG(3,"Surface-edge (edge " << strTE(edge) << "): " << vToStr(ptB) << " added to B ");
               }
-           
+
           }
       }
 
@@ -313,7 +337,7 @@ namespace INTERP_KERNEL
             double* ptB = new double[3];
             copyVector3(&COORDS_TET_CORNER[3 * corner], ptB);
             _polygonB.push_back(ptB);
-            LOG(3,"Surface-ray : " << vToStr(ptB) << " added to B");
+            LOG(3,"Surface-ray (corner " << strTC(corner) << "): " << vToStr(ptB) << " added to B");
           }
       }
 
@@ -323,33 +347,31 @@ namespace INTERP_KERNEL
 
         bool isZero[NO_DP];
 
-        // check beforehand which double-products are zero
+        // check beforehand which double-products are zero.
         for(DoubleProduct dp = C_YZ; dp < NO_DP; dp = DoubleProduct(dp + 1))
-          {
-            isZero[dp] = (calcStableC(seg, dp) == 0.0);
-          }
+          isZero[dp] = (calcStableC(seg, dp) == 0.0);
 
         // segment - facet
         for(TetraFacet facet = OYZ ; facet < NO_TET_FACET ; facet = TetraFacet(facet + 1))
           {
             // is this test worth it?
             const bool doTest = 
-              !isZero[DP_FOR_SEG_FACET_INTERSECTION[3*facet]] && 
-              !isZero[DP_FOR_SEG_FACET_INTERSECTION[3*facet + 1]] &&
-              !isZero[DP_FOR_SEG_FACET_INTERSECTION[3*facet + 2]];
+                !isZero[DP_FOR_SEG_FACET_INTERSECTION[3*facet]] &&
+                !isZero[DP_FOR_SEG_FACET_INTERSECTION[3*facet + 1]] &&
+                !isZero[DP_FOR_SEG_FACET_INTERSECTION[3*facet + 2]];
 
             if(doTest && testSegmentFacetIntersection(seg, facet))
               {
                 double* ptA = new double[3];
                 calcIntersectionPtSegmentFacet(seg, facet, ptA);
                 _polygonA.push_back(ptA);
-                LOG(3,"Segment-facet : " << vToStr(ptA) << " added to A");
+                LOG(3,"Segment-facet (facet " << strTF(facet) << ", seg " << strTriS(seg) << "): " << vToStr(ptA) << " added to A");
                 if(facet == XYZ)
                   {
                     double* ptB = new double[3];
                     copyVector3(ptA, ptB);
                     _polygonB.push_back(ptB);
-                    LOG(3,"Segment-facet : " << vToStr(ptB) << " added to B");
+                    LOG(3,"Segment-facet (facet " << strTF(facet) << ", seg " << strTriS(seg) << "): " << vToStr(ptB) << " added to B");
                   }
 
               }
@@ -365,112 +387,113 @@ namespace INTERP_KERNEL
                 double* ptA = new double[3];
                 calcIntersectionPtSegmentEdge(seg, edge, ptA);
                 _polygonA.push_back(ptA);
-                LOG(3,"Segment-edge : " << vToStr(ptA) << " added to A");
+                LOG(3,"Segment-edge (edge " << strTE(edge) << ", seg " << strTriS(seg) << "): " << vToStr(ptA) << " added to A");
                 if(edge >= XY)
                   {
                     double* ptB = new double[3];
                     copyVector3(ptA, ptB);
                     _polygonB.push_back(ptB);
+                    LOG(3,"Segment-edge (edge " << strTE(edge) << ", seg " << strTriS(seg) << "): " << vToStr(ptA) << " added to B");
                   }
               }
           }
-       
+
         // segment - corner
         for(TetraCorner corner = O ; corner < NO_TET_CORNER ; corner = TetraCorner(corner + 1))
           {
             const bool doTest = 
-              isZero[DoubleProduct( EDGES_FOR_CORNER[3*corner] )] &&
-              isZero[DoubleProduct( EDGES_FOR_CORNER[3*corner+1] )] &&
-              isZero[DoubleProduct( EDGES_FOR_CORNER[3*corner+2] )];
+                isZero[DoubleProduct( EDGES_FOR_CORNER[3*corner] )] &&
+                isZero[DoubleProduct( EDGES_FOR_CORNER[3*corner+1] )] &&
+                isZero[DoubleProduct( EDGES_FOR_CORNER[3*corner+2] )];
 
             if(doTest && testSegmentCornerIntersection(seg, corner))
               {
                 double* ptA = new double[3];
                 copyVector3(&COORDS_TET_CORNER[3 * corner], ptA);
                 _polygonA.push_back(ptA);
-                LOG(3,"Segment-corner : " << vToStr(ptA) << " added to A");
+                LOG(3,"Segment-corner (corner " << strTC(corner) << ", seg " << strTriS(seg) << "): " << vToStr(ptA) << " added to A");
                 if(corner != O)
                   {
                     double* ptB = new double[3];
                     _polygonB.push_back(ptB);
                     copyVector3(&COORDS_TET_CORNER[3 * corner], ptB);
-                    LOG(3,"Segment-corner : " << vToStr(ptB) << " added to B");
+                    LOG(3,"Segment-corner (corner " << strTC(corner) << ", seg " << strTriS(seg) << "): " << vToStr(ptB) << " added to B");
                   }
               }
           }
 
-            // segment - ray 
-            for(TetraCorner corner = X ; corner < NO_TET_CORNER ; corner = TetraCorner(corner + 1))
+        // segment - ray
+        for(TetraCorner corner = X ; corner < NO_TET_CORNER ; corner = TetraCorner(corner + 1))
+          {
+            if(isZero[DP_SEGMENT_RAY_INTERSECTION[7*(corner-1)]] && testSegmentRayIntersection(seg, corner))
               {
-                if(isZero[DP_SEGMENT_RAY_INTERSECTION[7*(corner-1)]] && testSegmentRayIntersection(seg, corner))
-                  {
-                    double* ptB = new double[3];
-                    copyVector3(&COORDS_TET_CORNER[3 * corner], ptB);
-                    _polygonB.push_back(ptB);
-                    LOG(3,"Segment-ray : " << vToStr(ptB) << " added to B");
-                  }
+                double* ptB = new double[3];
+                copyVector3(&COORDS_TET_CORNER[3 * corner], ptB);
+                _polygonB.push_back(ptB);
+                LOG(3,"Segment-ray (corner " << strTC(corner) << ", seg " << strTriS(seg) << "): " << vToStr(ptB) << " added to B");
               }
-       
-            // segment - halfstrip
-            for(TetraEdge edge = XY ; edge <= ZX ; edge = TetraEdge(edge + 1))
-              {
+          }
+
+        // segment - halfstrip
+        for(TetraEdge edge = XY ; edge <= ZX ; edge = TetraEdge(edge + 1))
+          {
 
 #if 0
-                const int edgeIdx = int(edge) - 3; // offset since we only care for edges XY - ZX
-                const bool doTest = 
-                  !isZero[DP_FOR_HALFSTRIP_INTERSECTION[4*edgeIdx]] &&
-                  !isZero[DP_FOR_HALFSTRIP_INTERSECTION[4*edgeIdx+1]];
-       
+            const int edgeIdx = int(edge) - 3; // offset since we only care for edges XY - ZX
+            const bool doTest =
+                !isZero[DP_FOR_HALFSTRIP_INTERSECTION[4*edgeIdx]] &&
+                !isZero[DP_FOR_HALFSTRIP_INTERSECTION[4*edgeIdx+1]];
+
 
-                if(doTest && testSegmentHalfstripIntersection(seg, edge))
+            if(doTest && testSegmentHalfstripIntersection(seg, edge))
 #endif
-                  if(testSegmentHalfstripIntersection(seg, edge))
-                    {
-                      double* ptB = new double[3];
-                      calcIntersectionPtSegmentHalfstrip(seg, edge, ptB);
-                      _polygonB.push_back(ptB);
-                      LOG(3,"Segment-halfstrip : " << vToStr(ptB) << " added to B");
-                    }
-              }
+              if(testSegmentHalfstripIntersection(seg, edge))
+                {
+                  double* ptB = new double[3];
+                  calcIntersectionPtSegmentHalfstrip(seg, edge, ptB);
+                  _polygonB.push_back(ptB);
+                  LOG(3,"Segment-halfstrip : " << vToStr(ptB) << " added to B");
+                }
+          }
       }
 
-        // inclusion tests
-        for(TriCorner corner = P ; corner < NO_TRI_CORNER ; corner = TriCorner(corner + 1))
+    // inclusion tests
+    for(TriCorner corner = P ; corner < NO_TRI_CORNER ; corner = TriCorner(corner + 1))
+      {
+        // { XYZ - inclusion only possible if in Tetrahedron?
+        // tetrahedron
+        if(testCornerInTetrahedron(corner))
           {
-            // { XYZ - inclusion only possible if in Tetrahedron?
-            // tetrahedron
-            if(testCornerInTetrahedron(corner))
-              {
-                double* ptA = new double[3];
-                copyVector3(&_coords[5*corner], ptA);
-                _polygonA.push_back(ptA);
-                LOG(3,"Inclusion tetrahedron : " << vToStr(ptA) << " added to A");
-              }
-
-            // XYZ - plane
-            if(testCornerOnXYZFacet(corner))
-              {
-                double* ptB = new double[3];
-                copyVector3(&_coords[5*corner], ptB);
-                _polygonB.push_back(ptB);
-                LOG(3,"Inclusion XYZ-plane : " << vToStr(ptB) << " added to B");
-              }
+            double* ptA = new double[3];
+            copyVector3(&_coords[5*corner], ptA);
+            _polygonA.push_back(ptA);
+            LOG(3,"Inclusion tetrahedron (corner " << strTriC(corner) << "): " << vToStr(ptA) << " added to A");
+          }
 
-            // projection on XYZ - facet
-            if(testCornerAboveXYZFacet(corner))
-              {
-                double* ptB = new double[3];
-                copyVector3(&_coords[5*corner], ptB);
-                ptB[2] = 1 - ptB[0] - ptB[1];
-                assert(epsilonEqual(ptB[0]+ptB[1]+ptB[2] - 1, 0.0));
-                _polygonB.push_back(ptB);
-                LOG(3,"Projection XYZ-plane : " << vToStr(ptB) << " added to B");
-              }
+        // XYZ - plane
+        if(testCornerOnXYZFacet(corner))
+          {
+            double* ptB = new double[3];
+            copyVector3(&_coords[5*corner], ptB);
+            _polygonB.push_back(ptB);
+            LOG(3,"Inclusion XYZ-plane (corner " << strTriC(corner) << "): " << vToStr(ptB) << " added to B");
+          }
 
+        // projection on XYZ - facet
+        if(testCornerAboveXYZFacet(corner))
+          {
+            double* ptB = new double[3];
+            copyVector3(&_coords[5*corner], ptB);
+            ptB[2] = 1 - ptB[0] - ptB[1];   // lower z to project on XYZ
+            assert(epsilonEqual(ptB[0]+ptB[1]+ptB[2] - 1, 0.0));
+            _polygonB.push_back(ptB);
+            LOG(3,"Projection XYZ-plane (corner " << strTriC(corner) << "): " << vToStr(ptB) << " added to B");
           }
 
       }
 
+  }
+
   /**
    * Calculates the intersection polygon A, performing the intersection tests
    * and storing the corresponding point in the vector _polygonA.
@@ -504,10 +527,9 @@ namespace INTERP_KERNEL
         bool isZero[NO_DP];
 
         // check beforehand which double-products are zero
+        // Test for "== 0.0" here is OK since doubleProduct has been fixed for rounding to zero already.
         for(DoubleProduct dp = C_YZ; dp < NO_DP; dp = DoubleProduct(dp + 1))
-          {
-            isZero[dp] = (calcStableC(seg, dp) == 0.0);
-          }
+          isZero[dp] = (calcStableC(seg, dp) == 0.0);
 
         // segment - facet
         for(TetraFacet facet = OYZ ; facet < NO_TET_FACET ; facet = TetraFacet(facet + 1))
@@ -623,20 +645,19 @@ namespace INTERP_KERNEL
       const std::size_t m = polygon.size();
 
       for(int j = 0 ; j < 3 ; ++j)
-        {
-          barycenter[j] = 0.0;
-        }
+	barycenter[j] = 0.0;
+
+      for(std::size_t i = 0 ; i < m ; ++i)
+	{
+	  const double* pt = polygon[i];
+	  for(int j = 0 ; j < 3 ; ++j)
+	    barycenter[j] += pt[j];
+	}
 
       if(m != 0)
         {
-          for(std::size_t i = 0 ; i < m ; ++i)
-            {
-              const double* pt = polygon[i];
-              for(int j = 0 ; j < 3 ; ++j)
-                {
-                  barycenter[j] += pt[j] / double(m);
-                }
-            }
+	  for(int j = 0 ; j < 3 ; ++j)
+	    barycenter[j] = barycenter[j] / double(m);
         }
       LOG(3,"Barycenter is " << vToStr(barycenter));
     }
@@ -674,14 +695,7 @@ namespace INTERP_KERNEL
           // We keep the test here anyway, to avoid interdependency.
 
           // is triangle inclined to x == 0 ?
-          if(isTriangleInclinedToFacet(OZX))
-            {
-              type = SortOrder::XZ;
-            }
-          else //if(isTriangleParallelToFacet(OYZ))
-            {
-              type = SortOrder::YZ;
-            }
+          type = isTriangleInclinedToFacet(OZX) ? SortOrder::XZ : SortOrder::YZ;
         }
 
       // create order object
@@ -751,18 +765,13 @@ namespace INTERP_KERNEL
      */
     bool TransformedTriangle::isTriangleInPlaneOfFacet(const TetraFacet facet) const
     {
-
       // coordinate to check
       const int coord = static_cast<int>(facet);
 
       for(TriCorner c = P ; c < NO_TRI_CORNER ; c = TriCorner(c + 1))
-        {
-          if(_coords[5*c + coord] != 0.0)
-            {
-              return false;
-            }
-        }
-    
+        if(_coords[5*c + coord] != 0.0)
+          return false;
+
       return true;
     }
 
@@ -776,7 +785,7 @@ namespace INTERP_KERNEL
     {
       // coordinate to check
       const int coord = static_cast<int>(facet);
-      return (_coords[5*P + coord] == _coords[5*Q + coord]) && (_coords[5*P + coord] == _coords[5*R + coord]);
+      return (epsilonEqual(_coords[5*P + coord], _coords[5*Q + coord])) && (epsilonEqual(_coords[5*P + coord], _coords[5*R + coord]));
     }
 
     /**
@@ -801,9 +810,7 @@ namespace INTERP_KERNEL
 
       double sign = uv_xy[0] * uv_xy[3] - uv_xy[1] * uv_xy[2];
       if(epsilonEqual(sign, 0.))
-        {
-          sign = 0.;
-        }
+        sign = 0.;
       return (sign < 0.) ? -1 : (sign > 0.) ? 1 : 0;
     }
 
@@ -815,13 +822,10 @@ namespace INTERP_KERNEL
     bool TransformedTriangle::isTriangleBelowTetraeder() const
     {
       for(TriCorner c = P ; c < NO_TRI_CORNER ; c = TriCorner(c + 1))
-        {
-          // check z-coords for all points
-          if(_coords[5*c + 2] >= 0.0)
-            {
-              return false;
-            }
-        }
+        // check z-coords for all points
+        if(_coords[5*c + 2] >= 0.0)
+          return false;
+
       return true;
     }
 
@@ -833,10 +837,10 @@ namespace INTERP_KERNEL
     {
       std::cout << "Coords : ";
       for(int i = 0 ; i < 3; ++i)
-        {
-          std::cout << vToStr(&_coords[5*i]) << ",";
-        }
+        std::cout << vToStr(&_coords[5*i]) << ",";
+
       std::cout << std::endl;
     }
-    
+
+
   } // NAMESPACE 
diff --git a/src/INTERP_KERNEL/TransformedTriangle.hxx b/src/INTERP_KERNEL/TransformedTriangle.hxx
index 2904d95d..14d39659 100644
--- a/src/INTERP_KERNEL/TransformedTriangle.hxx
+++ b/src/INTERP_KERNEL/TransformedTriangle.hxx
@@ -22,6 +22,7 @@
 
 #include "INTERPKERNELDefines.hxx"
 #include "VectorUtils.hxx"
+#include "assert.h"
 
 #include <vector>
 
@@ -69,6 +70,9 @@ namespace INTERP_KERNEL
    * coordinates of the corners of the triangle. It copies their coordinates and then proceeds to pre-calculating certain
    * entities used in the intersection calculation : the double products, triple products and the values of the function E
    * (Grandy, [53]).
+   * It is also at this point in constructor that:
+   *  - the special case of PQR included in the XYZ plane is treated
+   *  - the inconsistencies between double products/triple products computation is handled
    *
    * calculateIntersectionVolume() : 
    * This is the only method in the public interface. It calculates the volume under the intersection polygons
@@ -94,18 +98,14 @@ namespace INTERP_KERNEL
    *    When an intersection point has been detected it is calculated with a corresponding calc* - method in the cases where it
    * is not known directly. It is then added to the polygon A and/or B as necessary.
    *
-   * OPTIMIZE : 
-   *    If OPTIMIZE is defined, a large number of methods will be prefixed with inline and some optimizations concerning the tests 
-   * with zero double products will be used.
    */
   class INTERPKERNEL_EXPORT TransformedTriangle
   {
  
 
   public:
-
-    friend class INTERP_TEST::TransformedTriangleTest;
     friend class INTERP_TEST::TransformedTriangleIntersectTest;
+    friend class INTERP_TEST::TransformedTriangleTest;
     /*
      * Enumerations representing the different geometric elements of the unit tetrahedron
      * and the triangle. The end element, NO_* gives the number of elements in the enumeration
@@ -139,126 +139,90 @@ namespace INTERP_KERNEL
 
     double calculateIntersectionVolume(); 
     double calculateIntersectionSurface(TetraAffineTransform* tat);
-
     void dumpCoords() const;
 
     // Queries of member values used by UnitTetraIntersectionBary
-
     const double* getCorner(TriCorner corner) const { return _coords + 5*corner; }
-
     const std::vector<double*>& getPolygonA() const { return _polygonA; }
-
     double getVolume() const { return _volume; }
 
   protected:
-
     TransformedTriangle() { }
 
     // ----------------------------------------------------------------------------------
     //  High-level methods called directly by calculateIntersectionVolume()     
     // ----------------------------------------------------------------------------------
     void calculateIntersectionAndProjectionPolygons();
-
     void calculatePolygonBarycenter(const IntersectionPolygon poly, double* barycenter); 
-
     void sortIntersectionPolygon(const IntersectionPolygon poly, const double* barycenter); 
-
     double calculateVolumeUnderPolygon(IntersectionPolygon poly, const double* barycenter); 
 
     // ----------------------------------------------------------------------------------
     //  High-level methods called directly by calculateIntersectionSurface()
     // ----------------------------------------------------------------------------------
     void calculateIntersectionPolygon();
-
     double calculateSurfacePolygon();
 
     // ----------------------------------------------------------------------------------
     //  Detection of degenerate triangles  
     // ----------------------------------------------------------------------------------
-
     bool isTriangleInPlaneOfFacet(const TetraFacet facet) const;
-    
     bool isTriangleParallelToFacet(const TetraFacet facet) const;
-
     int isTriangleInclinedToFacet(const TetraFacet facet) const;
-
     bool isTriangleBelowTetraeder() const;
 
     // ----------------------------------------------------------------------------------
     //  Intersection test methods and intersection point calculations           
     // ----------------------------------------------------------------------------------
- 
     inline bool testSurfaceEdgeIntersection(const TetraEdge edge) const; 
-
     void calcIntersectionPtSurfaceEdge(const TetraEdge edge, double* pt) const;  
-
     inline bool testSegmentFacetIntersection(const TriSegment seg, const TetraFacet facet) const; 
-
     void calcIntersectionPtSegmentFacet(const TriSegment seg, const TetraFacet facet, double* pt) const;  
-
     bool testSegmentEdgeIntersection(const TriSegment seg, const TetraEdge edge) const; 
- 
     void calcIntersectionPtSegmentEdge(const TriSegment seg, const TetraEdge edge, double* pt) const ; 
-
     bool testSegmentCornerIntersection(const TriSegment seg, const TetraCorner corner) const ;
-
     inline bool testSurfaceRayIntersection(const TetraCorner corner) const;
-
     bool testSegmentHalfstripIntersection(const TriSegment seg, const TetraEdge edg);
-
     void calcIntersectionPtSegmentHalfstrip(const TriSegment seg, const TetraEdge edge, double* pt) const;
-    
     bool testSegmentRayIntersection(const TriSegment seg, const TetraCorner corner) const;
-
     inline bool testCornerInTetrahedron(const TriCorner corner) const;
-
     inline bool testCornerOnXYZFacet(const TriCorner corner) const;
-
     inline bool testCornerAboveXYZFacet(const TriCorner corner) const;
 
     // ----------------------------------------------------------------------------------
     //  Utility methods used in intersection tests                       
     // ----------------------------------------------------------------------------------
-    
     bool testTriangleSurroundsEdge(const TetraEdge edge) const;
-
     inline bool testEdgeIntersectsTriangle(const TetraEdge edge) const;
-
     inline bool testFacetSurroundsSegment(const TriSegment seg, const TetraFacet facet) const;
-
     inline bool testSegmentIntersectsFacet(const TriSegment seg, const TetraFacet facet) const;
-
     bool testSegmentIntersectsHPlane(const TriSegment seg) const;
-
     bool testSurfaceAboveCorner(const TetraCorner corner) const;
-    
     bool testTriangleSurroundsRay(const TetraCorner corner) const;
 
     // ----------------------------------------------------------------------------------
     //  Double and triple product calculations                           
     // ----------------------------------------------------------------------------------
-    
-    void resetNearZeroCoordinates();
-
+    void handleDegenerateCases();
     bool areDoubleProductsConsistent(const TriSegment seg) const;
-
-    void preCalculateDoubleProducts(void);
-
+    void preCalculateDoubleProducts();
     inline void resetDoubleProducts(const TriSegment seg, const TetraCorner corner);
-
     double calculateDistanceCornerSegment(const TetraCorner corner, const TriSegment seg) const;
-    
-    void preCalculateTripleProducts(void);
-
+    void preCalculateTripleProducts();
     double calculateAngleEdgeTriangle(const TetraEdge edge) const;
-
     inline double calcStableC(const TriSegment seg, const DoubleProduct dp) const;
-
     inline double calcStableT(const TetraCorner corner) const;
+    inline double calcUnstableC(const TriSegment seg, const DoubleProduct dp, double & delta) const;
+    double calcTByDevelopingRow(const TetraCorner corner, const int row, const bool project) const;
 
-    inline double calcUnstableC(const TriSegment seg, const DoubleProduct dp) const;
-
-    double calcTByDevelopingRow(const TetraCorner corner, const int row = 1, const bool project = false) const;
+    // ----------------------------------------------------------------------------------
+    // Debug
+    // ----------------------------------------------------------------------------------
+    inline const std::string& strTC(TetraCorner tc) const;
+    inline const std::string& strTE(TetraEdge te) const;
+    inline const std::string& strTF(TetraFacet tf) const;
+    inline const std::string& strTriC(TriCorner tc) const;
+    inline const std::string& strTriS(TriSegment tc) const;
 
     // ----------------------------------------------------------------------------------
     //  Member variables                                                 
@@ -281,8 +245,12 @@ namespace INTERP_KERNEL
     /// following order in enumeration DoubleProduct
     double _doubleProducts[24];
 
+    double _deltas[24];
+
     /// Array containing the 4 triple products.
     /// order : t_O, t_X, t_Y, t_Z
+    /// For example t_O represent the signed volume of the tetrahedron OPQR, and is positive if PQR is oriented clockwise
+    //  when seen from the vertex O.
     double _tripleProducts[4];
 
     /// Vector holding the points of the intersection polygon A.
@@ -339,11 +307,11 @@ namespace INTERP_KERNEL
     // by a given row
     static const DoubleProduct DP_FOR_DETERMINANT_EXPANSION[12];
     
-    // values used to decide how imprecise the double products 
+    // values used to decide how/when imprecise the double products
     // should be to set them to 0.0
-    static const long double MACH_EPS;    // machine epsilon
-    static const long double MULT_PREC_F; // precision of multiplications (Grandy : f)
-    static const long double THRESHOLD_F; // threshold for zeroing (Grandy : F/f)
+    static const double MACH_EPS;    // machine epsilon
+    static const double MULT_PREC_F; // precision of multiplications (Grandy : f)
+    static const double THRESHOLD_F; // threshold for zeroing (Grandy : F/f)
 
     static const double TRIPLE_PRODUCT_ANGLE_THRESHOLD;
 
@@ -353,10 +321,10 @@ namespace INTERP_KERNEL
 
     // signs associated with entries in DP_FOR_SEGMENT_FACET_INTERSECTION
     static const double SIGN_FOR_SEG_FACET_INTERSECTION[12];
-    
+
     // coordinates of corners of tetrahedron
     static const double COORDS_TET_CORNER[12];
-    
+
     // indices to use in tables DP_FOR_SEG_FACET_INTERSECTION and SIGN_FOR_SEG_FACET_INTERSECTION
     // for the calculation of the coordinates (x,y,z) of the intersection points
     // for Segment-Facet and Segment-Edge intersections
@@ -380,10 +348,285 @@ namespace INTERP_KERNEL
 
   };
 
-  // include definitions of inline methods
+  inline void TransformedTriangle::preCalculateTriangleSurroundsEdge()
+  {
+    for(TetraEdge edge = OX ; edge <= ZX ; edge = TetraEdge(edge + 1))
+      {
+        _triangleSurroundsEdgeCache[edge] = testTriangleSurroundsEdge(edge);
+      }
+  }
+
 
-#include "TransformedTriangleInline.hxx"
-}
+  // ----------------------------------------------------------------------------------
+  //   TransformedTriangle_math.cxx
+  // ----------------------------------------------------------------------------------
+
+  inline void TransformedTriangle::resetDoubleProducts(const TriSegment seg, const TetraCorner corner)
+  {
+    // set the three corresponding double products to 0.0
+    static const DoubleProduct DOUBLE_PRODUCTS[12] =
+    {
+      C_YZ, C_ZX, C_XY, // O
+      C_YZ, C_ZH, C_YH, // X
+      C_ZX, C_ZH, C_XH, // Y
+      C_XY, C_YH, C_XH  // Z
+    };
+
+    for(int i = 0 ; i < 3 ; ++i) {
+        const DoubleProduct dp = DOUBLE_PRODUCTS[3*corner + i];
+
+        LOG(6, std::endl << "resetting inconsistent dp :" << dp << " for corner " << corner);
+        _doubleProducts[8*seg + dp] = 0.0;
+    };
+  }
+
+  inline double TransformedTriangle::calcStableC(const TriSegment seg, const DoubleProduct dp) const
+  {
+    return _doubleProducts[8*seg + dp];
+  }
+
+  inline double TransformedTriangle::calcStableT(const TetraCorner corner) const
+  {
+    assert(_validTP[corner]);
+    return _tripleProducts[corner];
+  }
+
+  inline double TransformedTriangle::calcUnstableC(const TriSegment seg, const DoubleProduct dp, double& delta) const
+  {
+    // find the points of the triangle
+    // 0 -> P, 1 -> Q, 2 -> R
+    const int pt1 = seg;
+    const int pt2 = (seg + 1) % 3;
+
+    // find offsets
+    const int off1 = DP_OFFSET_1[dp];
+    const int off2 = DP_OFFSET_2[dp];
+
+    const double prd1 = _coords[5*pt1 + off1] * _coords[5*pt2 + off2],
+                 prd2 = _coords[5*pt1 + off2] * _coords[5*pt2 + off1];
+    delta = std::fabs(prd1) + std::fabs(prd2);
+    return  prd1 - prd2;
+  }
+
+  // ----------------------------------------------------------------------------------
+  //  TransformedTriangle_intersect.cxx
+  // ----------------------------------------------------------------------------------
+  inline bool TransformedTriangle::testSurfaceEdgeIntersection(const TetraEdge edge) const
+  {
+    return _triangleSurroundsEdgeCache[edge] && testEdgeIntersectsTriangle(edge);
+  }
+
+  inline bool TransformedTriangle::testSegmentFacetIntersection(const TriSegment seg, const TetraFacet facet) const
+  {
+    return testFacetSurroundsSegment(seg, facet) && testSegmentIntersectsFacet(seg, facet);
+  }
+
+  inline bool TransformedTriangle::testSurfaceRayIntersection(const TetraCorner corner) const
+  {
+    return testTriangleSurroundsRay( corner ) && testSurfaceAboveCorner( corner );
+  }
+
+  inline bool TransformedTriangle::testCornerInTetrahedron(const TriCorner corner) const
+  {
+    const double pt[4] =
+    {
+      _coords[5*corner],     // x
+      _coords[5*corner + 1], // y
+      _coords[5*corner + 2], // z
+      _coords[5*corner + 3]  // z
+    };
+
+    for(int i = 0 ; i < 4 ; ++i)
+      {
+        if(pt[i] < 0.0 || pt[i] > 1.0)
+          {
+            return false;
+          }
+      }
+    return true;
+  }
+
+  inline  bool TransformedTriangle::testCornerOnXYZFacet(const TriCorner corner) const
+  {
+#if 0
+    const double pt[4] =
+    {
+      _coords[5*corner],     // x
+      _coords[5*corner + 1], // y
+      _coords[5*corner + 2], // z
+      _coords[5*corner + 3]  // h
+    };
+#endif
+    const double* pt = &_coords[5*corner];
+
+    if(pt[3] != 0.0)
+      {
+        return false;
+      }
+
+    for(int i = 0 ; i < 3 ; ++i)
+      {
+        if(pt[i] < 0.0 || pt[i] > 1.0)
+          {
+            return false;
+          }
+      }
+    return true;
+  }
+
+  inline  bool TransformedTriangle::testCornerAboveXYZFacet(const TriCorner corner) const
+  {
+    const double x = _coords[5*corner];
+    const double y = _coords[5*corner + 1];
+    const double h = _coords[5*corner + 3];
+    const double H = _coords[5*corner + 4];
+
+    return h < 0.0 && H >= 0.0 && x >= 0.0 && y >= 0.0;
+
+  }
+
+  inline bool TransformedTriangle::testEdgeIntersectsTriangle(const TetraEdge edge) const
+  {
+    // correspondence edge - triple products for edges OX, ..., ZX (Grandy, table III)
+    static const TetraCorner TRIPLE_PRODUCTS[12] =
+    {
+      X, O, // OX
+      Y, O, // OY
+      Z, O, // OZ
+      X, Y, // XY
+      Y, Z, // YZ
+      Z, X, // ZX
+    };
+
+    // Grandy, [16]
+    const double t1 = calcStableT(TRIPLE_PRODUCTS[2*edge]);
+    const double t2 = calcStableT(TRIPLE_PRODUCTS[2*edge + 1]);
+
+    // [ABN] Okayyy: if either t1 or t2 exactly equal zero, then it can mean two things:
+    //   - either PQR is very close to the corner -> this is OK, further computation of intersection point between
+    // surface and edge will produce a correct result
+    //   - or, if the other triple prod is also very small, then this is a degenerate case: the edge is almost in PQR -> this is bad
+    // and leads to weird intersection point computation -> we avoid this.
+    // PS : here was written "// tuleap26461" -> whoo this helps :-)
+    if (t1 == 0.0 || t2 == 0.0)
+      if (std::fabs(t1+t2) < THRESHOLD_F*MULT_PREC_F)
+        return false;
+
+    return (t1*t2 <= 0.0) && !epsilonEqual(t1,t2, MULT_PREC_F);
+  }
+
+  inline bool TransformedTriangle::testFacetSurroundsSegment(const TriSegment seg, const TetraFacet facet) const
+  {
+#if 0
+    const double signs[3] =
+    {
+      SIGN_FOR_SEG_FACET_INTERSECTION[3*facet],
+      SIGN_FOR_SEG_FACET_INTERSECTION[3*facet + 1],
+      SIGN_FOR_SEG_FACET_INTERSECTION[3*facet + 2]
+    };
+#endif
 
+    const double* signs = &SIGN_FOR_SEG_FACET_INTERSECTION[3*facet];
+    const double c1 = signs[0]*calcStableC(seg, DP_FOR_SEG_FACET_INTERSECTION[3*facet]);
+    const double c2 = signs[1]*calcStableC(seg, DP_FOR_SEG_FACET_INTERSECTION[3*facet + 1]);
+    const double c3 = signs[2]*calcStableC(seg, DP_FOR_SEG_FACET_INTERSECTION[3*facet + 2]);
+
+    return (c1*c3 > 0.0) && (c2*c3 > 0.0);
+  }
+
+  inline bool TransformedTriangle::testSegmentIntersectsFacet(const TriSegment seg, const TetraFacet facet) const
+  {
+    // use correspondence facet a = 0 <=> offset for coordinate a in _coords
+    // and also correspondence segment AB => corner A
+    const double coord1 = _coords[5*seg + facet];
+    const double coord2 = _coords[5*( (seg + 1) % 3) + facet];
+
+    //? should we use epsilon-equality here in second test?
+    LOG(5, "coord1 : " << coord1 << " coord2 : " << coord2 );
+
+    return (coord1*coord2 <= 0.0) && (coord1 != coord2);
+  }
+
+  inline bool TransformedTriangle::testSegmentIntersectsHPlane(const TriSegment seg) const
+  {
+    // get the H - coordinates
+    const double coord1 = _coords[5*seg + 4];
+    const double coord2 = _coords[5*( (seg + 1) % 3) + 4];
+    //? should we use epsilon-equality here in second test?
+    LOG(5, "coord1 : " << coord1 << " coord2 : " << coord2 );
+
+    return (coord1*coord2 <= 0.0) && (coord1 != coord2);
+  }
+
+  inline bool TransformedTriangle::testSurfaceAboveCorner(const TetraCorner corner) const
+  {
+    // There is an error in Grandy -> it should be C_XY instead of C_YZ in [28].
+    //
+    // Idea: the nz value (Grandy [28] corrected!) can be interpreted as a special variant of the triple product t_O
+    // where the z coordinate has been set to 1. It represents the signed volume of the tet OP'Q'R' where P', Q' and R' are the
+    // projection of P, Q, R on the z=1 plane.
+    // Comparing the sign of this triple product with t_X (or t_Y, ... dep on the corner) indicates whether the corner is in the
+    // half-space above or below the PQR triangle, similarly to what is explained in [16].
+    // (this works even for the Z corner, since we could have chosen z=24 (instead of z=1) this would not have changed the final sign test).
+    const double nz = calcStableC(PQ, C_XY) + calcStableC(QR, C_XY) + calcStableC(RP, C_XY);
+
+    // Triple product might have not been computed, but here we need one:
+    const double tp = _validTP[corner] ? calcStableT(corner) : calcTByDevelopingRow(corner, 1, false);
+
+    return tp*nz >= 0.0;
+  }
+
+  inline bool TransformedTriangle::testTriangleSurroundsRay(const TetraCorner corner) const
+  {
+    // double products to use for the possible corners
+    static const DoubleProduct DP_FOR_RAY_INTERSECTION[4] =
+    {
+      DoubleProduct(0),        // O - only here to fill out and make indices match
+      C_10,     // X
+      C_01,     // Y
+      C_XY      // Z
+    };
+
+    const DoubleProduct dp = DP_FOR_RAY_INTERSECTION[corner];
+
+    const double cPQ = calcStableC(PQ, dp);
+    const double cQR = calcStableC(QR, dp);
+    const double cRP = calcStableC(RP, dp);
+
+    return ( cPQ*cQR > 0.0 ) && ( cPQ*cRP > 0.0 );
+  }
+
+  inline const std::string& TransformedTriangle::strTC(TetraCorner tc) const
+  {
+    static const std::map<TetraCorner, std::string> m = {{O, "O"}, {X, "X"}, {Y, "Y"}, {Z, "Z"}};
+    return m.at(tc);
+  }
+
+  inline const std::string& TransformedTriangle::strTE(TetraEdge te) const
+  {
+    static const std::map<TetraEdge, std::string> m = {{OX, "OX"}, {OY, "OY"}, {OZ, "OZ"}, {XY, "XY"}, {YZ, "YZ"},
+      {ZX, "ZX"}, {H01, "H01"}, {H10, "H10"}};
+    return m.at(te);
+  }
+
+  inline const std::string& TransformedTriangle::strTF(TetraFacet tf) const
+  {
+    static const std::map<TetraFacet, std::string> m = {{OYZ, "OYZ"}, {OZX, "OZX"}, {OXY, "OXY"}, {XYZ, "XYZ"}};
+    return m.at(tf);
+  }
+
+  inline const std::string& TransformedTriangle::strTriC(TriCorner tc) const
+  {
+    static const std::map<TriCorner, std::string> m = {{P, "P"}, {Q, "Q"}, {R, "R"}};
+    return m.at(tc);
+  }
+
+  inline const std::string& TransformedTriangle::strTriS(TriSegment ts) const
+  {
+    static const std::map<TriSegment, std::string> m = {{PQ, "PQ"}, {QR, "QR"}, {RP, "RP"}};
+    return m.at(ts);
+  }
+
+}
 
 #endif
diff --git a/src/INTERP_KERNEL/TransformedTriangleIntersect.cxx b/src/INTERP_KERNEL/TransformedTriangleIntersect.cxx
index d7259259..9fc3a167 100644
--- a/src/INTERP_KERNEL/TransformedTriangleIntersect.cxx
+++ b/src/INTERP_KERNEL/TransformedTriangleIntersect.cxx
@@ -168,13 +168,12 @@ namespace INTERP_KERNEL
     const double alpha = tA / (tA - tB);
 
     // calculate point
-    LOG(4, "corner A = " << corners[0] << " corner B = " << corners[1] );
+    LOG(4, "corner A = " << strTC(corners[0]) << " corner B = " << strTC(corners[1]) );
     LOG(4, "tA = " << tA << " tB = " << tB << " alpha= " << alpha );
     for(int i = 0; i < 3; ++i)
       {
 
-        pt[i] = (1 - alpha) * COORDS_TET_CORNER[3*corners[0] + i] + 
-          alpha * COORDS_TET_CORNER[3*corners[1] + i];
+        pt[i] = (1 - alpha)*COORDS_TET_CORNER[3*corners[0] + i] + alpha*COORDS_TET_CORNER[3*corners[1] + i];
 #if 0
         pt[i] = (1 - alpha) * getCoordinateForTetCorner<corners[0], i>() + 
           alpha * getCoordinateForTetCorner<corners[0], i>();
@@ -234,7 +233,7 @@ namespace INTERP_KERNEL
 
   /**
    * Tests if the given segment of the triangle intersects the given edge of the tetrahedron (Grandy, eq. [20]
-   * If the OPTIMIZE is defined, it does not do the test the double product that should be zero.
+   *
    * @param seg    segment of the triangle
    * @param edge   edge of tetrahedron
    * @return      true if the segment intersects the edge 
@@ -249,13 +248,13 @@ namespace INTERP_KERNEL
         for(int i = 0 ; i < 2 ; ++i) 
           {
             facet[i] = FACET_FOR_EDGE[2*edge + i];
-           
+
             // find the two c-values -> the two for the other edges of the facet
             int idx1 = 0 ; 
             int idx2 = 1;
             DoubleProduct dp1 = DP_FOR_SEG_FACET_INTERSECTION[3*facet[i] + idx1];
             DoubleProduct dp2 = DP_FOR_SEG_FACET_INTERSECTION[3*facet[i] + idx2];
-           
+
             if(dp1 == DoubleProduct( edge ))
               {
                 idx1 = 2;
@@ -266,7 +265,7 @@ namespace INTERP_KERNEL
                 idx2 = 2;
                 dp2 = DP_FOR_SEG_FACET_INTERSECTION[3*facet[i] + idx2];
               }
-           
+
             const double c1 = SIGN_FOR_SEG_FACET_INTERSECTION[3*facet[i] + idx1]*calcStableC(seg, dp1);
             const double c2 = SIGN_FOR_SEG_FACET_INTERSECTION[3*facet[i] + idx2]*calcStableC(seg, dp2);
 
@@ -347,24 +346,15 @@ namespace INTERP_KERNEL
             const double sign = SIGN_FOR_SEG_FACET_INTERSECTION[dpIdx];
             c[j] = dpIdx < 0.0 ? 0.0 : sign * calcStableC(seg, dp);
           }
-       
-        // pt[i] = (c1*s1 + c2*s2) / (s1^2 + s2^2)
 
         pt[i] = (c[0] * s[0] + c[1] * s[1]) / denominator;
-       
-        // strange bug with -O2 enabled : assertion fails when we don't have the following
-        // trace - line
-        //std::cout << "pt[i] = " << pt[i] << std::endl;
-        //assert(pt[i] >= 0.0); // check we are in tetraeder
-        //assert(pt[i] <= 1.0);
-       
       }
   }
 
     
   /**
    * Tests if the given segment of the triangle intersects the given corner of the tetrahedron.
-   * (Grandy, eq. [21]). If OPTIMIZE is defined, the double products that should be zero are not verified.
+   * (Grandy, eq. [21]).
    *
    * @param seg    segment of the triangle
    * @param corner corner of the tetrahedron
@@ -372,8 +362,6 @@ namespace INTERP_KERNEL
    */
   bool TransformedTriangle::testSegmentCornerIntersection(const TriSegment seg, const TetraCorner corner) const 
   {
-    
-
     // facets meeting at a given corner
     static const TetraFacet FACETS_FOR_CORNER[12] =
       {
@@ -388,9 +376,7 @@ namespace INTERP_KERNEL
       {
         const TetraFacet facet = FACETS_FOR_CORNER[3*corner + i];
         if(testSegmentIntersectsFacet(seg, facet))
-          {
-            return true;
-          }
+          return true;
       }
     
     return false;
@@ -432,11 +418,10 @@ namespace INTERP_KERNEL
       };
     
     const TetraFacet facet =  FACET_FOR_HALFSTRIP_INTERSECTION[edgeIndex];
-
     
     // special case : facet H = 0
     const bool cond2 = (facet == NO_TET_FACET) ? testSegmentIntersectsHPlane(seg) : testSegmentIntersectsFacet(seg, facet);
-    LOG(4, "Halfstrip tests (" << seg << ", " << edge << ") : " << (cVals[0]*cVals[1] < 0.0) << ", " << cond2 << ", " << (cVals[2]*cVals[3] > 0.0) );
+    LOG(4, "Halfstrip tests (" << strTriS(seg) << ", " << strTE(edge) << ") : " << (cVals[0]*cVals[1] < 0.0) << ", " << cond2 << ", " << (cVals[2]*cVals[3] > 0.0) );
     LOG(4, "c2 = " << cVals[2] << ", c3 = " << cVals[3] ); 
   
     return (cVals[0]*cVals[1] < 0.0) && cond2 && (cVals[2]*cVals[3] > 0.0);
@@ -497,7 +482,6 @@ namespace INTERP_KERNEL
   /**
    * Tests if the given segment of triangle PQR intersects the ray pointing 
    * in the upwards z - direction from the given corner of the tetrahedron. (Grandy eq. [29])
-   * If OPTIMIZE is defined, the double product that should be zero is not verified.
    * 
    * @param seg    segment of the triangle PQR
    * @param corner corner of the tetrahedron on the h = 0 facet (X, Y, or Z)
@@ -573,6 +557,7 @@ namespace INTERP_KERNEL
 
     // if two or more c-values are zero we disallow x-edge intersection
     // Grandy, p.446
+    // test for == 0.0 is OK here, if you look at the way double products were pre-comuted:
     const int numZeros = (cPQ == 0.0 ? 1 : 0) + (cQR == 0.0 ? 1 : 0) + (cRP == 0.0 ? 1 : 0);
     
     if(numZeros >= 2 ) 
diff --git a/src/INTERP_KERNEL/TransformedTriangleMath.cxx b/src/INTERP_KERNEL/TransformedTriangleMath.cxx
index 72f42d1b..7b3eba4e 100644
--- a/src/INTERP_KERNEL/TransformedTriangleMath.cxx
+++ b/src/INTERP_KERNEL/TransformedTriangleMath.cxx
@@ -62,24 +62,55 @@ namespace INTERP_KERNEL
     };
   
   /// The machine epsilon, used in precision corrections
-  const long double TransformedTriangle::MACH_EPS = std::numeric_limits<double>::epsilon();
+  const double TransformedTriangle::MACH_EPS = std::numeric_limits<double>::epsilon();
   
   /// 4.0 * the machine epsilon, represents the precision of multiplication when performing corrections corrections ( f in Grandy )
-  const long double TransformedTriangle::MULT_PREC_F = 4.0 * TransformedTriangle::MACH_EPS;
+  const double TransformedTriangle::MULT_PREC_F = 4.0 * TransformedTriangle::MACH_EPS;
 
   /// Threshold for resetting double and triple products to zero; ( F / f in Grandy )
-  const long double TransformedTriangle::THRESHOLD_F = 500.0;
+  const double TransformedTriangle::THRESHOLD_F = 100.0;
 
   /// Threshold for what is considered a small enough angle to warrant correction of triple products by Grandy, [57]
   const double TransformedTriangle::TRIPLE_PRODUCT_ANGLE_THRESHOLD = 0.1;
 
 
-  // after transformation to the U-space, coordinates are inaccurate
-  // small variations around zero should not be taken into account
-  void TransformedTriangle::resetNearZeroCoordinates()
+  // Handle cases where one of the segment (or all) is (almost) in XYZ plane.
+  // We follow Grandy's suggestion and perturb slightly to have exactly h=0 for the segment (Grandy p.447)
+  // Note that if PQR is == to the upper facet of the unit tetra (XYZ), the tetra-corner-inclusion test should take it in,
+  // thanks to Grandy [21] and the fact that S_x test is "<=0" (not <0)
+  // After that, we also snap P,Q,R to the corners if they're very close.
+  void TransformedTriangle::handleDegenerateCases()
   {
-    for (int i=0; i<15; i++)
-      if (fabs(_coords[i])<TransformedTriangle::MACH_EPS*40.0) _coords[i]=0.0;
+    static const TriCorner PT_SEG_MAP[] = {
+      P, Q,
+      Q, R,
+      R, P
+    };
+
+    const double eps = THRESHOLD_F*TransformedTriangle::MULT_PREC_F;
+    for (TriSegment seg = PQ; seg <= RP; seg = TriSegment(seg+1))
+      {
+        // Is h coordinate for both end of segment small enough?
+        int pt1 = PT_SEG_MAP[2*seg], pt2 = PT_SEG_MAP[2*seg+1];
+        if (fabs(_coords[5*pt1+3]) < eps && fabs(_coords[5*pt2+3]) < eps)
+          {
+            // If so, perturb x,y and z to reset h to exactly zero.
+            for (auto pt: {pt1, pt2})  // thx C++17
+              {
+                const double correc = _coords[pt*5+3]/3.; // this should be really small!
+                _coords[pt*5+0] += correc;
+                _coords[pt*5+1] += correc;
+                _coords[pt*5+2] += correc;
+                // And then, if x,y or z very close to 0 or 1, snap exactly to tetra corner:
+                for(int d=0; d < 3; d++)
+                  {
+                    if (fabs(_coords[5*pt+d]) < eps)    _coords[5*pt+d] = 0.0;
+                    if (fabs(_coords[5*pt+d]-1) < eps)  _coords[5*pt+d] = 1.0;
+                  }
+                _coords[pt*5+3] = 0.0;
+              }
+          }
+      }
   }
   
   // ----------------------------------------------------------------------------------
@@ -92,7 +123,7 @@ namespace INTERP_KERNEL
    * and it is thus the "stable" double products that are stored.
    *
    */
-  void TransformedTriangle::preCalculateDoubleProducts(void)
+  void TransformedTriangle::preCalculateDoubleProducts()
   {
     if(_is_double_products_calculated)
       return;
@@ -101,7 +132,10 @@ namespace INTERP_KERNEL
     for(TriSegment seg = PQ ; seg <= RP ; seg = TriSegment(seg + 1))
       {
         for(DoubleProduct dp = C_YZ ; dp <= C_10 ; dp = DoubleProduct(dp + 1))
-          _doubleProducts[8*seg + dp] = calcUnstableC(seg, dp);
+          {
+            const int idx = 8*seg + dp;
+            _doubleProducts[idx] = calcUnstableC(seg, dp, _deltas[idx]);
+          }
       }
 
     std::map<double, TetraCorner> distances;
@@ -120,33 +154,21 @@ namespace INTERP_KERNEL
                 distances.insert( std::make_pair( dist, corner ) );
               }
 
-            // first element -> minimum distance
+            // first element -> minimum distance (because map is sorted)
             const TetraCorner minCorner = distances.begin()->second;
             resetDoubleProducts(seg, minCorner);
             distances.clear();
           }
       }
-  
+
     // -- (2) check that each double product satisfies Grandy, [47], else set to 0
     for(TriSegment seg = PQ ; seg <= RP ; seg = TriSegment(seg + 1))
       {
         for(DoubleProduct dp = C_YZ ; dp <=  C_10 ; dp = DoubleProduct(dp + 1))
           {
-            // find the points of the triangle
-            // 0 -> P, 1 -> Q, 2 -> R 
-            const int pt1 = seg;
-            const int pt2 = (seg + 1) % 3;
-
-            // find offsets
-            const int off1 = DP_OFFSET_1[dp];
-            const int off2 = DP_OFFSET_2[dp];
-
-            const double term1 = _coords[5*pt1 + off1] * _coords[5*pt2 + off2]; 
-            const double term2 = _coords[5*pt1 + off2] * _coords[5*pt2 + off1];
+            const int idx = 8*seg+dp;
 
-            const long double delta = MULT_PREC_F * ( std::fabs(term1) + std::fabs(term2) );
-         
-            if( epsilonEqual(_doubleProducts[8*seg + dp], 0.0, (double)(THRESHOLD_F * delta)))
+            if( epsilonEqual(_doubleProducts[idx], 0.0, THRESHOLD_F * MULT_PREC_F * _deltas[idx]))
               {
                 // debug output
 #if LOG_LEVEL >= 5
@@ -157,13 +179,11 @@ namespace INTERP_KERNEL
                   }
 #endif 
 
-
-                _doubleProducts[8*seg + dp] = 0.0;
-                
+                _doubleProducts[idx] = 0.0;
               }
           }
       }
-    
+
     _is_double_products_calculated = true;
   }
 
@@ -176,30 +196,45 @@ namespace INTERP_KERNEL
    */
   bool TransformedTriangle::areDoubleProductsConsistent(const TriSegment seg) const
   {
-    const double term1 = _doubleProducts[8*seg + C_YZ] * _doubleProducts[8*seg + C_XH];
-    const double term2 = _doubleProducts[8*seg + C_ZX] * _doubleProducts[8*seg + C_YH];
-    const double term3 = _doubleProducts[8*seg + C_XY] * _doubleProducts[8*seg + C_ZH];
+    // Careful! Here doubleProducts have not yet been corrected for roundoff errors!
+    // So we need to epsilon-adjust to correctly identify zeros:
+    static const DoubleProduct DP_LST[6] = {C_YZ, C_XH,
+                                            C_ZX, C_YH,
+                                            C_XY, C_ZH};
+    double dps[6];
+    for (int i = 0; i < 6; i++)
+      {
+        const double dp = _doubleProducts[8*seg + DP_LST[i]];
+        dps[i] = dp;
+      }
+
+    const double term1 = dps[0] * dps[1];
+    const double term2 = dps[2] * dps[3];
+    const double term3 = dps[4] * dps[5];
 
     LOG(2, "for seg " << seg << " consistency " << term1 + term2 + term3 );
     LOG(2, "term1 :" << term1 << " term2 :" << term2 << " term3: " << term3 );
 
+    // Test for "== 0.0" here is OK since doubleProduct has been fixed for rounding to zero already.
     const int num_zero = (term1 == 0.0 ? 1 : 0) + (term2 == 0.0 ? 1 : 0) + (term3 == 0.0 ? 1 : 0);
     const int num_neg = (term1 < 0.0 ? 1 : 0) + (term2 < 0.0 ? 1 : 0) + (term3 < 0.0 ? 1 : 0);
     const int num_pos = (term1 > 0.0 ? 1 : 0) + (term2 > 0.0 ? 1 : 0) + (term3 > 0.0 ? 1 : 0);
 
     assert( num_zero + num_neg + num_pos == 3 );
 
-    // calculated geometry is inconsistent if we have one of the following cases
+    // Calculated geometry is inconsistent if we have one of the following cases
     // * one term zero and the other two of the same sign
     // * two terms zero
     // * all terms positive
     // * all terms negative
-    if(((num_zero == 1 && num_neg != 1) || num_zero == 2 || (num_neg == 0 && num_zero != 3) || num_neg == 3 ))
-      {
+    const bool inconsist = (num_zero == 1 && num_neg != 1) ||
+                           num_zero == 2 ||
+                           (num_neg == 0 && num_zero != 3) ||
+                           num_neg == 3;
+    if(inconsist)  {
         LOG(4, "inconsistent dp found" );
       }
-    return !((num_zero == 1 && num_neg != 1) || num_zero == 2 || (num_neg == 0 && num_zero != 3) || num_neg == 3 );
-
+    return !inconsist;
   }
 
   /**
@@ -250,12 +285,10 @@ namespace INTERP_KERNEL
    * the problem of errors due to cancellation.
    *
    */
-  void TransformedTriangle::preCalculateTripleProducts(void)
+  void TransformedTriangle::preCalculateTripleProducts()
   {
     if(_is_triple_products_calculated)
-      {
-        return;
-      }
+      return;
 
     // find edge / row to use -> that whose edge makes the smallest angle to the triangle
     // use a map to find the minimum
@@ -272,44 +305,37 @@ namespace INTERP_KERNEL
 
             // get edge by using correspondence between Double Product and Edge
             TetraEdge edge = TetraEdge(dp);
-           
+
             // use edge only if it is surrounded by the surface
             if( _triangleSurroundsEdgeCache[edge] )
                 {
                   // -- calculate angle between edge and PQR
                   const double angle = calculateAngleEdgeTriangle(edge);
-                  anglesForRows.insert(std::make_pair(angle, row));              
+                  anglesForRows.insert(std::make_pair(angle, row));
                 }
           }
-       
+
         if(anglesForRows.size() != 0) // we have found a good row
           {
             const double minAngle = anglesForRows.begin()->first;
             const int minRow = anglesForRows.begin()->second;
 
             if(minAngle < TRIPLE_PRODUCT_ANGLE_THRESHOLD)
-              {
-                _tripleProducts[corner] = calcTByDevelopingRow(corner, minRow, true);
-              } 
+              _tripleProducts[corner] = calcTByDevelopingRow(corner, minRow, true);
             else 
-              {
-                _tripleProducts[corner] = calcTByDevelopingRow(corner, minRow, false);
-              }
+              _tripleProducts[corner] = calcTByDevelopingRow(corner, minRow, false);
+
             _validTP[corner] = true;
           }
         else
           {
-            // this value will not be used
-            // we set it to whatever
+            // this value will not be used - we set it to whatever
             LOG(6, "Triple product not calculated for corner " << corner );
-            _tripleProducts[corner] = -3.14159265;
+            _tripleProducts[corner] = std::nan("triplep");
             _validTP[corner] = false;
-
           }
         anglesForRows.clear();
-
       }
-
     _is_triple_products_calculated = true;
   }
 
@@ -364,20 +390,21 @@ namespace INTERP_KERNEL
     
     //? is this more stable? -> no subtraction
     //    return asin( dotProd / ( lenNormal * lenEdgeVec ) ) + 3.141592625358979 / 2.0;
-    double tmp=dotProd / ( lenNormal * lenEdgeVec );
-    tmp=std::max(tmp,-1.);
-    tmp=std::min(tmp,1.);
-    return atan(1.0)*4.0 - acos(tmp);
-
+    const double tmp=dotProd / ( lenNormal * lenEdgeVec );
+    const double safe_tmp=std::max(std::min(tmp,1.),-1.);
+    return M_PI - std::acos(safe_tmp);
   }
 
   /**
-   * Calculates triple product associated with the given corner of tetrahedron, developing 
+   * Calculates triple product associated with the given corner of tetrahedron, developing
    * the determinant by the given row. The triple product gives the signed volume of 
    * the tetrahedron between this corner and the triangle PQR. If the flag project is true, 
    * one coordinate is projected out in order to eliminate errors in the intersection point
    * calculation due to cancellation.
    * 
+   * Consistency with the double product computation and potential cancellation is also done here.
+   *
+   *
    * @pre            double products have already been calculated
    * @param corner   corner for which the triple product is calculated
    * @param row      row (1 <= row <= 3) used to calculate the determinant
@@ -440,23 +467,23 @@ namespace INTERP_KERNEL
     const double cPQ = calcStableC(PQ, dp);
 
     double alpha = 0.0;
-    
+
     // coordinate to use for projection (Grandy, [57]) with edges
     // OX, OY, OZ, XY, YZ, ZX in order : 
     // (y, z, x, h, h, h)
     // for the first three we could also use {2, 0, 1}
     static const int PROJECTION_COORDS[6] = { 1, 2, 0, 3, 3, 3 } ;
-    
+
     const int coord = PROJECTION_COORDS[ dp ];
-    
+
     // coordinate values for P, Q and R
     const double coordValues[3] = { _coords[5*P + coord], _coords[5*Q + coord], _coords[5*R + coord] };
-    
+
     if(project)
       {
         // products coordinate values with corresponding double product
         const double coordDPProd[3] = { coordValues[0] * cQR, coordValues[1] * cRP, coordValues[2] * cPQ };
-       
+
         const double sumDPProd = coordDPProd[0] + coordDPProd[1] + coordDPProd[2];
         const double sumDPProdSq = dot(coordDPProd, coordDPProd);
 
@@ -468,6 +495,22 @@ namespace INTERP_KERNEL
     const double cRPbar = cRP * (1.0 - alpha * coordValues[1] * cRP);
     const double cPQbar = cPQ * (1.0 - alpha * coordValues[2] * cPQ);
 
+    // [ABN] Triple product cancellation logic:
+    // This part is not well described in Grandy (end of p.446) :
+    //     "We use a method analogous to (47) to remove imprecise triple products,..."
+    //
+    // Our algo for cancelling a triple product:
+    //   - retrieve the deltas associated with each DP involved (because a DP itself is a sum of two terms - see [42]
+    //   - multiply them by the coordinate coming from the determinant expansion
+    //   - and finally sum the 3 corresponding terms of the developement
+    //
+    // Using directly the DP (as was done before here) leads to issues, since this DP might have been cancelled
+    // already earlier on, and we lost the delta information -> doing this, we risk not cancelling the triple prod
+    // when we should have.
+    const double cQRbar_delta = _deltas[8*QR + dp],
+                 cRPbar_delta = _deltas[8*RP + dp],
+                 cPQbar_delta = _deltas[8*PQ + dp];
+
     // check sign of barred products - should not change
     //    assert(cQRbar * cQR >= 0.0);
     //assert(cRPbar * cRP >= 0.0);
@@ -477,15 +520,13 @@ namespace INTERP_KERNEL
     const double q_term = _coords[5*Q + offset] * cRPbar;
     const double r_term = _coords[5*R + offset] * cPQbar;
 
-    // check that we are not so close to zero that numerical errors could take over, 
-    // otherwise reset to zero (cf Grandy, p. 446)
-#ifdef FIXED_DELTA
-    const double delta = FIXED_DELTA;
-#else
-    const long double delta = MULT_PREC_F * (std::fabs(p_term) + std::fabs(q_term) + std::fabs(r_term));
-#endif
+    const double p_delta = std::fabs(_coords[5*P + offset] * cQRbar_delta),
+                 q_delta = std::fabs(_coords[5*Q + offset] * cRPbar_delta),
+                 r_delta = std::fabs(_coords[5*R + offset] * cPQbar_delta);
+
+    const double delta = p_delta + q_delta + r_delta;
 
-    if( epsilonEqual( p_term + q_term + r_term, 0.0, (double)(THRESHOLD_F * delta)) )
+    if( epsilonEqual( p_term + q_term + r_term, 0.0, THRESHOLD_F * MULT_PREC_F * delta) )
       {
         LOG(4, "Reset imprecise triple product for corner " << corner << " to zero" ); 
         return 0.0;
diff --git a/src/INTERP_KERNEL/VectorUtils.hxx b/src/INTERP_KERNEL/VectorUtils.hxx
index efb5937b..f3ce8f3a 100644
--- a/src/INTERP_KERNEL/VectorUtils.hxx
+++ b/src/INTERP_KERNEL/VectorUtils.hxx
@@ -22,6 +22,7 @@
 
 #include <algorithm>
 #include <sstream>
+#include <iomanip>
 #include <numeric>
 #include <string>
 #include <cmath>
@@ -78,7 +79,7 @@ namespace INTERP_KERNEL
   inline const std::string vToStr(const double* pt)
   {
     std::stringstream ss(std::ios::out);
-    ss << "[" << pt[0] << ", " << pt[1] << ", " << pt[2] << "]";
+    ss << std::setprecision(16) << "[" << pt[0] << ", " << pt[1] << ", " << pt[2] << "]";
     return ss.str();
   }
 
diff --git a/src/INTERP_KERNELTest/HexaTests.hxx b/src/INTERP_KERNELTest/HexaTests.hxx
index dadb3497..d74580ae 100644
--- a/src/INTERP_KERNELTest/HexaTests.hxx
+++ b/src/INTERP_KERNELTest/HexaTests.hxx
@@ -33,9 +33,7 @@ namespace INTERP_TEST
     CPPUNIT_TEST_SUITE( HexaTests );
 
     CPPUNIT_TEST( simpleHexaBox );
-    //VB : slightly inaccurate so that it triggers a failure of the test
-    // should be investigated in the future
-    //    CPPUNIT_TEST( reflexiveHexaBox );
+    CPPUNIT_TEST( reflexiveHexaBox );
     CPPUNIT_TEST( hexaBoxes );
     CPPUNIT_TEST( hexaBoxesMoved );
 
diff --git a/src/INTERP_KERNELTest/MeshTestToolkit.txx b/src/INTERP_KERNELTest/MeshTestToolkit.txx
index 06388508..49097166 100644
--- a/src/INTERP_KERNELTest/MeshTestToolkit.txx
+++ b/src/INTERP_KERNELTest/MeshTestToolkit.txx
@@ -166,7 +166,7 @@ namespace INTERP_TEST
             LOG(1, "Source volume inconsistent : vol of cell " << i << " = " << sVol[i] << " but the row sum is " << sum_row );
             ok = false;
           }
-        LOG(1, "diff = " <<sum_row - sVol[i] );
+        LOG(2, "diff = " <<sum_row - sVol[i] );
       }
 
     // target elements
@@ -180,7 +180,7 @@ namespace INTERP_TEST
             LOG(1, "Target volume inconsistent : vol of cell " << i << " = " << tVol[i] << " but the col sum is " << sum_col);
             ok = false;
           }
-        LOG(1, "diff = " <<sum_col - tVol[i] );
+        LOG(2, "diff = " <<sum_col - tVol[i] );
       }
     delete[] sVol;
     delete[] tVol;
@@ -419,7 +419,6 @@ namespace INTERP_TEST
 
     IntersectionMatrix matrix1;
     calcIntersectionMatrix(mesh1path, mesh1, mesh2path, mesh2, matrix1);
-
 #if LOG_LEVEL >= 2
     dumpIntersectionMatrix(matrix1);
 #endif
@@ -475,8 +474,8 @@ namespace INTERP_TEST
   void MeshTestToolkit<SPACEDIM,MESHDIM>::intersectMeshes(const char* mesh1, const char* mesh2, const double correctVol, const double prec, bool doubleTest) const
   {
     const std::string path1 = std::string(mesh1) + std::string(".med");
-    std::cout << "here :" << path1 << std::endl;
     const std::string path2 = std::string(mesh2) + std::string(".med");
+    std::cout << "here :" << path1 << " with " << path2 << std::endl;
 
     intersectMeshes(path1.c_str(), mesh1, path2.c_str(), mesh2, correctVol, prec, doubleTest);
   }
diff --git a/src/INTERP_KERNELTest/PerfTest.cxx b/src/INTERP_KERNELTest/PerfTest.cxx
index c3d5f0b0..cd0c3b2b 100644
--- a/src/INTERP_KERNELTest/PerfTest.cxx
+++ b/src/INTERP_KERNELTest/PerfTest.cxx
@@ -83,8 +83,8 @@ namespace INTERP_TEST
 //      std::pair<int, int> eff = countNumberOfMatrixEntries(m);
 //      LOG(1, eff.first << " of " << numTargetElems * numSrcElems << " intersections calculated : ratio = "
 //          << double(eff.first) / double(numTargetElems * numSrcElems));
-      LOG(1, eff.second << " non-zero elements of " << eff.first << " total : filter efficiency = "
-          << double(eff.second) / double(eff.first));
+//      LOG(1, eff.second << " non-zero elements of " << eff.first << " total : filter efficiency = "
+//          << double(eff.second) / double(eff.first));
 
       LOG(1, "Intersection calculation done. " << std::endl );
 
diff --git a/src/INTERP_KERNELTest/TestInterpKernel.cxx b/src/INTERP_KERNELTest/TestInterpKernel.cxx
index 6f346272..1a885ad5 100644
--- a/src/INTERP_KERNELTest/TestInterpKernel.cxx
+++ b/src/INTERP_KERNELTest/TestInterpKernel.cxx
@@ -52,10 +52,10 @@ CPPUNIT_TEST_SUITE_REGISTRATION( UnitTetra3D2DIntersectionTest );
 #ifndef MEDCOUPLING_MICROMED
 // These test suites need MEDLoader to load some test files:
 CPPUNIT_TEST_SUITE_REGISTRATION( InterpolationOptionsTest );
+CPPUNIT_TEST_SUITE_REGISTRATION( SingleElementTetraTests );
 CPPUNIT_TEST_SUITE_REGISTRATION( HexaTests );
 CPPUNIT_TEST_SUITE_REGISTRATION( MultiElement2DTests );
 CPPUNIT_TEST_SUITE_REGISTRATION( MultiElementTetraTests );
-CPPUNIT_TEST_SUITE_REGISTRATION( SingleElementTetraTests );
 CPPUNIT_TEST_SUITE_REGISTRATION( ThreeDSurfProjectionTest );
 #endif
 // --- generic Main program from KERNEL_SRC/src/Basics/Test
diff --git a/src/INTERP_KERNELTest/TransformedTriangleIntersectTest.cxx b/src/INTERP_KERNELTest/TransformedTriangleIntersectTest.cxx
index ca6cbb6b..41c12e1c 100644
--- a/src/INTERP_KERNELTest/TransformedTriangleIntersectTest.cxx
+++ b/src/INTERP_KERNELTest/TransformedTriangleIntersectTest.cxx
@@ -19,6 +19,7 @@
 
 #include "TransformedTriangleIntersectTest.hxx"
 #include <iostream>
+#include <iomanip>
 
 #include "Log.hxx"
 
@@ -1194,7 +1195,7 @@ namespace INTERP_TEST
     CPPUNIT_ASSERT_EQUAL(false, tri->testSurfaceEdgeIntersection(TT::XY));
 
     // surface-ray (3 possibilities)
-    CPPUNIT_ASSERT_EQUAL(true , tri->testSurfaceRayIntersection(TT::X));
+    CPPUNIT_ASSERT_EQUAL(true, tri->testSurfaceRayIntersection(TT::X));
     CPPUNIT_ASSERT_EQUAL(false, tri->testSurfaceRayIntersection(TT::Y));
     CPPUNIT_ASSERT_EQUAL(false, tri->testSurfaceRayIntersection(TT::Z));
 
@@ -2127,10 +2128,229 @@ namespace INTERP_TEST
     delete tri;
   }
 
+  // Extract from BoxHexa1.med (or was it BoxHexa2.med ?)
+  void TransformedTriangleIntersectTest::testTriangle_vol1()
+  {
+    LOG(1, "+++++++ Testing testTriangle_vol1" );
 
-} // NAMESPACE 
+    double coords[9] = {
+      -0.8088235294117645, 0, 0.55882352941176472,
+        0.44117647058823506, 0, 0.55882352941176483,
+        -0.89215686274509864, 1.3333333333333339, 0.55882352941176483};
+
+    double refVol = 0.054383777732546296;
+
+    TransformedTriangle tri(&coords[0], &coords[3], &coords[6]);
+    const double vol = tri.calculateIntersectionVolume();
+
+    LOG(3, "  --- Final points in polygon A");
+    for(const auto& pt:  tri._polygonA)
+      LOG(3,vToStr(pt));
+    LOG(3, "  --- Final points in polygon B");
+    for(const auto& pt:  tri._polygonB)
+      LOG(3,vToStr(pt));
+
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(vol, refVol, 1.0e-10);
+  }
+
+  // Extract from BoxHexa1.med (or was it BoxHexa2.med ?)
+  void TransformedTriangleIntersectTest::testTriangle_vol2()
+  {
+    LOG(1, "+++++++ Testing testTriangle_vol2" );
+
+    double coords[9] = {
+      0.44117647058823506, 0, 0.55882352941176483,
+      -0.55882352941176472, 0, 1.5588235294117649,
+      -0.89215686274509864, 1.3333333333333339, 0.55882352941176483 };
+
+    double refVol = -0.06869529818848;
+
+    TransformedTriangle tri(&coords[0], &coords[3], &coords[6]);
+    const double vol = tri.calculateIntersectionVolume();
+
+    LOG(3, "  --- Final points in polygon A");
+    for(const auto& pt:  tri._polygonA)
+      LOG(3,vToStr(pt));
+    LOG(3, "  --- Final points in polygon B");
+    for(const auto& pt:  tri._polygonB)
+      LOG(3,vToStr(pt));
+
+    CPPUNIT_ASSERT(tri.isTriangleInPlaneOfFacet(TransformedTriangle::XYZ));
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(vol, refVol, 1.0e-10);
+  }
+
+  // Extract from BoxModSmall1.med
+  void TransformedTriangleIntersectTest::testTriangle_vol3()
+  {
+    LOG(1, "+++++++ Testing testTriangle_vol3" );
+
+    double coords[9] = {
+      0, -4.4408920985006262e-16, 1,
+      -1.2062474433365091, -0.037350951323461778, 2.1879983126221099,
+      0.49877186496532655, 0.59827776894780405, 0.79353793765518521
+    };
+    double refVol = -0.051135429735185;
+
+    TransformedTriangle tri(&coords[0], &coords[3], &coords[6]);
+    const double vol = tri.calculateIntersectionVolume();
+
+    LOG(3, "  --- Final points in polygon A");
+    for(const auto& pt:  tri._polygonA)
+      LOG(3,vToStr(pt));
+    LOG(3, "  --- Final points in polygon B");
+    for(const auto& pt:  tri._polygonB)
+      LOG(3,vToStr(pt));
+
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(vol, refVol, 1.0e-10);
+  }
+
+  // Taken from Box1Moderate.med
+  void TransformedTriangleIntersectTest::testTriangle_vol4()
+  {
+    LOG(1, "+++++++ Testing testTriangle_vol4" );
+
+    double coords[9] = {
+      1, 3.552713678800501e-15, 0,
+      2.022774182629973, -1.020222639063029, -0.01375178680446254,
+      0.7495960843059706, 0.1125313911637846, 0.7430770879625861
+    };
+    double refVol = -0.00060846166394417;
+
+    TransformedTriangle tri(&coords[0], &coords[3], &coords[6]);
+    const double vol = tri.calculateIntersectionVolume();
+
+    LOG(3, "  --- Final points in polygon A");
+    for(const auto& pt:  tri._polygonA)
+      LOG(3,vToStr(pt));
+    LOG(3, "  --- Final points in polygon B");
+    for(const auto& pt:  tri._polygonB)
+      LOG(3,vToStr(pt));
 
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(vol, refVol, 1.0e-10);
+  }
+
+  // Taken from Box1Moderate.med too
+  void TransformedTriangleIntersectTest::testTriangle_vol5()
+  {
+    LOG(1, "+++++++ Testing testTriangle_vol5" );
+
+    double coords[9] = {
+      1, 3.552713678800501e-15, 0,
+      -3.552713678800501e-15, 0, 0.9999999999999982,
+      0, 1.000000000000004, -8.881784197001252e-16
+    };
+    double refVol = -1/6.;
+
+    TransformedTriangle tri(&coords[0], &coords[3], &coords[6]);
+    const double vol = tri.calculateIntersectionVolume();
 
+    LOG(3, "  --- Final points in polygon A");
+    for(const auto& pt:  tri._polygonA)
+      LOG(3,vToStr(pt));
+    LOG(3, "  --- Final points in polygon B");
+    for(const auto& pt:  tri._polygonB)
+      LOG(3,vToStr(pt));
+
+    CPPUNIT_ASSERT(tri.isTriangleInPlaneOfFacet(TransformedTriangle::XYZ));
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(vol, refVol, 1.0e-10);
+  }
+
+  // Taken from Box1Moderate.med again
+  void TransformedTriangleIntersectTest::testTriangle_vol6()
+  {
+    LOG(1, "+++++++ Testing testTriangle_vol6" );
+
+    double coords[9] = {
+      1.000000000000004, 0, 0,
+      0, 0, 0.9999999999999929,
+      3.552713678800501e-15, 1, 0};
+    double refVol = -1/6.;
+
+    TransformedTriangle tri(&coords[0], &coords[3], &coords[6]);
+    const double vol = tri.calculateIntersectionVolume();
+
+    LOG(3, "  --- Final points in polygon A");
+    for(const auto& pt:  tri._polygonA)
+      LOG(3,vToStr(pt));
+    LOG(3, "  --- Final points in polygon B");
+    for(const auto& pt:  tri._polygonB)
+      LOG(3,vToStr(pt));
+
+    CPPUNIT_ASSERT(tri.isTriangleInPlaneOfFacet(TransformedTriangle::XYZ));
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(vol, refVol, 1.0e-10);
+  }
+
+  // Taken from  MEDCouplingRemapperTest.py::testCellToNodeReverse3D()
+  void TransformedTriangleIntersectTest::testTriangle_vol7()
+  {
+    LOG(1, "+++++++ Testing testTriangle_vol7" );
+
+    double coords[9] = {
+      0.9999999999999999, 3.700743415417188e-17, 3.700743415417188e-17,
+      -5.551115123125783e-17, 0, 1,
+      3.700743415417188e-17, 0.9999999999999999, 3.700743415417188e-17
+    };
+
+    double refVol = -1/6.;
+
+    TransformedTriangle tri(&coords[0], &coords[3], &coords[6]);
+    const double vol = tri.calculateIntersectionVolume();
+
+    LOG(3, "  --- Final points in polygon A");
+    for(const auto& pt:  tri._polygonA)
+      LOG(3,vToStr(pt));
+    LOG(3, "  --- Final points in polygon B");
+    for(const auto& pt:  tri._polygonB)
+      LOG(3,vToStr(pt));
+
+    CPPUNIT_ASSERT(tri.isTriangleInPlaneOfFacet(TransformedTriangle::XYZ));
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(vol, refVol, 1.0e-10);
+
+    // Polygon A should not contain anything else than tetra corners:
+    double barycenter[3];
+    tri.calculatePolygonBarycenter(TransformedTriangle::A, barycenter);
+    tri.sortIntersectionPolygon(TransformedTriangle::A, barycenter);
+    const double eps = TransformedTriangle::THRESHOLD_F *  TransformedTriangle::MULT_PREC_F;
+    for (auto& p: tri._polygonA)
+      for (int d=0; d<3; d++)
+        {
+          CPPUNIT_ASSERT(fabs(p[d]) < eps || fabs(p[d]-1) < eps);
+        }
+  }
+
+  // This test is useful if TransformedTriangle::THRESHOLD_F = 20 (like in Grandy's article)
+  // With this value, it is an almost degenerate case : the triangle is very close to XYZ plane, but this still
+  // falls in the 'non-degenerate' category. Total volume is 1/6 but coming from
+  // contributions from A and B.
+  // With current value of threshold (=100, chosen because of P1P1 intersector), triangle becomes completely degenerated.
+  void TransformedTriangleIntersectTest::testTriangle_vol8()
+  {
+    LOG(1, "+++++++ Testing testTriangle_vol8" );
+
+    double coords[9] = {
+      0.9999999999999787, 7.105427357601002e-15, -3.552713678800501e-15,
+      -1.4210854715202e-14, 0, 0.9999999999999964,
+      -7.105427357601002e-15, 1.000000000000014, -3.552713678800501e-15
+    };
+
+    double refVol = -1/6.;
+
+    TransformedTriangle tri(&coords[0], &coords[3], &coords[6]);
+    const double vol = tri.calculateIntersectionVolume();
+
+    LOG(3, "  --- Final points in polygon A");
+    for(const auto& pt:  tri._polygonA)
+      LOG(3,vToStr(pt));
+    LOG(3, "  --- Final points in polygon B");
+    for(const auto& pt:  tri._polygonB)
+      LOG(3,vToStr(pt));
+
+//    CPPUNIT_ASSERT (! tri.isTriangleInPlaneOfFacet(TransformedTriangle::XYZ) ); // not degenerate if threshold == 20.0
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(vol, refVol, 1.0e-10);
+  }
+
+
+} // NAMESPACE 
 
 
 
diff --git a/src/INTERP_KERNELTest/TransformedTriangleIntersectTest.hxx b/src/INTERP_KERNELTest/TransformedTriangleIntersectTest.hxx
index 1fa23e6f..8d7ef5e6 100644
--- a/src/INTERP_KERNELTest/TransformedTriangleIntersectTest.hxx
+++ b/src/INTERP_KERNELTest/TransformedTriangleIntersectTest.hxx
@@ -47,6 +47,17 @@ namespace INTERP_TEST
     CPPUNIT_TEST( testTriangle12 );
     CPPUNIT_TEST( testTriangle13 );
 
+
+    // Tests for degenerated cases where PQR is almost in XYZ plane:
+    CPPUNIT_TEST( testTriangle_vol1 );
+    CPPUNIT_TEST( testTriangle_vol2 );
+    CPPUNIT_TEST( testTriangle_vol3 );
+    CPPUNIT_TEST( testTriangle_vol4 );
+    CPPUNIT_TEST( testTriangle_vol5 );
+    CPPUNIT_TEST( testTriangle_vol6 );
+    CPPUNIT_TEST( testTriangle_vol7 );
+    CPPUNIT_TEST( testTriangle_vol8 );
+
     CPPUNIT_TEST_SUITE_END();
 
     typedef INTERP_KERNEL::TransformedTriangle::TriSegment TriSegment;
@@ -55,40 +66,30 @@ namespace INTERP_TEST
   public:
 
     void testTriangle1();
-  
     void testTriangle2();
-
     void testTriangle3();
-
     void testTriangle4();
-
     void testTriangle5();
-
     void testTriangle6();
-
     void testTriangle7();
-
     void testTriangle8();
-
     void testTriangle9();
-  
     void testTriangle10();
-  
     void testTriangle11();
-  
     void testTriangle12();
-
     void testTriangle13();
 
-  private:
- 
+    void testTriangle_vol1();
+    void testTriangle_vol2();
+    void testTriangle_vol3();
+    void testTriangle_vol4();
+    void testTriangle_vol5();
+    void testTriangle_vol6();
+    void testTriangle_vol7();
+    void testTriangle_vol8();
+
   };
 
 }
 
-
-
-
-
-
 #endif
diff --git a/src/INTERP_KERNELTest/TransformedTriangleTest.cxx b/src/INTERP_KERNELTest/TransformedTriangleTest.cxx
index bfe66cb2..856e0608 100644
--- a/src/INTERP_KERNELTest/TransformedTriangleTest.cxx
+++ b/src/INTERP_KERNELTest/TransformedTriangleTest.cxx
@@ -148,15 +148,15 @@ namespace INTERP_TEST
 
     double c_vals[3 * 8];
     for(TriSegment seg = TransformedTriangle::PQ ; seg <= TransformedTriangle::RP ; seg = TriSegment(seg + 1)) {
-      
-      c_vals[seg*8 + 0] = tri1->calcUnstableC(seg, TransformedTriangle::C_XY);
-      c_vals[seg*8 + 1] = tri1->calcUnstableC(seg, TransformedTriangle::C_YZ);
-      c_vals[seg*8 + 2] = tri1->calcUnstableC(seg, TransformedTriangle::C_ZX);
-      c_vals[seg*8 + 3] = tri1->calcUnstableC(seg, TransformedTriangle::C_XH);
-      c_vals[seg*8 + 4] = tri1->calcUnstableC(seg, TransformedTriangle::C_YH);
-      c_vals[seg*8 + 5] = tri1->calcUnstableC(seg, TransformedTriangle::C_ZH);
-      c_vals[seg*8 + 6] = tri1->calcUnstableC(seg, TransformedTriangle::C_01);
-      c_vals[seg*8 + 7] = tri1->calcUnstableC(seg, TransformedTriangle::C_10);
+      double dnu;
+      c_vals[seg*8 + 0] = tri1->calcUnstableC(seg, TransformedTriangle::C_XY, dnu);
+      c_vals[seg*8 + 1] = tri1->calcUnstableC(seg, TransformedTriangle::C_YZ, dnu);
+      c_vals[seg*8 + 2] = tri1->calcUnstableC(seg, TransformedTriangle::C_ZX, dnu);
+      c_vals[seg*8 + 3] = tri1->calcUnstableC(seg, TransformedTriangle::C_XH, dnu);
+      c_vals[seg*8 + 4] = tri1->calcUnstableC(seg, TransformedTriangle::C_YH, dnu);
+      c_vals[seg*8 + 5] = tri1->calcUnstableC(seg, TransformedTriangle::C_ZH, dnu);
+      c_vals[seg*8 + 6] = tri1->calcUnstableC(seg, TransformedTriangle::C_01, dnu);
+      c_vals[seg*8 + 7] = tri1->calcUnstableC(seg, TransformedTriangle::C_10, dnu);
 
     }
     
@@ -253,12 +253,13 @@ namespace INTERP_TEST
     // find unstable products to check for consistency (Grandy [46])  
     for(TriSegment seg = TransformedTriangle::PQ ; seg <= TransformedTriangle::RP ; seg = TriSegment(seg + 1)) 
       {
-        const double c_xy = tri2->calcUnstableC(seg, TransformedTriangle::C_XY);
-        const double c_yz = tri2->calcUnstableC(seg, TransformedTriangle::C_YZ);
-        const double c_zx = tri2->calcUnstableC(seg, TransformedTriangle::C_ZX);
-        const double c_xh = tri2->calcUnstableC(seg, TransformedTriangle::C_XH);
-        const double c_yh = tri2->calcUnstableC(seg, TransformedTriangle::C_YH);
-        const double c_zh = tri2->calcUnstableC(seg, TransformedTriangle::C_ZH);
+        double dnu;
+        const double c_xy = tri2->calcUnstableC(seg, TransformedTriangle::C_XY, dnu);
+        const double c_yz = tri2->calcUnstableC(seg, TransformedTriangle::C_YZ, dnu);
+        const double c_zx = tri2->calcUnstableC(seg, TransformedTriangle::C_ZX, dnu);
+        const double c_xh = tri2->calcUnstableC(seg, TransformedTriangle::C_XH, dnu);
+        const double c_yh = tri2->calcUnstableC(seg, TransformedTriangle::C_YH, dnu);
+        const double c_zh = tri2->calcUnstableC(seg, TransformedTriangle::C_ZH, dnu);
       
         const int num_zero = (c_yz*c_xh == 0.0 ? 1 : 0) + (c_zx*c_yh == 0.0 ? 1 : 0) + (c_xy*c_zh == 0.0 ? 1 : 0);
         const int num_neg = (c_yz*c_xh < 0.0 ? 1 : 0) + (c_zx*c_yh < 0.0 ? 1 : 0) + (c_xy*c_zh < 0.0 ? 1 : 0);
diff --git a/src/INTERP_KERNELTest/UnitTetraIntersectionBaryTest.cxx b/src/INTERP_KERNELTest/UnitTetraIntersectionBaryTest.cxx
index 4ae487e8..991b93c7 100644
--- a/src/INTERP_KERNELTest/UnitTetraIntersectionBaryTest.cxx
+++ b/src/INTERP_KERNELTest/UnitTetraIntersectionBaryTest.cxx
@@ -300,6 +300,41 @@ namespace INTERP_TEST
     CPPUNIT_ASSERT_DOUBLES_EQUAL(6944.4444444444443,volume,1e-9);
   }
 
+  /**
+   * Extract from a single tetra from BoxHexa1.med and BoxHexa2.med.
+   * Symetry test was failing.
+   */
+  void UnitTetraIntersectionBaryTest::test_UnitTetraIntersectionBary_14()
+  {
+    double S[] = {
+      25.0, 96.0, 0.0,
+      25.0, 120.0, 0.0,
+      37.5, 120.0, 0.0,
+      25.0, 120.0, 11.333333333333339255};
+
+    double T[] = {
+      25.0, 90.0, 6.333333333333339255,
+      25.0, 120.0, 6.3333333333333357018,
+      41.6666666666666714036, 120.0, 6.3333333333333348136,
+      25.0, 120.0, 17.6666666666666714036};
+
+    mcIdType conn[4] = { 0,1,2,3 };
+    const double* tnodes[4]={ T, T+3, T+6, T+9 };
+    const double* snodes[4]={ S, S+3, S+6, S+9 };
+    const double refVol = 48.6591695501729;
+
+    __MESH_DUMMY dummyMesh;
+    SplitterTetra<__MESH_DUMMY> src( dummyMesh, snodes, conn );
+    double volume = src.intersectTetra( tnodes );
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(refVol,volume,1e-9);
+
+    // Now the other way round:
+    SplitterTetra<__MESH_DUMMY> tgt( dummyMesh, tnodes, conn );
+    double volume2 = tgt.intersectTetra( snodes );
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(refVol,volume2,1e-9);
+  }
+
+
   void UnitTetraIntersectionBaryTest::test_TetraAffineTransform_reverseApply()
   {
     double nodes[12] = { -4.0, 9.0, 3.0, 
diff --git a/src/INTERP_KERNELTest/UnitTetraIntersectionBaryTest.hxx b/src/INTERP_KERNELTest/UnitTetraIntersectionBaryTest.hxx
index 0f217bed..ab7dcecb 100644
--- a/src/INTERP_KERNELTest/UnitTetraIntersectionBaryTest.hxx
+++ b/src/INTERP_KERNELTest/UnitTetraIntersectionBaryTest.hxx
@@ -37,6 +37,7 @@ namespace INTERP_TEST
   class INTERPKERNELTEST_EXPORT UnitTetraIntersectionBaryTest : public CppUnit::TestFixture
   {
     CPPUNIT_TEST_SUITE( UnitTetraIntersectionBaryTest );
+    CPPUNIT_TEST( test_UnitTetraIntersectionBary_14 );
     CPPUNIT_TEST( test_UnitTetraIntersectionBary_13 );
     CPPUNIT_TEST( test_UnitTetraIntersectionBary_12 );
     CPPUNIT_TEST( test_UnitTetraIntersectionBary_1 );
@@ -69,6 +70,7 @@ namespace INTERP_TEST
     void test_UnitTetraIntersectionBary_11();
     void test_UnitTetraIntersectionBary_12();
     void test_UnitTetraIntersectionBary_13();
+    void test_UnitTetraIntersectionBary_14();
     void test_TetraAffineTransform_reverseApply();
     void test_barycentric_coords();
     void test_cuboid_mapped_coords_3D();
