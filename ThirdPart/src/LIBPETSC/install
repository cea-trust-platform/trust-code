#!/bin/bash
# Script d'installation de PETSC
package=$1

minimal_mumps=0
scotch=1
# [ $TRUST_ARCH = cygwin ] && minimal_mumps=1
[ $minimal_mumps = 1 ] && scotch=0
if [ "$1" = "" ]
then
   echo "Usage: `basename $0` package.tar.gz"
   exit -1
fi

if [ $package = check ]
then
   #############################################################################################
   # Petsc est installe, on verifie maintenant si MPI_Init fonctionne en sequentiel sans mpirun
   # sinon on desactive l'appel a PetscInitialize (qui contient un appel a MPI_Init)
   #############################################################################################
   if [ "$TRUST_DISABLE_MPI" = 0 ]
   then
      if [ ! -f mpi_init.log ] || [ $TRUST_ROOT/env/machine.env -nt mpi_init.log ]
      then
	 echo "Test of MPI_Init in sequential without mpirun..."
	 echo "#include <mpi.h>
	 #include <iostream>
	 using std::cout;
	 using std::endl;   
	 int main(int argc, char** argv)
	 {
	    MPI_Init(&argc,&argv);
	    cout<<\"OK\"<<endl; 
	    return 0;
	 }" > $TRUST_TMP/mpi_init.cpp
	 $TRUST_CC -o $TRUST_TMP/mpi_init $TRUST_TMP/mpi_init.cpp
	 rm -f mpi_init.log
	 $TRUST_TMP/mpi_init 1>mpi_init.log 2>&1 &
	 # Pour eviter les blocages, on attends quelques secondes
	 $TRUST_ROOT/bin/KSH/wait_for $! 5
      fi
      if [ "`grep OK mpi_init.log`" = "" ]
      then
	 string="define MPI_INIT_NEEDS_MPIRUN"
      else
	 string="undef MPI_INIT_NEEDS_MPIRUN"
      fi
   else
      string="undef MPI_INIT_NEEDS_MPIRUN"
   fi
   ################################################################
   # Creation des liens pour avoir toutes les options OPT possibles
   ################################################################
   for make in `cd $TRUST_ENV;\ls make.$TRUST_ARCH_CC*`
   do
      TRUST_ARCH_OPT=$TRUST_ARCH${make#make.$TRUST_ARCH_CC}
      if [ ! -d $PETSC_ROOT/$TRUST_ARCH_OPT/lib ]
      then
         # Si $TRUST_ARCH_OPT pas installe par PETSc alors
	 # il faut creer un lien vers un repertoire existant
	 if [ "`echo $TRUST_ARCH_OPT | grep _opt`" != "" ]
	 then
	    # On pointe vers PETSc optimise
	    PETSC_ARCH_OPT=$TRUST_ARCH"_opt"
	 else
	    # On pointe vers PETSc debug si existante
	    PETSC_ARCH_OPT=$TRUST_ARCH && [ ! -d $PETSC_ROOT/$PETSC_ARCH_OPT/lib ] && PETSC_ARCH_OPT=$TRUST_ARCH"_opt"
	 fi
	 # On cree le lien
	 cd $PETSC_ROOT 1>/dev/null 2>&1
	 rm -r -f $TRUST_ARCH_OPT
	 ln -s -f $PETSC_ARCH_OPT $TRUST_ARCH_OPT
	 echo "Link $TRUST_ARCH_OPT created to $PETSC_ARCH_OPT"
	 cd - 1>/dev/null 2>&1
      fi
   done
   #################################################################
   # Creation de l'include pour le Kernel TRUST: petsc_for_kernel.h
   #################################################################
   for REP in `\ls $PETSC_ROOT 2>/dev/null`
   do
      petsc_for_kernel=$PETSC_ROOT/$REP/include/petsc_for_kernel.h
      if [ "`grep "$string" $petsc_for_kernel 2>/dev/null`" = "" ]
      then
         echo "$petsc_for_kernel file changed..."
         echo "#include <petscksp.h>
#$string" > $petsc_for_kernel
      fi
   done  
   exit 0
fi

# recuperation des archives

for file in `ls $TRUST_ROOT/externalpackages/petsc/*`
do
ln -sf $file .
done
ln -sf scotch_6.0.3.tar.gz ptscotch.tar.gz


##############
# PETSC-MASTER
##############
if [ $HOST = $TRUST_HOST_ADMIN ] && [ "`crontab -l 2>/dev/null | grep $TRUST_ROOT`" != "" ]
then
   ADMIN=1
else
   ADMIN=0
fi

# Update petsc-master
PETSC_MASTER=petsc-master.tar.gz
touch $PETSC_MASTER
HTTP_PETSC_MASTER=http://ftp.mcs.anl.gov/pub/petsc/$PETSC_MASTER
if [ "$PETSC_HAVE_CUDA" = 1 ] || [ "$PETSC_HAVE_OPENMP" = 1 ] || [ "$ADMIN" = 1 ]
then
   # Download last petsc-master package
   wget_ -O $PETSC_MASTER.tmp $HTTP_PETSC_MASTER
   if [ $? = 0 ] && [ "`diff $PETSC_MASTER.tmp $PETSC_MASTER`" != "" ]
   then
      mv -f $PETSC_MASTER.tmp $PETSC_MASTER
   else
      rm -f $PETSC_MASTER.tmp
   fi
fi

if [ "$PETSC_HAVE_CUDA" = 1 ] || [ "$PETSC_HAVE_OPENMP" = 1 ]
then
   # PETSc strongly recommend petsc-master to try CUDA support or Thread support
   package=$PETSC_MASTER
fi

####################
# Download if needed
####################
[ ! -f $package ] && wget_ http://ftp.mcs.anl.gov/pub/petsc/release-snapshots/$package 
[ ! -f $package ] && echo "Package $package not found." && exit -1

#############
# Deballage #
#############
rm -r -f ${package%.tar.gz}
gunzip -f -c $package | tar -xf -
package=${package%.tar.gz}
[ ! -d $package ] && echo "Error, directory $package not found!" && exit -1
ROOT=`dirname $PETSC_ROOT`
ROOT=`pwd`

###################################
# Correction eventuelle des sources
###################################
cd $ROOT/$package
CONFIG=config/PETSc/packages
if [ -d $CONFIG ]
then
   #echo "Change some python scripts to force parallel build of external packages..."
   echo $ECHO_OPTS "1,$ s?make install?$TRUST_MAKE install?g\nw" | ed $CONFIG/hypre.py 	1>/dev/null 2>&1  #  on ne sarrete plus car si pas hypre...|| exit -1 
else
   # Config directory has moved (for PETSc 3.6?)
   CONFIG=config/BuildSystem/config/packages
fi 

# Hack to have MUMPS sequential:
if [ "$TRUST_DISABLE_MPI" = 1 ]
then
   # Need to be improved for the future changes:
   cat ../MUMPS_SEQ.py > $CONFIG/MUMPS.py
fi    
    
################
# GPU support? #
################
if [ $PETSC_HAVE_CUDA = 1 ]
then
   REVISION_NUMBER=`$TRUST_Awk '/Revision number:/ {gsub("\\\.","",$NF);print $NF}' $TRUST_ENV/card.log | head -1`
   echo "****************************************"
   echo "PETSC_HAVE_CUDA=$PETSC_HAVE_CUDA"
   echo "REVISION_NUMBER=$REVISION_NUMBER"
   [ "$REVISION_NUMBER" = "" ] && exit -1
   ###################################################
   # Installation de CUPS (algebre lineaire pour CUDA)
   # CUSP has been renamed CUSPLIBRARY
   # https://github.com/cusplibrary/cusplibrary
   ###################################################
   CUSP=cusplibrary-0.4.0
   rm -r -f $ROOT/$CUSP
   #unzip pas toujours installe sur les PCs
   #On transforme le .zip en .tgz
   (cd $ROOT;gunzip -f -c $CUSP.tgz | tar -xf -)
   echo "CUSP is installed."
   # Add ViennaCL promising: See http://viennacl.sourceforge.net/viennacl-about.html (needs OpenCL)
   # --download-viennacl=../ViennaCL-1.5.1.tar.gz --with-opencl-dir=$OPENCL_INTEL_ROOT
   with_gpu="--with-cuda=1 --with-cuda-dir=$CUDA_ROOT 
--with-cusp=1 --with-cusp-dir=$ROOT/$CUSP
--with-thrust=1 --with-cuda-arch=sm_$REVISION_NUMBER
--with-ssl=0
" # SSL nouveau par defaut
   echo "CUDA support for PETSc with: "$with_gpu
   echo "****************************************"
else
   echo "****************************************"
   echo "CUDA support is not activated for PETSc "
   echo "****************************************"
fi

####################
# Thread support ? #
####################
if [ "$PETSC_HAVE_OPENMP" = 1 ]
then
   #USE_OPENMP=1
   #if [ $USE_OPENMP = 0 ]
   #then
   #   with_thread="--with-threadcomm --with-pthreadclasses"
   #else
   #   with_thread="--with-threadcomm --with-openmp" 
   #fi
   # On airain, --with-threadcomm --with-openmp is not enough... Strange. So:
   with_thread="--with-threadcomm --with-pthreadclasses --with-openmp" 
   echo "****************************************"
   echo "Thread support for PETSc with: "$with_thread
   echo "****************************************"
fi

########################################################
# 2 versions construites, une debug et une optimisee
# sur les login TMA triou
########################################################
#if [ "`whoami`" = triou ]
if [ $HOST = $TRUST_HOST_ADMIN ]
then
   liste_debug="0 1"	# Version optimisee et debug consruite si machine TMA ou support CUDA
   # Possibilite d'afficher la matrice sous forme graphique uniquement si:
   # a) libX11 is available
   # b) We are not building the official binary (less machine sensitive)
   if [ "`ls /usr/lib*/libX11.so 2>/dev/null`" != "" ] && [ "`liste_machines "\get_binary" | grep ^$HOST"\."`" = "" ]
   then
      options="--with-x=1"
   else
      options="--with-x=0"
   fi
else
   liste_debug="0" 	# Une seule version construite (optimisee)
   options="--with-x=0" # Car --with-x=1 pose probleme pour Insure 
fi

######################################
# Ajout d'un package au build de PETSc 
######################################
add_package()
{
   echo $ECHO_OPTS "Looking for package $1... \c"   
   external_package=`cd ..;ls -rt $1*.tar.gz $1*.tgz $1*.tar.bz2 2>/dev/null | tail -1`
   #external_package=`grep petsc $TRUST_ROOT/bin/gestion_externalpackages/liste_dep.csv  | awk -F, '{print "/"$2}' | grep "/"$1`
   name=`echo $1 | awk '{print tolower($1)}'`
   if [ "$external_package" = "" ]
   then
      # Download     
      with_package="--download-$name=yes"
   else
      # Located
      with_package="--download-$name=../$external_package"
   fi
   echo "PETSc needs to build it with $with_package"
   with_packages=$with_packages" "$with_package
}

###########################################################################
# Construction de la liste des packages a utiliser pour le build de petsc #
###########################################################################
with_packages=""

#################################################
# Choix de Scalapack & Blacs (natives ou de base)
#################################################   
if [ "$TRUST_DISABLE_MPI" = 0 ]
then
   # Probleme lors du link, donc on n'utilise pas
   if [ "$TRUST_BLAS_LAPACK" != "" ] && [ -d $TRUST_BLAS_LAPACK ]
   then
      ############################
      # Choix de Scalapack natif #
      ############################     
      libscalapack=`ls $TRUST_BLAS_LAPACK/lib*scalapack_lp64.a 2>/dev/null`
      libscalapack=""
      # On desactive car SCALAPACK natif sur CCRT/SuperMUC bloque MUMPS parfois avec Petsc 3.2 (ex PAR_Cx sur 5 ou 6 processeurs) !
      # Avec Petsc 3.3 cela a l'air bon ? Oui mais les orderings parallele crashe signe d'une mauvaise installation de Scalapack d'apres MUMPS
      # A essayer avec Petsc 3.4 ?
      if [ "$libscalapack" != "" ]
      then
	 echo "Native optimized SCALAPACK will be used in $TRUST_BLAS_LAPACK"		
	 with_packages=$with_packages" --with-scalapack-lib=$libscalapack --with-scalapack-include=$TRUST_BLAS_LAPACK/../../include" 
      else
	 add_package scalapack
      fi
      ##########################
      # Choix de BLACS natives #
      ##########################     	 
      # La detection de la librairie MPI BLAS a prendre n'est pas evidente
      # CCRT: openmpi car bullxmpi ou intelmpi si mpich (en fait mvapich)
      # jade: mpt
      # SuperMuc: intel ou ibm	
      if [ "`env | grep -i /mpt`" != "" ]
      then
	 mpi=_sgimpt
      elif [ "`echo $MPI_ROOT | grep mpi/bullxmpi`" != "" ]
      then
	 mpi=_openmpi
      elif [ "`echo $MPI_ROOT | grep intel/mpi`" != "" ] || [ "`echo $MPI_ROOT | grep mpich`" != "" ]
      then
	 mpi=_intelmpi
      elif [ "`echo $MPI_ROOT | grep ibmhpc`" != "" ] 
      then
	 mpi=""
      fi	
      libblacs=`ls $TRUST_BLAS_LAPACK/lib*blacs"$mpi"_lp64.a 2>/dev/null`
      if [ "$libblacs" != "" ]
      then
	 echo "Native optimized BLACS will be used in $TRUST_BLAS_LAPACK"
	 with_packages=$with_packages" --with-blacs-lib=$libblacs
			               --with-blacs-include=$TRUST_BLAS_LAPACK/../../include"
      fi
   else
      if [ -d /ccc ] && [ ${TRUST_CC_BASE%icpc} != $TRUST_CC_BASE ] # CCRT & Intel compiler
      then
	 # Sur les machines du CCRT (detectees par /ccc):
	 echo "What a pity that MKL libraries are not found on $HOST for PETSc build with Intel compilers. Contact TRUST support." && exit -1
      fi
      add_package scalapack
   fi
fi

######################
# Choix de BLAS/LAPACK (native ou de base)
######################
if [ "$TRUST_BLAS_LAPACK" != "" ] && [ -d $TRUST_BLAS_LAPACK ]
then
   with_blas=" --with-blas-lapack-dir=$TRUST_BLAS_LAPACK"
   echo "******************************************************************"
   echo "Native optimized BLAS will be used in $TRUST_BLAS_LAPACK"
   echo "******************************************************************"
else
   # 1.6.4: On n'utilise plus fblaslapack-3.1.1 et l'on prend LIBLAPACK (livre)
   with_blas=" --with-blas-lapack-dir=$TRUST_ROOT/lib/src/LIBLAPACK"
fi  
 
##################
# Solveurs directs
##################
if [ "$TRUST_USE_MUMPS" = 1 ]
then
   # On prend MUMPS (plus performant)
   add_package MUMPS
   add_package metis
fi    

##############
# MPI or not #
##############
if [ "$TRUST_DISABLE_MPI" = 0 ]
then
   with_mpi="--with-mpi-dir=$MPI_ROOT"
else
   with_mpi="--with-mpi=0 -with-mumps-serial --with-mpiuni-fortran-binding=0"
fi

# Add other package if MPI is used:
if [ "$TRUST_DISABLE_MPI" = 0 ]
then
   # SUPERLU_DIST
   [ $minimal_mumps = 0 ] &&  add_package superlu_dist

   # New (Cholmod):
   [ $minimal_mumps = 0 ] && add_package SuiteSparse

   # New (Pastix) pb sous cygwin
   [  $TRUST_ARCH != cygwin ] &&  [ $minimal_mumps = 0 ] && [ $scotch -eq 1 ] &&add_package pastix

   # New (Pardiso)
   [ -f $MKLROOT/include/mkl_pardiso.h ] && with_packages=$with_packages" --with-mkl_pardiso=1 --with-mkl_pardiso-dir=$MKLROOT"

   # MUMPS et SUPERLU necessitent desormais parmetis
   add_package parmetis

   ##########
   # SCOTCH #
   ##########
   if [  $scotch -eq 1 ]
   then
      # On ajoute PT-Scotch sur certaines machines (ne compile pas sur castor, compilateur trop vieux?)
      add_package ptscotch
      # PT-Scotch necessite bison
      if [ "`bison --version 1>/dev/null 2>&1;echo $?`" != 0 ]
      then
	 if [ ! -d $ROOT/bison/bin ]
	 then
	    # Si on construit bison, m4>=1.4.6 doit etre bien installe d'apres bison qui signale un bug dans m4 de 1.4.11 a 1.4.15
	    if [ "`m4 --version 2>/dev/null | head -1 | awk '/[mM]4 / {print $NF}' | grep -v 1.4.[0-5]$ | grep -v 1.4.1[1-5]`" = "" ]
	    then
               echo "bison build needs a correct m4 installed. So installing it..."
		  #m4=m4-1.4.17
		  m4=`(cd ..; ls m4-*.tar.gz | sed "s/.tar.gz//")`
               if [ ! -d $ROOT/m4/bin ]
               then
		  gunzip -f -c ../$m4.tar.gz | tar -xf -
		  cd $m4
		  # Seen on herens: CC=g++ so m4 build fails... Cause C compiler is needed for m4
		  unset CC
        	  ./configure --prefix=$ROOT/m4 || exit -1
		  $TRUST_MAKE || exit -1
		  make install || exit -1
		  cd ..	 
		  rm -r -f $m4
              fi
	      export PATH=$PATH:$ROOT/m4/bin
	    fi		 
            echo "PT-Scotch needs bison installed. So installing it..."
	    bison=`(cd ..; ls bison-*.tar.gz | sed "s/.tar.gz//")`
	    gunzip -f -c ../$bison.tar.gz | tar -xf -
	    cd $bison
	    ./configure --prefix=$ROOT/bison || exit -1
	    $TRUST_MAKE || exit -1
	    make install || exit -1
	    cd ..
	    rm -r -f $bison
	 fi
	 export PATH=$PATH:$ROOT/bison/bin
      fi
      # PT-Scotch necessite flex
      if [ "`flex --version 1>/dev/null 2>&1;echo $?`" != 0 ]
      then
	 if [ ! -d $ROOT/flex/bin ]
	 then
            echo "PT-Scotch needs flex installed. So installing it..."
	    flex=`(cd ..; ls flex-*.tar.gz | sed "s/.tar.gz//")`
	    gunzip -f -c ../$flex.tar.gz | tar -xf -
	    cd $flex
	    ./configure --prefix=$ROOT/flex || exit -1
	    $TRUST_MAKE || exit -1
	    make install || exit -1
	    cd ..
	    rm -r -f $flex
	 fi
	 export PATH=$PATH:$ROOT/flex/bin
      fi 
   fi
   #######
   # Hypre
   #######
   [ $minimal_mumps = 0 ]  && add_package hypre
fi

##########
# Valgrind
##########
package_valgrind=$TRUST_ROOT/exec/valgrind
# Provisoire (need to add --with-valgrind-include to avoid error valgrind/valgrind.h not found ?)
#[ -d $package_valgrind ] && with_packages=$with_packages" --with-valgrind-dir=$package_valgrind --with-valgrind-include=$package_valgrind/include"
[ -d $package_valgrind ] && with_packages=$with_packages" --with-valgrind-include=$package_valgrind/include"

########
# PYTHON
########
# Chargement de l'environnement si necessaire
# Car parfois Ex Debian, le python construit ne marche pas: 
# scotch_5.1.12b_esmumps-p1.tar.gz is not a tarball
# [or installed python cannot process compressed files]
if [ "`python --version 2>/dev/null;echo $?`" != 0 ]
then
   if [ -f $TRUST_ROOT/exec/python/env.sh ]
   then
      echo "Initializing Python..."
      source $TRUST_ROOT/exec/python/env.sh
   else
      echo "Error, PETSc needs python!"
      exit -1         
   fi
fi

###############
# Loop on build
###############
for debug in $liste_debug
do
   echo "**********************************"
   echo "Build `v="optimised";[ $debug = 1 ] && v="debug";echo $v` version of PETSc"
   echo "**********************************"
   cd $ROOT/$package
   
   ###############
   # Configuration
   ###############
   export PETSC_ARCH=$TRUST_ARCH`[ $debug = 0 ] && echo "_opt"`
   export PETSC_DIR=`pwd`   
   # On recupere les flags de compilation de TRUST pour etre coherent (oubli de -fPIC dans 1.6.2)
   fic_env=$TRUST_ROOT/env/make.$TRUST_ARCH_CC`[ $debug = 0 ] && echo _opt`
   COPTFLAGS=`$TRUST_Awk '/ccFLAGS =/ {gsub("ccFLAGS =","",$0);print $0}' $fic_env`
   FOPTFLAGS=`$TRUST_Awk '/F77Flags =/ {gsub("F77Flags =","",$0);print $0}' $fic_env`
   CXXOPTFLAGS=$COPTFLAGS
   echo "Configuring PETSc..."
   ./configure --help 1>../configure.help 2>&1
   # Tous les paquets sont recuperes sur ftp://ftp.mcs.anl.gov/pub/petsc/externalpackages
   # en etudiant ce qu'il y'a dans ./$CONFIG
   # On prend with-errorchecking=1 meme en optimise (ne degrade pas les performances)
   # PETSc 3.4: default is now shared library libpetsc.so so we add --with-shared-libraries=0 to keep building static library libpetsc.a:
   ./configure --prefix=$PETSC_ROOT/$PETSC_ARCH \
   --with-single-library --with-shared-libraries=0 \
   --with-debugging=$debug --with-errorchecking=1 \
   --COPTFLAGS="$COPTFLAGS" --CXXOPTFLAGS="$CXXOPTFLAGS" --FOPTFLAGS="$FOPTFLAGS" \
   --with-fortran=yes \
   --with-clean=1 \
   --with-ssl=0 \
   $with_packages \
   $with_blas \
   $with_gpu \
   $with_thread \
   $with_mpi \
   $options || exit -1
   
   #############
   # Compilation
   #############
   # build avec cmake (parallel build) ou classique selon les machines (castor,titane,...)
   # $TRUST_MAKE inutile (et produit des warnings)
   # make all-legacy : force le build classique
   make all 	
   if [ $? = 0 ]
   then
      ###########
      # Cas tests
      ###########
      err=0
      if [ "$PETSC_HAVE_CUDA" != 1 ]
      then
         # Tests with PETSC_HAVE_CUDA=1 are done below
        #  bloque de temps en temps make test
        echo No running make test 
	 err=$?
      fi
      if [ $err = 0 ]
      then	 
	 ##############
	 # Installation
	 ##############
	 # Erreur possible et bizarre (dont on ne tient pas compte) produite lors d'une installation avec sudo (eg: cezanne27)
	 make install   
	 if [ $? = 0 ] || [ "$SUDO_UID" != "" ]
	 then
	    # On fait un touch des fichiers include
	    touch $PETSC_ROOT/$PETSC_ARCH/include/*.h
	    # Copie des fichiers include pour PETSc sequentiel:
	    [ "$TRUST_DISABLE_MPI" = 1 ] && cp $PETSC_ROOT/$PETSC_ARCH/include/mpiuni/*.h $PETSC_ROOT/$PETSC_ARCH/include/
	    # Copie de la doc
	    [ -d docs ] && cp -r docs $PETSC_ROOT/$PETSC_ARCH/.
	    # Copie des exemples
	    [ -d src ] && cp -r src $PETSC_ROOT/$PETSC_ARCH/.
            cd ..
	 else
	    echo "make install failed." && exit -1
	 fi
	 # Correction du fichier metis.h
	 echo $ECHO_OPTS "1,$ s?2048,?2048?g\nw" | ed $PETSC_ROOT/$PETSC_ARCH/include/metis.h 1>/dev/null 2>&1	 
	 if [ $? != 0 ]
	 then
	    echo "Change of the file $PETSC_ROOT/$PETSC_ARCH/include/metis.h failed." && exit -1
	 fi
      else
         echo "make test failed." && exit -1
      fi
   else
      echo "make all failed." && exit -1
   fi
done
cd $ROOT
###########
# Tests GPU
###########
if [ "$PETSC_HAVE_CUDA" = 1 ]
then
   ./test_gpu || exit -1
fi

##############
# Tests Thread
##############
if [ "$PETSC_HAVE_OPENMP" = 1 ]
then
   ./test_openmp || exit -1
fi

# On efface la distribution sur les machines ou Petsc a ete compile uniquement en optimise
cp $package/configure.log .
[ "$liste_debug" = "0" ] && rm -r -f $package
echo "Leaving install PETSc, it seems OK."
exit 0
