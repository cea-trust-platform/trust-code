#!/bin/bash
check_components()
{
   for Composant in $Composants
   do
      if [ ! -d $TRUST_ROOT/../Composants/$Composant ] && [ $* != sourceforge/Kernel ]
      then
         # Create a link for some components
	 cd $TRUST_ROOT/../Composants
	 if [ -d ../TRUST/doc/TRUST/exercices/$Composant ]   # baltik equation_convection_diffusion
	 then
	    ln -sf ../TRUST/doc/TRUST/exercices/$Composant .
	 fi
	 if [ -d ../TRUST/Outils/$Composant/$Composant_src ] # baltik ICoCo
	 then
	    ln -sf ../TRUST/Outils/$Composant/$Composant"_src" $Composant
	 fi
	 if [ -d ../TRUST/bin/baltik/templates/$Composant ] # baltik basic ou Test_Baltik
	 then
	    ln -sf ../TRUST/bin/baltik/templates/$Composant .
	 fi
	 cd - 1>/dev/null 2>&1
      fi
      if [ -d $TRUST_ROOT/../Composants/$Composant ]
      then
         cd $TRUST_ROOT/../Composants/$Composant
         rm -rf build/portability
	 rm -f $Composant*.log
	 Composant_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}".log"
	 Gui_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}"_gui.log"
         echo "  Check `pwd`"
	 echo "    See $Composant_log"
	 (
            echo "TRUST script on $HOST the `date` ..."
            echo " "
            echo "Check $Composant Component for $TRUST_VERSION version"
            echo " "
            echo "******************************************************"
            echo " "
	    [ $TRUST_ROOT = $TRUST_ROOT_MASTER ] && export MAKEATELIER_SEVERITY=1
	    COMPOSANT_OK=0
	    # First pass, reconfigure to clean properly (in the case where the TRUST_ROOT has changed):
	    [ "$Composant" != ICoCo ] && source env_$Composant.sh && make dist_clean
	    [ "$Composant" == ICoCo ] && source env_MED$Composant.sh && make dist_clean
	    make_option="make check_all_optim"
	    if [ "$Composant" = basic ] 
	    then
	       make_option="make check_trust_optim"
	    elif [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
	    then
	       if [ "$Composant" != TrioCFD ] && [ "$Composant" != ModeleCoeur ] && [ "$Composant" != Test_Baltik ]
	       then
	          make_option="make check_all_optim check_all_debug"
	       fi
	    fi
	    [ "$Composant" = Test_Baltik ] && ./Configure_Tests
	    $TRUST_ROOT/bin/baltik/bin/baltik_build_configure -execute &&
	    make optim module_optim debug module_debug &&
	    $make_option && echo "$Composant OK" && COMPOSANT_OK=1
	    if [[ "$ComposantsGit" = *"$Composant"* ]] && [ $* != sourceforge/Kernel ] # Test si Composant est dans la liste des composants GIT
	    then
	       if [ "`date '+%u'`" -ge 5 ] && [ `date '+%H'` -gt 18 ]
	       then
	          make check_gui 1>$Gui_log 2>&1 &
	       else
	          make gui 1>$Gui_log 2>&1
	       fi
	    fi
            echo " "
            echo "******************************************************"
            echo " "
	    echo $ECHO_OPTS "Component $Composant checked on $HOST with $TRUST_VERSION ...\c"
	    if [ "$COMPOSANT_OK" = 0 ]
	    then
	       echo $ECHO_OPTS "KO."
	       cat $Composant_log | mail_ -s\"[lance_test_nuit] check_components $Composant $TRUST_VERSION KO\" $TRUST_MAIL
	    else
	       echo $ECHO_OPTS "OK"
	    fi	    
	    echo " "
            echo "TRUST script on $HOST the `date` ..."
            echo " "
	    rm -f Run.liste
	    rm -f nuit_$Composant.html
	    rm -f $Composant_%_*.log
	    # On teste la portabilite uniquement si tout a fonctionne en local (pour eviter de bloquer d'autres PCs)
	    #if [ "$COMPOSANT_OK" = 1 ] && [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
	    if [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
	    then
               echo "Portability $Composant Component for $TRUST_VERSION version"
               echo " "
               echo "******************************************************"
               echo " "
	       echo "  See `pwd`/Run.liste"
	       # Machines en mode debug
	       debug_machines=`liste_machines "\-g " | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Machines en mode valgrind
	       valgrind_machines=`liste_machines "\-valgrind" | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Clusters
	       updated_machines=`liste_machines limited | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Machines cible pour la sortie de version
	       cible_machines=`liste_machines cible | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       cible_machines=$cible_machines" "`liste_machines get_binary | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Toutes les machines
	       all_machines=`liste_machines`
	       # Machines sur lesquelles on ne garde pas la compilation des baltiks
	       non_machines=`liste_machines non | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Liste des machines a tester selon le baltik en question
	       if [ "$Composant" = ICoCo ]
	       then
	          # Machines en mode sequentiel
	          wompi_machines=`liste_machines "\-disable-mpi"`
	          wompi_machines=$wompi_machines" `liste_machines "\-disable-optionals"`"
	          wompi_machines=$wompi_machines" `liste_machines "\-disable "`"
	          wompi_machines=$wompi_machines" `liste_machines "\-disable-medcoupling"`"
	          # Machines en mode parallele
		  machines=""
		  for machine in $all_machines
		  do
		     [[ "$wompi_machines" != *"$machine"* ]] && machines=$machines" $machine"
		  done
	       elif [ "$Composant" = TrioCFD ]
	       then
	          machines=`liste_machines "\-TrioCFD"`
	       elif [ "$Composant" = ModeleCoeur ]
	       then
	          machines=`liste_machines "\-ModeleCoeur"`
	       elif [ "$Composant" = MPCube ]
	       then
	          machines=`liste_machines "\-MPCube"`
	       elif [ "$Composant" = basic ] || [ "$Composant" = Test_Baltik ]
	       then
	          machines=`liste_machines "\-TRUST"`
	       else
	          machines=$all_machines
	       fi
	       for adr in $machines
	       do
	          machine=`echo $adr | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`
	          liste_options="--with-efface-dir-before"
	          #if [[ "$liste_machines_KO" != *"$machine"* ]] # Test si machine n est pas dans la liste des machines KO
		  #then
	             if [[ "$valgrind_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines valgrind
		     then
		        valgrind_option="--with-valgrind"
			# Pour ModeleCoeur, test en valgrind seulement le vendredi car ne passe pas en une nuit
			if [ "$Composant" = ModeleCoeur ]
			then
			   if [ "`date '+%u'`" -ge 5 ] && [ `date '+%H'` -gt 18 ]
			   then
		              valgrind_option="--with-valgrind"
			   else
		              valgrind_option=""
			   fi
			fi
		     else
		        valgrind_option=""
		     fi
	             if [[ "$debug_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines debug
		     then
		        mode_option="--with-mode=debug"
			# Pour TrioCFD, test en debug seulement le vendredi car ne passe pas en une nuit
			if [ "$Composant" = TrioCFD ]
			then
			   if [ "`date '+%u'`" -ge 5 ] && [ `date '+%H'` -gt 18 ]
			   then
		              mode_option="--with-mode=debug"
			   else
		              mode_option="--with-mode=optim"
			   fi
			fi
		     else
		        mode_option="--with-mode=optim"
		     fi
	             check_option="--check-all"
	             if [[ "$updated_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines updated
		     then
	                if [ "$Composant" = TrioCFD ] || [ "$Composant" = Test_Baltik ] || [ "$Composant" = ModeleCoeur ]
			then
			   if [ "`date '+%u'`" -ge 5 ] && [ `date '+%H'` -gt 18 ]
			   then
		              check_option="--check-all"
			   else
		              check_option="--without-run"
			   fi
	                   liste_options="--with-efface-dir-before"
			fi
	             fi
	             if [[ "$non_machines" = *"$machine"* ]] # Test si machine n est pas dans la liste des machines cible, get_binary et tache
		     then
		        liste_options=$liste_options" --clean-after-if-ok"
	             fi
	             if [[ "$cible_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines cible
		     then
		        liste_options=$liste_options" --cible"
	             fi
                     log=`awk -v adr=$adr '($2==adr) {print $4}' ~/.netrc | head -1`
		     WORKTMP=`ssh_ -o BatchMode=yes $log@$adr -n 'if [ "\$WORKDIR" = "" ]; then echo \$HOME;else echo \$WORKDIR;fi'`
                     echo "$Composant.tar $WORKTMP/$WORKBASE$machine/Composants/$Composant $log@$adr --with-TRUST=$WORKTMP/$WORKBASE$machine/TRUST $liste_options $mode_option $check_option $valgrind_option" >> Run.liste
		  #fi
	       done
               echo " "
	       cat Run.liste
	       echo " "
	       echo "Call to $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_portability Run.liste"
	       echo " "
	       $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_portability Run.liste & # Take care if run not with &, the second argument should be different for each project
	    fi
	 ) 1>$Composant_log 2>&1
	 echo "    `grep "Component $Composant" $Composant_log`"
         cd $TRUST_ROOT
      #else
      #   echo "  Component $Composant KO not found here: $TRUST_ROOT/../Composants"
      fi
   done
}

# Push to repos (called several times, once at the beginning and sometimes at the end...)
git_push()
{
   tags=0
   force=0
   while [ "$1" != "" ]
   do
      if [ "${1%-tags}" != $1 ]
      then
         tags=1
      elif [ "${1%-force}" != $1 ]
      then
         force=1
      fi
      shift
   done
   git_branch=`git branch 2>/dev/null | awk '($1=="*") {print $2}'`
   repos=`git remote`
   # => nouveau depot GIT: on ne pousse rien sur origin, seulement sur shared
   repos=`git remote | grep -v origin`
   for repo in $repos
   do
      repo_log=$REP_NUIT"/git_"$repo"_"$git_branch"_"$HOST".log"
      echo "TRUST git push on $HOST the `date` ...">$repo_log
      echo>>$repo_log
      echo "  git push $repo $git_branch. See $repo_log"
      if [ "$tags" != 1 ]
      then
         if [ "$force" != 1 ]
         then
            git push $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] Error for git push $repo $git_branch\" $TRUST_MAIL
         else
            git push --force $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] Error for git push force $repo $git_branch\" $TRUST_MAIL
         fi
      else
         if [ "$force" != 1 ]
         then
            git push --tags $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] Error for git push tags $repo $git_branch\" $TRUST_MAIL
         else
            git push --force --tags $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] Error for git push force tags $repo $git_branch\" $TRUST_MAIL
         fi
      fi
      cat $repo_log | tail -n +3
      [ "`cat $repo_log | tail -n +3`" != "Everything up-to-date" ] && cat $repo_log | mail_ -s\"[lance_test_nuit] git push $repo $git_branch\" -c $TRUST_MAIL $TMA_PROJECT_LEADER
   done
}

############################################################################################################################################################

#########
# BEGIN #
#########
echo "****************************************************"
echo `date`
echo "Beginning of the `basename $0` script at `date '+%H:%M:%S'` from:"
echo "\$TRUST_ROOT=${0%/bin/admin/lance_test_nuit}"
echo "****************************************************"
echo " "
echo "##########################"
echo "# Initialize environment #"
echo "##########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
if [ -f ~/.profile ]
then
   echo "Call to "`echo ~`"/.profile"
   . ~/.profile 1>/dev/null 2>&1
   echo "  HOST=$HOST"
   echo "  WORKDIR=$WORKDIR"
   echo "  WORKBASE=$WORKBASE"
else
   echo `echo ~`"/.profile file not exist!" && exit -1
fi
# ROOT
export TRUST_ROOT=${0%/bin/admin/lance_test_nuit}
export TRUST_ROOT_MASTER=$TRUST_ROOT # New variable to set Livraison workdir (master branch in git)

# On recupere les numeros de version dans le fichier RELEASE_NOTES
export old=`awk '/version/ {print $(NF-1);exit}' $TRUST_ROOT/RELEASE_NOTES`
export new=`awk '/version/ {print $4;exit}' $TRUST_ROOT/RELEASE_NOTES`
export Version=Version$new
echo " "
echo "Release notes old version: "$old
echo "Release notes new version: "$new

# DISPLAY
[ ${#DISPLAY} = 0 ] && export DISPLAY=":0"
[ "`echo -e`" != "-e" ] && ECHO_OPTS="-e"

#VOBS="Doc_TRUST Pre_Post_TRUST Tests_TRUST TRUST Composants"
VOBS="TRUST Composants"

# List of components tested with TRUST:
# TrioCFD est ajoute a la liste car est devenu un Baltik de TRUST suite au decoupage de Trio_U.
# ICoCo est devenu un Outil de TRUST.
# equation_convection_diffusion est un projet Baltik qui sert de tutorial a la formation developpeur.
# MPCube est un Baltik qui peut etre teste sur TRUST et sur le kernel.
# basic est le template Hello_word qui permet de tester TRUST avec make check_trust_optim (pas possible via script de portabilite) 
# => on utilise maintenant le baltik Test_Baltik pour la portabilite
ComposantsLns="equation_convection_diffusion ICoCo Test_Baltik" # basic"
ComposantsGit="MPCube TrioCFD ModeleCoeur"
Composants=$ComposantsLns" "$ComposantsGit 

# Initialize environment TRUST:
echo " "
echo "Call to "$TRUST_ROOT"/env/TRUST.env"
. $TRUST_ROOT/env/TRUST.env #1>/dev/null 2>&1

# List of executables tested:
exec_debug=$TRUST_ROOT/exec/TRUST$COMM
exec_semi_opt=$TRUST_ROOT/exec/TRUST$COMM"_semi_opt"
exec_opt=$TRUST_ROOT/exec/TRUST$COMM"_opt"
liste_exec=$exec_debug" "$exec_semi_opt

# Initialize ftp connection:
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/connect_ftp"
. $TRUST_ROOT/bin/admin/connect_ftp -no_ftp #1>/dev/null 2>&1
echo "Public  ftp server: ftp://$TRUST_FTP/$PUBLIC"
echo "Private ftp server: ftp://$TRUST_FTP/$SECRET"
echo " "

# Backup de hostname
echo "Call to "`echo ~`"/bin/backup_pc_tma.sh via crontab"
echo "  See "`echo ~`"/bin/backup_pc_tma.log"
# NB: Now via crontab
#~/bin/backup_pc_tma.sh 1>~/bin/backup_pc_tma.log 2>&1
head -n1 ~/bin/backup_pc_tma.log
grep "Backup " ~/bin/backup_pc_tma.log
tail -n1 ~/bin/backup_pc_tma.log
echo " "

[ $HOST != $TRUST_HOST_ADMIN ] && echo "Error: You must be on $TRUST_HOST_ADMIN to do this action" && exit

export DATE=`date '+%d%m%y'`
export NUIT=1
REP_NUIT=/data/tmptrust/tmptrust/Historique/NUIT
REP_HIST=/data/tmptrust/tmptrust/Historique/HIST
MESSAGES_NUIT=$REP_NUIT/MESSAGES_NUIT
MESSAGES_LIVRAISON=~/MESSAGES_LIVRAISON

# On fait le menage :
echo "Cleaning of $REP_NUIT directory"
rm -f $REP_NUIT/CR_* $REP_NUIT/PERF_* $REP_NUIT/MAKE_* $REP_NUIT/*.log
rm -f $REP_NUIT/rsync_include_from $REP_NUIT/NUIT.html
rm -f $REP_NUIT/os $REP_NUIT/CC $REP_NUIT/CR
rm -f $MESSAGES_NUIT $REP_NUIT/nuit_*.html
rm -f $REP_NUIT/MESSAGES_LIVRAISON*
rm -f $REP_NUIT/.nfs*
# On cree :
[ ! -d $REP_NUIT ] && mkdir $REP_NUIT
[ ! -d $REP_HIST ] && mkdir $REP_HIST
ls -a $REP_NUIT
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "###########################"
echo "# Work on the new version #"
echo "###########################"

###################################
# Debut du travail sur la version #
###################################
echo " "
echo "############################"
echo "# Create the documentation #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
credoc_log=$REP_NUIT/credoc_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/KSH/credoc"
echo "  See $credoc_log"
echo "TRUST documentation creation on $HOST the `date` ...">$credoc_log
echo>>$credoc_log
# NB: Verification des includes avec Doxygen fait uniquement le vendredi
$TRUST_ROOT/bin/KSH/credoc 1>>$credoc_log 2>&1
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "######################"
echo "# Update the sources #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $TRUST_ROOT
# Mise a jour des includes, des makefile de TRUST
config_log=$REP_NUIT/configure_$HOST.log
echo "Call to "$TRUST_ROOT"/configure"
echo "  See $config_log"
echo "TRUST configuration on $HOST the `date` ...">$config_log
echo>>$config_log
./configure 1>>$config_log || exit -1
#grep -i error $config_log
grep KO $config_log
tail -n9 $config_log | head -n1
echo " "
echo "Call to "$TRUST_ROOT"/env_TRUST.sh"
source env_TRUST.sh #1>/dev/null 2>&1

# Verifie la qualite de la version
# Verifie si plusieurs classes ne sont pas instanciees avec le meme nom
# Verification de l'unicite du nom des classes dans les macros implemente_...
instanc_log=$REP_NUIT/verifie_instanciable_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/KSH/verifie_instanciable"
echo "  See $instanc_log"
echo "TRUST instanciable check on $HOST the `date` ...">$instanc_log
echo>>$instanc_log
verifie_instanciable 1>>$instanc_log 2>&1
grep -i error $instanc_log
tail -n1 $instanc_log 
# Verifie la validite de la classe mere dans les instanciations
# Verification du nom de la classe pere dans les macros implemente_...
verif_log=$REP_NUIT/Verifie_pere_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/KSH/Verifie_pere"
echo "  See $verif_log"
echo "TRUST father class check on $HOST the `date` ...">$verif_log
echo>>$verif_log
Verifie_pere 1>>$verif_log 2>&1
verif_error=$?
tail -n1 $verif_log
if [ $verif_error != 0 ]
then
   echo>>$verif_log
   cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log
   cat $verif_log | mail_ -s\"[lance_test_nuit] Verifie_pere KO on $HOST:$TRUST_ROOT\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
fi
echo>>$verif_log
cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log 

# Gestion externalpackages
cd $TRUST_ROOT/bin/gestion_externalpackages
external_log=$REP_NUIT/Verify_externalpackages_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/gestion_externalpackages/Verify_externalpackages.sh"
echo "  See $external_log"
echo "TRUST external packages check on $HOST the `date` ...">$external_log
echo>>$external_log
./Verify_externalpackages.sh 1>>$external_log 2>&1
nb_error=`grep "not in" $external_log | wc -l`
if [ $nb_error != 0 ]
then
   cat $external_log | mail_ -s\"[lance_test_nuit] Verify_externalpackages.sh KO on $HOST:$TRUST_ROOT\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
   cat $external_log
   echo "  KO"
else
   echo "  OK"
fi
liste_log=$REP_NUIT/Verify_liste_dep_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/gestion_externalpackages/Verify_liste_dep.sh"
echo "  See $liste_log"
echo "TRUST external packages liste dep on $HOST the `date` ...">$liste_log
echo>>$liste_log
# NB: Verification complete (apres nettoyage) le vendredi
[ "`date '+%u'`" = 5 ] && rm -r -f Test
./Verify_liste_dep.sh 1>>$liste_log 2>&1
# les 3 paquets suivants different car
# qt-everywhere-opensource-src-4.8.3 sans doc (taille passe de 685M a 352M)
# med-3.0.7 sans doc et sans python (taille passe de 162M a 19M)
# osu-micro-benchmarks-3.8 version initiale non retrouvee
nb_error=`grep "FAILED" $liste_log | grep -v qt-everywhere-opensource-src-4.8.3 | grep -v med-3.2.0 | grep -v osu-micro-benchmarks-3.8 | wc -l`
# les 3 paquets suivants sont sous http://downloads.sourceforge.net/project/trust-platform/X.Y.Z/extra/
# medcoupling-7.8.0.tar.gz
# hypre-2.10.0b-p2-TRUST.tar.gz
# CURVEPLOT.tgz
# nvc_get_devices.tgz
if [ $nb_error != 0 ]
then
   # qt-everywhere-opensource-src-4.8.3 sans doc (taille passe de 685M a 352M)
   # med-3.0.7 sans doc et sans python (taille passe de 162M a 19M)
   # osu-micro-benchmarks-3.8 version initiale non retrouvee
   #liste_failed=`grep "FAILED" $liste_log | sed "s,: FAILED,," | grep -v qt-everywhere-opensource-src-4.8.3 | grep -v med-3.2.0 | grep -v osu-micro-benchmarks-3.8 | grep -v medcoupling-7.8.0 | grep -v hypre-2.10.0b-p2-TRUST | grep -v CURVEPLOT | grep -v nvc_get_devices`
   liste_failed=`grep "FAILED" $liste_log | sed "s,: FAILED,," | grep -v qt-everywhere-opensource-src-4.8.3 | grep -v med-3.2.0 | grep -v osu-micro-benchmarks-3.8`
   cd $TRUST_ROOT/build/bin/gestion_externalpackages/Test
   rm -r -f old new
   for package in $liste_failed
   do
      echo>>$liste_log
      echo "Launch ../compare_archive $package">>$liste_log    
      $TRUST_ROOT/bin/gestion_externalpackages/compare_archive $package 1>>$liste_log 2>&1
   done
   cd - 1>/dev/null 2>&1
   cat $liste_log | mail_ -s\"[lance_test_nuit] Verify_liste_dep.sh KO on $HOST:$TRUST_ROOT\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
   grep "computed checksums did NOT match" $liste_log
   grep "FAILED" $liste_log
   echo "  KO"
else
   echo "  OK"
fi
cd $TRUST_ROOT

# Marque la version dans MAIN.cpp et mon_main.cpp
#if [ "`echo $new | grep beta`" = "" ]
#then
   echo " "
   echo "Mark new version in following files:"
   for MAIN in $TRUST_ROOT/src/MAIN/MAIN.cpp $TRUST_ROOT/src/MAIN/mon_main.cpp
   do
      CHECKOUT $MAIN 1>/dev/null 2>&1
      version=`$TRUST_Awk '/version :/ {print $4}' $MAIN`
      echo "  "$version"=>"$new": "$MAIN
      echo $ECHO_OPTS "1,$ s?version : $version?version : $new?g\nw" | ed $MAIN 1>/dev/null 2>&1
      CHECKIN $MAIN 1>/dev/null 2>&1
   done
   index=$TRUST_ROOT/index.html
   version=`$TRUST_Awk '/ Version / {print $4}' $index`
   echo $ECHO_OPTS "1,$ s?$version?$new?g\nw $index.new" | ed $index 1>/dev/null 2>&1
   if [ "`diff $index $index.new`" != "" ]
   then
      echo "Mark new version in "$index
      CHECKOUT $index
      cat $index.new > $index
   fi
   rm -f $index.new
   ref_manual=Outils/TRIOXDATA/XTriou/objet_u.py
   version=`$TRUST_Awk '/ Manual V/ {print $5}' $ref_manual`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $ref_manual.new" | ed $ref_manual 1>/dev/null 2>&1
   if [ "`diff $ref_manual $ref_manual.new`" != "" ]
   then
      echo "Mark new version in "$ref_manual
      CHECKOUT $ref_manual
      cat $ref_manual.new > $ref_manual
   fi
   rm -f $ref_manual.new
   tuto=doc/TRUST/Tutorial/TRUST_tutorial.tex
   version=`$TRUST_Awk '/ Tutorial V/ {print $3}' $tuto`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}]{TRUST?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
   version=`$TRUST_Awk '/ Tutorial V/ {print $5}' $tuto.new`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $tuto.new" | ed $tuto.new 1>/dev/null 2>&1
   if [ "`diff $tuto $tuto.new`" != "" ]
   then
      echo "Mark new version in "$tuto
      CHECKOUT $tuto
      cat $tuto.new > $tuto
   fi
   rm -f $tuto.new
   tuto=doc/TRUST/exercices/Tutorial_solutions/Tutorial_solutions.tex
   version=`$TRUST_Awk '/ Tutorial V/ {print $3}' $tuto`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
   if [ "`diff $tuto $tuto.new`" != "" ]
   then
      echo "Mark new version in "$tuto
      CHECKOUT $tuto
      cat $tuto.new > $tuto
   fi
   rm -f $tuto.new
   tuto=doc/TRUST/Tutorial/Baltik_tutorial.tex
   version=`$TRUST_Awk '/ Project V/ {print $4}' $tuto`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}]{TRUST?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
   version=`$TRUST_Awk '/ Project V/ {print $7}' $tuto.new`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $tuto.new" | ed $tuto.new 1>/dev/null 2>&1
   if [ "`diff $tuto $tuto.new`" != "" ]
   then
      echo "Mark new version in "$tuto
      CHECKOUT $tuto
      cat $tuto.new > $tuto
   fi
   rm -f $tuto.new
   echo " "
#fi


[ ! -d $TRUST_ROOT/.git ] && echo "Error: You must have $TRUST_ROOT/.git directory to do this action" && exit

# Update Git repos #
####################
# Must be done BEFORE envoie_TRUST_arch (git_cron or git_ssh process)
(
   # Assume unchanged some files (big one with a lot of changes):
   cd $TRUST_ROOT/doc
   echo "Update Git repos "`pwd`
   for assume_inchanged in TRUST/TRUST_Reference_Manual.pdf Coverage/cpp.gcov.tar.gz Coverage/list_methodes.gz Coverage/dico.pkl.gz Coverage/list_methodes_non_appelees.gz
   do
      if [ ! -f $assume_inchanged ]
      then
         echo | mail_ -s\"[lance_test_nuit] File $assume_inchanged not found, fix lance_test_nuit. \" $TRUST_MAIL
      else
         # Ignore the changes of the specified files
         git update-index --assume-unchanged $assume_inchanged
      fi
   done
   # List untracked files:
   echo "  List of files untracked with git update-index --assume-unchanged:"
   git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'
   cd - 1>/dev/null 2>&1
   # Push to repos
   echo " "
   echo "Call git push shared Livraison"
   git_push -tags
   cd $TRUST_ROOT/externalpackages
   echo " git push shared Livraison in `pwd`"
   git push --tags shared Livraison
   cd - 1>/dev/null 2>&1
)
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "#######################################"
echo "# Send the sources to remote machines #"
echo "#######################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
envoie_log=$REP_NUIT/envoie_TRUST_arch_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/envoie_TRUST_arch"
echo "  See $envoie_log"
echo "TRUST script on $HOST the `date` ...">$envoie_log
echo>>$envoie_log
touch liste_envoie_KO
# NB: Versions distantes automatiquement effacees le vendredi
envoie_TRUST_arch 1>>$envoie_log 2>&1
export liste_machines_KO=`cat liste_envoie_KO`
rm -f liste_envoie_KO
grep -i delete $envoie_log | head -n1
grep "KO " $envoie_log
#grep error $envoie_log
mv -f build/rsync_*.log $REP_NUIT/.
mv -f build/rsync_include_from $REP_NUIT/.
mv -f build/ssh_*.log $REP_NUIT/.
# On recupere le nom des machines sur lesquelles les sources n'ont pu etre mises a jour 
# Cette liste permettra de ne pas lancer la portabilite des baltiks sur ces machines
if [ ${#liste_machines_KO} != 0 ] # chaine non vide
then
   echo "  liste_machines_KO:"
   echo $liste_machines_KO
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "###############################################"
echo "# Compile and verify the old and new versions #"
echo "###############################################"
( 
  # On allege le nombre de versions compilees:
  for vue in sourceforge/Livraison sourceforge/Maintenance sourceforge/Kernel
  do
     if [ -d $WORKDIR/$vue ]
     then
	# Git workdir
	TRUST_ROOT=$WORKDIR/$vue/TRUST
	cd $TRUST_ROOT
        echo " "
        echo "#############################"
        echo "# On workdir: "$TRUST_ROOT
        echo "#############################"
        echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
	if [ $vue = sourceforge/Kernel ]
	then
           # Kernel desormais workdir Git:
	   #rebase_log=`mktemp_`
	   rebase_log=$REP_NUIT"/rebase_"$HOST"_"${vue#*/}".log"
	   echo "Call git rebase master"
	   echo "  See $rebase_log"
           echo "git rebase on $HOST the `date` ...">$rebase_log
           echo>>$rebase_log
           echo "externalpackages">>$rebase_log
	   cd $TRUST_ROOT/externalpackages
	   git rebase Livraison 1>>$rebase_log 2>&1
	   [ $? != 0 ] && echo "  KO rebase externalpackages"
	   git rebase --continue 1>>$rebase_log 2>&1
	   [ "`git rebase --continue 2>&1`" != "No rebase in progress?" ] && echo "  KO rebase externalpackages"
	   cd - 1>/dev/null 2>&1
           echo>>$rebase_log
	   for Composant in $ComposantsGit 
	   do
              if [ -d $TRUST_ROOT/../Composants/$Composant ]
              then
                 echo "Composants/$Composant">>$rebase_log
	         cd $TRUST_ROOT/../Composants/$Composant
	         git rebase Livraison 1>>$rebase_log 2>&1
	         [ $? != 0 ] && echo "  KO rebase Composants/$Composant"
	         git rebase --continue 1>>$rebase_log 2>&1
	         [ "`git rebase --continue 2>&1`" != "No rebase in progress?" ] && echo "  KO rebase Composants/$Composant"
	         cd - 1>/dev/null 2>&1
                 echo>>$rebase_log
	      fi
	   done
	   cd $TRUST_ROOT
	   git commit doc/.dico src/CMakeLists.txt src/MAIN/instancie_appel.h src/MAIN/instancie_appel_c.h -m"Commit in Kernel before git rebase master" --u=no 1>>$rebase_log 2>&1
	   git rebase Livraison 1>>$rebase_log 2>&1
	   rebase_error=$?
	   if [ $rebase_error != 0 ]
	   then
	      deleted_item=deleted_item
	      compt=10
	      while [ $rebase_error != 0 ] && [ "$deleted_item" != "" ] && [ $compt != 0 ]
	      do
	         let compt=$compt-1
	         for deleted_item in `git status | awk '/deleted by them/ || /added by us/ {print $5}'`
	         do
		    git rm $deleted_item #1>>$rebase_log 2>&1
	         done
	         git rebase --continue 1>>$rebase_log 2>&1
	         rebase_error=$?
		 if [ "`git rebase --continue 2>&1`" = "No rebase in progress?" ]
		 then
		    rebase_error=0
		 fi
	      done
	   fi
	   if [ $rebase_error != 0 ]
	   then
	      cat $rebase_log | mail_ -s\"[lance_test_nuit] Error when rebasing $vue workdir. Check.\" $TRUST_MAIL
	   fi
	   grep -i error $rebase_log
	   echo "  rebase_error=$rebase_error"
	   echo " "
	   #rm -f $rebase_log
	   # Delete non Kernel tests if any:
	   cd $TRUST_ROOT/tests
	   NonKernelTests=`find * -type d | grep -v Kernel | grep "/"`
	   if [ "$NonKernelTests" != "" ]
	   then
	      echo "Call git rm no $vue tests..."
	      for NonKernelTest in $NonKernelTests
	      do
		 git rm -r $NonKernelTest
	      done
	      git commit --all -m"Non Kernel tests suppressed from the branch Kernel"
	      echo " "
	   fi
	   cd - 1>/dev/null 2>&1
	   if [ $rebase_error = 0 ]
	   then
              echo "Call git push shared Kernel"
              git_push -tags -force
	      echo " "
	   fi
	fi
	echo "Call to configure $vue version in `pwd`"
	./configure 1>/dev/null 2>&1
        source env_TRUST.sh 1>/dev/null 2>&1
	echo "TRUST_ROOT=$TRUST_ROOT"
	echo "TRUST_VERSION=$TRUST_VERSION"
	###################################################
	# Boucle sur les differentes options de compilation
	###################################################
	for OPT in _semi_opt_ _opt_ _ _opt_pg_ _opt_gcov_ _opt_avx_
	do
           case $OPT in
	   _semi_opt_) TYPE="semi_opt";;
	   _opt_) TYPE="opt";;
	   _) TYPE="debug";;
	   _opt_pg_) TYPE="prof";;
	   _opt_gcov_) TYPE="gcov";;
	   _opt_avx_) TYPE="opt_avx";;
           *) echo $OPT not coded in $0;  exit -1 ;;
	   esac;
	   OPT=${OPT%_} # <=> OPT=${OPT::-1}
	   echo " "
	   make_log=$REP_NUIT"/MAKE_TRUST"$COMM"_"$TYPE"_"$TRUST_ARCH"_"$HOST"_"${vue#*/}
           echo "Call to make $TYPE on `pwd`";
	   echo "  See $make_log"
           echo "TRUST make on $HOST the `date` ...">$make_log
           echo>>$make_log
	   make $TYPE 1>>$make_log 2>&1
	   grep "BUILD_" $make_log
	   grep error $make_log
	   grep -i Stop $make_log
	   grep KO $make_log
	   if [ "$OPT" = "_semi_opt" ]
	   then
	      if [ $vue = sourceforge/Livraison ]
	      then
                 # Force une compilation statique pour:
                 # a) Instanciation manquante
                 # b) Sauve un exec en le zippant sous NUIT
		 echo " "
		 echo "Call to make with COMPIL_DYN=OFF on $TRUST_ROOT/MonoDir_mpi$OPT/src"
                 cd $TRUST_ROOT/MonoDir_mpi$OPT/src
		 cmake . -DCOMPIL_DYN=OFF
   		 tmp=`mktemp_`
		 make 1>>$tmp 2>&1
		 tail -n2 $tmp
		 rm -f $tmp
                 gzip -c $exec > $REP_HIST/`basename $exec`"."$DATE".gz"
		 cd $TRUST_ROOT
		 echo " "
	         echo "Save "$REP_HIST/`basename $exec`"."$DATE".gz"
	      elif [ $vue = sourceforge/Maintenance ]
	      then
	         echo " "
		 new_patch=1
	         echo "Special treatment..."
	         ################################
	         # Travaux sur la vue Maintenance
		 ################################
		 checkin_log=$REP_NUIT"/checkin_patch_"$HOST"_"${vue#*/}".log"
                 echo "Call to "$TRUST_ROOT"/bin/admin/checkin_patch.ct"
                 echo "  See $checkin_log"
                 echo "TRUST checkin patch on $HOST the `date` ...">$checkin_log
		 $TRUST_ROOT/bin/admin/checkin_patch.ct 1>>$checkin_log 2>&1
		 wc -l $checkin_log
		 grep "diff --git" $checkin_log
		 [ "`cat $checkin_log | tail -n +2`" != "" ] && cat $checkin_log | mail_ -s\"[checkin_patch.ct] Changes in the $TRUST_VERSION patch branch\" $TRUST_MAIL
		 #######################
		 # Construction du patch
		 #######################
		 patch_version=`awk '/version/ && /Release notes/ {print $4;exit}' RELEASE_NOTES`
		 rm -f $TRUST_TMP/patch
		 GRAVAGE=$WORKDIR/A_GRAVER_CD_TRUST
		 patch=$GRAVAGE/Patch-$patch_version".tar.gz" && rm -f $patch
		 echo " "
		 echo "Construction of the $patch patch..."
		 echo "from `pwd`"
		 # Git (On ne scrute que les VOBs TRUST):
		 cd $TRUST_ROOT
                 echo "  Call git push shared Maintenance"
		 git_push -tags
		 echo "  Files contained in the patch"
                 Build=$TRUST_ROOT/build
                 [ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
		 echo "    See $Build/patch.files"
		 git diff --name-only v$TRUST_VERSION > $Build/patch.files
                 patch_error=$?
		 if [ -s $Build/patch.files ]
		 then
                    # ajout du log pour identifier l'archive
		    git log -1 > .git_patch_log
                    echo .git_patch_log >> $Build/patch.files
		    # Ajout de Patch au fichier
		    #BASE=`basename $TRUST_ROOT`
		    #for file in `cat $Build/patch.files`
		    #do
		    #   if [ -f $file ]
		    #   then
		    #      echo $BASE/$file
        	    #   fi
		    #done > Patch.files
		    # creation des archives
		    echo "  Files compressed in $patch"
		    tar zcf $patch `cat $Build/patch.files`
		    #cd ..
		    #tar zcf $patch  --transform=s?$BASE?Patch-${patch_version}? `cat $BASE/Patch.files`
		    #md5sum  $patch > $patch.md5
		 fi
		 cd $TRUST_ROOT
		 cat $Build/patch.files 
		 rm -f Patch.files
                 if [ $patch_error = 0 ] && [ -s $Build/patch.files ]
                 then
		    # Envoi immediat sur ftp.cea.fr
                    echo "  Call to "$TRUST_ROOT"/bin/admin/connect_ftp"
                    . $TRUST_ROOT/bin/admin/connect_ftp
                    echo "  Call to "$TRUST_ROOT"/bin/admin/cp_ftp"
		    $TRUST_ROOT/bin/admin/cp_ftp $patch $PUBLIC/patch
		    # Mise a jour des versions patchees
		    echo " "
                    echo "Call to "$TRUST_ROOT"/bin/admin/Installer_TRUST.ssh on:"
		    liste_machines updated
		    for machine in `liste_machines updated`
		    do
		       (
		       install_patch_log=$REP_NUIT"/install_patch_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
		       echo "-> Start of Installer_TRUST.ssh $machine $patch_version -patch -compile..."
	               echo "  See $install_patch_log"
		       )
		    done
		    for machine in `liste_machines updated`
		    do
		       (
		       install_patch_log=$REP_NUIT"/install_patch_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
                       echo "TRUST script on $HOST the `date` ...">$install_patch_log
		       echo>>$install_patch_log
		       $TRUST_ROOT/bin/admin/Installer_TRUST.ssh $machine $patch_version -patch -compile 1>>$install_patch_log 2>&1
		       if [ $? != 0 ] || [ "`grep :error $install_patch_log | grep -iv warning | grep -v TRIOXDATA | grep -v Gmsh`" != "" ]
		       then
                          cat $install_patch_log | mail_ -s\"[lance_test_nuit] Failed to install patch version on $machine\" $TRUST_MAIL
		       fi
		       ) &
		       # Quels sont les conflits ?
		    done
		 elif [ $patch_error != 0 ]
		 then
                    echo "Not install on remote machine!" | mail_ -s\"[lance_test_nuit] Failed to create $TRUST_VERSION patch version\" $TRUST_MAIL
		 else
		    echo "No patch"
		    new_patch=0
		 fi
	         echo "End special treatment."
	      fi
	   fi
	done
	########################
	# Check non regression #
	########################
	if ([ $vue = sourceforge/Maintenance ] && [ $new_patch != 0 ]) || [ $vue = sourceforge/Kernel ]
	then
	   lance_test_log=$REP_NUIT"/lance_test_"$HOST"_"${vue#*/}".log"
	   echo " "
	   echo "-> Start of exec=$exec_opt trust -check all"
           echo "  See $lance_test_log"
           echo "TRUST script on $HOST the `date` ...">$lance_test_log
	   echo>>$lance_test_log
	   # Reduce priority with nice:
	   exec=$exec_opt nice -n 19 $TRUST_ROOT/bin/trust -check all 1>>$lance_test_log 2>&1 &
	fi
	###############################
	# Verification des composants #
	###############################
	if ([ $vue = sourceforge/Maintenance ] && [ $new_patch != 0 ]) || [ $vue = sourceforge/Kernel ]
	then
	   echo " "
	   echo "Call check_components for $TRUST_VERSION version from `pwd`"
	   check_components $vue
	fi
	if [ $vue = sourceforge/Livraison ]
	then
	   ##########################################
 	   # Merge needed from patch branch under Git
 	   ##########################################
	   to_merge=`mktemp_`
  	   patch_branch=`cd $WORKDIR/sourceforge/Maintenance/TRUST;git rev-parse --abbrev-ref HEAD`
  	   master_branch=`cd $WORKDIR/sourceforge/Livraison/TRUST;git rev-parse --abbrev-ref HEAD`
	   echo " "
 	   echo "Call `pwd`/git diff --name-status $master_branch...$patch_branch"
 	   git diff --name-status $master_branch...$patch_branch 1>$to_merge
	   cat $to_merge
 	   if [ -s $to_merge ]
	   then
	      echo "  KO: Some stuff to merge in $master_branch from $patch_branch with command: fusion.git $patch_branch"
	      cat $to_merge | mail_ -s\"[lance_test_nuit] Some stuff to merge in $master_branch from $patch_branch with command: fusion.git $patch_branch\" $TRUST_MAIL
	   else
	      echo "  OK: No stuff to merge in $master_branch from $patch_branch"
	   fi
 	   rm -f $to_merge
	fi
        echo "<--- End at "`date '+%H:%M:%S %d/%m'`
     fi
  done
)
TRUST_ROOT=${0%/bin/admin/lance_test_nuit}
cd $TRUST_ROOT
source env_TRUST.sh 1>/dev/null 2>&1
echo " "
echo "------------------------------------------------------"
echo " "
echo "########################"
echo "# Test the new version #"
echo "########################"

####################################################
# Lancement des etudes sur une machine de production
####################################################
ETUDES=$WORKDIR/sourceforge/Etudes
echo " "
echo "##################"
echo "# On study cases #"
echo "##################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
etude_activation=1
if [ `date '+%u'` -ge 5 ]
then
   # le vendredi soir on lance toutes les etudes
   etude_test=0
else
   # On ne lance qu'une etude
   etude_test=1
fi
disable_etudes=~/disable_etudes && [ -f $disable_etudes ] && etude_test=1 && rm -f $disable_etudes
if [ "$etude_activation" = 1 ] 
then
   cd $ETUDES 2>/dev/null
   if [ $? != 0 ]
   then
      echo "Error: $ETUDES not found !"
      echo "  You should create a git repo for Etudes and change the run script"
      echo "  or for the moment, you can create a link to Etudes directory."
      etude_activation=0
   fi
fi
# seulement si le script run de la veille est termine (ie run_Etudes.log deplace dans $REP_NUIT)
if [ "$etude_activation" = 1 ]  && [ -f run_Etudes.log ]
then
   echo "NOT launched because $ETUDES/run script not finished"
   echo "  See $ETUDES/run_Etudes.log"
   etude_activation=0
fi
if [ "$etude_activation" = 1 ]  && [ ! -f run_Etudes.log ] && [ "$etude_test" = 1 ]
then
   touch $ETUDES/run_Etudes.log
   echo "  See $REP_NUIT/run_EOLE_120_curie.log"
   echo "TRUST script on curie the `date` ...">run_EOLE_120_curie.log
   echo>>run_EOLE_120_curie.log
   (./run Studies/EOLE_120 -adr curie-ccrt.ccc.cea.fr 1>>run_EOLE_120_curie.log 2>&1;mv -f run_EOLE_120_curie.log $REP_NUIT/.) &
   mv -f run_Etudes.log $REP_NUIT/.
fi
if [ "$etude_activation" = 1 ]  && [ ! -f run_Etudes.log ] && [ "$etude_test" = 0 ]
then
   echo "-> Start of "$ETUDES"/run -all"
   touch $ETUDES/run_Etudes.log
   echo "  See $REP_NUIT/run_Etudes.log"
   echo "TRUST script from $HOST the `date` ...">run_Etudes.log
   echo>>run_Etudes.log
   (./run -all 1>>run_Etudes.log 2>&1;mv -f run_Etudes.log $REP_NUIT/.) & # Deplace le log des etudes si script termine
fi
if [ "$etude_activation" = 0 ] 
then
   echo "NOT executed"
   [ -f run_Etudes.log ] && cp run_Etudes.log $REP_NUIT/.
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################
# Lancement des tests sur Livraison #
#####################################
cd $TRUST_ROOT
vue="sourceforge/Livraison"
lance_test_log=$REP_NUIT"/lance_test_"$HOST"_"${vue#*/}".log"
touch $lance_test_log
echo "TRUST script on $HOST the `date` ...">$lance_test_log
echo " "
echo "##########################"
echo "# On no-regression tests #"
echo "##########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "  See $lance_test_log"
for exec in $liste_exec
do
   cd $TRUST_ROOT
   TYPE=""
   [ $exec = "$exec_debug" ] && TYPE=debugged && PERF=$REP_NUIT/PERF_`basename $exec`"_debug_"$TRUST_ARCH"_"$HOST
   [ $exec = "$exec_semi_opt" ] && TYPE=semi-optimized && PERF=$REP_NUIT/PERF_`basename $exec`_$TRUST_ARCH"_"$HOST
   echo " "
   echo "MODE: $TYPE (exec=$exec)"
   echo "TRUST performance on $HOST the `date` ...">$PERF
   echo "--------------------------------------------------------" >> $PERF
   echo "hostname "$HOST >> $PERF
   OS="Os "`uname -s` && [ $TRUST_ARCH = linux ] && OS=$OS" "`cat /proc/cpuinfo | $TRUST_Awk '/MHz/ {print $4"Mhz";exit}'`
   echo $OS >> $PERF
   echo "release "`uname -r` >> $PERF
   echo "model "`uname -m` >> $PERF
########################################################
# La nuit, lance_test est lance avec l'executable exec :
########################################################
   if [ -f $exec ] && [ "`$exec 2>&1 | grep TRUST`" != "" ]
   then
      taille=`ls -la $exec | $TRUST_Awk '{print $5}'`
      taille=`echo $ECHO_OPTS "scale=1\n$taille/1000000" | bc -l`
      #type=`echo $taille | $TRUST_Awk '{type="Statique";if ($1<=2) type="Dynamique";print type}'`
      type=`ldd $exec | $TRUST_Awk 'END {type="Statique";if (NR>20) type="Dynamique";print type}'`
      if [ $type = Statique ]
      then
         echo "size "$taille" "$type >> $PERF
      elif [ $type = Dynamique ]
      then
         sl=`ls -la $TRUST_ROOT/lib/lib*.s* | $TRUST_Awk 'BEGIN {i=0} {i+=$5} END {print i}'`
         #echo "sl="$sl
         sl=`echo $ECHO_OPTS "scale=1\n$sl/1000000" | bc -l`
         #echo "sl="$sl
         echo "size "$taille"+"$sl" "$type >> $PERF
      fi
      echo "--------------------------------------------------------" >> $PERF
      echo "exec "$exec >> $PERF
      #######################################
      ### CHOIX DU NOMBRE DE TESTS PASSES ###
      N=0
      [ $exec = "$exec_debug" ] && N=VAHL_DAVIS
      #######################################
      echo "-> Start of echo $N | $TRUST_ROOT/bin/lance_test"
      echo "  See $PERF"
      fic_test=`dirname $exec`/.tests_`basename $exec`
      rm -f $fic_test
      echo " " >> $lance_test_log
      echo "######################################################" >> $lance_test_log
      echo " " >> $lance_test_log
      export PAR=0
      echo $ECHO_OPTS $N | lance_test $exec `dirname $exec` 2>/dev/null  >> $lance_test_log
      if [ -f $fic_test ]
      then
         #cat $fic_test".html" | grep "Mo|" >> $PERF
         cat $fic_test".html" | $TRUST_Awk -F":" '/ucces/ {print "succes "$2}' >> $PERF
	 grep -A 5000 unsuccess $fic_test".html" >> $PERF
      fi
      # On fait l'executable share libs
      # CC: 16/02/2015 => Pourquoi fait-on ca ici et pas lors de la compilation plus haut ?
      #(cd $TRUST_ROOT/src/MAIN;make)
      (
      OPT=""
      [ $exec = "$exec_debug" ] && OPT=_
      [ $exec = "$exec_semi_opt" ] && OPT=_semi_opt_
      OPT=${OPT%_} # <=> OPT=${OPT::-1}
      if [ $type = Statique ]
      then
	 echo "Call to make with COMPIL_DYN=OFF on $TRUST_ROOT/MonoDir_mpi$OPT/src"
         cd $TRUST_ROOT/MonoDir_mpi$OPT/src
	 cmake . -DCOMPIL_DYN=OFF
      elif [ $type = Dynamique ]  
      then
	 echo "Call to make with COMPIL_DYN=ON  on $TRUST_ROOT/MonoDir_mpi$OPT/src"
         cd $TRUST_ROOT/MonoDir_mpi$OPT/src
         cmake . -DCOMPIL_DYN=ON
      fi 
      tmp=`mktemp_`
      make 1>>$tmp 2>&1
      tail -n2 $tmp
      rm -f $tmp
      )
   fi
   # Suite au test `$exec 2>&1 | grep TRUST`
   rm -f convert_jdd hierarchie.dump TRUST.log TRUST.stop
done
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#################################################
# Verification de la portabilite des composants #
#################################################
cd $TRUST_ROOT
echo " "
echo "#################"
echo "# On components #"
echo "#################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Call check_components for $TRUST_VERSION version from `pwd`"
check_components $vue
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "#####################################"
echo "# Validate and save the new version #"
echo "#####################################"
cd $TRUST_ROOT
# Attente jusqu'a minuit le vendredi
# pour certains tests faits que le week-end
while [ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 20 ]
do
   sleep 30
done
echo " "
echo "###################################"
echo "# Create the matrix of validation #"
echo "###################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
(
matrice_validation=0 # Non actualise
# Changement 164, on cree la matrice de validation le week-end
if [ "$matrice_validation" = 1 ] && [ "`date '+%u'`" -gt 5 ]
then
   cd $TRUST_ROOT/doc/Validation
   echo "-> Start of "$TRUST_ROOT"/doc/Validation/Matrice.sh"
   echo "  See `pwd`/Matrice_Validation.pdf"
   ./Matrice.sh -no_verbose # Utiliser l'option -no_verbose permet de conserve une trace dans le fichier Matrice.log du lance_test_modifie
   if [ -f Matrice.pdf ] && [ "`diff Matrice.pdf Matrice_Validation.pdf`" != "" ]
   then
      CHECKOUT Matrice_Validation.pdf 1>/dev/null 2>&1
      mv -f Matrice.pdf Matrice_Validation.pdf
   fi
   cd - 1>/dev/null 2>&1
else
   echo "NOT executed"
fi
) &
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "#####################################"
echo "# Use and execute cpplint.py script #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
# le week-end uniquement
if [ "`date '+%u'`" -gt 5 ]
then
   cd $TRUST_ROOT
   echo "Call to $TRUST_ROOT/bin/KSH/cpplint.py"
   echo "from `pwd`"
   cpplint_log=$REP_NUIT"/cpplint_$HOST.log"
   echo "  See $cpplint_log"
   echo "TRUST script on $HOST the `date` ...">$cpplint_log
   filter="--filter=-whitespace,-legal/copyright,-build/header_guard,-runtime/references,-readability/casting,\
-build/include_what_you_use,-runtime/sizeof,-runtime/explicit,-runtime/printf,-runtime/int,\
-readability/function,-readability/braces,-readability/streams,-readability/multiline_comment"   
   echo "====================================
Running cpplint by filtering with --filter=$filter
====================================" >> $cpplint_log
   python $TRUST_ROOT/bin/KSH/cpplint.py $filter src/*/*.cpp src/*/*/*.cpp src/*/*/*/*.cpp src/*/*/*/*/*.cpp include/*.h 2>&1 | grep -v "Done processing" >> $cpplint_log
   tail -n1 $cpplint_log
   cat $cpplint_log | mail_ -s\"[lance_test_nuit] Google rules with cpplint on TRUST $new\" -c $TRUST_MAIL $TMA_PROJECT_LEADER
else
   echo "NOT executed"
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "######################"
echo "# Build the packages #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
GRAVAGE=$WORKDIR/A_GRAVER_CD_TRUST
echo "Deleting of _build_ packages in $GRAVAGE"
ls -f $GRAVAGE/*_build_*
rm -f $GRAVAGE/*_build_*
v=${Version#Version}
version_arch=TRUST-$v".tar.gz"
package_log=$REP_NUIT"/package_$HOST.log"
# Dans le paquet officiel, on ne met pas les tests de validation car cela prend trop de place
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/mise_a_jour_TRUST_tar -without_test_validation -without_version"
echo "  See $package_log"
echo "TRUST script on $HOST the `date` ...">$package_log
echo>>$package_log
mise_a_jour_TRUST_tar -without_test_validation -without_version 1>>$package_log
grep "Creation of" $package_log
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/cree_Version_TRUST $v"
echo "  See $package_log"
echo $ECHO_OPTS $v"\n" | cree_Version_TRUST 1>>$package_log
tail -n1 $package_log
echo " "
echo "Move $version_arch packages to $GRAVAGE"
mv $TRUST_ROOT/$version_arch $GRAVAGE/.
ls $GRAVAGE/$version_arch
cd $TRUST_ROOT
rm -f TRUST.tar.gz externalpackages.tar
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
####################
# Release criteria #
####################
echo "----------------------------------------------------------------------------------------" > $MESSAGES_NUIT
echo `date` >> $MESSAGES_NUIT
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/RELEASE_NOTES ] && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/RELEASE_NOTES | head -n -1 >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/DEVELOPER_NOTES ] && $TRUST_Awk '/Developer notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/DEVELOPER_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/externalpackages/RELEASE_NOTES ] && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/externalpackages/RELEASE_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
for Composant in $ComposantsGit
do
  [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
done
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST/TrioCFD WEB site:    http://www-trio-u.cea.fr" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST distribution site:   http://sourceforge.net/projects/trust-platform" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD distribution site: http://sourceforge.net/projects/triocfd" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST environment at Saclay:   source /home/triou/env_TRUST_$old.sh" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD environment at Saclay: source /home/triou/env_TrioCFD_$old.sh" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "User TRUST TrioCFD     diffusion list http://saxifrage:3500/wws/info/trio_u_annonces" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Developer TRUST        diffusion list http://saxifrage:3500/wws/info/trio_u_dev" >> $MESSAGES_NUIT
echo $ECHO_OPTS "User TRUST TrioMC2     diffusion list http://saxifrage:3500/wws/info/mc2_annonces" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST Kernel             mailing list http://saxifrage:3500/wws/info/trio_u_kernel" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST Post Processing    mailing list http://saxifrage:3500/wws/info/trio_u_post_traitement" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD Front Tracking   mailing list http://saxifrage:3500/wws/info/trio_u_front_tracking" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST ftp site:          ftp://$TRUST_FTP/$PUBLIC/index.html" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST documentation:     ftp://$TRUST_FTP/$PUBLIC/documentation" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Generic Guide:    ftp://$TRUST_FTP/$SECRET/doc/TRUST_Generic_Guide.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Reference Manual: ftp://$TRUST_FTP/$SECRET/doc/TRUST_Reference_Manual.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Tutorial:         ftp://$TRUST_FTP/$SECRET/doc/TRUST_tutorial.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest list of builds:   ftp://$TRUST_FTP/$SECRET/NUIT/NUIT.html" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest TRUST binary:     ftp://$TRUST_FTP/$SECRET/exec/linux/TRUST_mpi_opt"_"$new"_build_"$DATE.gz" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo "Binaries of TRUST $new version are available here:" >> $MESSAGES_NUIT
for adr in `liste_machines | grep -v is1 | grep -v is2 | grep -v cezanne`
do 
   machine=`echo $adr | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
   log=`awk -v adr=$adr '($2==adr) {print $4}' ~/.netrc | head -1`
   ssh_ $log@$machine -n 'echo -e "'$machine: '\c";ls ${WORKDIR:-$HOME}/$WORKBASE"'$machine'"/TRUST/exec/TRUST_mpi_opt 2>/dev/null || echo' 2>/dev/null
done >> $MESSAGES_NUIT
echo "Older binaries (> v1.7.1) are available here: ftp://$TRUST_FTP/$PUBLIC/" >> $MESSAGES_NUIT
echo "Older binaries (< v1.7.1) are available here: ftp://ftp.cea.fr/pub/Trio_U/a87pour/" >> $MESSAGES_NUIT
#echo "Older binaries (< v1.6.6) are available here: file:///net/dibona/users/dibona/triou/version/" >> $MESSAGES_NUIT
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
##########################################################
# On checkine dans la vue si criteres suivants respectes :
##########################################################
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo "Release criteria of the $new version:" >> $MESSAGES_NUIT

criteres_remplis=0
total_criteres=0
baltik_ok=0
total_baltik=`echo $ComposantsGit | wc -w`

######################
# Tests d'installation
######################
echo " "
echo "############################################"
echo "# Test the installation to remote machines #"
echo "############################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
version_arch="TRUST-$TRUST_VERSION.tar.gz"
installation=1
machine1=`liste_machines "\-remote_install_TRUST_with_source" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [[ "$liste_machines_KO" != *"$machine1"* ]] # Test si machine n est pas dans la liste des machines KO
then
   remote1="-remote "`liste_machines "\-remote_install_TRUST_with_source" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
else
   remote1="-remote "`liste_machines "\-remote_install_TRUST_with_source" 		| tail -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
fi
machine2=`liste_machines "\-remote_install_TRUST_kernel_only" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [[ "$liste_machines_KO" != *"$machine2"* ]] # Test si machine n est pas dans la liste des machines KO
then
   remote2="-remote "`liste_machines "\-remote_install_TRUST_kernel_only" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
else
   remote2="-remote "`liste_machines "\-remote_install_TRUST_kernel_only" 		| tail -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
fi
# Version sans source devenue inutile depuis le passage en OpenSource
#remote3="-remote "`liste_machines "\-remote_install_TRUST_without_source" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
remote1_log=$REP_NUIT"/simule_install_TRUST_with_source_"`echo ${remote1##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote1_log
echo>>$remote1_log
remote2_log=$REP_NUIT"/simule_install_TRUST_kernel_only_"`echo ${remote2##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote2_log
echo>>$remote2_log
#remote3_log=$REP_NUIT"/simule_install_TRUST_without_source_"`echo ${remote3##* }`".log"
#echo "TRUST script on $HOST the `date` ...">$remote3_log
#echo>>$remote3_log
cd $GRAVAGE
echo "Call to $TRUST_ROOT/bin/admin/simule_install_TRUST $version_arch $remote1"
echo "  See $remote1_log"
echo "Call to $TRUST_ROOT/bin/admin/extract_Version_TRUST $version_arch -install $remote2 -kernel_only"
echo "  See $remote2_log"
#echo "Call to $TRUST_ROOT/bin/admin/extract_Version_TRUST $version_arch -install $remote3 -without_source"
#echo "  See $remote3_log"
# Test d'une extraction/installation d'une version avec les sources
(
simule_install_TRUST ./$version_arch $remote1 					1>>$remote1_log 2>&1 	
echo " "
if [ "`grep "BUILD_" $remote1_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote1_log 2>/dev/null`" != "" ] 
then
   echo "Installation KO -with_source on $remote1"
   cat $remote1_log | mail_ -s\"[lance_test_nuit] Remote install with source failed on ${remote1##* }\" $TRUST_MAIL
   cp $remote1_log $TRUST_ROOT/simule_install_TRUST.log
else
   echo "Installation OK -with_source on $remote1"
fi
grep "Installation KO" $remote1_log
grep "BUILD_" $remote1_log
) &
installation_id1=$!
# Test d'une extraction/installation d'une version kernel
(
extract_Version_TRUST ./$version_arch -install $remote2 -kernel_only 		1>>$remote2_log 2>&1
echo " "
if [ "`grep "BUILD_" $remote2_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote2_log 2>/dev/null`" != "" ]
then
   echo "Installation KO -kernel_only on $remote2"
   cat $remote2_log | mail_ -s\"[lance_test_nuit] Remote install kernel only failed on ${remote2##* }\" $TRUST_MAIL
   cp $remote2_log $TRUST_ROOT/simule_install_TRUST_kernel_only.log
else
   echo "Installation OK -kernel_only on $remote2"
fi
grep "Installation KO" $remote2_log
grep "BUILD_" $remote2_log
) &
installation_id2=$!
# Test d'une extraction/installation d'une version sans les sources
#(
#extract_Version_TRUST ./$version_arch -install $remote3 -without_source 	1>>$remote3_log 2>&1
#echo " "
#if [ "`grep "BUILD_" $remote3_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote3_log 2>/dev/null`" != "" ]
#then
#   echo "Installation KO -without_source on $remote3"
#   cat $remote3_log | mail_ -s\"[lance_test_nuit] Remote install without source failed on ${remote3##* }\" $TRUST_MAIL
#   cp $remote3_log $TRUST_ROOT/simule_install_TRUST_without_source.log
#else
#   echo "Installation OK -without_source on $remote3"
#fi
#grep "Installation KO" $remote3_log
#grep "BUILD_" $remote3_log
#) &
#installation_id3=$!
# On attend la fin des installations lancees en parallele
#wait $installation_id1 $installation_id2 $installation_id3 1>/dev/null 2>&1
wait $installation_id1 $installation_id2 1>/dev/null 2>&1
# S'il n'y a pas de logs, c'est que les installations ont toutes reussies
NB=`ls $REP_NUIT/simule_install_TRUST*.log 2>/dev/null | wc -l`
KO=`ls $TRUST_ROOT/simule_install_TRUST*.log 2>/dev/null | wc -l`
let OK=$NB-$KO
[ $NB = 0 ] && installation=0
[ $KO != 0 ] && installation=0
rm -f $TRUST_ROOT/simule_install_TRUST*.log
################################
# Test de la taille du DVD grave
################################
echo " "
echo "Test the size of the $version_arch package if it can be written to a DVD"
limite_Mo=2000
package_size=`ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{print $5/1000000}'`
export package_size=`printf '%0.f' $package_size`
if [ "`ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{if ($5>limite_Mo*1000000) print "KO"}'`" = KO ]
then
   msg="The package $version_arch on $GRAVAGE is too large ($package_size>"$limite_Mo"Mo) to be written to a DVD."
   tmp=`mktemp_`
   echo $msg > $tmp
   echo "More large files (>2Mo) in each VOB:" >> $tmp
   (
   cd $TRUST_ROOT
   for contenu in *gz.files
   do
      VOB=${contenu%.tar.gz.files}
      cd $TRUST_ROOT/../$VOB
      echo $VOB >> $tmp
      for file in `cat $TRUST_ROOT/$contenu`
      do
         [ -f $file ] && echo $file
      done | xargs ls -l | awk '{if ($5>2000000) print $5" "$NF}' | sort -nr >> $tmp
      cd - 1>/dev/null 2>&1
   done
   )
   cat $tmp | mail_ -s\"[lance_test_nuit] Problem of $version_arch package size that is too large to be delivered.\" $TRUST_MAIL
   cat $tmp
   rm -f $tmp
   installation=0
   echo "  Size $package_size > "$limite_Mo"Mo KO"
elif [ "$package_size" = 0 ]
then
   installation=0
   echo "  Size $package_size >< "$limite_Mo"Mo KO"
else
   echo "  Size $package_size < "$limite_Mo"Mo OK"
fi
cd - 1>/dev/null 2>&1
echo " "
if [ "$installation" = 1 ]
then
   echo "Release criterion: Installation OK"
else
   echo "Release criterion: Installation KO"
fi
force_installation=~/force_installation && [ -f $force_installation ] && installation=1 && rm -f $force_installation
[ "$NB" -eq 0 ] && NB=-1
if [ "$NB" -eq -1 ]
then
   echo "$installation  Installation $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" + size="$package_size"Mo (=1+size<"$limite_Mo"Mo)" >> $MESSAGES_NUIT
   NB=0
else
   echo "$installation  Installation $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" + size="$package_size"Mo (=1+size<"$limite_Mo"Mo)" >> $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$installation
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################################################
# Attente jusqu'a pour attendre le retour des compilations eloignees:
#####################################################################
# sauf le week-end (on attend le dimanche car lance_test_nuit via crontab non lance le week-end)
if [ "`date '+%u'`" -lt 6 ]
then
   while [ `date '+%H'` -lt 6 ] || [ `date '+%H'` -gt 21 ]
   do
      sleep 30
   done
else
   # Attente jusqu'au lundi matin
   while [ "`date '+%u'`" -gt 5 ]
   do
      sleep 30
   done
fi
  
#####################################################
# Arret de la portabilite des baltik si non terminee:  
#####################################################
echo " "
echo "##########################################"
echo "# Verify the end of baltik portabilities #"
echo "##########################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
for Composant in $Composants
do
   if [ -d $TRUST_ROOT/../Composants/$Composant ]
   then
      cd $TRUST_ROOT/../Composants/$Composant
      echo "Check $Composant"
      if [ ! -f  nuit_$Composant.html ] # Fichier non cree donc portabilite non terminee
      then
         #nbtot=`sed -n '$=' Run.liste` # Nombre total de machines surlesquelles c est teste
         (grep PID $Composant*.log | grep start | awk '{$NF=""; print $0}') 1>start.liste 2>/dev/null # Nombre de start (4 x nbtot)
         (grep PID $Composant*.log | grep stop | awk '{$NF=""; print $0}') 1>stop.liste 2>/dev/null # Nombre de stop
	 sort start.liste stop.liste | uniq -u 1>kill.liste 2>/dev/null # Pour chaque start non stoppe, recuperer le nom de la machine et le PID
         if [ `cat kill.liste | wc -l` = 0 ]
	 then
	    echo "  => The portability was NOT launched"
	 else
	    cat kill.liste
	    echo "  => KO: portability is NOT finished"
            old_IFS=$IFS  # sauvegarde du sparateur de champ  
            IFS=$'\n'     # nouveau sparateur de champ, le caractre fin de ligne  
	    for line in $(cat kill.liste)
	    do
	      (
	       PID=`echo $line | awk '{print $(NF)}'`
	       adr=`echo $line | awk -F"@" '{print $2}' | awk -F"_" '{print $1}'`
	       log=`echo $line | awk -F"@" '{print $1}' | awk -F"%" '{print $2}' | awk -F"_" '{print $2}'`
	       machine=`echo $adr | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`
               WORKTMP=`ssh_ -o BatchMode=yes $log@$adr -n 'if [ "\$WORKDIR" = "" ]; then echo \$HOME;else echo \$WORKDIR;fi'`
	       echo "  Treatment of $PID on $machine"
	       pids=$(ssh $log@$adr $WORKTMP/$WORKBASE$machine/TRUST/bin/baltik/share/baltik/bin/portability/list_pid_et_fils.sh $PID)
	       echo "    ssh $log@$adr kill -9 $pids"
	       ssh $log@$adr kill -19 $pids
	       ssh $log@$adr kill -9 $pids
	      ) 
	    done
	    IFS=$old_IFS  # rtablissement du sparateur de champ par dfaut
	 fi 
	 rm -f start.liste stop.liste kill.liste
      else
         echo "  => OK: portability is finished"
	 cp nuit_$Composant.html $REP_NUIT/nuit_$Composant.html
      fi 
   fi
done
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################################################
# Attente 1h pour attendre le retour des portabilites eloignees:
#####################################################################
if [ "`date '+%u'`" -lt 6 ]
then
   while [ `date '+%H'` -lt 7 ] || [ `date '+%H'` -gt 21 ]
   do
      sleep 30
   done
else
   while [ "`date '+%u'`" -gt 5 ]
   do
      sleep 30
   done
fi
  
#######################################################
# Arret des etudes lancees a distance si non terminees:  
#######################################################
echo " "
echo "#################################"
echo "# Verify the end of studies run #"
echo "#################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $ETUDES
echo "Check $ETUDES"
if [ "$etude_activation" = 0 ] 
then
   echo "  => The run_Etudes was NOT launched"
else
   if [ -f run_Etudes.log ] # Fichier non deplace dans REP_NUIT donc run non termine
   then
      grep PID run_Etudes.log
      echo "  => KO: run_Etudes is NOT finished"
      PID=`grep PID run_Etudes.log | grep start | awk '{$NF=""; print $0}' | awk '{print $(NF)}'`
      pids=$($TRUST_ROOT/bin/baltik/share/baltik/bin/portability/list_pid_et_fils.sh $PID)
      echo "    kill -9 $pids"
      echo "    KO: to do manually and check scancel on callisto" # Temporary
      #kill -19 $pids
      #kill -9 $pids
   else
      echo "  => OK: run_Etudes is finished"
   fi
fi
cd $TRUST_ROOT
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
 
##########################################################
# Recupere les executables et divers fichiers sur machines
##########################################################
echo " "
echo "#####################################################"
echo "# Receive from remote machines and copy on ftp site #"
echo "#####################################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $TRUST_ROOT
export binaire=1
recupere_log=$REP_NUIT/recupere_TRUST_arch_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/recupere_TRUST_arch"
echo "  See $recupere_log"
echo "TRUST script on $HOST the `date` ...">$recupere_log
echo>>$recupere_log
recupere_TRUST_arch 1>>$recupere_log 2>&1
grep KO $recupere_log
grep -i portage $recupere_log
if [ ${#liste_machines_KO} != 0 ] # chaine non vide
then
   echo "  Recall liste_machines_KO:"
   echo $liste_machines_KO
fi
echo "  Creation of $REP_NUIT/NUIT.html"
ls -la $REP_NUIT"/NUIT.html"
cd $TRUST_ROOT

for file in `ls $REP_NUIT/install_patch_*.log 2>/dev/null`
do
   echo " "
   echo "Analysis of $file file"
   head -n4 $file | tail -n1
   grep "BUILD_" $file
   grep error $file
   grep Stop $file
   grep KO $file
done

for file in `ls $REP_NUIT/lance_test_*.log 2>/dev/null`
do
   echo " "
   echo "Analysis of $file file"
   fic_test=`grep "Complete results into the file" -A 1 $file | tail -n 1`
   grep "Error:" $fic_test
   grep "Successful tests cases" $fic_test
done

echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##################
# Stabilite TRUST
##################
echo " "
echo "############################"
echo "# Test the TRUST stability #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
fic_test=$TRUST_ROOT"/exec/.tests_TRUST"$COMM
rm -f tmp.log 
echo "Analysis of "$fic_test" file" | tee -a tmp.log
grep "Successful tests cases" $fic_test | tee -a tmp.log
echo " " | tee -a tmp.log
fic_test=$TRUST_ROOT"/exec/.tests_TRUST"$COMM"_semi_opt" | tee -a tmp.log
echo "Analysis of "$fic_test" file" | tee -a tmp.log
grep "Successful tests cases" $fic_test | tee -a tmp.log
echo " " | tee -a tmp.log
if [ -f $fic_test ]
then
   stabilite=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | sort -n | head -1`
   rstab=`$TRUST_Awk -F':' 'BEGIN {} /Successful tests cases/ {print $2}' $fic_test | sort -n | head -1`
else
   stabilite="0.000"
   rstab="0/0"
fi
if [ "$stabilite" = "1.000" ]
then
   echo "Release criterion: Stability OK"
else
   echo "Release criterion: Stability KO"
   cat tmp.log | mail_ -s\"[lance_test_nuit] $rstab=$stabilite TRUST stability KO\" $TRUST_MAIL
fi
force_stabilite=~/force_stabilite && [ -f $force_stabilite ] && stabilite="1.000" && rm -f $force_stabilite
echo `if [ "$stabilite" = "1.000" ]; then echo 1;else echo 0;fi`"  Stability $rstab=$stabilite (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+`if [ "$stabilite" = "1.000" ]; then echo 1;else echo 0;fi`
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

####################
# Portabilite TRUST
####################
echo " "
echo "###############################"
echo "# Test the TRUST portability #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step TRUST" $recupere_log
grep "step TRUST" $recupere_log | grep -v "1.000" > tmp.log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html >> tmp.log
grep "TRUST portability" $REP_NUIT/NUIT.html
all_cible=`$TRUST_Awk '/Total number portability/ {print $9}' $REP_NUIT/NUIT.html`
nb_cible=`$TRUST_Awk '/Total number portability/ {print $7}' $REP_NUIT/NUIT.html`
portabilite_test=`$TRUST_Awk '/TRUST portability/ {print $1}' $REP_NUIT/NUIT.html`
portabilite_trust=`$TRUST_Awk '/TRUST portability/ {print $6}' $REP_NUIT/NUIT.html`
portabilite=0 && [ "`grep "Portable version" $REP_NUIT/NUIT.html`" != "" ] && portabilite=1
echo " "
if [ "$portabilite" = 1 ]
then
   echo "Release criterion: TRUST  OK"
else
   echo "Release criterion: TRUST  KO"
   grep "No PERF report of" $recupere_log >> tmp.log
   cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST portability KO on cible host:\" $TRUST_MAIL
fi
force_portabilite=~/force_portabilite && [ -f $force_portabilite ] && portabilite=1 && rm -f $force_portabilite
limite=0.99 # cf recupere_TRUST_arch
echo "$portabilite  Portability $portabilite_trust=$portabilite_test + nb=$nb_cible (>$limite+nb=$all_cible)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$portabilite
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
force_cible=~/force_cible && [ -f $force_cible ] && nb_cible=$all_cible && rm -f $force_cible

###################
# Test d'un atelier
###################
echo " "
echo "#####################################"
echo "# Test the compilation of a atelier #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step atelier" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "TRUST atelier compilation" $REP_NUIT/NUIT.html
make_atelier=`$TRUST_Awk '/atelier compilation/ && /TRUST/ {print $1}' $REP_NUIT/NUIT.html`
port_atelier=`$TRUST_Awk '/atelier compilation/ && /TRUST/ {print $7}' $REP_NUIT/NUIT.html`
workshop=0
[ "$make_atelier" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && workshop=1
echo " "
if [ "$workshop" = 1 ]
then
   echo "Release criterion: Atelier OK"
else
   echo "Release criterion: Atelier KO"
   grep "ATELIER=KO" $REP_NUIT/CR_* > tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST atelier KO on host:\" $TRUST_MAIL
fi
force_make_atelier=~/force_make_atelier && [ -f $force_make_atelier ] && workshop=1 && rm -f $force_make_atelier
echo "$workshop  Atelier $port_atelier=$make_atelier (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$workshop
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################
# Portabilite Xprepro
#####################
echo " "
echo "################################"
echo "# Test the Xprepro portability #"
echo "################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step Xprepro" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "Xprepro portability" $REP_NUIT/NUIT.html
Xprepro=`$TRUST_Awk '/Xprepro portability with TRUST/ {print $1}' $REP_NUIT/NUIT.html`
port_Xprepro=`$TRUST_Awk '/Xprepro portability with TRUST/ {print $8}' $REP_NUIT/NUIT.html`
portabilite_Xprepro=`echo $Xprepro | $TRUST_Awk '{if ($1>=1) print 1;else print 0}'`
[ "$nb_cible" != "$all_cible" ] && portabilite_Xprepro=0
echo " "
if [ "$portabilite_Xprepro" = 1 ]
then
   echo "Release criterion: Xprepro OK"
else
   echo "Release criterion: Xprepro KO"
   grep "XPREPRO=KO" $REP_NUIT/CR_* > tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] XPREPRO KO on host:\" $TRUST_MAIL
fi
force_portabilite_Xprepro=~/force_portabilite_Xprepro && [ -f $force_portabilite_Xprepro ] && portabilite_Xprepro=1 && rm -f $force_portabilite_Xprepro
echo "$portabilite_Xprepro  Xprepro $port_Xprepro=$Xprepro (>=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$portabilite_Xprepro
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#######################
# Portabilite de BALTIK
#######################
echo " "
echo "###############################"
echo "# Test the Baltik portability #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step Baltik" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "Baltik portability" $REP_NUIT/NUIT.html
portabilite_baltik=`$TRUST_Awk '/Baltik portability/ && /TRUST/ {print $1}' $REP_NUIT/NUIT.html`
port_baltik=`$TRUST_Awk '/Baltik portability/ && /TRUST/ {print $8}' $REP_NUIT/NUIT.html`
testbaltik=0
[ "$portabilite_baltik" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && testbaltik=1
echo " "
if [ "$testbaltik" = 1 ]
then
   echo "Release criterion: Baltik  OK"
else
   echo "Release criterion: Baltik  KO"
   grep "BALTIK=KO" $REP_NUIT/CR_* > tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST baltik KO on host:\" $TRUST_MAIL
fi
force_portabilite_baltik=~/force_portabilite_baltik && [ -f $force_portabilite_baltik ] && testbaltik=1 && rm -f $force_portabilite_baltik
echo "$testbaltik  Baltik $port_baltik=$portabilite_baltik (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$testbaltik
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

################################
# Test des assert de compilation
################################
echo " "
echo "###############################"
echo "# Test the compilation assert #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step assert" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "Compilation assert test" $REP_NUIT/NUIT.html
test_assert=`$TRUST_Awk '/Compilation assert/ {print $1}' $REP_NUIT/NUIT.html`
port_assert=`$TRUST_Awk '/Compilation assert/ {print $7}' $REP_NUIT/NUIT.html`
assert=0
[ "$test_assert" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && assert=1
echo " "
if [ "$assert" = 1 ]
then
   echo "Release criterion: Assert OK"
else
   echo "Release criterion: Assert KO"
   grep "ASSERT=KO" $REP_NUIT/CR_* > tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST assert KO on host:\" $TRUST_MAIL
fi
force_test_assert=~/force_test_assert && [ -f $force_test_assert ] && assert=1 && rm -f $force_test_assert
echo "$assert  Assert $port_assert=$test_assert (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$assert
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

############################
# Disponibilite des binaires
############################
echo " "
echo "######################################"
echo "# Test the disponibility of binaries #"
echo "######################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
nb_binaires=0
porta_binaires=0
dispo_binaires=0
disponibilite_binaires=0
machine=`liste_machines "get_binary" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}' | head -1`
echo "Analysis of $WORKDIR/PORTAGE_$new directory"
binaires=`ls $WORKDIR/PORTAGE_$new/*/TRUST/exec/TRUST*opt* 2>/dev/null`
[ "$binaires" = "" ] && echo "See $REP_NUIT/CR_$machine" | mail_ -s\"[lance_test_nuit] No binary created under $WORKDIR/PORTAGE_$new/*/TRUST/exec\" $TRUST_MAIL
for binaire in $binaires
do
   let nb_binaires=$nb_binaires+1
   cd $TRUST_TMP
   rm -f nul.data
   touch nul.data
   echo $ECHO_OPTS "  Test of binary $binaire \c"
   $binaire nul 1>binaire.out 2>&1
   if [ $? != 0 ]
   then
      echo "KO"
      cat binaire.out | mail_ -s\"[lance_test_nuit] Binary $binaire KO\" $TRUST_MAIL
   else
      let porta_binaires=$porta_binaires+1
      echo "OK"
   fi
   cd - 1>/dev/null 2>&1
done
[ "$nb_binaires" != 0 ] && dispo_binaires=`echo $porta_binaires | $TRUST_Awk -v n=$nb_binaires '{print "scale=3\n"$1"/"n}' | bc -l`
disponibilite_binaires=`echo $dispo_binaires | $TRUST_Awk '{if ($1>=1) print 1;else print 0}'`
echo " "
if [ "$disponibilite_binaires" = 1 ]
then
   echo "Release criterion: Binaries OK"
else
   echo "Release criterion: Binaries KO"
fi
force_disponibilite_binaires=~/force_disponibilite_binaires && [ -f $force_disponibilite_binaires ] && disponibilite_binaires=1 && rm -f $force_disponibilite_binaires
echo "$disponibilite_binaires  Binairies $porta_binaires/$nb_binaires=$dispo_binaires (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$disponibilite_binaires
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

############
# Test XData
############
echo " "
echo "##################################"
echo "# Verify the validation of XData #"
echo "##################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
validation_xdata=""
machines=`liste_machines "\-xdata" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -xdata on $machines"
# Si une machine a XData qui fonctionne c'est OK
for machine in $machines
do
   check_xdata_log=$REP_NUIT"/check_xdata_"$machine".log"
   rm -f $check_xdata_log
   if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "  KO $machine machine not accessible via ssh."
      echo "  No $check_xdata_log"
      validation_xdata=0
      echo | mail_ -s\"[lance_test_nuit] Error when receiving XData log from $machine not accessible via ssh.\" $TRUST_MAIL
   else
      echo "  See $check_xdata_log"
      #scp triou@$machine:~/$WORKBASE$machine/TRUST/Outils/TRIOXDATA/check_xdata.log $check_xdata_log
      if  [ "${machine:0:2}" = "is" ]
      then
         #scp triou@$machine:$WORKDIR/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log
         scp triou@$machine:/export/home/triou/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log 1>/dev/null 2>&1
         scp_error=$?
         [ $scp_error != 0 ] && scp triou@$machine:/volatile/triou/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log && scp_error=$?
      else
         scp triou@$machine:~/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log
         scp_error=$?
      fi
      if [ $scp_error != 0 ]
      then
         echo | mail_ -s\"[lance_test_nuit] Error when receiving XData log from $machine. Check if not finished.\" $TRUST_MAIL
      else
         grep 'XDATA=' $check_xdata_log
      fi
      rm -f $scp_error
      if [ "`grep 'XDATA=OK' $check_xdata_log 2>/dev/null`" != "" ]
      then
         validation_xdata=1
      else
         [ "$validation_xdata" = "" ] && validation_xdata=0
         [ -f $check_xdata_log ] && cat $check_xdata_log | mail_ -s\"[lance_test_nuit] Check XData on $machine KO\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
      fi
   fi
done
echo " "
if [ "$validation_xdata" = 1 ]
then
   echo "Release criterion: XData OK"
else
   echo "Release criterion: XData KO"
fi
force_validation_xdata=~/force_validation_xdata && [ -f $force_validation_xdata ] && validation_xdata=1 && rm -f $force_validation_xdata
echo "$validation_xdata  XData $validation_xdata (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_xdata
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########################
# Verification des modules
##########################
echo " "
echo "####################################"
echo "# Verify the validation of Modules #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
activation_verification_modules=0 # Non actualise
if [ "$activation_verification_modules" = 1 ]
then
   cd $TRUST_ROOT/Validation/Modules
   # Lancement d'un cas test par module:
   echo "Call to $TRUST_ROOT/Validation/Modules/Test.sh"
   ./Test.sh
   if [ $? != 0 ]
   then
      echo "  Error in one case per module"
      echo " "
      echo "Release criterion: Modules KO"
   else 
      echo "  Lauching of one case per module OK"
      # Recuperation de tous les cas tests par module
      modules=`cd $TRUST_ROOT/Validation/Modules;ls */cree_liste_cas | $TRUST_Awk -F/ '{print $1}'`
      echo " "
      if [ "${#modules}" = 0 ]
      then
         ok=0
         nb=-1
	 echo "Zero module in $TRUST_ROOT/Validation/Modules directory"
      else
	 echo "Modules in $TRUST_ROOT/Validation/Modules directory:"
         echo modules
         ok=0
         nb=0
         for module in $modules
         do
	    echo " "
	    echo "Verification of $TRUST_ROOT/Validation/Modules/$module"
	    cd $TRUST_ROOT/Validation/Modules/$module
	    rm -f $module.log
	    machine=`liste_machines "\-verification_module_$module"`
	    if [ "$machine" != "" ]
	    then
	       let nb=$nb+1
	       hostname=`echo $machine | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
	       module_log=$REP_NUIT"/Modules_"$module"_"$hostname".log"
	       echo "  Receive tests of $module module from $hostname"
	       log=`awk -v adr=$machine '($2==adr) {print $4}' ~/.netrc | head -1`
	       scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/$module.log . 2>/dev/null
	       scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/compare_resultat.log . 2>/dev/null
	       # On efface les rapports precedants
	       rm -f .tests_TRUST_*
	       scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/.tests_TRUST_* . 2>/dev/null
	       if [ ! -f $module.log ]
	       then
                  echo | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host no made or no recovered.\" $TRUST_MAIL 
	       else
	          if [ "`grep $module=OK $module.log 2>/dev/null`" != "" ]
	          then
        	     let ok=$ok+1
	          else    
		     if [ "`grep $module=KO $module.log 2>/dev/null`" != "" ]
		     then
        	        [ ! -f compare_resultat.log ] && ../compare_resultat .tests_TRUST_mpi_*
        	        cat compare_resultat.log | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host KO\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
		     else
		        cat .tests_TRUST_mpi_* | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host not finished\" $TRUST_MAIL
		     fi
	          fi
	          # Mise a jour de la reference
	          if [ "`grep 'On change la reference' $module.log`" != "" ]
	          then
        	     echo "  Update reference of $module module"
        	     CHECKOUT res_test_ref 1>/dev/null 2>&1
		     new_rapport=`ls -rt .tests_TRUST_* | grep -v KO | grep -v OK 2>/dev/null | tail -1`
		     [ "$new_rapport" != "" ] && cat $new_rapport > res_test_ref
	          fi
	       fi
	       # Faire une page html regroupant l'ensemble des resultats
	    fi
         done
	 [ $nb -eq 0 ] && nb=-1
      fi
      verification_modules=0 && [ $ok -eq $nb ] && verification_modules=1
      echo " "
      if [ "$verification_modules" = 1 ]
      then
         echo "Release criterion: Modules OK"
      else
         echo "Release criterion: Modules KO"
      fi
      force_verification_modules=~/force_verification_modules && [ -f $force_verification_modules ] && verification_modules=1 && rm -f $force_verification_modules
      echo "$verification_modules  Modules $ok/$nb="`echo $ECHO_OPTS "scale=3;$ok/$nb" | bc -l`" (=1.000)" >> $MESSAGES_NUIT
      let total_criteres=$total_criteres+1
      let criteres_remplis=$criteres_remplis+$verification_modules
   fi
   cd $TRUST_ROOT
else
   echo "NOT executed"
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########
# Valgrind
##########
echo " "
echo "#####################################"
echo "# Verify the validation of Valgrind #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
# Recuperer le ANA.log sur les machines valgrind
cd $TRUST_ROOT/Validation/Valgrind
Build=$TRUST_ROOT/build/Validation/Valgrind
[ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
rm -f $Build/ANA_*.log $Build/casmem_* $Build/caserr_*
machines=`liste_machines "\-valgrind" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [ "${#machines}" = 0 ]
then
   valgrind=0
else
   valgrind=1
   echo "Validation by -valgrind on"
   echo $machines
   echo " "
fi
for machine in $machines
do
   valgrind_log=$Build"/ANA_"$machine".log"
   if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "  KO $machine machine not accessible via ssh."
      echo "  No $valgrind_log"
      valgrind=0
      echo | mail_ -s\"[lance_test_nuit] Error when receiving Valgrind log from $machine not accessible via ssh.\" $TRUST_MAIL
   else
      echo "Verification of $valgrind_log"
      #scp triou@$machine:~/$WORKBASE$machine/TRUST/Validation/Valgrind/ANA.log $valgrind_log
      if [ "${machine:0:2}" = "is" ]
      then
         #scp triou@$machine:$WORKDIR/.tmp_TRUST_$machine/ANA.log $valgrind_log
         scp triou@$machine:/export/home/triou/.tmp_TRUST_$machine/ANA.log $valgrind_log 1>/dev/null 2>&1
         scp_error=$?
         [ $scp_error != 0 ] && scp triou@$machine:/volatile/triou/.tmp_TRUST_$machine/ANA.log $valgrind_log && scp_error=$?
      else
         scp triou@$machine:~/.tmp_TRUST_$machine/ANA.log $valgrind_log
         scp_error=$?
      fi
      if [ $scp_error != 0 ]
      then
         echo | mail_ -s\"[lance_test_nuit] Error when receiving Valgrind log from $machine. Check if not finished.\" $TRUST_MAIL
      fi
      rm -f $scp_error
      sleep 1
      if [ ! -f $valgrind_log ]
      then
         echo "  valgrind not finished"
         valgrind=0
      else
         #scp triou@$machine:~/$WORKBASE$machine/TRUST/Validation/Valgrind/casmem $Build/casmem_$machine
         if [ "${machine:0:2}" = "is" ]
         then
            #scp triou@$machine:$WORKDIR/.tmp_TRUST_$machine/casmem $Build/casmem_$machine
            scp triou@$machine:/export/home/triou/.tmp_TRUST_$machine/casmem $Build/casmem_$machine 1>/dev/null 2>&1
            [ $? != 0 ] && scp triou@$machine:/volatile/triou/.tmp_TRUST_$machine/casmem $Build/casmem_$machine
         else
            scp triou@$machine:~/.tmp_TRUST_$machine/casmem $Build/casmem_$machine
         fi
         cat $valgrind_log 2>/dev/null | $TRUST_Awk -F: '/ errors from /{gsub("\\.val","",$2);print $2}' > $Build/caserr_$machine
         valgrind_max=0
         valgrind_err=`cat $Build/caserr_$machine 2>/dev/null | wc -l`
         # On supprime les cas de casmem qui se retrouvent dans liste (cas qui se sont arretes)
         grep -v -f $TRUST_ROOT/exec/tests_TRUST$COMM"_semi_opt"/liste $Build/casmem_$machine > cas
         valgrind_leak=`cat cas 2>/dev/null | wc -l`
         rm -f cas
         let valgrind_err=$valgrind_err+$valgrind_leak
         echo "  valgrind $valgrind_err errors including $valgrind_leak memory leak ($valgrind_err<=$valgrind_max)"  
         [ ! "$valgrind_err" = 0 ] && echo "    See $Build/caserr_$machine" #&& cat $Build/caserr_$machine
         [ ! "$valgrind_leak" = 0 ] && echo "    See $Build/casmem_$machine" #&& cat $Build/casmem_$machine
         if [ ${#valgrind_err} = 0 ] || [ $valgrind_err -gt $valgrind_max ]
         then
            valgrind=0 
	    # Envoi d'un mail pour prevenir immediatement
	    cat $Build/caserr_$machine $Build/casmem_$machine >> $TRUST_TMP/cas
	    if [ -s $TRUST_TMP/cas ]
	    then
	       log_filtre=`mktemp_`
	       grep -v -f $TRUST_ROOT/exec/tests_TRUST$COMM"_semi_opt"/liste $valgrind_log 1>$log_filtre 2>&1
	       echo "-----------" >>$log_filtre
	       cat $TRUST_TMP/cas >>$log_filtre
	       [ -s $log_filtre ] && cat $log_filtre | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects TRUST errors on $machine host\" -c $TRUST_MAIL $TMA_PROJECT_LEADER
               rm -f $log_filtre
	    fi
         fi
      fi
   fi
done
cd $TRUST_ROOT
echo " "
for Composant in $Composants
do
   PROJECT_ROOT=`dirname $TRUST_ROOT`/Composants/$Composant
   rm tmp.log 2>/dev/null
   for machine in $machines
   do
      # Check if valgrind for this composant:
      grep valgrind $PROJECT_ROOT/*$Composant*$machine*prepare.log 2>/dev/null > list.log
      if [ -s list.log ]
      then
         testko=`grep "make_check KO" $PROJECT_ROOT/*$Composant*$machine*make_check.log`
         if [ "$testko" != "" ]
	 then
	    echo $testko
	    echo $machine >> tmp.log
            grep " CORE " $PROJECT_ROOT/*$Composant*$machine*make_check.log | awk -F"|" '{print $NF}' >> tmp.log
            echo " " >> tmp.log
	    valgrind=0
	 fi
      fi
      rm list.log
    done
    if [ -s tmp.log ]
    then
       echo " "
       BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
       cat tmp.log | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects $Composant errors on host:\" -c ${!BALTIK_PROJECT_LEADER} -c $TRUST_MAIL $TMA_PROJECT_LEADER
    fi
    rm tmp.log 2>/dev/null
done
echo "Analysis of $REP_NUIT/CR_* files"
OK=`grep "KVALGRIND=OK" $REP_NUIT/CR_* 2>/dev/null | wc -l`
KO=`grep "KVALGRIND=KO" $REP_NUIT/CR_* 2>/dev/null | wc -l`
let NB=$OK+$KO
if [ $KO != 0 ]
then
   grep "KVALGRIND=KO" $REP_NUIT/CR_*
   (
   grep "KVALGRIND=KO" $REP_NUIT/CR_*  | cut -d_ -f2 | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects TRUST errors with upwind test case on host:\" -c $TRUST_MAIL $TMA_PROJECT_LEADER
   )
   valgrind=0
fi
echo " "
if [ "$valgrind" = 1 ]
then
   echo "Release criterion: Valgrind OK"
else
   echo "Release criterion: Valgrind KO"
fi
force_valgrind=~/force_valgrind && [ -f $force_valgrind ] && valgrind=1 && rm -f $force_valgrind
echo "$valgrind  Valgrind $valgrind (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$valgrind
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
echo " "
echo "############################"
echo "# Verify the code coverage #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
#############
# GCOV/LCOV #
#############
repertoire_gcov=$TRUST_ROOT/MonoDir$COMM/src
machines=`liste_machines "\-all" "\-gcov"`
echo "Validation by -gcov on $machines"
if [ "$machines" = "" ]
then
   echo "  No coverage by gcov!!!" 
   echo "Warning: No host -all -gcov in liste.machines! No coverage by gcov." | mail_ -s\"[lance_test_nuit] GCOV/LCOV: NO coverage!!!\" $TRUST_MAIL
fi
for machine_gcov in $machines # Compilation avec -gcov et passage de tous les cas tests
do
   hostname=`echo $machine_gcov | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'` 
   echo "  Recovery from $hostname"
   if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine_gcov -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "    KO $machine_gcov machine not accessible via ssh." 
      echo "    No $REP_NUIT/analyse_couverture_$hostname.log"
   else
      echo "    See $REP_NUIT/analyse_couverture_$hostname.log"
      if  [ "${hostname:0:2}" = "is" ]
      then
         scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/analyse_couverture.log $REP_NUIT/analyse_couverture_$hostname.log
         scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/GCDA/ana/monana_out $REP_NUIT/monana_out_$hostname.log
         scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_out $REP_NUIT/gcov_out_$hostname.log
         scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_err $REP_NUIT/gcov_err_$hostname.log
      else
         scp triou@$machine_gcov:~/.tmp_TRUST_$hostname/tests/analyse_couverture.log $REP_NUIT/analyse_couverture_$hostname.log
         scp triou@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/monana_out $REP_NUIT/monana_out_$hostname.log
         scp triou@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_out $REP_NUIT/gcov_out_$hostname.log
         scp triou@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_err $REP_NUIT/gcov_err_$hostname.log
      fi
      # Copie cpp.gcov.tar.gz 
      file=cpp.gcov.tar.gz  
      #echo "    Copy $file to $TRUST_ROOT/doc/Coverage/" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
      echo "    Copy $file to $TRUST_TMP/"
      rm -f $TRUST_TMP/$file
      #scp triou@$machine_gcov:~/$WORKBASE$hostname/TRUST/doc/Coverage/$file $TRUST_TMP/$file
      if  [ "${hostname:0:2}" = "is" ]
      then
         scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
      else
         scp triou@$machine_gcov:~/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
      fi
      if [ "`diff $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file`" != "" ]
      then
         echo "    => updated"
         #CHECKOUT $TRUST_ROOT/doc/Coverage/$file 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         #mv -f $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file    # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
      else
         echo "    => NOT updated"
      fi
      #rm -f $TRUST_TMP/$file                  # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
      #ls -la $TRUST_ROOT"/doc/Coverage/"$file # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
      # Copie apres menage des fichiers .gcda et .gcno pour pouvoir utiliser tggcov_ plus loin
      #echo "    Copy *.gcda and *.gcno files to $repertoire_gcov"
      #for suffixe in gcda gcno
      #do
      #   find $repertoire_gcov -name '*'.$suffixe | xargs rm -f
      #   #scp triou@$machine_gcov:$WORKDIR/$WORKBASE$hostname/TRUST/MonoDir$COMM"_gcov"/src/[A-N]*.$suffixe $repertoire_gcov/.
      #   #scp triou@$machine_gcov:$WORKDIR/$WORKBASE$hostname/TRUST/MonoDir$COMM"_gcov"/src/[N-Z]*.$suffixe $repertoire_gcov/.
      #   #scp triou@$machine_gcov:$WORKDIR/$WORKBASE$hostname/TRUST/MonoDir$COMM"_gcov"/src/[a-z]*.$suffixe $repertoire_gcov/.
      #   scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/GCDA/ana/*.$suffixe $repertoire_gcov/. 1>/dev/null 2>&1
      #   find $repertoire_gcov -name '*'.$suffixe | wc -l
      #done
      # Copie lcov (genere sur la machine car compilateur et gcov doivent matcher)
      #echo "    Copy html directory to $TRUST_ROOT/doc/Coverage/lcov"
      #rm -r -f $TRUST_ROOT/doc/Coverage/lcov/html
      #mkdir $TRUST_ROOT/doc/Coverage/lcov/html
      #scp -r triou@$machine_gcov:$WORKDIR/$WORKBASE$hostname/TRUST/doc/Coverage/lcov/html $TRUST_ROOT/doc/Coverage/lcov
      #ls -l $TRUST_ROOT/doc/Coverage/lcov/ | grep html
   fi
done
###########
# PROFILE #
###########
# Recuperer des informations de couverture du code (ce n'est pas encore un critere de livraison)
machines=`liste_machines "\-all" "\-prof"`
echo " "
echo "Validation by -prof on $machines"
if [ "$machines" = "" ]
then
   echo "  No coverage by prof!!!" 
   echo "Warning: No host -all -prof in liste.machines! No coverage by prof." | mail_ -s\"[lance_test_nuit] PROFILE: NO coverage!!!\" $TRUST_MAIL
fi
for machine in $machines # Compilation avec -prof et passage de tous les cas tests
do
   cd $TRUST_ROOT/doc/Coverage
   hostname=`echo $machine | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
   echo "  Recovery from $hostname"
   if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "    KO $machine machine not accessible via ssh." 
      echo "    No $REP_NUIT/make_Couverture_$hostname.log"
   else
      echo "    See $REP_NUIT/make_Couverture_$hostname.log"
      if [ "${hostname:0:2}" = "is" ]
      then
         scp triou@$machine:$WORKDIR/.tmp_TRUST_$hostname/tests/make_Couverture.log $REP_NUIT/make_Couverture_$hostname.log
      else
         scp triou@$machine:~/.tmp_TRUST_$hostname/tests/make_Couverture.log $REP_NUIT/make_Couverture_$hostname.log
      fi
      error_log=`grep "Problem with the gprof command" $REP_NUIT/make_Couverture_$hostname.log`
      [ ${#error_log} != 0 ] && cat $REP_NUIT/make_Couverture_$hostname.log | mail_ -s\"[lance_test_nuit] Problem with the gprof command on $hostname in make_Couverture\" $TRUST_MAIL
      # Copie file 
      for file in list_methodes.gz list_methodes_non_appelees.gz dico.pkl.gz 
      do
         #echo "    Copy $file to $TRUST_ROOT/doc/Coverage/" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         echo "    Copy $file to $TRUST_TMP/"
         rm -f $TRUST_TMP/$file
         #scp triou@$machine:~/$WORKBASE$hostname/TRUST/doc/Coverage/$file $TRUST_TMP/$file
         if [ "${hostname:0:2}" = "is" ]
         then
            scp triou@$machine:$WORKDIR/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
         else
            scp triou@$machine:~/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
         fi
         if [ -f $TRUST_TMP/$file ] && [ "`diff $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file`" != "" ]
         then
            echo "    => updated"
            #CHECKOUT $TRUST_ROOT/doc/Coverage/$file 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
            #mv -f $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file    # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         else
            echo "    => NOT updated"
         fi
         #rm -f $TRUST_TMP/$file                  # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         #ls -la $TRUST_ROOT"/doc/Coverage/"$file # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         # Recuperation du rapport gprof de l'ensemble des cas tests de non regression si cree
         if [ "`grep 'GMON_DIR=""' $TRUST_ROOT/bin/lance_test`" = "" ]
         then
            cpu=all_tests.cpu 
            echo "    Copy $cpu to $TRUST_ROOT/doc/Coverage/"
            #CHECKOUT $cpu 
            if [ "${hostname:0:2}" = "is" ]
	    then
               scp triou@$machine:$WORKDIR/.tmp_TRUST_$hostname/tests/$cpu . #1>/dev/null 2>&1
	    else
               scp triou@$machine:~/.tmp_TRUST_$hostname/tests/$cpu . #1>/dev/null 2>&1
	    fi
            #CHECKIN $cpu
            ls -la $TRUST_ROOT"/doc/Coverage/"$cpu
         fi
      done
   fi
done
#
##########
# TGGCOV #
##########
# Mise a jour du repertoire doc/Coverage et verification que la couverture est a jour
cd $TRUST_ROOT/doc/Coverage
Build=$TRUST_ROOT/build/doc/Coverage
[ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
echo " "
echo "Verification of the coverage in `pwd`:"
# Creation des classes appellees ou non
(
cd $TRUST_ROOT/doc/Coverage
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -file"
listing=`mktemp_`
export PYTHONPATH=$PYTHONPATH:$TRUST_ROOT/bin/KSH
python -c "from Couv import nombre_de_cas_par_classe;nombre_de_cas_par_classe()" > $listing
# Classes non testees
for string in `$TRUST_Awk '/ 0 0/ {print $1}' $listing | sort`
do
   classe=`echo $string | $TRUST_Awk -F'|' '{print $1}'`
   path_fichier_cpp=`ViC $classe cpp -no_vi`
   if [ "$path_fichier_cpp" != "" ]
   then
      cpp=`basename $path_fichier_cpp`
      tc=`tggcov_ -file $cpp | awk '/File / {print "fichier couvert a "$1"%"}'`
   else
      # Fichier non trouve
      tc=""
   fi
   echo $ECHO_OPTS $string" \tdans \$TRUST_ROOT"${path_fichier_cpp#$TRUST_ROOT/.}" "$tc
done > $Build/liste_classes_non_testees
cat $Build/liste_classes_non_testees | grep Kernel > $Build/liste_classes_non_testees_Kernel
cat $Build/liste_classes_non_testees_Kernel | grep " 0.00" > $Build/liste_fichiers_Kernel_a_supprimer
for file in $Build/liste_classes_non_testees $Build/liste_classes_non_testees_Kernel $Build/liste_fichiers_Kernel_a_supprimer
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
# Classes testees
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -short -file"
html=$Build/liste_classes_testees.html
echo $ECHO_OPTS "<HTML><PRE>Critere\tCouvert\tTests\tClasse" > $html
for string in `$TRUST_Awk '!/ 0 0/ {print $1"|"$2"|"$3}' $listing`
do
   classe=`echo $string | $TRUST_Awk -F'|' '{print $1}'`
   nb_tests=`echo $string | $TRUST_Awk -F'|' '{print $2+$3}'`
   path_fichier_cpp=`ViC $classe cpp -no_vi`
   if [ "$path_fichier_cpp" != "" ]
   then
      fichier_cpp=`basename $path_fichier_cpp`
      taux_couverture=`tggcov_ -short -file $fichier_cpp | $TRUST_Awk '{print $1}'`
      critere=`echo $taux_couverture $nb_tests | $TRUST_Awk '{t=$1;n=$2;c=100*(0.01*t)**n;printf("%7.3f",c)}'`
   else
      fichier_cpp="not_found"
      taux_couverture="?????"
      critere="  0.000"
   fi
   echo $ECHO_OPTS "$critere\t$taux_couverture%\t$nb_tests\t<A HREF=cpp.gcov/$fichier_cpp.gcov>$classe</A>"
done | sort -nr >> $html
echo "</HTML>" >> $html
rm -f $listing
for file in $html
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
)
#
##########
# TGGCOV #
##########
# Calcul de la couverture du code par les cas tests
# Attention les .gcda et .gcno doivent etre du meme GCC
cd $repertoire_gcov
#On n'utilise plus ggcov car il faut le meme compilateur pour exploiter les .gcda et .gcno
#couverture_de_code=`tggcov -R all | $TRUST_Awk 'BEGIN {lines="??"} /Summary/ && /src/ {for (i=0;i<7;i++) getline;lines=$1} END {gsub("%","",lines);print lines}'`
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_"
echo "from `pwd`"
echo "    See $REP_NUIT/tggcov.log"
$TRUST_ROOT/bin/KSH/tggcov_ 1>$REP_NUIT/tggcov.log 2>&1
#tail -n2 $REP_NUIT/tggcov.log
couverture_de_code=`tggcov_ | $TRUST_Awk '/TRUST code/ {print $1}'`
cd - 1>/dev/null 2>&1
couverture_minimale=69.87 #v1.7.5 ; 70.04 v1.7.4 ; 69.61 v1.7.3 ; 69.28 v1.7.2 ; 65.26 v1.7.1
coverage=`echo $couverture_de_code | $TRUST_Awk -v m=$couverture_minimale '{if ($1>=m) print 1;else print 0}'`
if [ "$coverage" = 1 ]
then
   echo "    Code coverage $couverture_de_code% >= $couverture_minimale% of lines"
else
   echo "    Code coverage $couverture_de_code% < $couverture_minimale% of lines"
   cat $REP_NUIT/tggcov.log | mail_ -s\"[lance_test_nuit] Code coverage KO with $couverture_de_code% \< $couverture_minimale% of lines tested\" -c $TRUST_MAIL $TMA_PROJECT_LEADER
fi
#(
## Creation du rapport html
#cd $TRUST_ROOT/doc/Coverage
#cd html
#echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -html"
#echo "from `pwd`"
#echo "    See $REP_NUIT/tggcov_html.log"
#$TRUST_ROOT/bin/KSH/tggcov_ -html 1>$REP_NUIT/tggcov_html.log 2>&1
#tail -n1 $REP_NUIT/tggcov_html.log
##echo "    Update html.tgz on $TRUST_ROOT/doc/Coverage" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
#echo "    Update html.tgz on $TRUST_ROOT/doc/Coverage/html"
#tar cfz html.tgz *.html
## Mise a jour si different
#if [ "`diff -a html.tgz ../html.tgz 2>/dev/null;echo $?`" != 0 ]
#then
#   echo "    => updated"
#   #CHECKOUT ../html.tgz 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
#   mv -f html.tgz ../html.tgz            # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
#else
#   echo "    => NOT updated"
#   rm -f html.tgz   # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
#fi
#ls -la ../html.tgz  # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
#)
cd $TRUST_ROOT/doc/Coverage
echo "  Call to make in $TRUST_ROOT/doc/Coverage"
make clean # dossier Coverage/html supprime et Coverage/html/index.html vide car non mis  jour dans l'archive TRUST + all baltik
make
CPP_GCOV=$TRUST_ROOT/doc/Coverage/html/cpp.gcov
echo "  Verification of $CPP_GCOV"
#grep $DATE $CPP_GCOV/MAIN.cpp.gcov # Build a ete retire des fichiers MAIN.cpp
#if [ "`grep $DATE $CPP_GCOV/MAIN.cpp.gcov 2>/dev/null`" = "" ]
#then
#   echo "    KO"
#   echo "$CPP_GCOV KO. See on $machine_gcov host with the gcov TRUST binairy: `grep build $CPP_GCOV/MAIN.cpp.gcov`" | mail_ -s\"[lance_test_nuit] Coverage KO on $hostname host\" $TRUST_MAIL
#else
#   echo "    OK"
#fi
ls -la $CPP_GCOV/MAIN.cpp.gcov
for file in list_methodes list_methodes_non_appelees
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
# Nouveau pour 1.6.3: Comparaison de la couverture de code fichier par fichier par rapport a la version precedante (sous $WORKDIR/sourceforge/Maintenance)
(
cd $TRUST_ROOT/doc/Coverage/html/cpp.gcov
MAINTENANCE=$WORKDIR/sourceforge/Maintenance/TRUST
echo " "
echo "Comparison of code coverage between new and old versions"
echo "from `pwd`"
echo " and $MAINTENANCE/doc/Coverage/html/cpp.gcov"
echo "Call to bin/KSH/tggcov_ -short -file *.gcov"
[ ! -d $MAINTENANCE ] && echo "  Verification of test coverage impossible because $MAINTENANCE not exist." #&& coverage=0
log=`mktemp_`
for gcov in *.gcov
do
   if [ -f $MAINTENANCE/doc/Coverage/html/cpp.gcov/$gcov ]
   then
      file=${gcov%.gcov}
      new_coverage=`tggcov_ -short -file $file`
      old_coverage=`export TRUST_ROOT=$MAINTENANCE;tggcov_ -short -file $file`
      # Regression de la couverture de code (Le nombre de lignes non testees augmente si la couverture est pas nulle)
      couverture=`echo $old_coverage | awk '{print $1}'`
      lignes_non_testees_en_plus=`echo $new_coverage $old_coverage | awk '{split($2,new,"/");split($6,old,"/");print (new_coverage[2]-new_coverage[1])-(old_coverage[2]-old_coverage[1])}'`
      if [ $lignes_non_testees_en_plus -gt 0 ] && [ $couverture != 0.00 ]
      then
         echo $ECHO_OPTS "$lignes_non_testees_en_plus lines not tested more in $file"
	 # echo "  "sdiff $TRUST_ROOT/doc/Coverage/html/cpp.gcov/$gcov $MAINTENANCE/doc/Coverage/html/cpp.gcov/$gcov
	 # Mise en echec du critere de livraison:
	 #coverage=0
      fi
   fi
done | tee $log
# Pas au point, donc on ne signale rien:
#[ -s $log ] && cat $log | mail_ -s\"[lance_test_nuit] Regression code coverage between `basename $TRUST_ROOT_MASTER` and Maintenance:\" $TRUST_MAIL
rm -f $log
cd - 1>/dev/null 2>&1
)
echo " "
if [ "$coverage" = 1 ]
then
   echo "Release criterion: Code coverage OK"
else
   echo "Release criterion: Code coverage KO"
fi
echo "$coverage  Code coverage $couverture_de_code% (>=$couverture_minimale% of lines)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$coverage
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
echo " "
echo "################################"
echo "# Verify the keywords coverage #"
echo "################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "  Analysis of $credoc_log"
grep OK $credoc_log
grep KO $credoc_log
error_log=`grep 'error Doxygen' $credoc_log`
[ ${#error_log} != 0 ] && mail_ -s\"[credoc] Doxygen: Study of TRUST includes under `pwd`\" $TRUST_MAIL
#echo "    See $TRUST_ROOT/build/doc/TRUST/list_keywords_covered file"
#OK=`wc -l $TRUST_ROOT/build/doc/TRUST/list_keywords_covered | awk '{ print $1 }'`
#echo "    $OK keywords covered by test cases"
#echo "    See $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered file"
#KO=`wc -l $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered | awk '{ print $1 }'`
#echo "    $KO keywords NOT covered by test cases"
#let NB=$OK+$KO
# Mail de verification uniquement le week-end
#[ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ] && [ -f $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered ] && cat $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered | mail_ -s\"[lance_test_nuit] Tests coverage credoc: list of keywords NOT covered by test cases\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
#keywords_minimal=77.37 #v1.7.5
#
echo "    See $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata* files"
NB=`wc -l $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata | awk '{ print $1 }'`
OK=`wc -l $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested | awk '{ print $1 }'`
let KO=$NB-$OK
echo "    $OK keywords covered by test cases"
echo "    $KO keywords NOT covered by test cases"
keywords_minimal=82.89 #v1.7.5

echo " "
couverture_de_motcle=`echo $ECHO_OPTS "scale=2;100*$OK/$NB" | bc -l`
keywords=`echo $couverture_de_motcle | $TRUST_Awk -v m=$keywords_minimal '{if ($1>=m) print 1;else print 0}'`
if [ "$keywords" = 1 ]
then
   echo "    Keywords coverage $couverture_de_motcle% >= $keywords_minimal% tested "
else
   echo "    Keywords coverage $couverture_de_motcle% < $keywords_minimal% tested"
   cat $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested | mail_ -s\"[lance_test_nuit] Keywords coverage KO with $couverture_de_motcle% \< $keywords_minimal% tested\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
fi
echo " "
if [ "$keywords" = 1 ]
then
   echo "Release criterion: Keywords coverage OK"
else
   echo "Release criterion: Keywords coverage KO"
fi
echo "$keywords  Keywords coverage $OK/$NB=$couverture_de_motcle% (>=$keywords_minimal% tested)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$coverage
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
##############
# Parallelisme
##############
echo " "
echo "#####################################"
echo "# Test the stability of parallelism #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
machine=`liste_machines "\-Check_decoupage" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -Check_decoupage on $machine"
if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
then
   echo "  KO $machine machine not accessible via ssh." 
   echo "  No $REP_NUIT/Check_decoupage.ksh_$machine.log"
   echo | mail_ -s\"[lance_test_nuit] Error when receiving Check_decoupage log from $machine not accessible via ssh.\" $TRUST_MAIL
   stabilite_parallelisme=0
   resultat_parallelisme=0/0
   parallelism=0
   echo " "
   echo "Release criterion: Parallelism KO"
else
   echo "  See $REP_NUIT/Check_decoupage.ksh_$machine.log"
   if [ "${machine:0:2}" = "is" ]
   then
      #scp triou@$machine:$WORKDIR/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log
      scp triou@$machine:/export/home/triou/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log 1>/dev/null 2>&1
      [ $? != 0 ] && scp triou@$machine:/volatile/triou/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log
   else
      scp triou@$machine:~/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log
   fi
   error_log=`grep "Failure on " $REP_NUIT/Check_decoupage.ksh_$machine.log`
   [ ${#error_log} != 0 ] && cat $REP_NUIT/Check_decoupage.ksh_$machine.log | mail_ -s\"[lance_test_nuit] Check_decoupage.ksh on $machine KO\" $TRUST_MAIL
   file_log=$REP_NUIT"/PERF_TRUST"$COMM"_opt_linux_"$machine
   check_log=`mktemp_`
   echo "  Analysis of "$file_log" file" | tee -a $check_log
   if [ ! -f $REP_NUIT/Check_decoupage.ksh_$machine.log ]
   then
      stabilite_parallelisme=0
      resultat_parallelisme=0/0
      parallelism=0
   else
      grep "Decoupage...OK Execution...Arret Validite...KO" $file_log | tee -a $check_log
      grep "Failure on" $file_log | tee -a $check_log
      stabilite_parallelisme=`$TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print ok/procs}' $file_log`
      resultat_parallelisme=`$TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print ok"/"procs}' $file_log`
      $TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print cas " cases including "ok " OK to "procs" CPUs. Validity = "ok"/"procs" = "ok/procs" %"}' $file_log | tee -a $check_log
      parallelism=`echo $stabilite_parallelisme | $TRUST_Awk '{if ($1==1) print 1;else print 0}'`
   fi
   echo " " | tee -a $check_log
   if [ "$parallelism" = 1 ]
   then
      echo "Release criterion: Parallelism OK" | tee -a $check_log
   else
      echo "Release criterion: Parallelism KO" | tee -a $check_log
      echo "-------------------------------------------------------------------------------------------" >> $check_log
      echo " " >> $check_log
      [ "$error_log" != "" ] && cat $REP_NUIT/Check_decoupage.ksh_$machine.log >> $check_log
      cat $check_log | mail_ -s\"[lance_test_nuit] KO Check_decoupage script on $machine\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
   fi
   rm -f $check_log
fi
force_check_decoupage=~/force_check_decoupage && [ -f $force_check_decoupage ] && parallelism=1 && rm -f $force_check_decoupage
echo "$parallelism  Parallelism $resultat_parallelisme=$stabilite_parallelisme (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$parallelism
# Desormais le week-end sur pc tma, on met a jour les cas tests
# pour la balise PARALLEL OK
# Dangereux car blocages possibles
#if [ "`date '+%u'`" -gt 5 ]
#then
#   Check_decoupage.ksh -all -update
#fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##############
# Performances
##############
echo " "
echo "########################"
echo "# Test the performance #"
echo "########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
total=0
machines=`liste_machines "\-benchmark" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -benchmarck on"
echo $machines
nb_machines=0
for machine in $machines
do
   PERF=`ls $REP_NUIT/PERF_TRUST_*$machine 2>/dev/null`  
   echo "  Analysis of "$PERF" file"
   if [ -f "$PERF" ] && [ "`grep Run_bench $PERF`" != "" ]
   then
      # Aucune efficacite en dessous de 0.60 sur 4 processeurs et aucun cpu au dessus de 8s sur 1 processeur:
      perf=`$TRUST_Awk 'BEGIN {p=0} ($1==4) && (NF==12) && /\|/ {if ($(NF-1)>0.60) p=p+0.25} ($1==1) && (NF==12) && /\|/ {if ($3<8) p=p+0.25} END {print p}' $PERF`
      ([ "`liste_machines cible | grep $machine`" != "" ] || [ "`liste_machines tache | grep $machine`" != "" ]) && total=`echo "$total+$perf" | bc -l`
      echo "Time VDF and VEF on 1 CPU: < 8s ?"
      $TRUST_Awk '($1==1) && (NF==12) && /\|/ {print $3}' $PERF
      echo "Speed-UP VDF and VEF on 4 CPUs: > 0.60 ?"
      $TRUST_Awk '($1==4) && (NF==12) && /\|/ {print $(NF-1)}' $PERF
      if ([ "`liste_machines cible | grep $machine`" != "" ] || [ "`liste_machines tache | grep $machine`" != "" ])
      then
         echo "=> perf+=$perf (total=$total)"  
         let nb_machines=$nb_machines+1
      else
         echo "=> perf+=$perf"  
      fi
      [ $(echo " $perf < 1 " | bc) -eq 1 ] && cat $PERF | mail_ -s\"[lance_test_nuit] Benchmark on $machine KO\" $TRUST_MAIL
   else
      echo "File not exist => benchmark not executed on the machine: $machine"
   fi
done
#
if [ "$nb_machines" != 0 ]
then
   echo "Call to $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/Run_fiche"
   bench_log=$REP_NUIT"/benchmark_report_"$HOST".log"
   echo "  See $bench_log"
   echo "TRUST benchmarh report on $HOST the `date` ...">$bench_log
   echo>>$bench_log
   (Build=$TRUST_ROOT/build/tests/Reference/BENCHMARK;
    [ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build};
    rm -rf $Build/Rapport;
    cp -r $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport $Build/.;
    cd $Build/Rapport;Run_fiche 1>>$bench_log 2>&1
   )
   tail -n1 $bench_log
   if [ -f $TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf ]
   then
       # Envoi du rapport genere le week-end au project leader
      if [ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ]
      then
         echo "$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run_fiche" | mail_ -a\"$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Benchmark report generated `date '+%d/%m/%y'`\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
      else
         echo "$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run_fiche" | mail_ -a\"$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Benchmark report generated `date '+%d/%m/%y'`\" $TRUST_MAIL
      fi
   else
      cat $TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run.log | mail_ -s\"[lance_test_nuit] KO Benchmark report NOT generated `date '+%d/%m/%y'`\" $TRUST_MAIL
   fi
else
   echo "...no machine with benchmark option in $TRUST_ROOT/bin/admin/liste.machines file"
fi
#nb_machines=`echo $machines | $TRUST_Awk '{print NF}'`
performances=0 && [ $total = $nb_machines ] && [ $total != 0 ] && performances=1
echo " "
if [ "$performances" = 1 ]
then
   echo "Release criterion: Performance OK"
else
   echo "Release criterion: Performance KO"
fi
force_performances=~/force_performances && [ -f $force_performances ] && performances=1 && rm -f $force_performances
[ "$nb_machines" -eq 0 ] && nb_machines=-1
if [ "$nb_machines" -eq -1 ]
then
  echo "$performances  Performance $total/0="`echo $ECHO_OPTS "scale=3;$total/$nb_machines" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
  nb_machines=0
else
   echo "$performances  Performance $total/$nb_machines="`echo $ECHO_OPTS "scale=3;$total/$nb_machines" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$performances
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

###########
# ToDo list
###########
echo " "
echo "########################"
echo "# Verify the ToDo list #"
echo "########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $TRUST_ROOT/ToDo file"
nb_todo=`grep -c ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo`
echo "$nb_todo requests to do before the release of the next version"
nothing_todo=0 && [ "`grep ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo`" = "" ] && nothing_todo=1
# Envoi aux personnes concernees le lundi avant COSUIV
for qui in `$TRUST_Awk '!/Qui/ {print $2}' $TRUST_ROOT/ToDo | sort -u`
do
   grep $qui $TRUST_ROOT/ToDo | grep ${TRUST_VERSION%_beta} > $TRUST_TMP/ToDo
   [ -s $TRUST_TMP/ToDo ] && [ "`date '+%u'`" = 1 ] && cat $TRUST_TMP/ToDo | mail_ -s\"[lance_test_nuit] ToDo list for the version ${TRUST_VERSION%_beta}\" -c $TRUST_MAIL $qui
done
# Envoi la liste complete le jeudi au chef de projet pour planning debut de semaine prochaine
[ "`date '+%u'`" = 4 ] && cat $TRUST_ROOT/ToDo | mail_ -s\"[lance_test_nuit] ToDo list for next Monday COSUIV\" -c $TRUST_MAIL $TMA_PROJECT_LEADER
rm -f $TRUST_TMP/ToDo
#
echo " "
if [ "$nothing_todo" = 1 ]
then
   echo "Release criterion: ToDo OK"
else
   echo "Release criterion: ToDo KO"
fi
echo "$nothing_todo  ToDo $nb_todo (=0)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$nothing_todo
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

########
# Etudes
########
echo " "
echo "#####################################"
echo "# Verify the results of study cases #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $REP_NUIT/run_Etudes.log file"
grep "Study OK " $REP_NUIT/run*.log 2>/dev/null
grep "Study KO " $REP_NUIT/run*.log 2>/dev/null
OK=`grep "Study OK " $REP_NUIT/run*.log 2>/dev/null | wc -l`
KO=`grep "Study KO " $REP_NUIT/run*.log 2>/dev/null | wc -l`
let NB=$OK+$KO
echo "  $OK/$NB studies verified"
[ "$NB" -eq 0 ] && NB=-1 
validation_etudes=0 && [ $OK = $NB ] && validation_etudes=1
echo " "
if [ "$validation_etudes" = 1 ]
then
   echo "Release criterion: Studies OK"
else
   echo "Release criterion: Studies KO"
   [ "$NB" -gt 0 ] && cat $REP_NUIT/run_Etudes.log | mail_ -s\"[lance_test_nuit] Results of study cases KO\" $TRUST_MAIL
fi
if [ "$etude_activation" = 1 ] 
then
   if [ "$NB" -gt 0 ] && [ -f $ETUDES/Rapport/build/rapport.pdf ]
   then
      # Envoi du rapport genere le week-end au project leader
      if [ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ]
      then
         echo "$ETUDES/Rapport/Run_fiche" | mail_ -a\"$ETUDES/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Studies report generated `date '+%d/%m/%y'`\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
      else
         echo "$ETUDES/Rapport/Run_fiche" | mail_ -a\"$ETUDES/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Studies report generated `date '+%d/%m/%y'`\" $TRUST_MAIL
      fi
   else
      [ "$NB" -gt 0 ] && cat $ETUDES/Rapport/Run.log | mail_ -s\"[lance_test_nuit] KO Studies report NOT generated `date '+%d/%m/%y'`\" $TRUST_MAIL
   fi
fi
force_validation_etudes=~/force_validation_etudes && [ -f $force_validation_etudes ] && validation_etudes=1 && rm -f $force_validation_etudes
if [ "$NB" -eq -1 ]
then
  echo "$validation_etudes  Studies $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)" >> $MESSAGES_NUIT
  NB=0
else
  echo "$validation_etudes  Studies $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)" >> $MESSAGES_NUIT
fi
[ "$NB" -eq -1 ] && NB=0 
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_etudes
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

###########################################
# PROJETS BALTIK BASES SUR LE KERNEL ONLY #
###########################################
# CC 01/09/2015: desormais MPCube issu de git teste via check_component
#echo " "
#echo "#########################################"
#echo "# Test the portability of baltik MPCube #"
#echo "#########################################"
#echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
## Voir si dans le futur on ne peut pas faire converger la procedure check_components sur
## les projets Baltik place sous la VOBS Composants et ce projet Baltik.
#PROJECT_ROOT=$WORKDIR/MPCube/mpcube-portage166	# MPCube a porter pour 1.6.2
##log=$PROJECT_ROOT/check_baltik_project.log
#log=$REP_NUIT"/baltik_MPCube_"$HOST"_Kernel.log"
## Necessaire de mettre entre () car initialisation du projet Baltik
#(
#source $WORKDIR/sourceforge/Kernel/TRUST/env_TRUST.sh 1>/dev/null 2>&1
#cd $PROJECT_ROOT
#echo "Call to $WORKDIR/sourceforge/Kernel/TRUST/bin/admin/check_baltik_project"
#echo "from `pwd`"
#echo "  See $log"
#echo "MPCube project baltik check on $HOST the `date` ...">$log
#echo>>$log
#$WORKDIR/sourceforge/Kernel/TRUST/bin/admin/check_baltik_project 1>>$log 2>&1
#grep 'Projet Baltik' $log | grep OK
#cd - 1>/dev/null 2>&1
#)
#if [ "`grep 'Projet Baltik' $log | grep OK`" != "" ]
#then
#   validation_projets_baltik=1
#else
#   validation_projets_baltik=0
#   cat $log | mail_ -s\"[lance_test_nuit] Portability KO on Baltik $PROJECT_ROOT\" -c $TMA_PROJECT_LEADER $TRUST_MAIL
#fi
#echo " "
#if [ "$validation_projets_baltik" = 1 ]
#then
#   echo "Release criterion: MPCube OK"
#else
#   echo "Release criterion: MPCube KO"
#fi
#echo "$validation_projets_baltik  MPCube $validation_projets_baltik (=1) Baltik=$HOST:$PROJECT_ROOT" >> $MESSAGES_NUIT
#let total_criteres=$total_criteres+1
#let criteres_remplis=$criteres_remplis+$validation_projets_baltik
#echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########
# PROJETS
##########
force_composant=~/force_composant
for Composant in $Composants
do
   echo " "
   echo "###################################"
   echo "# Verify the portability of baltik $Composant "
   echo "###################################"
   echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
   PROJECT_ROOT=`dirname $TRUST_ROOT`/Composants/$Composant
   validation_composant=1
   # Check if component is OK on $HOST:
   OK=0
   KO=0
   rm -f tmp.log
   for view in Livraison Maintenance Kernel
   do
      Composant_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"$view".log"
      if [ -f $Composant_log ]
      then
         echo "Analysis of "$Composant_log" file" | tee -a tmp.log
         #grep "$Composant OK" $Composant_log | sed 1d | tee -a tmp.log # check only component without portability
         grep "$Composant OK" $Composant_log #| tee -a tmp.log
         (grep " KO" $Composant_log;grep KO $Composant_log | grep $Composant;grep " connect to host " $Composant_log | cut -d: -f2) | tee -a tmp.log
	 nb=`grep "$Composant OK" $Composant_log | wc -l`
         OK=`echo $(($OK+$nb))`
	 nb=`(grep " KO" $Composant_log;grep KO $Composant_log | grep $Composant;grep " connect to host " $Composant_log | cut -d: -f2) | wc -l`
         KO=`echo $(($KO+$nb))`
      fi
   done
   let NB=$OK+$KO
   [ $NB = 0 ] && validation_composant=0
   # Check if portability is OK:
   nuit_log=$PROJECT_ROOT/nuit_$Composant.html
   nb_cible=0
   tot_cible=0
   nb_total=0
   tot_total=0
   if [ -f $nuit_log ]
   then
      echo "Analysis of "$nuit_log" file" | tee -a tmp.log
      grep "_OK" $nuit_log | tee -a tmp.log
      nb_cible=`$TRUST_Awk '/cible_OK/ {print $2}' $nuit_log`
      tot_cible=`$TRUST_Awk '/cible_OK/ {print $4}' $nuit_log`
      nb_total=`$TRUST_Awk '/total_OK/ {print $2}' $nuit_log`
      tot_total=`$TRUST_Awk '/total_OK/ {print $4}' $nuit_log`
   else
      validation_composant=0
   fi
   [ $tot_cible != 0 ] && [ $nb_cible != $tot_cible ] && validation_composant=0
   [ $tot_cible = 0 ] && [ $nb_cible = 0 ] && validation_composant=0
   #if [ "`grep KO $PROJECT_ROOT/*.log | grep Info_global 2>/dev/null`" != "" ]
   if [ $KO != 0 ]
   then
      #validation_composant=0
      if [ -f $nuit_log ]
      then
         echo " " | tee -a tmp.log
         echo "Run: konqueror $REP_NUIT/nuit_$Composant.html" | tee -a tmp.log	 
      fi
   fi
   echo " "
   if [ "$validation_composant" = 1 ]
   then
      echo "Release criterion: $Composant OK"
      [ $nb_total != $tot_total ] && cat tmp.log | mail_ -s\"[lance_test_nuit] Portability KO on Baltik $Composant\" $TRUST_MAIL
   else
      echo "Release criterion: $Composant KO"
      BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
      [ $KO != 0 ] && cat tmp.log | mail_ -s\"[lance_test_nuit] Cible portability KO on Baltik $Composant\" -c ${!BALTIK_PROJECT_LEADER} -c $TMA_PROJECT_LEADER $TRUST_MAIL
   fi
   rm -f tmp.log
   [ $KO != 0 ] && [ $nb_total = $tot_total ] && validation_composant=0
   [ -f $force_composant ] && validation_composant=1
   # Test sur l'ensemble des machines
   [ "$NB" -eq 0 ] && NB=-1
   if [ "$NB" -eq -1 ]
   then
      echo "$validation_composant  $Composant $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)" #>> $MESSAGES_NUIT
      NB=0
   else
      echo "$validation_composant  $Composant $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)" #>> $MESSAGES_NUIT
   fi
   # Test sur les machines cible
   [ "$tot_cible" -eq 0 ] && tot_cible=-1
   if [ "$tot_cible" -eq -1 ]
   then
      echo "$validation_composant  $Composant $nb_cible/0="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
      tot_cible=0
   else
      echo "$validation_composant  $Composant $nb_cible/$tot_cible="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
   fi
   let total_criteres=$total_criteres+1
   let criteres_remplis=$criteres_remplis+$validation_composant
   if [[ "$ComposantsGit" = *"$Composant"* ]] # Test si Composant est dans la liste des composants GIT
   then
      let baltik_ok=$baltik_ok+$validation_composant
   fi
   echo "<--- End at "`date '+%H:%M:%S %d/%m'`
done
rm -f $force_composant

####################
# SCRIPTS IMPORTANTS
####################
echo " "
echo "####################################"
echo "# Verify the validation of scripts #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $REP_NUIT/CR_* files"
grep "Script " $REP_NUIT/CR_* | grep OK 2>/dev/null
grep "Script " $REP_NUIT/CR_* | grep KO 2>/dev/null
validation_scripts=0
OKt=0
KOt=0
machines=`liste_machines cible | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
for machine in $machines
do
   if [ "`grep "Script " $REP_NUIT/CR_$machine`" != "" ]
   then
      OKm=`grep "Script " $REP_NUIT/CR_$machine | grep OK 2>/dev/null | wc -l`
      KOm=`grep "Script " $REP_NUIT/CR_$machine | grep KO 2>/dev/null | wc -l`
      OKt=`echo "$OKt+$OKm" | bc -l`
      KOt=`echo "$KOt+$KOm" | bc -l`
   fi
done
let NBt=$OKt+$KOt
OK=`grep "Script " $REP_NUIT/CR_* | grep OK 2>/dev/null | wc -l`
KO=`grep "Script " $REP_NUIT/CR_* | grep KO 2>/dev/null | wc -l`
let NB=$OK+$KO
if [ "`grep "Script " $REP_NUIT/CR_* | grep KO`" = "" ]
then
   validation_scripts=1
else
   grep "Script " $REP_NUIT/CR_* | grep KO | mail_ -s\"[lance_test_nuit] Validation of scripts KO\" $TRUST_MAIL
fi
[ "$KOt" -eq 0 ] && validation_scripts=1
echo " "
if [ "$validation_scripts" = 1 ]
then
   echo "Release criterion: Scripts OK"
else
   echo "Release criterion: Scripts KO"
fi
force_validation_scripts=~/force_validation_scripts && [ -f $force_validation_scripts ] && validation_scripts=1 && rm -f $force_validation_scripts
[ "$NB" -eq 0 ] && NB=-1
if [ "$NB" -eq -1 ]
then
   echo "$validation_scripts  Scripts $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)"
   NB=0
else
   echo "$validation_scripts  Scripts $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)"
fi
[ "$NBt" -eq 0 ] && NBt=-1
if [ "$NBt" -eq -1 ]
then
   echo "$validation_scripts  Scripts $OKt/0="`echo $ECHO_OPTS "scale=3;$OKt/$NBt" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
   NB=0
else
   echo "$validation_scripts  Scripts $OKt/$NBt="`echo $ECHO_OPTS "scale=3;$OKt/$NBt" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_scripts
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#########
# Doxygen
#########
echo " "
echo "####################################"
echo "# Verify the Doxygen documentation #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Search of $TRUST_ROOT/doc/doxygen*.err file"
if [ -f $TRUST_ROOT/doc/doxygen*.err ]
then
   ls -la $TRUST_ROOT/doc/doxygen*.*
   head -n1 $TRUST_ROOT/doc/doxygen*.out
   tail -n1 $TRUST_ROOT/doc/doxygen*.out
fi
validation_doxygen=1 && [ -s $TRUST_ROOT/doc/doxygen*.err ] && validation_doxygen=0 && cat $TRUST_ROOT/doc/doxygen*.err | mail_ -s\"[lance_test_nuit] Validation of Doxygen documentation KO\" $TRUST_MAIL
echo " "
if [ "$validation_doxygen" = 1 ]
then
   echo "Release criterion: Doxygen OK"
else
   echo "Release criterion: Doxygen KO"
fi
echo "$validation_doxygen  Doxygen $validation_doxygen (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_doxygen
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo "Total: $criteres_remplis/$total_criteres criteria for the $new version" >> $MESSAGES_NUIT
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
#
#
#
echo " "
echo "------------------------------------------------------"
echo " "
echo "##############################"
echo "# Deliver and export version #"
echo "##############################"
echo " "
echo "###########################"
echo "# Test if Release version #"
echo "###########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`

########################################################################
# Feu vert de l'administrateur TRUST d'apres l'en tete de RELEASE_NOTES
########################################################################
echo "Analysis of $TRUST_ROOT/RELEASE_NOTES file"
export accord_admin=0 && [ ${new%_beta} = $new ] && accord_admin=1
export accord_beta=0
export label_pose=$new
label=v${new%_beta}
deja_livre=0
if [ "$accord_admin" = 1 ]
then
   echo ${new%_beta}" == "$new" => agreement_administrator = "$accord_admin
   # Commit
   echo "Call git commit --u=no --all -m Commit before the $new version."
   git commit --u=no --all -m"Commit before the $new version."
else
   echo ${new%_beta}" >< "$new" => agreement_administrator = "$accord_admin
fi

####################################################################################################
# Si un certain nombre de criteres sont remplis, on propose une release (candidate ou intermediaire)
# Tous les jours si accord_admin = 1, label_rc=X.Y.Z_rc
# Le week-end seulement si accord_admin = 0, label_rc=X.Y.Z_beta
####################################################################################################
echo " "
echo "Analysis of $MESSAGES_NUIT file"
grep "Total:" $MESSAGES_NUIT
echo "  criteria:    "$criteres_remplis" != "$total_criteres
echo "  minimum:     "$criteres_remplis" -ge 16"
echo "  stability:   "$stabilite" = 1.000"
echo "  portability: "$portabilite" = 1"
echo "  baltikGIT:   "$baltik_ok" = "$total_baltik
cd $TRUST_ROOT
if [ $criteres_remplis != $total_criteres ] && [ $criteres_remplis -ge 16 ] && [ $stabilite = "1.000" ] && [ $portabilite = "1" ] && [ $baltik_ok = $total_baltik ]
then
   echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
   echo -e "=> release OK\c"
   [ "`date '+%u'`" -gt 5 ] && accord_beta=1 # week-end
   [ "`date '+%u'`" = 1 ] && [ "`date '+%H'`" -lt 8 ] && accord_beta=1 # lundi matin
   [ -f ~/force_version_beta ] && accord_beta=1 && rm -f ~/force_version_beta
   [ -f ~/no_version_beta ] && accord_beta=0 #&& rm -f ~/no_version_beta
   if [ $accord_admin = 1 ] || [ $accord_beta = 1 ]
   then
      # On decide du nom du label specifique
      label_rc=$label"_rc" && release=candidate && [ $accord_admin = 0 ] && label_rc=$label"_beta" && release=beta
      numero=`git tag | grep $label_rc | wc -l` && [ "$numero" = "" ] && numero=0
      let numero=$numero+1
      label_pose=$label_rc$numero 
      echo " with label "$label_pose
      echo " "
      error_rc=0
      
      # Commit
      echo "  Call git commit --all -m Commit for a Release $release $label_pose version"
      git commit --all -m"Commit for a Release $release $label_pose version."
      # On pose le tag:
      echo "  Call git tag $label_pose"
      git tag $label_pose
      error_rc=$?
      # Push
      echo "  Call git push shared Livraison"
      git_push -tags
      if [ $error_rc = 0 ]
      then  
         # On previent l'administrateur et le project leader
         cat $TRUST_ROOT/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] TRUST Release version - Tag a $release version: $label_pose \(See shared/Livraison branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER $TRUST_PROJECT_LEADER
      else
         echo "" | mail_ -s\"[lance_test_nuit] TRUST - Tag a $release version: $label_pose KO\" $TRUST_MAIL
      fi
      # On pose le meme tag sur externalpackages
      echo "  Update externalpackages:"
      cd $TRUST_ROOT/externalpackages
      echo "    Call git commit --all -m Commit for a Release $release $label_pose version"
      git commit --all -m"Commit for a Release $release $label_pose version."
      echo "    Call git tag $label_pose"
      git tag $label_pose
      error_rc=$?
      echo "    Call git push shared Livraison"
      git push --tags shared Livraison
      if [ $error_rc = 0 ]
      then  
         # On previent l'administrateur et le project leader
         cat $TRUST_ROOT/externalpackages/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] externalpackages Release version - Tag a $release version: $label_pose \(See shared/Livraison branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER
      else
         echo "" | mail_ -s\"[lance_test_nuit] externalpackages - Tag a $release version: $label_pose KO\" $TRUST_MAIL
      fi
      cd - 1>/dev/null 2>&1
      echo " "
      echo "Release of the $release version: $label_pose"
      echo "New version $label_pose : Not delivery" >> $MESSAGES_NUIT
      
      # On pose le meme tag sur les BALTIK
      for Composant in $ComposantsGit 
      do
         echo " "
         echo "  Update $Composant BALTIK:"
         cd $WORKDIR/sourceforge/Livraison/Composants/$Composant
         error_rcb=0
         echo "    Call git commit --all -m Commit for a Release $release $label_pose version"
         git commit --all -m"Commit for a Release $release $label_pose version."
         echo "    Call git tag $label_pose"
         git tag $label_pose
         error_rcb=$?
         echo "    Call git push shared TMA"
         git push --tags shared Livraison:TMA
         error_rcb=$?
	 [ "$Composant" = TrioCFD ] && git push --tags shared Livraison
         if [ $error_rcb = 0 ]
         then  
            # On previent l'administrateur et les project leader
	    BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
            cat $WORKDIR/sourceforge/Livraison/Composants/$Composant/share/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] $Composant Release version - Tag a $release version: $label_pose \(See shared/TMA branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER ${!BALTIK_PROJECT_LEADER}
         else
            echo "" | mail_ -s\"[lance_test_nuit] $Composant - Tag a $release version: $label_pose KO\" $TRUST_MAIL
         fi
      done
      cd $TRUST_ROOT
   else
      echo " without label"
   fi
else
   if [ $criteres_remplis != $total_criteres ]
   then
     echo "=> release KO"
     if [ $accord_admin = 1 ]
     then
        echo "New version $label : Not delivery because only $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
     else
        echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
     fi
   fi
fi

#############################################################
# Si tous les criteres sont remplis, on tamponne la version !
#############################################################
export livraison=0
if [ $criteres_remplis = $total_criteres ]
then
   echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
   echo -e "=> release OK\c"
   if [ $accord_admin = 0 ]
   then
      [ $deja_livre = 0 ] && echo "New version $label : Delivery possible if agreement of $TRUST_MAIL" >> $MESSAGES_NUIT
      [ $deja_livre = 1 ] && echo "New version $label : Delivery already made" >> $MESSAGES_NUIT
   else
      # On decide du nom du label specifique
      label_rc=$label"_rc" && release=candidate && [ $accord_admin = 0 ] && label_rc=$label"_beta" && release=beta
      numero=`git tag | grep $label_rc | wc -l` && [ "$numero" = "" ] && numero=0
      let numero=$numero+1
      label_pose=$label_rc$numero 
      # Le tag label est pose par Gauthier sur origin sinon conflit
      echo " with label "$label
      echo " "
      # Checkin et verification que tous les fichiers sont checkines
      erreur_checkin=""
      # Track again all files which were --assume-unchanged before:
      cd $TRUST_ROOT
      #Couverture de code genere sur l ensemble des baltiks et pas que sur TRUST donc on n ecrase pas...
      echo "  Call git update-index --no-assume-unchanged"
      for unchanged in `git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'`
      do
         git update-index --no-assume-unchanged $unchanged
      done
      # Commit & Push
      echo "  Call git commit --all -m Commit for an official Release $label version."
      git commit --all -m"Commit for an official Release $label version."
      echo "  Call git push shared Livraison"
      git tag $label_pose
      git_push -tags
      git push --tags shared Livraison:master
      if [ "$erreur_checkin" != "" ]
      then
         echo "New version $label : Delivery canceled because some files could not be checkined: $erreur_checkin" >> $MESSAGES_NUIT
      else
	 echo "New version $label : Delivery in progress..." >> $MESSAGES_NUIT
	 livraison=1
	 accord_beta=0
	 echo "  Call git tag $label at "`date`
         git tag $label
	 # On pose le meme tag sur externalpackages
         cd externalpackages
         git commit --all -m"Commit for an official Release $label version."
         git tag $label_pose
         git push --tags shared Livraison
         git tag $label
	 git push --tags ssh://triou@sedna${TRUST_GIT_REPOS%TRUST}externalpackages Livraison:master
         git push --tags shared Livraison:master
	 git fetch --all
         cd - 1>/dev/null 2>&1
	 # Creation des packages TRUST et externalpackages
	 echo " "
	 echo "  Creation of the packages of TRUST and externalpackages"
         echo "!!! See A_GRAVER_CD_TRUST (Warning externalpackages) and A_GRAVER_CD_TrioCFD !!!" | mail_ -s\"[lance_test_nuit] WARNING! TRUST v$new released: Ensure that packages for sourceforge.net are correct...\" $TRUST_MAIL
         mise_a_jour_TRUST_tar
         GRAVAGE=$WORKDIR/A_GRAVER_CD_TRUST
         version_arch=TRUST-$new".tar.gz"
         mv $TRUST_ROOT/$version_arch $GRAVAGE/.
         version_arch=externalpackages-$new".tar"
         mv $TRUST_ROOT/$version_arch $GRAVAGE/.
	 # Changement de la vue Maintenance
	 echo " "
	 echo "Changing the Maintenance view"
         patch_old=patch_`echo $old`
	 patch_new=patch_`echo $new`
	 (
	    cd $WORKDIR/sourceforge/Maintenance/TRUST
	    echo "from `pwd`"
	    echo "  Call git fetch --all"
            git fetch --all # Pour recuperer tous les tags
            # Creation de la branche depuis le tag (example: patch_XYZ depuis vX.Y.Z)
	    echo "  Call git checkout -b $patch_new $label"
            git checkout -b $patch_new $label
	    if [ $? = 0 ]
	    then
               # Positionnement de HEAD sur la branche (exemple: patch_XYZ)
               #git symbolic-ref HEAD refs/heads/$patch_new
	       git branch -D Maintenance
	       git branch -m $patch_new Maintenance
	       echo "  Call git symbolic-ref HEAD refs/heads/Maintenance"
               git symbolic-ref HEAD refs/heads/Maintenance
               # Push
	       echo "  Call git push shared Maintenance"
               git_push
               # Le repo officiel pointe desormais sur la branche (exemple: patch_XYZ) # Temporary
	       #echo "  Update $TRUST_GIT_REPOS repos on $TRUST_GIT_SERVER server"
               #ssh triou@$TRUST_GIT_SERVER -n 'cd '$TRUST_GIT_REPOS';git symbolic-ref HEAD refs/heads/'$patch_new
	    else
	       echo "" | mail_ -s\"[lance_test_nuit] Error for git checkout \-b $patch_new $label in Maintenance view\" $TRUST_MAIL
	    fi
	    # externalpackages
	    echo " "
            echo "Changing the Maintenance/externalpackages view"
	    cd externalpackages
	    git fetch --all
	    git checkout -b $patch_new $label
	    if [ $? = 0 ]
	    then
	       #git symbolic-ref HEAD refs/heads/$patch_new
	       git branch -D Maintenance
	       git branch -m $patch_new Maintenance
	       git symbolic-ref HEAD refs/heads/Maintenance
	    else
	       echo "" | mail_ -s\"[lance_test_nuit] Error for git checkout \-b $patch_new $label in Maintenance/externalpackages view\" $TRUST_MAIL
	    fi
	    cd - 1>/dev/null 2>&1
	 )
	 echo " "
	 echo "Creation of the packages of each Baltik component"
	 # Creation des packages de chaque composant BALTIK
	 cd $WORKDIR/sourceforge/Livraison/TRUST
	 source env_TRUST.sh 1>/dev/null 2>&1
	 for Composant in $ComposantsGit 
	 do
	    cd $WORKDIR/sourceforge/Livraison/Composants/$Composant
	    echo "from `pwd`"
	    # On pose le meme tag sur les BALTIK
            echo "    Call git commit --all -m Commit for an official Release $label version."
            git commit --all -m"Commit for an official Release $label version."
            echo "    Call git push shared TMA"
	    git tag $label_pose
            git push --tags shared Livraison:TMA
	    [ "$Composant" = TrioCFD ] && git push --tags shared Livraison
	    echo "    Call git tag $label"
            git tag $label
	    [ "$Composant" != TrioCFD ] && git push --tags ssh://triou@sedna${TRUST_GIT_REPOS%TRUST}$Composant Livraison:master
            git push --tags shared Livraison:master
	    git fetch --all
	    # Appel du make distrib
	    echo "    Call make distrib"
	    make distrib
	    mkdir -p $WORKDIR/A_GRAVER_CD_$Composant
	    echo "    Copy $Composant.tar.gz to $WORKDIR/A_GRAVER_CD_$Composant/$Composant-$new.tar.gz"
	    cp -f $Composant.tar.gz $WORKDIR/A_GRAVER_CD_$Composant/$Composant-$new.tar.gz
	    echo | mail_ -s\"[lance_test_nuit] $Composant v$new is released under $WORKDIR/A_GRAVER_CD_$Composant\" $TRUST_MAIL	 
	    # Changement de la vue Maintenance
            if [ -d $WORKDIR/sourceforge/Maintenance/Composants/$Composant ]
            then
	       echo "    Call git symbolic-ref HEAD refs/heads/$patch_new"
	       cd $WORKDIR/sourceforge/Livraison/Composants/$Composant
	       echo "from `pwd`"
	       git fetch --all
	       git checkout -b $patch_new $label
	       if [ $? = 0 ]
	       then
	          #git symbolic-ref HEAD refs/heads/$patch_new
	          git branch -D Maintenance
	          git branch -m $patch_new Maintenance
	          git symbolic-ref HEAD refs/heads/Maintenance
	       else
	          echo "" | mail_ -s\"[lance_test_nuit] Error for git checkout \-b $patch_new $label in Maintenance/Composants/$Composant view\" $TRUST_MAIL
	       fi
	       cd - 1>/dev/null 2>&1
	    fi 
	    echo " "
	 done
	 cd $WORKDIR/sourceforge/Livraison/TRUST
	 echo "Version $new : ...End" >> $MESSAGES_NUIT
         echo " "
         echo "Creation of the Stable version: $label"
      fi
   fi
fi
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo `date` >> $MESSAGES_NUIT
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
grep -A `echo $(($total_criteres+2))` -B 1 "Release criteria of the" $MESSAGES_NUIT > tmp_NUIT.txt
sed 's/$/ <BR>/g' tmp_NUIT.txt > tmp_NUIT.html
cat tmp_NUIT.html >> $REP_NUIT/NUIT.html
rm -f tmp_NUIT.txt tmp_NUIT.html
echo "<--- End at "`date '+%H:%M:%S %d/%m'`



####################################
# Envoi des binaires et des versions
####################################
echo " "
echo "####################"
echo "# Send to ftp site #"
echo "####################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
for Composant in $Composants
do
   if [ -d $TRUST_ROOT/../Composants/$Composant ]
   then
      cd $TRUST_ROOT/../Composants/$Composant
      mkdir -p build/portability
      mv $Composant*.log build/portability/.
      mv Run.liste debut nuit_$Composant.html build/portability/.
   fi
done
cd $TRUST_ROOT
envoie_ftp_log=$REP_NUIT/envoie_ftp_cea_fr_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/envoie_ftp_cea_fr"
echo "  See $envoie_ftp_log"
echo "TRUST script on $HOST the `date` ...">$envoie_ftp_log
echo>>$envoie_ftp_log
envoie_ftp_cea_fr 1>>$envoie_ftp_log 2>&1
echo>>$envoie_ftp_log
echo "End at `date` ...">>$envoie_ftp_log
grep -i killed $envoie_ftp_log
grep -i Error $envoie_ftp_log
grep KO $envoie_ftp_log
grep local $envoie_ftp_log

#####################################
# Mises a jour diverses de $TRUST_FTP
#####################################
cd $TRUST_TMP
# Update the index.html file of the FTP site:
if [ $livraison = 1 ]
then
   echo " "
   echo "Call to "$TRUST_ROOT"/bin/admin/cree_index.html"
   echo "from `pwd`"
   cree_index.html
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#-------------------------------------------------------
echo " "
echo "###########################"
echo "# Send announcements mail #"
echo "###########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`

################################################################################################
# Le mail des RELEASES NOTES est envoye aux developpeurs tous les lundis ou lors de la livraison
# sinon uniquement a l'admin TRUST et au chef de projet
################################################################################################
if [ "`date '+%u'`" = 1 ] || [ $livraison = 1 ] || [ $accord_beta = 1 ]
then
   ALL_DEVELOPERS_TRUST_MAIL="trio_u_dev@saxifrage.saclay.cea.fr"
   echo " " >> $MESSAGES_NUIT
   echo "TRUST support team. mailto: $TRUST_MAIL  Web: http://www-trio-u.cea.fr" >> $MESSAGES_NUIT
   echo " " >> $MESSAGES_NUIT
   echo "To unsubscribe from this list, send an e-mail to $TRUST_MAIL " >> $MESSAGES_NUIT
else
   ALL_DEVELOPERS_TRUST_MAIL=$TRUST_MAIL" "$TMA_PROJECT_LEADER
fi

#####################################
# Envoi d'un message aux developpeurs
#####################################
cd $TRUST_ROOT
for dest in $ALL_DEVELOPERS_TRUST_MAIL
do
   echo "$MESSAGES_NUIT sent to $dest"
   if [ $livraison = 0 ]
   then
      if [ $accord_beta = 0 ]
      then
         mail_ -s \"Release criteria of TRUST $new on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
      else
         mail_ -s \"Tagged release criteria of TRUST $label_pose on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
      fi
   elif [ $livraison = 1 ]
   then
      mail_ -s \"Tagged release criteria of TRUST $label_pose on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
   fi
done

############################################################################
# Annonce d'une version stable a tout le monde (developpeur et utilisateurs)
############################################################################
if [ $livraison = 1 ]
then
   ALL_USERS_TRUST_MAIL="trio_u_annonces@saxifrage.saclay.cea.fr"
   push_error=1 # Temporary
   [ $push_error = 1 ] && ALL_USERS_TRUST_MAIL=$TRUST_MAIL
   echo "!!! mail not sent to trio_u_annonces !!!" | mail_ -s \"[lance_test_nuit] WARNING! TRUST v$new released: Ensure that git push origin has been done manually...\" $TRUST_MAIL
   for dest in $ALL_USERS_TRUST_MAIL
   do
      echo "Stable release announcement sent to $dest"
      echo "
TRUST is a thermohydraulic software package for CFD 
simulations for incompressible monophasic/diphasic flow.
TRUST platform name means TRrio_U Software for Thermohydraulics
(\"Trio_U\" without Front_Tracking, Radiation, Zoom and LES models).
This software is OpenSource (license BSD).

---------------------------------
New TRUST version released v$new
---------------------------------
is available at http://sourceforge.net/projects/trust-platform/

-----------------
Table of contents
-----------------
1. How to install?
2. How to run preinstalled version?
3. TRUST Release notes
4. TRUST Developer notes
5. externalpackages Release notes
6. Version tested on several OS
7. Version portability with several compilers

TRUST support team. mailto: $TRUST_MAIL  Web: http://www-trio-u.cea.fr

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
      echo "
---------------------------------------------------------------------------------------------
1. How to install?
---------------------------------------------------------------------------------------------
# Option to minimize build
OPTIONS=\"-disable-optionals\"

# First method:
wget http://downloads.sourceforge.net/project/trust-platform/Installer_TRUST.sh;
chmod +x Installer_TRUST.sh;
./Installer_TRUST.sh -configure-options \"\$OPTIONS\"

# Second method:
wget http://downloads.sourceforge.net/project/trust-platform/$new/TRUST-$new.tar.gz;
tar xzf TRUST-$new.tar.gz;
cd TRUST-$new;
./configure \$OPTIONS;
make

# Third method:
git clone git://git.code.sf.net/p/trust-platform/code TRUST-$new;
cd TRUST-$new;
wget http://downloads.sourceforge.net/project/trust-platform/$new/externalpackages-$new.tar;
tar xf externalpackages-$new.tar;
./configure \$OPTIONS;
make
---------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "
----------------------------------------------------------------------------------------------------
2. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for PC connected to CEA Saclay network (Please be notified that VisIt is KO on Ubuntu 16.04):
source /home/triou/env_TRUST_$new.sh

# for CEA Saclay cluster (callisto):
source /home/triou/env_TRUST_$new.sh

# for CEA Cadarache cluster (mezel):
source /soft/mezel/TRIO/env_TRUST-$new.sh

# for CEA Marcoule cluster (ceres2):
source /softs/trio_u/env_TRUST-$new.sh

# for CEA CCRT-TGCC supercomputers (cobalt & curie-ccrt):
source /ccc/cont002/home/den/triou/env_TRUST-$new.sh

# for CINES supercomputer (occigen):
source /opt/software/applications/trio_u/env_TRUST-$new.sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
3. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/RELEASE_NOTES ] && echo $ECHO_OPTS "TRUST \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/RELEASE_NOTES >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
-------------------------------------------------------------
4. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/DEVELOPER_NOTES ] && echo $ECHO_OPTS "TRUST \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Developer notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/DEVELOPER_NOTES >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
5. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/externalpackages/RELEASE_NOTES ] && echo $ECHO_OPTS "externalpackages \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/externalpackages/RELEASE_NOTES >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "6. Version tested on several OS" >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      sed 's/<BR><LI>/ /g'  $REP_NUIT/os >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "7. Version portability with several compilers" >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      sed 's/<BR><LI>/ /g'  $REP_NUIT/CC >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      mail_ -s \"New TRUST v$new released\" $dest < $MESSAGES_LIVRAISON
      sleep 5
      mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_TRUST
   done
   for Composant in $ComposantsGit
   do
      if [ "$Composant" == TrioCFD ]
      then
         echo "
TrioCFD (previously named \"Trio_U\") is Computational Fluid Dynamics (CFD) code, 
based on the TRUST platform (\"TRUST\" with Front_Tracking, Radiation, Zoom and LES models).
This software is OpenSource (license BSD).

-----------------------------------
New TrioCFD version released v$new
-----------------------------------
is available at http://sourceforge.net/projects/triocfd/

-----------------
Table of contents
-----------------
1. How to install?
2. How to run preinstalled version?
3. TrioCFD Release notes

TRUST/TrioCFD support team. mailto: $TRUST_MAIL  Web: http://www-trio-u.cea.fr

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
      echo "
---------------------------------------------------------------------------------------------
1. How to install?
---------------------------------------------------------------------------------------------
# Option to minimize build
OPTIONS=\"-disable-optionals\"

# First method if TRUST-$new platform is not installed:
wget http://sourceforge.net/projects/triocfd/files/Installer_TrioCFD.sh;
chmod +x Installer_TrioCFD.sh;
./Installer_TrioCFD.sh -configure-options \"\$OPTIONS\"

# Second method if TRUST-$new platform is already installed:
wget http://sourceforge.net/projects/triocfd/files/Installer_TrioCFD.sh;
chmod +x Installer_TrioCFD.sh;
./Installer_TrioCFD.sh -with-trust \$TRUST_ROOT

# Third method if TRUST-$new platform is already installed:
git clone git://git.code.sf.net/p/triocfd/code TrioCFD-$new;
cd TrioCFD-$new;
source \$TRUST_ROOT/env_TRUST.sh;
baltik_build_configure -execute;
make optim debug
---------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "
----------------------------------------------------------------------------------------------------
2. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for PC connected to CEA Saclay network (Please be notified that VisIt is KO on Ubuntu 16.04):
source /home/triou/env_TrioCFD_$new.sh

# for CEA Saclay cluster (callisto):
source /home/triou/env_TrioCFD_$new.sh

# for CEA Cadarache cluster (mezel):
source /soft/mezel/TRIO/env_TrioCFD-$new.sh

# for CEA Marcoule cluster (ceres2):
source /softs/trio_u/env_TrioCFD-$new.sh

# for CEA CCRT-TGCC supercomputers (cobalt & curie-ccrt):
source /ccc/cont002/home/den/triou/env_TrioCFD-$new.sh

# for CINES supercomputer (occigen):
source /opt/software/applications/trio_u/env_TrioCFD-$new.sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
3. \c" >> $MESSAGES_LIVRAISON
         [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && echo $ECHO_OPTS "$Composant \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES >> $MESSAGES_LIVRAISON
         echo " " >> $MESSAGES_LIVRAISON
         mail_ -s \"New TrioCFD v$new released\" $TRUST_MAIL < $MESSAGES_LIVRAISON
         sleep 5
         mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_$Composant
      elif [ "$Composant" == ModeleCoeur ]
      then
         echo "
TrioMC is a subchannel code dedicated to the study of SFR subassemblies
at the complete core scale. Through the MATHYS code, TrioMC can be coupled:
- with the TrioCFD code to model the coupling between the core and the inter-wrapper region;
- with the CATHARE code to model the local core behavior during reactor transients.
TrioMC is based on the TRUST platform.

-----------------------------------
New TrioMC2 version released v$new
-----------------------------------
1. How to run preinstalled version?
2. Release notes

TRUST/TrioMC2 support team. mailto: $TRUST_MAIL  Web: http://www-trio-u.cea.fr
MATHYS support team. mailto: mathys@cea.fr

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
 echo "
----------------------------------------------------------------------------------------------------
1. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for PC connected to CEA SESI network:
source /soft/der/sesi/TrioMC2/env_TrioMC2-$new.sh

# for CEA Cadarache cluster (mezel):
source /soft/mezel/TRIO/env_TrioMC2-$new.sh

# for CEA Saclay cluster (callisto):
source /home/triou/env_TrioMC2_$new.sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
2. \c" >> $MESSAGES_LIVRAISON
         [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && echo $ECHO_OPTS "$Composant \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES >> $MESSAGES_LIVRAISON
         echo " " >> $MESSAGES_LIVRAISON
         mail_ -s \"New TrioMC2 v$new released\" $TRUST_MAIL < $MESSAGES_LIVRAISON
         sleep 5
         mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_$Composant
      fi
   done
   ########################################################
   # On change les NOTES en augmentant le numero de version
   # car sinon on risque des ennuis le lendemain (Version1.5.3.tar+cle effaces dans A_GRAVER_CD_TRUST)
   echo " "
   echo "Call CHECKOUT $TRUST_ROOT/RELEASE_NOTES $TRUST_ROOT/DEVELOPER_NOTES"
   CHECKOUT $TRUST_ROOT/RELEASE_NOTES $TRUST_ROOT/DEVELOPER_NOTES
   next_new=`echo $new | $TRUST_Awk -F"." '{if (NF==3) print $1"."$2"."$3+1"_beta";else if (NF==2) print $1"."$2".1_beta"}'`
   echo "--------------------------------------------------------------------------------------------------
Release notes version $next_new : Enhancements, modifications and corrected bugs since version $new :
--------------------------------------------------------------------------------------------------
" > $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_ROOT/RELEASE_NOTES >> $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_TMP/RELEASE_NOTES > $TRUST_ROOT/RELEASE_NOTES
   echo "-------------------------------------------------------------
Developer notes version $next_new : Changes since version $new :
-------------------------------------------------------------
" > $TRUST_TMP/DEVELOPER_NOTES
   cat $TRUST_ROOT/DEVELOPER_NOTES >> $TRUST_TMP/DEVELOPER_NOTES
   cat $TRUST_TMP/DEVELOPER_NOTES > $TRUST_ROOT/DEVELOPER_NOTES  
   # Commit immediately to differenciate master and patch branchs for setting the correct default branch after git clone
   # See http://git.661346.n2.nabble.com/git-clone-not-getting-the-correct-default-branch-td7476876.html
   echo " "
   #echo "Call git commit --all"
   #git commit --all -m"First automatic commit"
   cd $TRUST_ROOT
   ################################################
   # Installation a distance sur plusieurs machines
   ################################################
   echo " "
   echo "Call to "$TRUST_ROOT"/bin/admin/Installer_TRUST.ssh on:"
   liste_machines updated
   for machine in `liste_machines updated`
   do
      (
       install_stable_log=$REP_NUIT"/install_stable_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
       echo "-> Start of Installer_TRUST.ssh $machine $new -compile..."
       echo "  See $install_stable_log"
      )
   done
   for machine in `liste_machines updated`
   do
      (
      install_stable_log=$REP_NUIT"/install_stable_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
      echo "TRUST script on $HOST the `date` ...">$install_stable_log
      echo>>$install_stable_log
      $TRUST_ROOT/bin/admin/Installer_TRUST.ssh $machine $new -compile 1>>$install_stable_log 2>&1
      if [ $? != 0 ] || [ "`grep :error $install_stable_log | grep -iv warning | grep -v TRIOXDATA | grep -v Gmsh`" != "" ]
      then
         cat $install_stable_log | mail_ -s \"[lance_test_nuit] Failed to install stable version on $machine\" $TRUST_MAIL
      fi
      ) &
   done
   #wait
   echo " "
fi
echo `echo ~`"/CR sent to $TRUST_MAIL"
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "****************************************************"
echo "End of the `basename $0` script at `date '+%H:%M:%S'`."
echo `date`
echo "****************************************************"

mail_ -s\"[lance_test_nuit] Night report of TRUST ATELIER  on `date '+%d/%m/%y'`\" $TRUST_MAIL < ~/CR
# On deplace le CR
mv -f ~/CR $REP_NUIT/CR
cp -f $REP_NUIT/CR $REP_HIST/CR.$DATE

# On sauvegarde l'historique de la nuit
cd $REP_NUIT
git rm .nfs*
git add --all
git commit -m"Commit $DATE"
cd $TRUST_ROOT
