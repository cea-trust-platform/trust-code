#!/bin/bash
check_components()
{
   for Composant in $Composants
   do
      if [ $* = tuleap/Maintenance ] && [[ "$ComposantsBeta" != *"$Composant"* ]]
      then
         [ -d $TRUST_ROOT/../Composants/$Composant ] && echo "  No check $Composant Component with $TRUST_VERSION version"
      else
      if [ ! -d $TRUST_ROOT/../Composants/$Composant ] && [ $* != tuleap/Kernel ]
      then
         # Create a link for some components
	 cd $TRUST_ROOT/../Composants
	 if [ -d ../TRUST/bin/baltik/templates/$Composant ] # baltik Test_Baltik ou basic
	 then
	    ln -sf ../TRUST/bin/baltik/templates/$Composant .
	 fi
	 if [ -d ../TRUST/doc/TRUST/exercices/$Composant ]   # baltik equation_convection_diffusion
	 then
	    ln -sf ../TRUST/doc/TRUST/exercices/$Composant .
	 fi
	 if [ -d ../TRUST/Outils/$Composant/$Composant_src ] # baltik ICoCo
	 then
	    ln -sf ../TRUST/Outils/$Composant/$Composant"_src" $Composant
	 fi
	 cd - 1>/dev/null 2>&1
      fi
      if [ -d $TRUST_ROOT/../Composants/$Composant ]
      then
         cd $TRUST_ROOT/../Composants/$Composant
         rm -rf build/portability
	 rm -f $Composant*.log
	 Composant_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}".log"
	 Gui_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}"_gui.log"
	 Doc_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}"_doxygen.log"
	 Modularity_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}"_modularity.log"
         BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
         echo "  Check `pwd`"
	 echo "    See $Composant_log"
	 (
            echo "TRUST script on $HOST the `date` ..."
            echo " "
            echo "Check $Composant Component for $TRUST_VERSION version"
            echo " "
            echo "******************************************************"
            echo " "
	    [ $TRUST_ROOT = $TRUST_ROOT_MASTER ] && export MAKEATELIER_SEVERITY=1
	    COMPOSANT_OK=0
	    # First pass, reconfigure to clean properly (in the case where the TRUST_ROOT has changed):
	    #[ "$Composant" != ICoCo ] && source env_$Composant.sh && make dist_clean
	    #[ "$Composant" == ICoCo ] && source env_MED$Composant.sh && make dist_clean
	    make dist_clean
	    make_option="make check_all_optim"
	    if [ "$Composant" = basic ]
	    then
	       make_option="make check_trust_optim"
	    #elif [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
	    #then
	    ##   make_option=""
	    #   make_option="make check_optim"
	    ##   make_option="make check_all_optim"
	    elif [ $* = tuleap/Kernel ]
	    then
	       make_option="make check_all_optim check_trust_optim"
            fi
            if [ "$Composant" = flica5 ] || [ "$Composant" = ijk ]
            then
               make_option="make check_optim"
            fi
	    if [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
	    then
	       # Test debug tous les jours sur Template, Tuto, ICoCo, TrioMC, MPCube, Genepi3 et Flica5
	       #if [ "$Composant" != Test_Baltik ] && [ "$Composant" != triocfd ] && [ "$Composant" != ijk ] && [ "$Composant" != polymac ] && [ "$Composant" != mathys ]
	       if [ "$Composant" != Test_Baltik ] && [ "$Composant" != triocfd ] && [ "$Composant" != ijk ] && [ "$Composant" != mathys ] && [ "$Composant" != flica5 ] && [ "$Composant" != pemfc ] &&  [ "$Composant" = sympy_to_TRUST ]
	       then
	          make_option="make check_all_optim check_all_debug"
	       elif [ "$Composant" = flica5 ]
               then
	          make_option="make check_optim check_debug"
	       elif [ "$Composant" = pemfc ] || [ "$Composant" = sympy_to_TRUST ]
               then
	          make_option="make check_all_optim"
	       fi
	    fi
            if [[ "$Composant" == "triocfd" ]]
            then
                 git checkout -- Multiphase/Front_tracking_discontinu/tests/Reference/Validation/ftd_gravite_jdd1/ftd_gravite_jdd1.data
            fi
            # Fait desormais via un post_configure dans Test_Baltik:
	    #[ "$Composant" = Test_Baltik ] && echo "We call ./Configure_Tests for Test_Baltik from `pwd`" && ./Configure_Tests
	    $TRUST_ROOT/bin/baltik/bin/baltik_build_configure -execute &&
	    make optim module_optim debug module_debug optim_avx &&
	    $make_option && echo "$Composant OK" && COMPOSANT_OK=1
	    MODIF_TRUST_OK=1
	    if [ -d share/kernel_official_sources ]
	    then
               echo " "
               echo "Call to "$TRUST_ROOT"/bin/baltik/share/baltik/bin/baltik_check_TRUST_modif"
               if  [[ "$ComposantsGit" = *"$Composant"* ]] # Test si Composant est dans la liste des Composants GIT
               then
                  $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_TRUST_modif 1>tmp.log 2>&1
                  if [ $? != 0 ]
                  then
                     echo "Baltik pas a jour"
                     cat tmp.log
                     cat tmp.log | mail_ -s\"[lance_test_nuit] baltik_check_TRUST_modif KO for $Composant\" ${!BALTIK_PROJECT_LEADER} $TRUST_MAIL
                     echo "  KO"
	             MODIF_TRUST_OK=0
                  else
                     echo "  OK"
                  fi
                  rm tmp.log 1>/dev/null 2>&1
               fi
            fi
	    #[ $MODIF_TRUST_OK = 0 ] && COMPOSANT_OK=0
            # Verification independance des sous BALTIKs de TrioCFD
            if [ $* = tuleap/Livraison ] && [ "$Composant" = triocfd ]
            then
	       MODULARITY_BALTIK_OK=1
               # On fait le test uniquement le weekend
	       if [ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])
	       then
                  echo " "
                  echo "Call to "$TRUST_ROOT"/bin/baltik/share/baltik/bin/baltik_check_project_modularity"
                  $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_project_modularity 1>$Modularity_log 2>&1
                  # on fait un grep sur ERROR
                  if [ "`grep "ERROR" $Modularity_log`" != "" ]
                  then
                     cat $Modularity_log
                     cat $Modularity_log | mail_ -s\"[lance_test_nuit] baltik_check_project_modularity KO for $Composant\" ${!BALTIK_PROJECT_LEADER} $TRUST_MAIL
                     echo "  KO"
	             MODULARITY_BALTIK_OK=0
                  else
                     echo "  OK"
                  fi
               else
                 echo "No call to $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_project_modularity"
               fi
	       [ $MODULARITY_BALTIK_OK = 0 ] && COMPOSANT_OK=0
	    fi
	    # Verification de Liste_fiche pour Create_light_archive.sh
	    VERIF_LIGHT_OK=1
            if [ $* = tuleap/Livraison ] && [ "$Composant" = triocfd ]
            then
               echo " "
               echo "Call to ./share/Distribution/Create_Light_archive.sh"
	       rm -rf Prov
	       ./share/Distribution/Create_light_archive.sh 1>tmp.log 2>&1
               if [ "`grep 'Pb not uptodate' tmp.log`" != "" ]
               then
                  cat tmp.log
                  cat tmp.log | mail_ -s\"[lance_test_nuit] Create_Light_archive.sh KO for $Composant\" ${!BALTIK_PROJECT_LEADER} $TMA_PROJECT_LEADER $TRUST_MAIL
                  echo "  KO"
	          VERIF_LIGHT_OK=0
               else
                  echo "  OK"
               fi
               rm tmp.log 1>/dev/null 2>&1
	    fi
	    [ $VERIF_LIGHT_OK = 0 ] && COMPOSANT_OK=0
	    DOC_PDF_OK=0
	    if [ $* != tuleap/Kernel ]
	    then
               echo " "
	       # Pas de check_gui sur baltiks sans XD
	       make gui 1>$Gui_log 2>&1 && echo $Composant"_Reference_Manual.pdf OK" && DOC_PDF_OK=1
	       grep "Error" $Gui_log
	       [ "`grep "Error" $Gui_log`" != "" ] && DOC_PDF_OK=0 && echo DOC_PDF_OK=0
               if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
	       then
                  if [ "$Composant" != Test_Baltik ]
                  then
	             ([ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])) && make check_gui 1>>$Gui_log 2>&1 &
	             make doxygen 1>$Doc_log 2>&1
	          fi
	       fi
	    fi
            echo " "
            echo "******************************************************"
            echo " "
	    echo $ECHO_OPTS "Component $Composant checked on $HOST with $TRUST_VERSION ...\c"
	    if [ $COMPOSANT_OK = 0 ]
	    then
	       echo $ECHO_OPTS "KO."
	       cat $Composant_log | mail_ -s\"[lance_test_nuit] check_components $Composant $TRUST_VERSION KO\" $TRUST_MAIL
	    else
	       echo $ECHO_OPTS "OK"
	    fi	   
	    if [ $* != tuleap/Kernel ]
	    then 
	       echo $ECHO_OPTS "Reference Manual $Composant built on $HOST with $TRUST_VERSION ...\c"
	       if [ $DOC_PDF_OK = 0 ]
	       then
	          echo $ECHO_OPTS "KO."
	          cat $Gui_log | mail_ -s\"[lance_test_nuit] reference manual $Composant $TRUST_VERSION KO\" ${!BALTIK_PROJECT_LEADER} $TMA_PROJECT_LEADER $TRUST_MAIL
	       else
	          echo $ECHO_OPTS "OK"
	       fi	    
	    fi	    
	    echo " "
            echo "TRUST script on $HOST the `date` ..."
            echo " "
	    rm -f Run.liste
	    rm -f nuit_$Composant.html
	    rm -f $Composant_%_*.log
	    # On teste la portabilite uniquement si tout a fonctionne en local (pour eviter de bloquer d'autres PCs)
	    #if [ $COMPOSANT_OK = 1 ] && [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
	    #if [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
	    if [ $TRUST_ROOT = $TRUST_ROOT_MASTER ] || [ $* = tuleap/Maintenance ] # Test a revoir !!!!
	    then
               echo "Portability $Composant Component for $TRUST_VERSION version"
               echo " "
               echo "******************************************************"
               echo " "
	       echo "  See `pwd`/Run.liste"
	       # Machines en mode debug
	       debug_machines=`liste_machines "\-g "` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Machines en mode semi_opt
	       semi_opt_machines=`liste_machines "\-semi_opt"`
	       # Machines en mode gcov
	       gcov_machines="" && [ $* = tuleap/Maintenance ] && gcov_machines=`liste_machines "\-gcov"`
	       # Machines en mode prof
	       prof_machines="" && [ $* = tuleap/Maintenance ] && prof_machines=`liste_machines "\-prof"`
	       # Machines en mode avx
	       avx_machines=`liste_machines "\-avx"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Machines en mode valgrind
	       valgrind_machines=`liste_machines "\-check-valgrind"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Machines en mode gui
	       gui_machines=`liste_machines "\-gui"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Machines en mode check trust
	       trust_machines=`liste_machines "\-platform"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Clusters
	       updated_machines=`liste_machines limited ` #| awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Test compilation
	       unruned_machines=`liste_machines "\-without_run"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Machines cible pour la sortie de version
	       cible_machines=`liste_machines cible` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       cible_machines=$cible_machines" "`liste_machines get_binary` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Toutes les machines
	       all_machines=`liste_machines`
	       # Machines en test build64
	       #build64_machines=`liste_machines "\-build64"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Machines titania
	       titania_machines=`liste_machines titania`
	       # Machines sur lesquelles on ne garde pas la compilation des baltiks
	       non_machines=`liste_machines non` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
	       # Liste des machines a tester selon le baltik en question
	       if [ "$Composant" = Test_Baltik ] || [ "$Composant" = basic ]
	       then
	          machines=`liste_machines "\-TRUST"`
	       elif [ "$Composant" = ICoCo ]
	       then
	          # Machines en mode sequentiel
	          wompi_machines=`liste_machines "\-disable-mpi"`
	          wompi_machines=$wompi_machines" `liste_machines "\-disable-optionals"`"
	          wompi_machines=$wompi_machines" `liste_machines "\-disable "`"
	          # Machines en mode parallele
		  machines=""
		  for machine in $all_machines
		  do
		     [[ "$wompi_machines" != *"$machine"* ]] && machines=$machines" $machine"
		  done
	       elif [ "$Composant" = TrioCFD ] || [ "$Composant" = triocfd ]
	       then
	          machines=`liste_machines "\-TrioCFD"`
	       elif [ "$Composant" = IJK ] || [ "$Composant" = ijk ]
	       then
	          machines=`liste_machines "\-IJK-FT"`
	      # elif [ "$Composant" = PolyMAC ] || [ "$Composant" = polymac ]
	      # then
	      #    machines=`liste_machines "\-PolyMAC"`
	       elif [ "$Composant" = ModeleCoeur ] || [ "$Composant" = triomc ]
	       then
	          machines=`liste_machines "\-TrioMC"`
	       elif [ "$Composant" = mathys ]
	       then
	          machines=`liste_machines "\-MATHYS"`
               elif [ "$Composant" = cathare3D ]
               then
                  machines=`liste_machines "\-C3D"`
               elif [ "$Composant" = TRUST-NK ]
               then
                  machines=`liste_machines "\-TRUST-NK"`
               elif [ "$Composant" = sides ]
               then
                  machines=`liste_machines "\-SIDES"`
               elif [ "$Composant" = scorpio ]
               then
                  machines=`liste_machines "\-SCORPIO"`
               elif [ "$Composant" = pemfc ]
               then
                  machines=`liste_machines "\-PEMFC"`
               elif [ "$Composant" = sympy_to_TRUST ]
               then
                  machines=`liste_machines "\-STT"`
	       elif [ "$Composant" = MPCube ] || [ "$Composant" = mpcube ]
	       then
	          machines=`liste_machines "\-MPCube"`
	       elif [ "$Composant" = Genepi3 ] || [ "$Composant" = genepi3 ]
	       then
	          machines=`liste_machines "\-GENEPI3"`
	       elif [ "$Composant" = pxp ]
	       then
	          machines=`liste_machines "\-PAREX+"`
	       elif [ "$Composant" = CoreComponent ] || [ "$Composant" = flica5 ]
	       then
	          machines=`liste_machines "\-FLICA5"`
	       else
	          machines=$all_machines
	       fi
	       for adr in $machines
	       do
	          machine=`echo $adr` # | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`
	         # if [[ "$build64_machines" != *"$machine"* ]] # Test si machine n est pas dans la liste des machines build64 (test actuel uniquement sur TRUST)
		 # then
	             liste_options="--with-efface-dir-before"
	             if [[ "$liste_machines_KO" != *"$machine"* ]] # Test si machine n est pas dans la liste des machines KO
		     then
	                if [[ "$valgrind_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines valgrind
		        then
		           valgrind_option="--with-valgrind"
                           #if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
                           #then
		           #   valgrind_option=""
			   ## Test en valgrind seulement le vendredi car ne passe pas en une nuit sauf tous les jours sur Template, Tuto, ICoCo, PolyMAC, MPCube et Flica5
			   #elif [ "$Composant" = Test_Baltik ] || [ "$Composant" = triocfd ] || [ "$Composant" = triomc ] || [ "$Composant" = mathys ] || [ "$Composant" = genepi3 ]
			   if [ "$Composant" = Test_Baltik ] || [ "$Composant" = triocfd ] || [ "$Composant" = triomc ] || [ "$Composant" = mathys ] || [ "$Composant" = genepi3 ]
			   then
			      if [ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])
			      then
		                 valgrind_option="--with-valgrind"
			      else
		                 valgrind_option=""
			      fi
			   fi
		        else
		           valgrind_option=""
		        fi
	                if [[ "$gui_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines gui
		        then
		           mode_option="--with-mode=gui"
	                elif [[ "$semi_opt_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines semi_opt
		        then
		           mode_option="--with-mode=semi_optim"
		        elif [[ "$gcov_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines gcov
		        then
		           mode_option="--with-mode=gcov"
		        elif [[ "$prof_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines prof
		        then
		           mode_option="--with-mode=prof"
	                elif [[ "$debug_machines" = *"$adr"* ]] # Test si machine est dans la liste des machines debug
		        then
		           mode_option="--with-mode=debug"
			   # pas de valgrind en mode debug
	                   if [[ "$valgrind_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines valgrind
		           then
		              mode_option="--with-mode=optim"
			   else
		              mode_option="--with-mode=debug"
			   fi
			   # Test en debug seulement le vendredi car ne passe pas en une nuit
			   if [ "$Composant" = triocfd ]
			   then
			      if [ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])
			      then
		                 mode_option="--with-mode=debug"
			      else
		                 mode_option="--with-mode=optim"
			      fi
			   fi
	                elif [[ "$avx_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines avx
		        then
		           mode_option="--with-mode=optim_avx"
		        else
		           mode_option="--with-mode=optim"
		        fi
	                if [[ "$gui_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines gui
		        then
                           if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
			   then
	                      check_option="--without-run"
			   else
	                      check_option=""
			   fi
	                else
	                   check_option="--check-all" && [ "$Composant" = ijk ] && check_option="" # IJK modifie le FT (modification PL 15/05/2020) donc on ne fait plus que make check_optim
		           if [[ "$updated_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines updated
		           then
			      if [ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])
			      then
		                 check_option=$check_option
			      else
		                 check_option="--without-run"
			      fi
	                      liste_options="--with-efface-dir-before"
			   fi
	                   #if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
                           #then
		           ##   check_option="--without-run"
		           #   check_option=""
	                   ##   check_option="--check-all"
			   #fi
			   [[ "$trust_machines" = *"$machine"* ]] && check_option="--check-trust"
			   [[ "$unruned_machines" = *"$machine"* ]] && check_option="--without-run"
	                fi
	                if [[ "$non_machines" = *"$machine"* ]] || [ $* = tuleap/Maintenance ] # Test si machine n est pas dans la liste des machines cible, get_binary et tache
		        then
		           liste_options=$liste_options" --clean-after-if-ok"
	                fi
	                if [[ "$cible_machines" = *"$machine"* ]] && [ $* != tuleap/Maintenance ] # Test si machine est dans la liste des machines cible
		        then
		           liste_options=$liste_options" --cible"
	                fi
	                machine=`echo $adr | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`
                        log=`awk -v adr=$adr '($2==adr) {print $4}' ~/.netrc | head -1`
		        WORKTMP=`ssh_ -o BatchMode=yes $log@$adr -n 'if [ "\$WORKDIR" = "" ]; then echo \$HOME;else echo \$WORKDIR;fi'`
                        if [ $* = tuleap/Maintenance ]
                        then
                           # Debut de partie a revoir !!!!
		           #WORKBETA=`ssh_ -o BatchMode=yes $log@$adr -n 'source /home/triou/env_TRUST_\$TRUST_VERSION.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           WORKBETA=""
                           trustversion=""
                           [ "$Composant" == "flica5" ] && trustversion=1.8.4
                           [ "$Composant" == "cathare3D" ] && trustversion=1.8.3
                           if  [ "${machine:0:5}" = "orcus" ]
                           then
		              [ $TRUST_VERSION = 1.8.3 ] && WORKBETA=`ssh_ -o BatchMode=yes $log@$adr -n 'source /home/trust_trio-public/env_TRUST-'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           elif  [ "${machine:0:9}" = "callisto-" ] || [ "${machine:0:11}" = "irene-ccrt-" ] || [ "${machine:0:7}" = "cobalt-" ]
                           then
                              WORKBETA=""
                           elif [ "${machine:0:10}" = "irene-ccrt" ] || [ "${machine:0:6}" = "topaze" ]
                           then
		              [ $TRUST_VERSION = 1.8.3 ] && WORKBETA=`ssh_ -o BatchMode=yes $log@$adr -n 'source /ccc/cont002/home/den/triou/env_TRUST-'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           elif [ "${machine:0:7}" = "cezanne" ]
                           then
		              [ $TRUST_VERSION = 1.8.3 ] && WORKBETA=`ssh_ -o BatchMode=yes $log@$adr -n 'source /soft/der/sesi/TRUST/env_TRUST-'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           elif  [ "${machine:0:2}" = "is" ]
                           then
		              [ $TRUST_VERSION = 1.8.3 ] && WORKBETA=`ssh_ -o BatchMode=yes $log@$adr -n 'source /home/triou/env_TRUST_'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
		              [[ "$titania_machines" = *"$machine"* ]] && WORKBETA=`ssh_ -o BatchMode=yes $log@$adr -n 'source /home/trust_trio-public/env_TRUST-'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           fi
                           if [ "$WORKBETA" != "" ]
                           then
                              echo "$Composant.tar $WORKTMP/$WORKBASE$machine/ComposantsBeta/$Composant $log@$adr --with-TRUST=$WORKBETA $liste_options $mode_option $check_option $valgrind_option" >> Run.liste
                           else
                              echo "No check on $log@$adr because no $trustversion version on this host"
                           fi
                           # !!!! Fin de partie a revoir
                        else
                           if [ "$Composant" = flica5 ]
                           then 
                               check_option=""
                           fi
                           echo "$Composant.tar $WORKTMP/$WORKBASE$machine/Composants/$Composant $log@$adr --with-TRUST=$WORKTMP/$WORKBASE$machine/TRUST $liste_options $mode_option $check_option $valgrind_option" >> Run.liste
		        fi
		     fi
		 # fi
	       done
               echo " "
	       cat Run.liste
	       echo " "
	       echo "Call to $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_portability Run.liste"
	       echo " "
	       $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_portability Run.liste & # Take care if run not with &, the second argument should be different for each project
	    fi
	 ) 1>$Composant_log 2>&1
	 echo "    `grep "Component $Composant" $Composant_log`"
         cd $TRUST_ROOT
      #else
      #   echo "  Component $Composant KO not found here: $TRUST_ROOT/../Composants"
      fi
      fi
   done
}

# Push to repos (called several times, once at the beginning and sometimes at the end...)
git_push()
{
   tags=0
   force=0
   while [ "$1" != "" ]
   do
      if [ "${1%-tags}" != $1 ]
      then
         tags=1
      elif [ "${1%-force}" != $1 ]
      then
         force=1
      fi
      shift
   done
   git_branch=`git branch 2>/dev/null | awk '($1=="*") {print $2}'`
   repos=`git remote`
   for repo in $repos
   do
      remote_branch="triou/TMA" 
      [ "$repo" = "github_write" ] && remote_branch="next"
      repo_log=$REP_NUIT"/git_"$repo"_"$git_branch"_"$HOST".log"
      echo "TRUST git push on $HOST the `date` ...">$repo_log
      echo>>$repo_log
      echo "  git push $repo $git_branch. See $repo_log"
      if [ "$tags" != 1 ]
      then
         if [ "$force" != 1 ]
         then
	    if [ "$git_branch" != "Livraison" ]
	    then
               git push $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push $repo $git_branch\" $TRUST_MAIL
	    else
               git push $repo $git_branch":"$remote_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push $repo TMA\" $TRUST_MAIL
	    fi
         else
            git push --force $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push force $repo $git_branch\" $TRUST_MAIL
         fi
      else
         if [ "$force" != 1 ]
         then
	    if [ "$git_branch" != "Livraison" ]
	    then
               git push --tags $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push tags $repo $git_branch\" $TRUST_MAIL
	    else
               git push --tags $repo $git_branch":"$remote_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push tags $repo TMA\" $TRUST_MAIL
	    fi
         else
            git push --force --tags $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push force tags $repo $git_branch\" $TRUST_MAIL
         fi
      fi
      cat $repo_log | tail -n +3
      if [ "$git_branch" != "Livraison" ]
      then
         [ "`cat $repo_log | tail -n +3`" != "Everything up-to-date" ] && cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST git push $repo $git_branch\" $TRUST_MAIL 
      else
         [ "`cat $repo_log | tail -n +3`" != "Everything up-to-date" ] && cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST git push $repo TMA\" $TRUST_MAIL 
      fi
   done
}

############################################################################################################################################################

#########
# BEGIN #
#########
export LANG=C
echo "****************************************************"
echo `date`
echo "Beginning of the `basename $0` script at `date '+%H:%M:%S'` from:"
echo "\$TRUST_ROOT=${0%/bin/admin/lance_test_nuit}"
echo "****************************************************"
echo " "
echo "##########################"
echo "# Initialize environment #"
echo "##########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
if [ -f ~/.profile ]
then
   echo "Call to "`echo ~`"/.profile"
   . ~/.profile 1>/dev/null 2>&1
   echo "  HOST=$HOST"
   echo "  WORKDIR=$WORKDIR"
   echo "  WORKBASE=$WORKBASE"
else
   echo `echo ~`"/.profile file not exist!" && exit -1
fi
# ROOT
export TRUST_ROOT=${0%/bin/admin/lance_test_nuit}
export TRUST_ROOT_MASTER=$TRUST_ROOT # New variable to set Livraison workdir (master branch in git)

# On recupere les numeros de version dans le fichier RELEASE_NOTES
export old=`awk '/version/ {print $(NF-1);exit}' $TRUST_ROOT/RELEASE_NOTES`
export new=`awk '/version/ {print $4;exit}' $TRUST_ROOT/RELEASE_NOTES`
export Version=Version$new
echo " "
echo "Release notes old version: "$old
echo "Release notes new version: "$new

# DISPLAY
[ ${#DISPLAY} = 0 ] && export DISPLAY=":0"
[ "`echo -e`" != "-e" ] && ECHO_OPTS="-e"

#VOBS="Doc_TRUST Pre_Post_TRUST Tests_TRUST TRUST Composants"
VOBS="TRUST Composants"

# List of components tested with TRUST:
# TrioCFD est ajoute a la liste car est devenu un Baltik de TRUST suite au decoupage de Trio_U.
# ICoCo est devenu un Outil de TRUST.
# equation_convection_diffusion est un projet Baltik qui sert de tutorial a la formation developpeur.
# MPCube est un Baltik qui peut etre teste sur TRUST et sur le kernel.
# basic est le template Hello_word qui permet de tester TRUST avec make check_trust_optim (pas possible via script de portabilite) 
# => on utilise maintenant le baltik Test_Baltik pour la portabilite
#ComposantsLns="Test_Baltik basic equation_convection_diffusion ICoCo"
ComposantsLns="Test_Baltik equation_convection_diffusion ICoCo"
#ComposantsGit="triocfd ijk polymac triomc mathys mpcube genepi3 pxp flica5"
ComposantsOfficial="triocfd ijk mpcube genepi3 flica5 TRUST-NK cathare3D"
# 14/10/2020 : je retire mathys et triomc sur decision RPL
#export ComposantsBeta="triomc mathys sides scorpio pemfc"
export ComposantsBeta="sides scorpio sympy_to_TRUST pemfc flica5 cathare3D"
ComposantsGit=$ComposantsOfficial" "$ComposantsBeta
ComposantsGit=`echo $ComposantsGit | xargs -n1 | sort -u | xargs`
export Composants=$ComposantsLns" "$ComposantsGit

# Initialize environment TRUST:
echo " "
echo "Call to "$TRUST_ROOT"/env/TRUST.env"
. $TRUST_ROOT/env/TRUST.env #1>/dev/null 2>&1

# List of executables tested:
exec_debug=$TRUST_ROOT/exec/TRUST$COMM
exec_semi_opt=$TRUST_ROOT/exec/TRUST$COMM"_semi_opt"
exec_opt=$TRUST_ROOT/exec/TRUST$COMM"_opt"
liste_exec=$exec_debug" "$exec_semi_opt

# Initialize ftp connection:
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/connect_ftp"
. $TRUST_ROOT/bin/admin/connect_ftp -no_ftp #1>/dev/null 2>&1
echo "Public  ftp server: ftp://$TRUST_FTP/$PUBLIC"
echo "Private ftp server: ftp://$TRUST_FTP/$SECRET"
echo " "

# Backup de hostname
echo "Call to "`echo ~`"/bin/backup_pc_tma.sh via crontab"
echo "  See "`echo ~`"/bin/backup_pc_tma.log"
# NB: Now via crontab
#~/bin/backup_pc_tma.sh 1>~/bin/backup_pc_tma.log 2>&1
head -n1 ~/bin/backup_pc_tma.log
grep "Backup " ~/bin/backup_pc_tma.log
tail -n1 ~/bin/backup_pc_tma.log
echo " "

[ $HOST != $TRUST_HOST_ADMIN ] && echo "Error: You must be on $TRUST_HOST_ADMIN to do this action" && exit

export DATE=`date '+%d%m%y'`
export NUIT=1
REP_NUIT=/home/trust_trio/triou/tmptrust/tmptrust/Historique/NUIT
REP_HIST=/home/trust_trio/triou/tmptrust/tmptrust/Historique/HIST
MESSAGES_NUIT=$REP_NUIT/MESSAGES_NUIT
MESSAGES_LIVRAISON=~/MESSAGES_LIVRAISON

# On fait le menage :
echo "Cleaning of $REP_NUIT directory"
rm -f $REP_NUIT/CR_* $REP_NUIT/PERF_* $REP_NUIT/MAKE_* $REP_NUIT/*.log
rm -f $REP_NUIT/rsync_include_from $REP_NUIT/NUIT.html
rm -f $REP_NUIT/os $REP_NUIT/CC $REP_NUIT/CR
rm -f $MESSAGES_NUIT $REP_NUIT/nuit_*.html
rm -f $REP_NUIT/MESSAGES_LIVRAISON* $REP_NUIT/MESSAGES_NUIT
rm -rf $REP_NUIT/Maintenance
rm -f $REP_NUIT/.nfs*
# On cree :
[ ! -d $REP_NUIT ] && mkdir $REP_NUIT
[ ! -d $REP_NUIT/Maintenance ] && mkdir -p $REP_NUIT/Maintenance
[ ! -d $REP_HIST ] && mkdir $REP_HIST
ls -a $REP_NUIT
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "###########################"
echo "# Work on the new version #"
echo "###########################"

###################################
# Debut du travail sur la version #
###################################
echo " "
echo "############################"
echo "# Create the documentation #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
credoc_log=$REP_NUIT/credoc_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/KSH/credoc"
echo "  See $credoc_log"
echo "TRUST documentation creation on $HOST the `date` ...">$credoc_log
echo>>$credoc_log
$TRUST_ROOT/bin/KSH/credoc 1>>$credoc_log 2>&1
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "######################"
echo "# Update the sources #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $TRUST_ROOT
# Mise a jour des includes, des makefile de TRUST
config_log=$REP_NUIT/configure_$HOST.log
echo "Call to "$TRUST_ROOT"/configure"
echo "  See $config_log"
echo "TRUST configuration on $HOST the `date` ...">$config_log
echo>>$config_log
./configure -force_provided_mpich 1>>$config_log || exit -1
#grep -i error $config_log
grep KO $config_log
tail -n9 $config_log | head -n1
echo " "
echo "Call to "$TRUST_ROOT"/env_TRUST.sh"
source env_TRUST.sh #1>/dev/null 2>&1

# Verifie la qualite de la version
# Verifie si plusieurs classes ne sont pas instanciees avec le meme nom
# Verification de l'unicite du nom des classes dans les macros implemente_...
instanc_log=$REP_NUIT/verifie_instanciable_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/KSH/verifie_instanciable"
echo "  See $instanc_log"
echo "TRUST instanciable check on $HOST the `date` ...">$instanc_log
echo>>$instanc_log
verifie_instanciable 1>>$instanc_log 2>&1
grep -i error $instanc_log
tail -n1 $instanc_log 
##############################################################
# verifie pere doit etre appele apres la compilation de TRUST
##############################################################
# # Verifie la validite de la classe mere dans les instanciations
# # Verification du nom de la classe pere dans les macros implemente_...
# verif_log=$REP_NUIT/Verifie_pere_$HOST.log
# echo " "
# echo "Call to "$TRUST_ROOT"/bin/KSH/Verifie_pere"
# echo "  See $verif_log"
# echo "TRUST father class check on $HOST the `date` ...">$verif_log
# echo>>$verif_log
# Verifie_pere 1>>$verif_log 2>&1
# verif_error=$?
# tail -n1 $verif_log
# if [ $verif_error != 0 ]
# then
#    echo>>$verif_log
#    cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log
#    cat $verif_log | mail_ -s\"[lance_test_nuit] Verifie_pere KO on $HOST:$TRUST_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
# fi
# echo>>$verif_log
# cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log 

# Gestion externalpackages
cd $TRUST_ROOT/bin/gestion_externalpackages
external_log=$REP_NUIT/Verify_externalpackages_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/gestion_externalpackages/Verify_externalpackages.sh"
echo "  See $external_log"
echo "TRUST external packages check on $HOST the `date` ...">$external_log
echo>>$external_log
./Verify_externalpackages.sh 1>>$external_log 2>&1
nb_error=`grep "not in" $external_log | wc -l`
if [ $nb_error != 0 ]
then
   cat $external_log | mail_ -s\"[lance_test_nuit] Verify_externalpackages.sh KO on $HOST:$TRUST_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
   cat $external_log
   echo "  KO"
else
   echo "  OK"
fi
liste_log=$REP_NUIT/Verify_liste_dep_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/gestion_externalpackages/Verify_liste_dep.sh"
echo "  See $liste_log"
echo "TRUST external packages liste dep on $HOST the `date` ...">$liste_log
echo>>$liste_log
# NB: Verification complete (apres nettoyage) le vendredi
[ "`date '+%u'`" = 5 ] && rm -r -f $TRUST_ROOT/build/bin/gestion_externalpackages/Test
./Verify_liste_dep.sh 1>>$liste_log 2>&1
# les paquets suivants sont bypasser car je ne sais pas ou adrien les a recuperer et si il les a modifie sciemment !!
# | CurvePlot-9.4.0.tar.gz, configuration-9.4.0.tar.gz, medcoupling-9.4.0.tar.gz, xdata-9.6.0.tar.gz et hdf5-1.10.3.tar.gz
# les 4 paquets suivants different car
# qt-everywhere-opensource-src-4.8.3 sans doc (taille passe de 685M a 352M)
# med-3.0.7 sans doc et sans python (taille passe de 162M a 19M)
# med-3.2.1 sans doc (taille passe de 45M a 17M)
# osu-micro-benchmarks-3.8 version initiale non retrouvee
# petsc-3.10.0 : superlu_dist.py correction TMA
nb_error=`grep "FAILED" $liste_log | grep -v qt-everywhere-opensource-src-4.8.3 | grep -v ml-6.2-p4 | grep -v VTK-8.1.0 | grep -v scalapack-2.1.0-p2 | grep -v med-4.1.1 | grep -v osu-micro-benchmarks-3.8 | grep -v scotch-6.0.9 | grep -v osqp-0.6.0 | grep -v configuration-9.8.0 | grep -v medcoupling-9.8.0 | grep -v xdata-9.6.0 | grep -v hdf5-1.10.3 | grep -v superlu-5.2.1 | grep -v hypre-2.19.0 | grep -v Miniforge3-Linux-aarch64.sh | grep -v AmgX_6dba8067ca | grep -v nvc_get_devices | grep -v AmgXWrapper_331eba32db693528749bd2c46158073079d80972 | grep -v viennacl-dc552a8 | grep -v SPARSKIT2 | grep -v zlib-1.2.11 | grep -v visit2.12.1 | grep -v setuptools-28.0.0 | grep -v seedme-python-client-v1.2.4 | grep -v requests-2.5.1 | grep -v qwt-6.1.2 | grep -v numpy-1.11.2 | grep -v Python-2.7.11 | grep -v Imaging-1.1.7 | grep -v IceT-1-0-0 | grep -v importlib_metadata-4.8.2 | wc -l`
# les 3 paquets suivants sont sous http://downloads.sourceforge.net/project/trust-platform/X.Y.Z/extra/
# medcoupling-7.8.0.tar.gz
# hypre-2.10.0b-p2-TRUST.tar.gz
# CURVEPLOT.tgz
# nvc_get_devices.tgz
if [ $nb_error != 0 ]
then
   # qt-everywhere-opensource-src-4.8.3 sans doc (taille passe de 685M a 352M)
   # med-3.0.7 sans doc et sans python (taille passe de 162M a 19M)
   # osu-micro-benchmarks-3.8 version initiale non retrouvee
   # petsc-3.10.0 : superlu_dist.py correction TMA
   #liste_failed=`grep "FAILED" $liste_log | sed "s,: FAILED,," | grep -v qt-everywhere-opensource-src-4.8.3 | grep -v med-3.2.1 | grep -v osu-micro-benchmarks-3.8 | grep -v medcoupling-7.8.0 | grep -v hypre-2.10.0b-p2-TRUST | grep -v CURVEPLOT | grep -v nvc_get_devices`
   liste_failed=`grep "FAILED" $liste_log | sed "s,: FAILED,," | grep -v qt-everywhere-opensource-src-4.8.3 | grep -v ml-6.2-p4 | grep -v VTK-8.1.0 | grep -v scalapack-2.1.0-p2 | grep -v med-4.1.1 | grep -v osu-micro-benchmarks-3.8 | grep -v scotch-6.0.9 | grep -v osqp-0.6.0 | grep -v configuration-9.8.0 | grep -v medcoupling-9.8.0 | grep -v xdata-9.6.0 | grep -v hdf5-1.10.3 | grep -v superlu-5.2.1 | grep -v hypre-2.19.0 | grep -v Miniforge3-Linux-aarch64.sh | grep -v AmgX_6dba8067ca | grep -v nvc_get_devices | grep -v AmgXWrapper_331eba32db693528749bd2c46158073079d80972 | grep -v viennacl-dc552a8 | grep -v SPARSKIT2 | grep -v zlib-1.2.11 | grep -v visit2.12.1 | grep -v setuptools-28.0.0 | grep -v seedme-python-client-v1.2.4 | grep -v requests-2.5.1 | grep -v qwt-6.1.2 | grep -v numpy-1.11.2 | grep -v Python-2.7.11 | grep -v Imaging-1.1.7 | grep -v IceT-1-0-0 | grep -v importlib_metadata-4.8.2`
   cd $TRUST_ROOT/build/bin/gestion_externalpackages/Test
   rm -r -f old new
   for package in $liste_failed
   do
      echo>>$liste_log
      echo "Launch ../compare_archive $package">>$liste_log    
      $TRUST_ROOT/bin/gestion_externalpackages/compare_archive $package 1>>$liste_log 2>&1
   done
   cd - 1>/dev/null 2>&1
   cat $liste_log | mail_ -s\"[lance_test_nuit] Verify_liste_dep.sh KO on $HOST:$TRUST_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
   grep "computed checksums did NOT match" $liste_log
   grep "FAILED" $liste_log
   echo "  KO"
else
   echo "  OK"
fi
cd $TRUST_ROOT

# Gestion BUILD64
build64_log=$REP_NUIT/Verifie_patch_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/BUILD64/Verifie_patch"
echo "  See $build64_log"
./bin/BUILD64/Verifie_patch 1>$build64_log 2>&1
if [ -s $build64_log  ]
then
   echo>>$build64_log
   echo "=> tkdiff diff_patch bin/BUILD64/diff_patch.ref ">>$build64_log
   cat $build64_log | mail_ -s\"[lance_test_nuit] BUILD64 Verifie_patch KO on $HOST:$TRUST_ROOT\" $TRUST_MAIL
   cat $build64_log
   echo "  KO"
else
   echo "  OK"
   rm diff_patch
fi

# Marque la version dans MAIN.cpp et mon_main.cpp
#if [ "`echo $new | grep beta`" = "" ]
#then
   echo " "
   echo "Mark new version in following files:"
   for MAIN in $TRUST_ROOT/src/MAIN/MAIN.cpp
   do
      CHECKOUT $MAIN 1>/dev/null 2>&1
      version=`$TRUST_Awk '/version :/ {print $4}' $MAIN`
      echo "  "$version"=>"$new": "$MAIN
      echo $ECHO_OPTS "1,$ s?version : $version?version : $new?g\nw" | ed $MAIN 1>/dev/null 2>&1
      CHECKIN $MAIN 1>/dev/null 2>&1
   done
   for MAIN in $TRUST_ROOT/src/MAIN/mon_main.cpp $TRUST_ROOT/doc/TRUST/exercices/my_first_class/mon_main.cpp
   do
      CHECKOUT $MAIN 1>/dev/null 2>&1
      version=`$TRUST_Awk '/version :/ {print $6}' $MAIN`
      echo "  "$version"=>"$new": "$MAIN
      echo $ECHO_OPTS "1,$ s?version : $version?version : $new?g\nw" | ed $MAIN 1>/dev/null 2>&1
      CHECKIN $MAIN 1>/dev/null 2>&1
   done
   index=$TRUST_ROOT/index.html
   version=`$TRUST_Awk '/ Version / {print $4}' $index`
   echo $ECHO_OPTS "1,$ s?$version?$new?g\nw $index.new" | ed $index 1>/dev/null 2>&1
   if [ "`diff $index $index.new`" != "" ]
   then
      echo "Mark new version in "$index
      CHECKOUT $index
      cat $index.new > $index
   fi
   rm -f $index.new
   ref_manual=Outils/TRIOXDATA/XTriou/objet_u.py
   version=`$TRUST_Awk '/ Manual V/ {print $5}' $ref_manual`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $ref_manual.new" | ed $ref_manual 1>/dev/null 2>&1
   if [ "`diff $ref_manual $ref_manual.new`" != "" ]
   then
      echo "Mark new version in "$ref_manual
      CHECKOUT $ref_manual
      cat $ref_manual.new > $ref_manual
   fi
   rm -f $ref_manual.new
   tuto=doc/TRUST/Tutorial/TRUST_tutorial.tex
   version=`$TRUST_Awk '/ Tutorial V/ {print $3}' $tuto`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}]{TRUST?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
   version=`$TRUST_Awk '/ Tutorial V/ {print $5}' $tuto.new`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $tuto.new" | ed $tuto.new 1>/dev/null 2>&1
   if [ "`diff $tuto $tuto.new`" != "" ]
   then
      echo "Mark new version in "$tuto
      CHECKOUT $tuto
      cat $tuto.new > $tuto
   fi
   rm -f $tuto.new
   tuto=doc/TRUST/exercices/Tutorial_solutions/Tutorial_solutions.tex
   version=`$TRUST_Awk '/ Tutorial V/ {print $3}' $tuto`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
   if [ "`diff $tuto $tuto.new`" != "" ]
   then
      echo "Mark new version in "$tuto
      CHECKOUT $tuto
      cat $tuto.new > $tuto
   fi
   rm -f $tuto.new
   tuto=doc/TRUST/Tutorial/Baltik_tutorial.tex
   version=`$TRUST_Awk '/ Tutorial V/ {print $5}' $tuto`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}]{TRUST?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
   version=`$TRUST_Awk '/ Tutorial V/ {print $9}' $tuto.new`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $tuto.new" | ed $tuto.new 1>/dev/null 2>&1
   if [ "`diff $tuto $tuto.new`" != "" ]
   then
      echo "Mark new version in "$tuto
      CHECKOUT $tuto
      cat $tuto.new > $tuto
   fi
   rm -f $tuto.new
   tuto=doc/TRUST/Tutorial/ICoCo_tutorial.tex
   version=`$TRUST_Awk '/ Tutorial V/ {print $4}' $tuto`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}]{TRUST?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
   version=`$TRUST_Awk '/ Tutorial V/ {print $7}' $tuto.new`
   echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $tuto.new" | ed $tuto.new 1>/dev/null 2>&1
   if [ "`diff $tuto $tuto.new`" != "" ]
   then
      echo "Mark new version in "$tuto
      CHECKOUT $tuto
      cat $tuto.new > $tuto
   fi
   rm -f $tuto.new
   echo " "
   if [ "`echo $new | grep beta`" = "" ]
   then
      touch doc/TRUST/Generic_Guide/Generic_Guide.tex
   fi
#fi

[ ! -d $TRUST_ROOT/.git ] && echo "Error: You must have $TRUST_ROOT/.git directory to do this action" && exit

# Update Git repos #
####################
# Must be done BEFORE envoie_TRUST_arch (git_cron or git_ssh process)
(
   # Assume unchanged some files (big one with a lot of changes):
   cd $TRUST_ROOT/doc
   echo "Update Git repos "`pwd`
   for assume_inchanged in TRUST/TRUST_Reference_Manual.pdf TRUST/Keywords.txt Coverage/cpp.gcov.tar.gz Coverage/list_methodes.gz Coverage/dico.pkl.gz Coverage/list_methodes_non_appelees.gz
   do
      if [ ! -f $assume_inchanged ]
      then
         echo | mail_ -s\"[lance_test_nuit] File $assume_inchanged not found, fix lance_test_nuit. \" $TRUST_MAIL
      else
         # Ignore the changes of the specified files
         git update-index --assume-unchanged $assume_inchanged
      fi
   done
   # List untracked files:
   echo "  List of files untracked with git update-index --assume-unchanged:"
   git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'
   cd - 1>/dev/null 2>&1
   # Push to repos
   echo " "
   echo "Call git push origin TMA"
   git_push -tags
   cd $TRUST_ROOT/externalpackages
   repos=`git remote`
   for repo in $repos
   do
     remote_branch="triou/TMA" && tags_="--tags"
     echo " git push $repo TMA in `pwd`"
     git push $tags_ $repo Livraison:$remote_branch 1>tmp.log 2>&1
     cat tmp.log
     [ "`cat tmp.log`" != "Everything up-to-date" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] externalpackages git push $repo TMA\" $TRUST_MAIL 
     rm tmp.log 1>/dev/null 2>&1
   done
   cd - 1>/dev/null 2>&1

      
   # BALTIK
   for Composant in $ComposantsGit 
   do
      cd $WORKDIR/tuleap/Livraison/Composants/$Composant
      BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
      echo " git push origin TMA in `pwd`"
      if [[ "$Composant" != "triocfd" && "$Composant" != "flica5" && "$Composant" != "ijk" && "$Composant" != "mpcube" && "$Composant" != "TRUST-NK" && "$Composant" != "cathare3D" && "$Composant" != "sides" && "$Composant" != "scorpio" && "$Composant" != "sympy_to_TRUST" && "$Composant" != "pemfc" ]]
      then
         #if [[ "$Composant" == "triocfd" ]]
         #then
         #    git checkout -- Front_tracking_discontinu/tests/Reference/Validation/ftd_gravite_jdd1/ftd_gravite_jdd1.data
         #fi
         git push --tags origin Livraison:triou/TMA 1>tmp.log 2>&1
         cat tmp.log
         [ "`cat tmp.log`" != "Everything up-to-date" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant git push origin TMA\" $TRUST_MAIL 
         rm tmp.log 1>/dev/null 2>&1
      elif [[ "$Composant" == "triocfd" ]]
      then
         #git checkout -- Front_tracking_discontinu/tests/Reference/Validation/ftd_gravite_jdd1/ftd_gravite_jdd1.data
         git remote update
         git checkout .
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull KO \" $TRUST_MAIL
         else
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull OK \" $TRUST_MAIL
         fi
         rm tmp.log 1>/dev/null 2>&1
         git push origin_irene-ccrt Livraison:triou/TMA 1>tmp.log 2>&1
         cat tmp.log
         [ "`cat tmp.log`" != "Everything up-to-date" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant git push origin_irene-ccrt TMA\" $TRUST_MAIL 
         rm tmp.log 1>/dev/null 2>&1
         git push github_write Livraison:next 1>tmp.log 2>&1
         cat tmp.log
         [ "`cat tmp.log`" != "Already up to date" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant git push github TMA\" $TRUST_MAIL 
         rm tmp.log 1>/dev/null 2>&1
      elif [[ "$Composant" == "TRUST-NK" ]]
      then
         git remote update
         git checkout .
         git checkout master
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull master KO \" $TRUST_MAIL
         else
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull master OK \" $TRUST_MAIL
         fi
         rm tmp.log 1>/dev/null 2>&1
      elif [[ "$Composant" == "flica5" ]]
      then
         git remote update
         git checkout .
         git checkout portage
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull portage KO \" $TRUST_MAIL
         else
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull portage OK \" $TRUST_MAIL
         fi
         rm tmp.log 1>/dev/null 2>&1
         cd $WORKDIR/tuleap/Maintenance/Composants/$Composant
         git remote update
         git checkout .
         git checkout master
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit_maintenance] $Composant : git pull master KO \" $TRUST_MAIL
         else
            cat tmp.log | mail_ -s\"[lance_test_nuit_maintenance] $Composant : git pull master OK \" $TRUST_MAIL
         fi
         rm tmp.log 1>/dev/null 2>&1
         cd -
      elif [[ "$Composant" == "cathare3D" ]]
      then
         git remote update
         git checkout .
         git checkout Issue0066_portage185
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull Issue0066_portage185 KO \" $TRUST_MAIL
         else
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull Issue0066_portage185 OK \" $TRUST_MAIL
         fi
         rm tmp.log 1>/dev/null 2>&1
         cd $WORKDIR/tuleap/Maintenance/Composants/$Composant
         git remote update
         git checkout .
         #git checkout master
         git checkout advance
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit_maintenance] $Composant : git pull master KO \" $TRUST_MAIL
         else
            cat tmp.log | mail_ -s\"[lance_test_nuit_maintenance] $Composant : git pull master OK \" $TRUST_MAIL
         fi
         rm tmp.log 1>/dev/null 2>&1
         cd -
      else
         git remote update
         git checkout .
         git checkout portage 1>tmp.log 2>&1
         [ $? != 0 ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git checkout portage KO\" $TRUST_MAIL
         rm tmp.log 1>/dev/null 2>&1
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull portage KO \" $TRUST_MAIL
         else
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull portage OK \" $TRUST_MAIL
         fi
         rm tmp.log 1>/dev/null 2>&1
         #git push origin Livraison:triou/TMA 1>tmp.log 2>&1
      fi
      cd - 1>/dev/null 2>&1
   done
)
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "#######################################"
echo "# Send the sources to remote machines #"
echo "#######################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
envoie_log=$REP_NUIT/envoie_TRUST_arch_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/envoie_TRUST_arch"
echo "  See $envoie_log"
echo "TRUST script on $HOST the `date` ...">$envoie_log
echo>>$envoie_log
touch liste_envoie_KO
# NB: Versions distantes automatiquement effacees le vendredi
envoie_TRUST_arch 1>>$envoie_log 2>&1
export liste_machines_KO=`cat liste_envoie_KO`
rm -f liste_envoie_KO
grep -i delete $envoie_log | head -n1
grep "KO " $envoie_log
#grep error $envoie_log
mv -f build/rsync_*.log $REP_NUIT/.
mv -f build/rsync_include_from $REP_NUIT/.
mv -f build/ssh_*.log $REP_NUIT/.
# On recupere le nom des machines sur lesquelles les sources n ont pu etre mises a jour
# Cette liste permettra de ne pas lancer la portabilite des baltiks sur ces machines
if [ ${#liste_machines_KO} != 0 ] # chaine non vide
then
   echo "  liste_machines_KO:"
   echo $liste_machines_KO
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "###############################################"
echo "# Compile and verify the old and new versions #"
echo "###############################################"
( 
  # On allege le nombre de versions compilees:
  for vue in tuleap/Livraison tuleap/Maintenance tuleap/Kernel
  do
     if [ -d $WORKDIR/$vue ]
     then
	# Git workdir
	TRUST_ROOT=$WORKDIR/$vue/TRUST
	cd $TRUST_ROOT
        echo " "
        echo "#############################"
        echo "# On workdir: "$TRUST_ROOT
        echo "#############################"
        echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
	if [ $vue = tuleap/Kernel ]
	then
           # Kernel desormais workdir Git:
	   #rebase_log=`mktemp_`
	   rebase_log=$REP_NUIT"/rebase_"$HOST"_"${vue#*/}".log"
	   echo "Call git rebase TMA"
	   echo "  See $rebase_log"
           echo "git rebase on $HOST the `date` ...">$rebase_log
           echo>>$rebase_log
           echo "externalpackages">>$rebase_log
	   cd $TRUST_ROOT/externalpackages
	   git rebase Livraison 1>>$rebase_log 2>&1
	   [ $? != 0 ] && echo "  KO rebase externalpackages"
	   git rebase --continue 1>>$rebase_log 2>&1
	   [ "`git rebase --continue 2>&1`" != "No rebase in progress?" ] && echo "  KO rebase externalpackages"
	   cd - 1>/dev/null 2>&1
           echo>>$rebase_log
	   for Composant in $ComposantsGit
	   do
              if [ -d $TRUST_ROOT/../Composants/$Composant ]
              then
                 echo "Composants/$Composant">>$rebase_log
	         cd $TRUST_ROOT/../Composants/$Composant
#	          git rebase Livraison 1>>$rebase_log 2>&1
#	          [ $? != 0 ] && echo "  KO rebase Composants/$Composant"
#	          git rebase --continue 1>>$rebase_log 2>&1
#	          [ "`git rebase --continue 2>&1`" != "No rebase in progress?" ] && echo "  KO rebase Composants/$Composant"
                 git remote update
                 git checkout .
#                On test uniquement mpcube sur la verison Kernel !
#                La branche est appele portage car elle ne bouge pas beacoup
                 git checkout portage
                 git pull
	         cd - 1>/dev/null 2>&1
                 echo>>$rebase_log
	      fi
	   done
	   cd $TRUST_ROOT
	   git commit doc/.dico src/CMakeLists.txt src/MAIN/instancie_appel.h src/MAIN/instancie_appel_c.h -m"Commit in Kernel before git rebase TMA" --u=no 1>>$rebase_log 2>&1
	   git rebase Livraison 1>>$rebase_log 2>&1
	   rebase_error=$?
	   if [ $rebase_error != 0 ]
	   then
	      deleted_item=deleted_item
	      compt=10
	      while [ $rebase_error != 0 ] && [ "$deleted_item" != "" ] && [ $compt != 0 ]
	      do
	         let compt=$compt-1
	         for deleted_item in `git status | awk '/deleted by them/ || /added by us/ {print $4}'`
	         do
		    git rm $deleted_item #1>>$rebase_log 2>&1
	         done
	         git rebase --continue 1>>$rebase_log 2>&1
	         rebase_error=$?
		 if [ "`git rebase --continue 2>&1`" = "No rebase in progress?" ]
		 then
		    rebase_error=0
		 fi
	      done
	   fi
	   if [ $rebase_error != 0 ]
	   then
	      cat $rebase_log | mail_ -s\"[lance_test_nuit] Error when rebasing $vue workdir. Check.\" $TRUST_MAIL
	   fi
	   grep -i error $rebase_log
	   echo "  rebase_error=$rebase_error"
	   echo " "
	   #rm -f $rebase_log
	   # Delete non Kernel src if any:
	   cd $TRUST_ROOT/src
	   NonKernelTests=`find * -type d | grep -v Kernel | grep -v MAIN`
	   if [ "$NonKernelTests" != "" ]
	   then
	      echo "Call git rm no $vue tests..."
	      for NonKernelTest in $NonKernelTests
	      do
		 git rm -r $NonKernelTest
	      done
	      #git commit --all -m"Non Kernel src suppressed from the branch Kernel"
	      echo " "
	   fi
	   cd - 1>/dev/null 2>&1
	   # Delete non Kernel tests if any:
	   cd $TRUST_ROOT/tests
	   NonKernelTests=`find * -type d | grep -v Kernel | grep "/"`
	   if [ "$NonKernelTests" != "" ]
	   then
	      echo "Call git rm no $vue tests..."
	      for NonKernelTest in $NonKernelTests
	      do
		 git rm -r $NonKernelTest
	      done
	      #git commit --all -m"Non Kernel tests suppressed from the branch Kernel"
	      echo " "
	   fi
	   cd - 1>/dev/null 2>&1
	   # Delete non Kernel verification if any:
	   cd $TRUST_ROOT/Validation/Rapports_automatiques/Verification
	   NonKernelTests=`find * -type d | grep -v Kernel | grep -v src |grep "/"`
	   if [ "$NonKernelTests" != "" ]
	   then
	      echo "Call git rm no $vue tests..."
	      for NonKernelTest in $NonKernelTests
	      do
		 git rm -r $NonKernelTest
	      done
	      git commit --all -m"Non Kernel src, tests and verification suppressed from the branch Kernel"
	      echo " "
	   fi
	   cd - 1>/dev/null 2>&1
	   if [ $rebase_error = 0 ]
	   then
              echo "Call git push origin Kernel"
              #git_push -tags -force
              git push --force origin Kernel:triou/Kernel 1>tmp.log 2>&1
              [ "`cat tmp.log`" != "Everything up-to-date" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] Kernel: git push origin TMA\" $TRUST_MAIL 
              echo " "
	   fi
	fi
	echo "Call to configure $vue version in `pwd`"
	./configure -force_provided_mpich 1>/dev/null 2>&1
        source env_TRUST.sh 1>/dev/null 2>&1
	echo "TRUST_ROOT=$TRUST_ROOT"
	echo "TRUST_VERSION=$TRUST_VERSION"
	###################################################
	# Boucle sur les differentes options de compilation
	###################################################
	for OPT in _semi_opt_ _opt_ _ _opt_pg_ _opt_gcov_ _opt_avx_
	do
           case $OPT in
	   _semi_opt_) TYPE="semi_opt";;
	   _opt_) TYPE="opt";;
	   _) TYPE="debug";;
	   _opt_pg_) TYPE="prof";;
	   _opt_gcov_) TYPE="gcov";;
	   _opt_avx_) TYPE="opt_avx";;
           *) echo $OPT not coded in $0;  exit -1 ;;
	   esac;
	   OPT=${OPT%_} # <=> OPT=${OPT::-1}
	   echo " "
	   make_log=$REP_NUIT"/MAKE_TRUST"$COMM"_"$TYPE"_"$TRUST_ARCH"_"$HOST"_"${vue#*/}
           echo "Call to make $TYPE on `pwd`";
	   echo "  See $make_log"
           echo "TRUST make on $HOST the `date` ...">$make_log
           echo>>$make_log
	   make $TYPE 1>>$make_log 2>&1
	   grep "BUILD_" $make_log
	   grep error $make_log
	   grep -i Stop $make_log
	   grep KO $make_log
	   if [ "$OPT" = "_semi_opt" ]
	   then
	      if [ $vue = tuleap/Livraison ]
	      then
                 # Force une compilation statique pour:
                 # a) Instanciation manquante
                 # b) Sauve un exec en le zippant sous NUIT
		 echo " "
		 echo "Call to make with COMPIL_DYN=OFF on $TRUST_ROOT/MonoDir_mpi$OPT/src"
                 cd $TRUST_ROOT/MonoDir_mpi$OPT/src
		 cmake . -DCOMPIL_DYN=OFF
   		 tmp=`mktemp_`
		 make 1>>$tmp 2>&1
		 tail -n2 $tmp
		 rm -f $tmp
                 gzip -c $exec > $REP_HIST/`basename $exec`"."$DATE".gz"
		 cd $TRUST_ROOT
		 echo " "
	         echo "Save "$REP_HIST/`basename $exec`"."$DATE".gz"
	      elif [ $vue = tuleap/Maintenance ]
	      then
	         echo " "
		 new_patch=1
	         echo "Special treatment..."
	         ################################
	         # Travaux sur la vue Maintenance
		 ################################
		 checkin_log=$REP_NUIT"/checkin_patch_"$HOST"_"${vue#*/}".log"
                 echo "Call to "$TRUST_ROOT"/bin/admin/checkin_patch.ct"
                 echo "  See $checkin_log"
                 echo "TRUST checkin patch on $HOST the `date` ...">$checkin_log
		 #$TRUST_ROOT/bin/admin/checkin_patch.ct 1>>$checkin_log 2>&1 # Test a revoir
		 wc -l $checkin_log
		 grep "diff --git" $checkin_log
		 if [ "`cat $checkin_log | tail -n +2`" != "" ]
		 then
		 cat $checkin_log | mail_ -s\"[checkin_patch.ct] Changes in the $TRUST_VERSION patch branch\" $TRUST_MAIL
		 #######################
		 # Construction du patch
		 #######################
		 patch_version=`awk '/version/ && /Release notes/ {print $4;exit}' RELEASE_NOTES`
		 rm -f $TRUST_TMP/patch
		 GRAVAGE=$WORKDIR/archives/ARCHIVES_TRUST
		 patch=$GRAVAGE/Patch-$patch_version".tar.gz" && rm -f $patch
		 echo " "
		 echo "Construction of the $patch patch..."
		 echo "from `pwd`"
		 # Git (On ne scrute que les VOBs TRUST):
		 cd $TRUST_ROOT
                 #echo "  Call git push origin Maintenance"
		 #git_push -tags
		 echo "  Files contained in the patch"
                 Build=$TRUST_ROOT/build
                 [ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
		 echo "    See $Build/patch.files"
		 git diff --name-only v$TRUST_VERSION > $Build/patch.files
                 patch_error=$?
		 if [ -s $Build/patch.files ]
		 then
                    # ajout du log pour identifier l'archive
		    git log -1 > .git_patch_log
                    echo .git_patch_log >> $Build/patch.files
		    # Ajout de Patch au fichier
		    #BASE=`basename $TRUST_ROOT`
		    #for file in `cat $Build/patch.files`
		    #do
		    #   if [ -f $file ]
		    #   then
		    #      echo $BASE/$file
        	    #   fi
		    #done > Patch.files
		    # creation des archives
		    echo "  Files compressed in $patch"
		    tar zcf $patch `cat $Build/patch.files`
		    #cd ..
		    #tar zcf $patch  --transform=s?$BASE?Patch-${patch_version}? `cat $BASE/Patch.files`
		    #md5sum  $patch > $patch.md5
		 fi
		 cd $TRUST_ROOT
		 cat $Build/patch.files 
		 rm -f Patch.files
                 if [ $patch_error = 0 ] && [ -s $Build/patch.files ]
                 then
		    # Envoi immediat sur ftp.cea.fr
                    echo "  Call to "$TRUST_ROOT"/bin/admin/connect_ftp"
                    . $TRUST_ROOT/bin/admin/connect_ftp
                    echo "  Call to "$TRUST_ROOT"/bin/admin/cp_ftp"
		    $TRUST_ROOT/bin/admin/cp_ftp $patch $PUBLIC/patch
		    # Mise a jour des versions patchees
		    echo " "
                    echo "Call to "$TRUST_ROOT"/bin/admin/Installer_TRUST.ssh on:"
		    liste_machines updated
		    for machine in `liste_machines updated`
		    do
		       (
		       install_patch_log=$REP_NUIT"/install_patch_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
		       echo "-> Start of Installer_TRUST.ssh $machine $patch_version -patch -compile..."
	               echo "  See $install_patch_log"
		       )
		    done
		    for machine in `liste_machines updated`
		    do
		       (
		       install_patch_log=$REP_NUIT"/install_patch_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
                       echo "TRUST script on $HOST the `date` ...">$install_patch_log
		       echo>>$install_patch_log
		       $TRUST_ROOT/bin/admin/Installer_TRUST.ssh $machine $patch_version -patch -compile 1>>$install_patch_log 2>&1
		       if [ $? != 0 ] || [ "`grep :error $install_patch_log | grep -iv warning | grep -v TRIOXDATA | grep -v Gmsh`" != "" ]
		       then
                          cat $install_patch_log | mail_ -s\"[lance_test_nuit] Failed to install patch version on $machine\" $TRUST_MAIL
		       fi
		       ) &
		       # Quels sont les conflits ?
		    done
		 elif [ $patch_error != 0 ]
		 then
                    echo "Not install on remote machine!" | mail_ -s\"[lance_test_nuit] Failed to create $TRUST_VERSION patch version\" $TRUST_MAIL
		 fi
		 else
		    echo "No patch"
		    new_patch=0
		 fi
	         echo "End special treatment."
	      fi
	   fi
	done
	########################
	# Check non regression #
	########################
	if ([ $vue = tuleap/Maintenance ] && [ $new_patch != 0 ]) || [ $vue = tuleap/Kernel ]
	then
	   lance_test_log=$REP_NUIT"/lance_test_"$HOST"_"${vue#*/}".log"
	   echo " "
	   echo "-> Start of exec=$exec_opt trust -check all"
           echo "  See $lance_test_log"
           echo "TRUST script on $HOST the `date` ...">$lance_test_log
	   echo>>$lance_test_log
	   # Reduce priority with nice:
	   exec=$exec_opt nice -n 19 $TRUST_ROOT/bin/trust -check all 1>>$lance_test_log 2>&1 &
	fi
	###############################
	# Verification des composants #
	###############################
	#if ([ $vue = tuleap/Maintenance ] && [ $new_patch != 0 ]) || [ $vue = tuleap/Kernel ]
	if [ $vue = tuleap/Maintenance ] || [ $vue = tuleap/Kernel ] # Test a revoir : pour livraison TrioMC qd TRUST est tagguee
	then
	   echo " "
	   echo "Call check_components for $TRUST_VERSION version from `pwd`"
	   check_components $vue
	fi
	if [ $vue = tuleap/Livraison ]
	then
	   ##########################################
 	   # Merge needed from patch branch under Git
 	   ##########################################
	   to_merge=`mktemp_`
  	   patch_branch=`cd $WORKDIR/tuleap/Maintenance/TRUST;git rev-parse --abbrev-ref HEAD`
  	   master_branch=`cd $WORKDIR/tuleap/Livraison/TRUST;git rev-parse --abbrev-ref HEAD`
	   echo " "
 	   echo "Call `pwd`/git diff --name-status $master_branch...$patch_branch"
 	   git diff --name-status $master_branch...$patch_branch 1>$to_merge
	   cat $to_merge
 	   if [ -s $to_merge ]
	   then
	      echo "  KO: Some stuff to merge in $master_branch from $patch_branch with command: fusion.git $patch_branch"
	      cat $to_merge | mail_ -s\"[lance_test_nuit] Some stuff to merge in $master_branch from $patch_branch with command: fusion.git $patch_branch\" $TRUST_MAIL
	   else
	      echo "  OK: No stuff to merge in $master_branch from $patch_branch"
	   fi
 	   rm -f $to_merge
	fi
        echo "<--- End at "`date '+%H:%M:%S %d/%m'`
     fi
  done
)
TRUST_ROOT=${0%/bin/admin/lance_test_nuit}
cd $TRUST_ROOT
source env_TRUST.sh 1>/dev/null 2>&1

##############################################################
# verifie pere doit etre appele apres la compilation de TRUST
##############################################################

# Verifie la validite de la classe mere dans les instanciations
# Verification du nom de la classe pere dans les macros implemente_...
verif_log=$REP_NUIT/Verifie_pere_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/KSH/Verifie_pere"
echo "  See $verif_log"
echo "TRUST father class check on $HOST the `date` ...">$verif_log
echo>>$verif_log
Verifie_pere 1>>$verif_log 2>&1
verif_error=$?
tail -n1 $verif_log
if [ $verif_error != 0 ]
then
   echo>>$verif_log
   cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log
   cat $verif_log | mail_ -s\"[lance_test_nuit] Verifie_pere KO on $HOST:$TRUST_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
echo>>$verif_log
cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log 

echo " "
echo "------------------------------------------------------"
echo " "
echo "########################"
echo "# Test the new version #"
echo "########################"

####################################################
# Lancement des etudes sur une machine de production
####################################################
ETUDES=$WORKDIR/tuleap/Etudes
echo " "
echo "##################"
echo "# On study cases #"
echo "##################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
etude_activation=1
if [ `date '+%u'` -ge 5 ]
then
   # le vendredi soir on lance toutes les etudes
   etude_test=0
else
   # On ne lance qu'une etude
   etude_test=1
fi
# On lance toutes les etudes
etude_test=0

disable_etudes=~/disable_etudes && [ -f $disable_etudes ] && etude_test=1 && rm -f $disable_etudes
if [ $etude_activation = 1 ] 
then
   cd $ETUDES 2>/dev/null
   if [ $? != 0 ]
   then
      echo "Error: $ETUDES not found !"
      echo "  You should create a git repo for Etudes and change the run script"
      echo "  or for the moment, you can create a link to Etudes directory."
      etude_activation=0
   fi
fi
# seulement si le script run de la veille est termine (ie run_Etudes.log deplace dans $REP_NUIT)
if [ $etude_activation = 1 ]  && [ -f run_Etudes.log ]
then
   echo "NOT launched because $ETUDES/run script not finished"
   echo "  See $ETUDES/run_Etudes.log"
   etude_activation=0
fi
if [ $etude_activation = 1 ]  && [ ! -f run_Etudes.log ] && [ $etude_test = 1 ]
then
   touch $ETUDES/run_Etudes.log
   echo "  See $REP_NUIT/run_EOLE_120_irene-amd.log"
   echo "TRUST script on irene-amd the `date` ...">run_EOLE_120_irene-amd.log
   echo>>run_EOLE_120_irene-amd.log
   (./run Studies/EOLE_120 -adr irene-amd-ccrt.ccc.cea.fr 1>>run_EOLE_120_irene-amd.log 2>&1;mv -f run_EOLE_120_irene-amd.log $REP_NUIT/.) &
   mv -f run_Etudes.log $REP_NUIT/.
fi
if [ $etude_activation = 1 ]  && [ ! -f run_Etudes.log ] && [ $etude_test = 0 ]
then
   echo "-> Start of "$ETUDES"/run -all"
   touch $ETUDES/run_Etudes.log
   echo "  See $REP_NUIT/run_Etudes.log"
   echo "TRUST script from $HOST the `date` ...">run_Etudes.log
   echo>>run_Etudes.log
   (./run -all 1>>run_Etudes.log 2>&1;mv -f run_Etudes.log $REP_NUIT/.) & # Deplace le log des etudes si script termine
fi
if [ $etude_activation = 0 ] 
then
   echo "NOT executed"
   [ -f run_Etudes.log ] && cp run_Etudes.log $REP_NUIT/.
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################
# Lancement des tests sur Livraison #
#####################################
cd $TRUST_ROOT
vue="tuleap/Livraison"
lance_test_log=$REP_NUIT"/lance_test_"$HOST"_"${vue#*/}".log"
touch $lance_test_log
echo "TRUST script on $HOST the `date` ...">$lance_test_log
echo " "
echo "##########################"
echo "# On no-regression tests #"
echo "##########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "  See $lance_test_log"
for exec in $liste_exec
do
   cd $TRUST_ROOT
   TYPE=""
   [ $exec = "$exec_debug" ] && TYPE=debugged && PERF=$REP_NUIT/PERF_`basename $exec`"_debug_"$TRUST_ARCH"_"$HOST
   [ $exec = "$exec_semi_opt" ] && TYPE=semi-optimized && PERF=$REP_NUIT/PERF_`basename $exec`_$TRUST_ARCH"_"$HOST
   echo " "
   echo "MODE: $TYPE (exec=$exec)"
   echo "TRUST performance on $HOST the `date` ...">$PERF
   echo "--------------------------------------------------------" >> $PERF
   echo "hostname "$HOST >> $PERF
   OS="Os "`uname -s` && [ $TRUST_ARCH = linux ] && OS=$OS" "`cat /proc/cpuinfo | $TRUST_Awk '/MHz/ {print $4"Mhz";exit}'`
   echo $OS >> $PERF
   echo "release "`uname -r` >> $PERF
   echo "model "`uname -m` >> $PERF
########################################################
# La nuit, lance_test est lance avec l'executable exec :
########################################################
   if [ -f $exec ] && [ "`$exec 2>&1 | grep TRUST`" != "" ]
   then
      taille=`ls -la $exec | $TRUST_Awk '{print $5}'`
      taille=`echo $ECHO_OPTS "scale=1\n$taille/1000000" | bc -l`
      #type=`echo $taille | $TRUST_Awk '{type="Statique";if ($1<=2) type="Dynamique";print type}'`
      type=`ldd $exec | $TRUST_Awk 'END {type="Statique";if (NR>20) type="Dynamique";print type}'`
      if [ $type = Statique ]
      then
         echo "size "$taille" "$type >> $PERF
      elif [ $type = Dynamique ]
      then
         sl=`ls -la $TRUST_ROOT/lib/lib*.s* 2>/dev/null | $TRUST_Awk 'BEGIN {i=0} {i+=$5} END {print i}'`
         #echo "sl="$sl
         sl=`echo $ECHO_OPTS "scale=1\n$sl/1000000" | bc -l`
         #echo "sl="$sl
         echo "size "$taille"+"$sl" "$type >> $PERF
      fi
      echo "--------------------------------------------------------" >> $PERF
      echo "exec "$exec >> $PERF
      #######################################
      ### CHOIX DU NOMBRE DE TESTS PASSES ###
      N=0
      [ $exec = "$exec_debug" ] && N=VAHL_DAVIS
      #######################################
      echo "-> Start of echo $N | $TRUST_ROOT/bin/lance_test"
      echo "  See $PERF"
      fic_test=`dirname $exec`/.tests_`basename $exec`
      rm -f $fic_test
      echo " " >> $lance_test_log
      echo "######################################################" >> $lance_test_log
      echo " " >> $lance_test_log
      export PAR=0
      echo $ECHO_OPTS $N | lance_test $exec `dirname $exec` 2>/dev/null  >> $lance_test_log
      if [ -f $fic_test ]
      then
         #cat $fic_test".html" | grep "Mo|" >> $PERF
         cat $fic_test".html" | $TRUST_Awk -F":" '/ucces/ {print "succes "$2}' >> $PERF
	 grep -A 5000 unsuccess $fic_test".html" >> $PERF
      fi
      # On fait l'executable share libs
      # CC: 16/02/2015 => Pourquoi fait-on ca ici et pas lors de la compilation plus haut ?
      #(cd $TRUST_ROOT/src/MAIN;make)
      (
      OPT=""
      [ $exec = "$exec_debug" ] && OPT=_
      [ $exec = "$exec_semi_opt" ] && OPT=_semi_opt_
      OPT=${OPT%_} # <=> OPT=${OPT::-1}
      if [ $type = Statique ]
      then
	 echo "Call to make with COMPIL_DYN=OFF on $TRUST_ROOT/MonoDir_mpi$OPT/src"
         cd $TRUST_ROOT/MonoDir_mpi$OPT/src
	 cmake . -DCOMPIL_DYN=OFF
      elif [ $type = Dynamique ]  
      then
	 echo "Call to make with COMPIL_DYN=ON  on $TRUST_ROOT/MonoDir_mpi$OPT/src"
         cd $TRUST_ROOT/MonoDir_mpi$OPT/src
         cmake . -DCOMPIL_DYN=ON
      fi 
      tmp=`mktemp_`
      make 1>>$tmp 2>&1
      tail -n2 $tmp
      rm -f $tmp
      )
   fi
   # Suite au test `$exec 2>&1 | grep TRUST`
   rm -f convert_jdd hierarchie.dump TRUST.log TRUST.stop
done
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#################################################
# Verification de la portabilite des composants #
#################################################
cd $TRUST_ROOT
echo " "
echo "#################"
echo "# On components #"
echo "#################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Call check_components for $TRUST_VERSION version from `pwd`"
check_components $vue
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "#####################################"
echo "# Validate and save the new version #"
echo "#####################################"
cd $TRUST_ROOT
# Attente jusqu'a minuit le vendredi
# pour certains tests faits que le week-end
while [ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 20 ]
do
   sleep 30
done
echo " "
echo "###################################"
echo "# Create the matrix of validation #"
echo "###################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
(
matrice_validation=0 # Non actualise
# Changement 164, on cree la matrice de validation le week-end
if [ $matrice_validation = 1 ] && [ "`date '+%u'`" -gt 5 ]
then
   cd $TRUST_ROOT/doc/Validation
   echo "-> Start of "$TRUST_ROOT"/doc/Validation/Matrice.sh"
   echo "  See `pwd`/Matrice_Validation.pdf"
   ./Matrice.sh -no_verbose # Utiliser l'option -no_verbose permet de conserve une trace dans le fichier Matrice.log du lance_test_modifie
   if [ -f Matrice.pdf ] && [ "`diff Matrice.pdf Matrice_Validation.pdf`" != "" ]
   then
      CHECKOUT Matrice_Validation.pdf 1>/dev/null 2>&1
      mv -f Matrice.pdf Matrice_Validation.pdf
   fi
   cd - 1>/dev/null 2>&1
else
   echo "NOT executed"
fi
) &
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "#####################################"
echo "# Use and execute cpplint.py script #"
echo "#####################################"
#echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
## le week-end uniquement
#if [ "`date '+%u'`" -gt 5 ]
#then
#   cd $TRUST_ROOT
#   echo "Call to $TRUST_ROOT/bin/KSH/cpplint.py"
#   echo "from `pwd`"
#   cpplint_log=$REP_NUIT"/cpplint_$HOST.log"
#   echo "  See $cpplint_log"
#   echo "TRUST script on $HOST the `date` ...">$cpplint_log
#   filter="--filter=-whitespace,-legal/copyright,-build/header_guard,-runtime/references,-readability/casting,\
#-build/include_what_you_use,-runtime/sizeof,-runtime/explicit,-runtime/printf,-runtime/int,\
#-readability/function,-readability/braces,-readability/streams,-readability/multiline_comment"   
#   echo "====================================
#Running cpplint by filtering with --filter=$filter
#====================================" >> $cpplint_log
#   python $TRUST_ROOT/bin/KSH/cpplint.py $filter src/*/*.cpp src/*/*/*.cpp src/*/*/*/*.cpp src/*/*/*/*/*.cpp include/*.h 2>&1 | grep -v "Done processing" >> $cpplint_log
#   tail -n1 $cpplint_log
#   cat $cpplint_log | mail_ -s\"[lance_test_nuit] Google rules with cpplint on TRUST $new\" $TRUST_MAIL
#else
   echo "NOT executed since upgrade to python3"
#fi
#echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "######################"
echo "# Build the packages #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
GRAVAGE=$WORKDIR/archives/ARCHIVES_TRUST
echo "Deleting of _build_ packages in $GRAVAGE"
ls -f $GRAVAGE/*_build_*
rm -f $GRAVAGE/*_build_*
v=${Version#Version}
version_arch=TRUST-$v".tar.gz"
package_log=$REP_NUIT"/package_$HOST.log"
# Dans le paquet officiel, on ne met pas les tests de validation car cela prend trop de place
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/mise_a_jour_TRUST_tar -without_test_validation -without_version"
echo "  See $package_log"
echo "TRUST script on $HOST the `date` ...">$package_log
echo>>$package_log
mise_a_jour_TRUST_tar -without_test_validation -without_version 1>>$package_log
grep "Creation of" $package_log
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/cree_Version_TRUST $v"
echo "  See $package_log"
echo $ECHO_OPTS $v"\n" | cree_Version_TRUST 1>>$package_log
tail -n1 $package_log
echo " "
echo "Move $version_arch packages to $GRAVAGE"
mv $TRUST_ROOT/$version_arch $GRAVAGE/.
ls $GRAVAGE/$version_arch
cd $TRUST_ROOT
mv externalpackages.tar externalpackages-next.tar
cp_ftp externalpackages-next.tar $PUBLIC/../externalpackages/
rm -f TRUST.tar.gz externalpackages-next.tar
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
####################
# Release criteria #
####################
echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo `date` >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/RELEASE_NOTES ] && echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/RELEASE_NOTES ] && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/RELEASE_NOTES | head -n -1 >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/DEVELOPER_NOTES ] && echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/DEVELOPER_NOTES ] && $TRUST_Awk '/Developer notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/DEVELOPER_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/externalpackages/RELEASE_NOTES ] && echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/externalpackages/RELEASE_NOTES ] && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/externalpackages/RELEASE_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
Composant="triocfd"
#for Composant in $ComposantsGit
#do
  [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
  [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
#done
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST/TrioCFD WEB site:    http://triocfd.cea.fr" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST's distribution site:   https://github.com/cea-trust-platform/trust-code" >> $MESSAGES_NUIT
#echo $ECHO_OPTS "TRUST<=1.8.3 distribution site:   http://sourceforge.net/projects/trust-platform" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD's distribution site: https://github.com/cea-trust-platform/TrioCFD-code" >> $MESSAGES_NUIT
#echo $ECHO_OPTS "TrioCFD<=1.8.3 distribution site: http://sourceforge.net/projects/triocfd" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST environment at Saclay:   source /home/triou/env_TRUST_$old.sh" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST environment at Saclay:   source /home/trust_trio-public/env_TRUST-$old.sh" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD environment at Saclay: source /home/triou/env_TrioCFD_$old.sh" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD environment at Saclay: source /home/trust_trio-public/env_TrioCFD-$old.sh" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "User TRUST TrioCFD     diffusion list http://saxifrage:3500/wws/info/trio_u_annonces" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Developer TRUST        diffusion list http://saxifrage:3500/wws/info/trio_u_dev" >> $MESSAGES_NUIT
echo $ECHO_OPTS "User TRUST TrioMC      diffusion list http://saxifrage:3500/wws/info/mc2_annonces" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST Kernel             mailing list http://saxifrage:3500/wws/info/trio_u_kernel" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST Post Processing    mailing list http://saxifrage:3500/wws/info/trio_u_post_traitement" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD Front Tracking   mailing list http://saxifrage:3500/wws/info/trio_u_front_tracking" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
#echo $ECHO_OPTS "TRUST ftp site:          ftp://$TRUST_FTP/$PUBLIC/index.html" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST documentation:     ftp://$TRUST_FTP/$SECRET/doc" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Generic Guide:    ftp://$TRUST_FTP/$SECRET/doc/TRUST_Generic_Guide.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Reference Manual: ftp://$TRUST_FTP/$SECRET/doc/TRUST_Reference_Manual.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Tutorial:         ftp://$TRUST_FTP/$SECRET/doc/TRUST_tutorial.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest list of builds:   ftp://$TRUST_FTP/$SECRET/NUIT/NUIT.html" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest TRUST binary:     ftp://$TRUST_FTP/$SECRET/exec/linux/TRUST_mpi_opt"_"$new"_build_"$DATE.gz" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo "Binaries of TRUST $new version are available here:" >> $MESSAGES_NUIT
for adr in `liste_machines | grep -v is1 | grep -v is2 | grep -v cezanne`
do 
   machine=`echo $adr | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
   log=`awk -v adr=$adr '($2==adr) {print $4}' ~/.netrc | head -1`
   ssh_ $log@$machine -n 'echo -e "'$machine: '\c";ls ${WORKDIR:-$HOME}/$WORKBASE"'$machine'"/TRUST/exec/TRUST_mpi_opt 2>/dev/null || echo' 2>/dev/null
done >> $MESSAGES_NUIT
echo "Older binaries (> v1.7.1) are available here: ftp://$TRUST_FTP/$PUBLIC/" >> $MESSAGES_NUIT
echo "Older binaries (< v1.7.1) are available here: ftp://ftp.cea.fr/pub/TRUST/a87pour/" >> $MESSAGES_NUIT
#echo "Older binaries (< v1.6.6) are available here: file:///net/dibona/users/dibona/triou/version/" >> $MESSAGES_NUIT
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
##########################################################
# On checkine dans la vue si criteres suivants respectes :
##########################################################
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo "Release criteria of the $new version:" >> $MESSAGES_NUIT

criteres_remplis=0
total_criteres=0
baltik_ok=0
#total_baltik=`echo $ComposantsOfficial | wc -w`
nb=$(echo $ComposantsOfficial-1 | wc -w) # nb de baltik test\E9s pour les versions (beta, RC ou officielle)
total_baltik=$(echo $nb-1 | bc -l)       # on retire ijk du d\E9compte car il n'est pas encore au point

######################
# Tests d'installation
######################
echo " "
echo "############################################"
echo "# Test the installation to remote machines #"
echo "############################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
version_arch="TRUST-$TRUST_VERSION.tar.gz"
installation=1
machine1=`liste_machines "\-remote_install_TRUST_with_source" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [[ "$liste_machines_KO" != *"$machine1"* ]] # Test si machine n est pas dans la liste des machines KO
then
   remote1="-remote "`liste_machines "\-remote_install_TRUST_with_source" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
else
   remote1="-remote "`liste_machines "\-remote_install_TRUST_with_source" 		| tail -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
fi
machine2=`liste_machines "\-remote_install_TRUST_kernel_only" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [[ "$liste_machines_KO" != *"$machine2"* ]] # Test si machine n est pas dans la liste des machines KO
then
   remote2="-remote "`liste_machines "\-remote_install_TRUST_kernel_only" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
else
   remote2="-remote "`liste_machines "\-remote_install_TRUST_kernel_only" 		| tail -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
fi
# Version sans source devenue inutile depuis le passage en OpenSource
#remote3="-remote "`liste_machines "\-remote_install_TRUST_without_source" 		| head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
remote1_log=$REP_NUIT"/simule_install_TRUST_with_source_"`echo ${remote1##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote1_log
echo>>$remote1_log
remote2_log=$REP_NUIT"/simule_install_TRUST_kernel_only_"`echo ${remote2##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote2_log
echo>>$remote2_log
#remote3_log=$REP_NUIT"/simule_install_TRUST_without_source_"`echo ${remote3##* }`".log"
#echo "TRUST script on $HOST the `date` ...">$remote3_log
#echo>>$remote3_log
cd $GRAVAGE
echo "Call to $TRUST_ROOT/bin/admin/simule_install_TRUST $version_arch $remote1"
echo "  See $remote1_log"
echo "Call to $TRUST_ROOT/bin/admin/extract_Version_TRUST $version_arch -install $remote2 -kernel_only"
echo "  See $remote2_log"
#echo "Call to $TRUST_ROOT/bin/admin/extract_Version_TRUST $version_arch -install $remote3 -without_source"
#echo "  See $remote3_log"
# Test d'une extraction/installation d'une version avec les sources
(
simule_install_TRUST ./$version_arch $remote1 					1>>$remote1_log 2>&1 	
echo " "
if [ "`grep "BUILD_" $remote1_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote1_log 2>/dev/null`" != "" ] 
then
   echo "Installation KO -with_source on $remote1"
   cat $remote1_log | mail_ -s\"[lance_test_nuit] Remote install with source failed on ${remote1##* }\" $TRUST_MAIL
   cp $remote1_log $TRUST_ROOT/simule_install_TRUST.log
else
   echo "Installation OK -with_source on $remote1"
fi
grep "Installation KO" $remote1_log
grep "BUILD_" $remote1_log
) &
installation_id1=$!
# Test d'une extraction/installation d'une version kernel
(
extract_Version_TRUST ./$version_arch -install $remote2 -kernel_only 		1>>$remote2_log 2>&1
echo " "
if [ "`grep "BUILD_" $remote2_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote2_log 2>/dev/null`" != "" ]
then
   echo "Installation KO -kernel_only on $remote2"
   cat $remote2_log | mail_ -s\"[lance_test_nuit] Remote install kernel only failed on ${remote2##* }\" $TRUST_MAIL
   cp $remote2_log $TRUST_ROOT/simule_install_TRUST_kernel_only.log
else
   echo "Installation OK -kernel_only on $remote2"
fi
grep "Installation KO" $remote2_log
grep "BUILD_" $remote2_log
) &
installation_id2=$!
# Test d'une extraction/installation d'une version sans les sources
#(
#extract_Version_TRUST ./$version_arch -install $remote3 -without_source 	1>>$remote3_log 2>&1
#echo " "
#if [ "`grep "BUILD_" $remote3_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote3_log 2>/dev/null`" != "" ]
#then
#   echo "Installation KO -without_source on $remote3"
#   cat $remote3_log | mail_ -s\"[lance_test_nuit] Remote install without source failed on ${remote3##* }\" $TRUST_MAIL
#   cp $remote3_log $TRUST_ROOT/simule_install_TRUST_without_source.log
#else
#   echo "Installation OK -without_source on $remote3"
#fi
#grep "Installation KO" $remote3_log
#grep "BUILD_" $remote3_log
#) &
#installation_id3=$!
# On attend la fin des installations lancees en parallele
#wait $installation_id1 $installation_id2 $installation_id3 1>/dev/null 2>&1
wait $installation_id1 $installation_id2 1>/dev/null 2>&1
# S'il n'y a pas de logs, c'est que les installations ont toutes reussies
NB=`ls $REP_NUIT/simule_install_TRUST*.log 2>/dev/null | wc -l`
KO=`ls $TRUST_ROOT/simule_install_TRUST*.log 2>/dev/null | wc -l`
let OK=$NB-$KO
[ $NB = 0 ] && installation=0
[ $KO != 0 ] && installation=0
rm -f $TRUST_ROOT/simule_install_TRUST*.log
################################
# Test de la taille du DVD grave
################################
echo " "
echo "Test the size of the $version_arch package if it can be written to a DVD"
limite_Mo=2000
package_size=`ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{print $5/1000000}'`
export package_size=`printf '%0.f' $package_size`
if [ "`ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{if ($5>limite_Mo*1000000) print "KO"}'`" = KO ]
then
   msg="The package $version_arch on $GRAVAGE is too large ($package_size>"$limite_Mo"Mo) to be written to a DVD."
   tmp=`mktemp_`
   echo $msg > $tmp
   echo "More large files (>2Mo) in each VOB:" >> $tmp
   (
   cd $TRUST_ROOT
   for contenu in *gz.files
   do
      VOB=${contenu%.tar.gz.files}
      cd $TRUST_ROOT/../$VOB
      echo $VOB >> $tmp
      for file in `cat $TRUST_ROOT/$contenu`
      do
         [ -f $file ] && echo $file
      done | xargs ls -l | awk '{if ($5>2000000) print $5" "$NF}' | sort -nr >> $tmp
      cd - 1>/dev/null 2>&1
   done
   )
   cat $tmp | mail_ -s\"[lance_test_nuit] Problem of $version_arch package size that is too large to be delivered.\" $TRUST_MAIL
   cat $tmp
   rm -f $tmp
   installation=0
   echo "  Size $package_size > "$limite_Mo"Mo KO"
elif [ $package_size = 0 ]
then
   installation=0
   echo "  Size $package_size >< "$limite_Mo"Mo KO"
else
   echo "  Size $package_size < "$limite_Mo"Mo OK"
fi
cd - 1>/dev/null 2>&1
echo " "
if [ $installation = 1 ]
then
   echo "Release criterion: Installation OK"
else
   echo "Release criterion: Installation KO"
fi
force_installation=~/force_installation && [ -f $force_installation ] && installation=1 && rm -f $force_installation
[ "$NB" -eq 0 ] && NB=-1
if [ "$NB" -eq -1 ]
then
   echo "$installation  Installation $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" + size="$package_size"Mo (=1+size<"$limite_Mo"Mo)" >> $MESSAGES_NUIT
   NB=0
else
   echo "$installation  Installation $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" + size="$package_size"Mo (=1+size<"$limite_Mo"Mo)" >> $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$installation
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################################################
# Attente jusqu'a pour attendre le retour des compilations eloignees:
#####################################################################
# sauf le week-end (on attend le dimanche car lance_test_nuit via crontab non lance le week-end)
if [ "`date '+%u'`" -lt 6 ]
then
   while [ `date '+%H'` -lt 6 ] || [ `date '+%H'` -gt 21 ]
   do
      sleep 30
   done
else
   # Attente jusqu'au lundi matin
   while [ "`date '+%u'`" -gt 5 ]
   do
      sleep 30
   done
fi
  
#####################################################
# Arret de la portabilite des baltik si non terminee:  
#####################################################
echo " "
echo "##########################################"
echo "# Verify the end of baltik portabilities #"
echo "##########################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
for Composant in $Composants
do
   if [ -d $TRUST_ROOT/../Composants/$Composant ]
   then
      cd $TRUST_ROOT/../Composants/$Composant
      echo "Check $Composant"
      if [ ! -f  nuit_$Composant.html ] # Fichier non cree donc portabilite non terminee
      then
         #nbtot=`sed -n '$=' Run.liste` # Nombre total de machines surlesquelles c est teste
         (grep PID $Composant*.log | grep start | awk '{$NF=""; print $0}') 1>start.liste 2>/dev/null # Nombre de start (4 x nbtot)
         (grep PID $Composant*.log | grep stop | awk '{$NF=""; print $0}') 1>stop.liste 2>/dev/null # Nombre de stop
	 sort start.liste stop.liste | uniq -u 1>kill.liste 2>/dev/null # Pour chaque start non stoppe, recuperer le nom de la machine et le PID
         if [ `cat kill.liste | wc -l` = 0 ]
	 then
	    echo "  => The portability was NOT launched"
	 else
	    cat kill.liste
	    echo "  => KO: portability is NOT finished"
            old_IFS=$IFS  # sauvegarde du separateur de champ
            IFS=$'\n'     # nouveau separateur de champ, le caractere fin de ligne
	    for line in $(cat kill.liste)
	    do
	      (
	       PID=`echo $line | awk '{print $(NF)}'`
	       adr=`echo $line | awk -F"@" '{print $2}' | awk -F"_" '{print $1}'`
	       log=`echo $line | awk -F"@" '{print $1}' | awk -F"%" '{print $2}' | awk -F"_" '{print $2}'`
	       machine=`echo $adr | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`
               WORKTMP=`ssh_ -o BatchMode=yes $log@$adr -n 'if [ "\$WORKDIR" = "" ]; then echo \$HOME;else echo \$WORKDIR;fi'`
	       echo "  Treatment of $PID on $machine"
	       pids=$(ssh $log@$adr $WORKTMP/$WORKBASE$machine/TRUST/bin/baltik/share/baltik/bin/portability/list_pid_et_fils.sh $PID)
	       echo "    ssh $log@$adr scancel $pids"
	       ssh $log@$adr scancel $pids
	       ssh $log@$adr scancel $pids
	     #  echo "    ssh $log@$adr kill -9 $pids"
	     #  ssh $log@$adr kill -19 $pids
	     #  ssh $log@$adr kill -9 $pids
	      ) 
	    done
	    IFS=$old_IFS  # r\E9tablissement du s\E9parateur de champ par d\E9faut
	 fi 
	 rm -f start.liste stop.liste kill.liste
      else
         echo "  => OK: portability is finished"
	 cp nuit_$Composant.html $REP_NUIT/nuit_$Composant.html
      fi 
   fi
done
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################################################
# Attente 1h pour attendre le retour des portabilites eloignees:
#####################################################################
if [ "`date '+%u'`" -lt 6 ]
then
   while [ `date '+%H'` -lt 7 ] || [ `date '+%H'` -gt 21 ]
   do
      sleep 30
   done
else
   while [ "`date '+%u'`" -gt 5 ]
   do
      sleep 30
   done
fi
  
#######################################################
# Arret des etudes lancees a distance si non terminees:  
#######################################################
echo " "
echo "#################################"
echo "# Verify the end of studies run #"
echo "#################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $ETUDES
echo "Check $ETUDES"
if [ $etude_activation = 0 ] 
then
   echo "  => The run_Etudes was NOT launched"
else
   if [ -f run_Etudes.log ] # Fichier non deplace dans REP_NUIT donc run non termine
   then
      grep PID run_Etudes.log
      echo "  => KO: run_Etudes is NOT finished"
      PID=`grep PID run_Etudes.log | grep start | awk '{$NF=""; print $0}' | awk '{print $(NF)}'`
      pids=$($TRUST_ROOT/bin/baltik/share/baltik/bin/portability/list_pid_et_fils.sh $PID)
      echo "    kill -9 $pids"
      echo "    KO: to do manually and check scancel on cluster" # Temporary
      #kill -19 $pids
      #kill -9 $pids
   else
      echo "  => OK: run_Etudes is finished"
   fi
fi
cd $TRUST_ROOT
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
 
##########################################################
# Recupere les executables et divers fichiers sur machines
##########################################################
echo " "
echo "#####################################################"
echo "# Receive from remote machines and copy on ftp site #"
echo "#####################################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $TRUST_ROOT
export binaire=1
recupere_log=$REP_NUIT/recupere_TRUST_arch_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/recupere_TRUST_arch"
echo "  See $recupere_log"
echo "TRUST script on $HOST the `date` ...">$recupere_log
echo>>$recupere_log
# pour le lance seul :
# cd $TRUST_ROOT/bin/admin
# export new=`awk '/version/ {print $4;exit}' $TRUST_ROOT/RELEASE_NOTES`
# export Version=Version$new
# export DATE=`date '+%d%m%y'`
# REP_NUIT=/data/tmptrust/tmptrust/Historique/NUIT
# recupere_log=$REP_NUIT/recupere_TRUST_arch_$HOST.log
# recupere_TRUST_arch 1>>$recupere_log 2>&1   
# cd $TRUST_ROOT
# envoie_ftp_log=$REP_NUIT/envoie_ftp_cea_fr_$HOST.log
# echo "TRUST script on $HOST the `date` ...">$envoie_ftp_log
# echo>>$envoie_ftp_log
# envoie_ftp_cea_fr 1>>$envoie_ftp_log 2>&1
recupere_TRUST_arch 1>>$recupere_log 2>&1   
grep KO $recupere_log
grep -i portage $recupere_log
if [ ${#liste_machines_KO} != 0 ] # chaine non vide
then
   echo "  Recall liste_machines_KO:"
   echo $liste_machines_KO
fi
echo "  Creation of $REP_NUIT/NUIT.html"
ls -la $REP_NUIT"/NUIT.html"
cd $TRUST_ROOT

for file in `ls $REP_NUIT/install_patch_*.log 2>/dev/null`
do
   echo " "
   echo "Analysis of $file file"
   head -n4 $file | tail -n1
   grep "BUILD_" $file
   grep error $file
   grep Stop $file
   grep KO $file
done

for file in `ls $REP_NUIT/lance_test_*.log 2>/dev/null`
do
   echo " "
   echo "Analysis of $file file"
   fic_test=`grep "Complete results into the file" -A 1 $file | tail -n 1`
   grep "Error:" $fic_test
   grep "Successful tests cases" $fic_test
done

echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##################
# Stabilite TRUST
##################
echo " "
echo "############################"
echo "# Test the TRUST stability #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
rm -f tmp.log 
#fic_test=$TRUST_ROOT"/exec/.tests_TRUST"$COMM
#echo "Analysis of "$fic_test" file" | tee -a tmp.log
#grep "Successful tests cases" $fic_test | tee -a tmp.log
#echo " " | tee -a tmp.log
fic_test=$TRUST_ROOT"/exec/.tests_TRUST"$COMM"_semi_opt" | tee -a tmp.log
echo "Analysis of "$fic_test" file" | tee -a tmp.log
grep "Successful tests cases" $fic_test | tee -a tmp.log
echo " " | tee -a tmp.log
if [ -f $fic_test ]
then
   stabilite1=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | head -1`
   stabilite2=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | tail -1`
   if [  "$stabilite1" = "1.000" ]
   then
      stabilite=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | tail -1`
      rstab=`$TRUST_Awk -F':' 'BEGIN {} /Successful tests cases/ {print $2}' $fic_test |  tail -1`
   else
      stabilite=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | head -1`
      rstab=`$TRUST_Awk -F':' 'BEGIN {} /Successful tests cases/ {print $2}' $fic_test | head -1`
   fi
else
   stabilite="0.000"
   rstab="0/0"
fi
if [ "$stabilite" = "1.000" ]
then
   echo "Release criterion: Stability OK"
else
   echo "Release criterion: Stability KO"
   cat tmp.log | mail_ -s\"[lance_test_nuit] $rstab=$stabilite TRUST stability KO\" $TRUST_MAIL
fi
force_stabilite=~/force_stabilite && [ -f $force_stabilite ] && stabilite="1.000" && rm -f $force_stabilite
echo `if [ "$stabilite" = "1.000" ]; then echo 1;else echo 0;fi`"  Stability $rstab=$stabilite (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+`if [ "$stabilite" = "1.000" ]; then echo 1;else echo 0;fi`
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

####################
# Portabilite TRUST
####################
echo " "
echo "###############################"
echo "# Test the TRUST portability #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step TRUST" $recupere_log
grep "step TRUST" $recupere_log | grep -v "1.000" > tmp.log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html | tee -a tmp.log
grep "TRUST portability" $REP_NUIT/NUIT.html
all_cible=`$TRUST_Awk '/Total number portability/ {print $9}' $REP_NUIT/NUIT.html`
nb_cible=`$TRUST_Awk '/Total number portability/ {print $7}' $REP_NUIT/NUIT.html`
portabilite_test=`$TRUST_Awk '/TRUST portability/ {print $1}' $REP_NUIT/NUIT.html`
portabilite_trust=`$TRUST_Awk '/TRUST portability/ {print $6}' $REP_NUIT/NUIT.html`
portabilite=0 && [ "`grep "Portable version" $REP_NUIT/NUIT.html`" != "" ] && portabilite=1
echo " "
if [ $portabilite = 1 ]
then
   echo "Release criterion: TRUST  OK"
else
   echo "Release criterion: TRUST  KO"
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST portability KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_portabilite=~/force_portabilite && [ -f $force_portabilite ] && portabilite=1 && rm -f $force_portabilite
limite=0.99 # cf recupere_TRUST_arch
echo "$portabilite  Portability $portabilite_trust=$portabilite_test + nb=$nb_cible (>$limite+nb=$all_cible)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$portabilite
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
force_cible=~/force_cible && [ -f $force_cible ] && nb_cible=$all_cible && rm -f $force_cible

###################
# Test d'un atelier
###################
echo " "
echo "#####################################"
echo "# Test the compilation of a atelier #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step atelier" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "TRUST atelier compilation" $REP_NUIT/NUIT.html
make_atelier=`$TRUST_Awk '/atelier compilation/ && /TRUST/ {print $1}' $REP_NUIT/NUIT.html`
port_atelier=`$TRUST_Awk '/atelier compilation/ && /TRUST/ {print $7}' $REP_NUIT/NUIT.html`
workshop=0
[ "$make_atelier" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && workshop=1
echo " "
grep "ATELIER=KO" $REP_NUIT/CR_* > tmp.log
if [ $workshop = 1 ]
then
   echo "Release criterion: Atelier OK"
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST atelier KO on host:\" $TRUST_MAIL
else
   echo "Release criterion: Atelier KO"
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST atelier KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_make_atelier=~/force_make_atelier && [ -f $force_make_atelier ] && workshop=1 && rm -f $force_make_atelier
echo "$workshop  Atelier $port_atelier=$make_atelier (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$workshop
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################
# Portabilite Xprepro
#####################
echo " "
echo "################################"
echo "# Test the Xprepro portability #"
echo "################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step Xprepro" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "Xprepro portability" $REP_NUIT/NUIT.html
Xprepro=`$TRUST_Awk '/Xprepro portability with TRUST/ {print $1}' $REP_NUIT/NUIT.html`
port_Xprepro=`$TRUST_Awk '/Xprepro portability with TRUST/ {print $8}' $REP_NUIT/NUIT.html`
portabilite_Xprepro=`echo $Xprepro | $TRUST_Awk '{if ($1>=1) print 1;else print 0}'`
[ "$nb_cible" != "$all_cible" ] && portabilite_Xprepro=0
echo " "
grep "XPREPRO=KO" $REP_NUIT/CR_* > tmp.log
if [ $portabilite_Xprepro = 1 ]
then
   echo "Release criterion: Xprepro OK"
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] XPREPRO KO on host:\" $TRUST_MAIL
else
   echo "Release criterion: Xprepro KO"
   grep "XPREPRO=NOT" $REP_NUIT/CR_* >> tmp.log
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] XPREPRO KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_portabilite_Xprepro=~/force_portabilite_Xprepro && [ -f $force_portabilite_Xprepro ] && portabilite_Xprepro=1 && rm -f $force_portabilite_Xprepro
echo "$portabilite_Xprepro  Xprepro $port_Xprepro=$Xprepro (>=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$portabilite_Xprepro
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#######################
# Portabilite de BALTIK
#######################
echo " "
echo "###############################"
echo "# Test the Baltik portability #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step Baltik" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "Baltik portability" $REP_NUIT/NUIT.html
portabilite_baltik=`$TRUST_Awk '/Baltik portability/ && /TRUST/ {print $1}' $REP_NUIT/NUIT.html`
port_baltik=`$TRUST_Awk '/Baltik portability/ && /TRUST/ {print $8}' $REP_NUIT/NUIT.html`
testbaltik=0
[ "$portabilite_baltik" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && testbaltik=1
echo " "
grep "BALTIK=KO" $REP_NUIT/CR_* > tmp.log
if [ $testbaltik = 1 ]
then
   echo "Release criterion: Baltik  OK"
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST baltik KO on host:\" $TRUST_MAIL
else
   echo "Release criterion: Baltik  KO"
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST baltik KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_portabilite_baltik=~/force_portabilite_baltik && [ -f $force_portabilite_baltik ] && testbaltik=1 && rm -f $force_portabilite_baltik
echo "$testbaltik  Baltik $port_baltik=$portabilite_baltik (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$testbaltik
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

################################
# Test des assert de compilation
################################
echo " "
echo "###############################"
echo "# Test the compilation assert #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step assert" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "Compilation assert test" $REP_NUIT/NUIT.html
test_assert=`$TRUST_Awk '/Compilation assert/ {print $1}' $REP_NUIT/NUIT.html`
port_assert=`$TRUST_Awk '/Compilation assert/ {print $7}' $REP_NUIT/NUIT.html`
assert=0
[ "$test_assert" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && assert=1
echo " "
grep "ASSERT=KO" $REP_NUIT/CR_* > tmp.log
if [ $assert = 1 ]
then
   echo "Release criterion: Assert OK"
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST assert KO on host:\" $TRUST_MAIL
else
   echo "Release criterion: Assert KO"
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST assert KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_test_assert=~/force_test_assert && [ -f $force_test_assert ] && assert=1 && rm -f $force_test_assert
echo "$assert  Assert $port_assert=$test_assert (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$assert
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

############################
# Disponibilite des binaires
############################
# echo " "
# echo "######################################"
# echo "# Test the disponibility of binaries #"
# echo "######################################"
# echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
# nb_binaires=0
# porta_binaires=0
# dispo_binaires=0
# disponibilite_binaires=0
# machine=`liste_machines "get_binary" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}' | head -1`
# echo "Analysis of $WORKDIR/portages/PORTAGE_$new directory"
# binaires=`ls $WORKDIR/portages/PORTAGE_$new/*/TRUST/exec/TRUST*opt* 2>/dev/null`
# [ "$binaires" = "" ] && echo "See $REP_NUIT/CR_$machine" | mail_ -s\"[lance_test_nuit] No binary created under $WORKDIR/portages/PORTAGE_$new/*/TRUST/exec\" $TRUST_MAIL
# for binaire in $binaires
# do
#    let nb_binaires=$nb_binaires+1
#    cd $TRUST_TMP
#    rm -f nul.data
#    touch nul.data
#    echo $ECHO_OPTS "  Test of binary $binaire \c"
#    $binaire nul 1>binaire.out 2>&1
#    if [ $? != 0 ]
#    then
#       echo "KO"
#       cat binaire.out | mail_ -s\"[lance_test_nuit] Binary $binaire KO\" $TRUST_MAIL
#    else
#       let porta_binaires=$porta_binaires+1
#      echo "OK"
#    fi
#    cd - 1>/dev/null 2>&1
# done
# [ "$nb_binaires" != 0 ] && dispo_binaires=`echo $porta_binaires | $TRUST_Awk -v n=$nb_binaires '{print "scale=3\n"$1"/"n}' | bc -l`
# disponibilite_binaires=`echo $dispo_binaires | $TRUST_Awk '{if ($1>=1) print 1;else print 0}'`
# echo " "
# if [ $disponibilite_binaires = 1 ]
# then
#    echo "Release criterion: Binaries OK"
# else
#    echo "Release criterion: Binaries KO"
# fi
# force_disponibilite_binaires=~/force_disponibilite_binaires && [ -f $force_disponibilite_binaires ] && disponibilite_binaires=1 && rm -f $force_disponibilite_binaires
# echo "$disponibilite_binaires  Binairies $porta_binaires/$nb_binaires=$dispo_binaires (=1)" >> $MESSAGES_NUIT
# let total_criteres=$total_criteres+1
# let criteres_remplis=$criteres_remplis+$disponibilite_binaires
# echo "<--- End at "`date '+%H:%M:%S %d/%m'`

############
# Test XData
############
echo " "
echo "##################################"
echo "# Verify the validation of XData #"
echo "##################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
validation_xdata=""
machines_=`liste_machines "\-xdata"`
machines=`liste_machines "\-xdata" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -xdata on $machines"
# Si une machine a XData qui fonctionne c'est OK
for machine_ in $machines_
do
   machine=`echo $machine_ | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
   check_xdata_log=$REP_NUIT"/check_xdata_"$machine".log"
   rm -f $check_xdata_log
   if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "  KO $machine machine not accessible via ssh."
      echo "  No $check_xdata_log"
      validation_xdata=0
      echo | mail_ -s\"[lance_test_nuit] Error when receiving XData log from $machine not accessible via ssh.\" $TRUST_MAIL
   else
      echo "  See $check_xdata_log"
      log=`awk -v adr=$machine_ '($2==adr) {print $4}' ~/.netrc | head -1`
      workdir=`ssh $machine -n 'echo $WORKDIR'`
      #scp $log@$machine:~/$WORKBASE$machine/TRUST/Outils/TRIOXDATA/check_xdata.log $check_xdata_log
      if  [ "${machine:0:2}" = "is" ]
      then
         #scp $log@$machine:$workdir/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log
         scp $log@$machine:$workdir/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log 1>/dev/null 2>&1
         scp_error=$?
         #[ $scp_error != 0 ] && scp $log@$machine:/volatile/triou/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log && scp_error=$?
      else
         scp $log@$machine:~/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log
         scp_error=$?
      fi
      if [ $scp_error != 0 ]
      then
         echo | mail_ -s\"[lance_test_nuit] Error when receiving XData log from $machine. Check if not finished.\" $TRUST_MAIL
      else
         grep 'XDATA=' $check_xdata_log
      fi
      rm -f $scp_error
      if [ "`grep 'XDATA=OK' $check_xdata_log 2>/dev/null`" != "" ]
      then
         validation_xdata=1
      else
         [ "$validation_xdata" = "" ] && validation_xdata=0
         [ -f $check_xdata_log ] && cat $check_xdata_log | mail_ -s\"[lance_test_nuit] Check XData on $machine KO\" $TRUST_MAIL
      fi
   fi
done
echo " "
if [ $validation_xdata = 1 ]
then
   echo "Release criterion: XData OK"
else
   echo "Release criterion: XData KO"
fi
force_validation_xdata=~/force_validation_xdata && [ -f $force_validation_xdata ] && validation_xdata=1 && rm -f $force_validation_xdata
echo "$validation_xdata  XData $validation_xdata (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_xdata
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########################
# Verification des modules
##########################
echo " "
echo "####################################"
echo "# Verify the validation of Modules #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
activation_verification_modules=0 # Non actualise
if [ $activation_verification_modules = 1 ]
then
   cd $TRUST_ROOT/Validation/Modules
   # Lancement d'un cas test par module:
   echo "Call to $TRUST_ROOT/Validation/Modules/Test.sh"
   ./Test.sh
   if [ $? != 0 ]
   then
      echo "  Error in one case per module"
      echo " "
      echo "Release criterion: Modules KO"
   else 
      echo "  Launching of one case per module OK"
      # Recuperation de tous les cas tests par module
      modules=`cd $TRUST_ROOT/Validation/Modules;ls */cree_liste_cas | $TRUST_Awk -F/ '{print $1}'`
      echo " "
      if [ "${#modules}" = 0 ]
      then
         ok=0
         nb=-1
	 echo "Zero module in $TRUST_ROOT/Validation/Modules directory"
      else
	 echo "Modules in $TRUST_ROOT/Validation/Modules directory:"
         echo modules
         ok=0
         nb=0
         for module in $modules
         do
	    echo " "
	    echo "Verification of $TRUST_ROOT/Validation/Modules/$module"
	    cd $TRUST_ROOT/Validation/Modules/$module
	    rm -f $module.log
	    machine=`liste_machines "\-verification_module_$module"`
	    if [ "$machine" != "" ]
	    then
	       let nb=$nb+1
	       hostname=`echo $machine | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
	       module_log=$REP_NUIT"/Modules_"$module"_"$hostname".log"
	       echo "  Receive tests of $module module from $hostname"
	       log=`awk -v adr=$machine '($2==adr) {print $4}' ~/.netrc | head -1`
	       scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/$module.log . 2>/dev/null
	       scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/compare_resultat.log . 2>/dev/null
	       # On efface les rapports precedants
	       rm -f .tests_TRUST_*
	       scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/.tests_TRUST_* . 2>/dev/null
	       if [ ! -f $module.log ]
	       then
                  echo | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host no made or no recovered.\" $TRUST_MAIL 
	       else
	          if [ "`grep $module=OK $module.log 2>/dev/null`" != "" ]
	          then
        	     let ok=$ok+1
	          else    
		     if [ "`grep $module=KO $module.log 2>/dev/null`" != "" ]
		     then
        	        [ ! -f compare_resultat.log ] && ../compare_resultat .tests_TRUST_mpi_*
        	        cat compare_resultat.log | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host KO\" $TMA_PROJECT_LEADER $TRUST_MAIL
		     else
		        cat .tests_TRUST_mpi_* | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host not finished\" $TRUST_MAIL
		     fi
	          fi
	          # Mise a jour de la reference
	          if [ "`grep 'On change la reference' $module.log`" != "" ]
	          then
        	     echo "  Update reference of $module module"
        	     CHECKOUT res_test_ref 1>/dev/null 2>&1
		     new_rapport=`ls -rt .tests_TRUST_* | grep -v KO | grep -v OK 2>/dev/null | tail -1`
		     [ "$new_rapport" != "" ] && cat $new_rapport > res_test_ref
	          fi
	       fi
	       # Faire une page html regroupant l'ensemble des resultats
	    fi
         done
	 [ $nb -eq 0 ] && nb=-1
      fi
      verification_modules=0 && [ $ok -eq $nb ] && verification_modules=1
      echo " "
      if [ $verification_modules = 1 ]
      then
         echo "Release criterion: Modules OK"
      else
         echo "Release criterion: Modules KO"
      fi
      force_verification_modules=~/force_verification_modules && [ -f $force_verification_modules ] && verification_modules=1 && rm -f $force_verification_modules
      echo "$verification_modules  Modules $ok/$nb="`echo $ECHO_OPTS "scale=3;$ok/$nb" | bc -l`" (=1.000)" >> $MESSAGES_NUIT
      let total_criteres=$total_criteres+1
      let criteres_remplis=$criteres_remplis+$verification_modules
   fi
   cd $TRUST_ROOT
else
   echo "NOT executed"
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########
# Valgrind
##########
echo " "
echo "#####################################"
echo "# Verify the validation of Valgrind #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
# Recuperer le ANA.log sur les machines valgrind
cd $TRUST_ROOT/Validation/Valgrind
Build=$TRUST_ROOT/build/Validation/Valgrind
[ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
rm -f $Build/ANA_*.log $Build/casmem_* $Build/caserr_*
machines_=`liste_machines "\-check-valgrind"`
machines=`liste_machines "\-check-valgrind" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [ ${#machines} = 0 ]
then
   valgrind=0
else
   valgrind=1
   echo "Validation by -valgrind on"
   echo $machines
   echo " "
fi
for machine_ in $machines_
do
   machine=`echo $machine_ | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
   valgrind_log=$Build"/ANA_"$machine".log"
   if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "  KO $machine machine not accessible via ssh."
      echo "  No $valgrind_log"
      valgrind=0
      echo | mail_ -s\"[lance_test_nuit] Error when receiving Valgrind log from $machine not accessible via ssh.\" $TRUST_MAIL
   else
      echo "Verification of $valgrind_log"
      log=`awk -v adr=$machine_ '($2==adr) {print $4}' ~/.netrc | head -1`
      workdir=`ssh $machine -n 'echo $WORKDIR'`
      #scp $log@$machine:~/$WORKBASE$machine/TRUST/Validation/Valgrind/ANA.log $valgrind_log
      if [ "${machine:0:2}" = "is" ]
      then
         #scp $log@$machine:$WORKDIR/.tmp_TRUST_$machine/ANA.log $valgrind_log
         scp $log@$machine:$workdir/.tmp_TRUST_$machine/ANA.log $valgrind_log 1>/dev/null 2>&1
         scp_error=$?
         #[ $scp_error != 0 ] && scp $log@$machine:/volatile/triou/.tmp_TRUST_$machine/ANA.log $valgrind_log && scp_error=$?
      else
         scp $log@$machine:~/.tmp_TRUST_$machine/ANA.log $valgrind_log
         scp_error=$?
      fi
      if [ $scp_error != 0 ]
      then
         echo | mail_ -s\"[lance_test_nuit] Error when receiving Valgrind log from $machine. Check if not finished.\" $TRUST_MAIL
      fi
      rm -f $scp_error
      sleep 1
      if [ ! -f $valgrind_log ]
      then
         echo "  valgrind not finished"
         valgrind=0
      else
         #scp $log@$machine:~/$WORKBASE$machine/TRUST/Validation/Valgrind/casmem $Build/casmem_$machine
         if [ "${machine:0:2}" = "is" ]
         then
            #scp $log@$machine:$WORKDIR/.tmp_TRUST_$machine/casmem $Build/casmem_$machine
            scp $log@$machine:$workdir/.tmp_TRUST_$machine/casmem $Build/casmem_$machine 1>/dev/null 2>&1
            #[ $? != 0 ] && scp $log@$machine:/volatile/triou/.tmp_TRUST_$machine/casmem $Build/casmem_$machine
         else
            scp $log@$machine:~/.tmp_TRUST_$machine/casmem $Build/casmem_$machine
         fi
	 # [ ! -s $valgrind_log ] && echo "  Empty file" && valgrind=0
         cat $valgrind_log 2>/dev/null | $TRUST_Awk -F: '/ errors from /{gsub("\\.val","",$2);print $2}' > $Build/caserr_$machine
         valgrind_max=0
         valgrind_err=`cat $Build/caserr_$machine 2>/dev/null | wc -l`
         # On supprime les cas de casmem qui se retrouvent dans liste (cas qui se sont arretes)
         grep -v -f $TRUST_ROOT/exec/tests_TRUST$COMM"_semi_opt"/liste $Build/casmem_$machine > cas
         valgrind_leak=`cat cas 2>/dev/null | wc -l`
         rm -f cas
         let valgrind_err=$valgrind_err+$valgrind_leak
         echo "  valgrind $valgrind_err errors including $valgrind_leak memory leak ($valgrind_err<=$valgrind_max)"  
         [ ! $valgrind_err = 0 ] && echo "    See $Build/caserr_$machine" #&& cat $Build/caserr_$machine
         [ ! $valgrind_leak = 0 ] && echo "    See $Build/casmem_$machine" #&& cat $Build/casmem_$machine
         if [ ${#valgrind_err} = 0 ] || [ $valgrind_err -gt $valgrind_max ]
         then
            valgrind=0
	    # Envoi d'un mail pour prevenir immediatement
	    cat $Build/caserr_$machine $Build/casmem_$machine >> $TRUST_TMP/cas
	    if [ -s $TRUST_TMP/cas ]
	    then
	       log_filtre=`mktemp_`
	       grep -v -f $TRUST_ROOT/exec/tests_TRUST$COMM"_semi_opt"/liste $valgrind_log 1>$log_filtre 2>&1
	       echo "-----------" >>$log_filtre
	       cat $TRUST_TMP/cas >>$log_filtre
	       [ -s $log_filtre ] && cat $log_filtre | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects TRUST errors on $machine host\" $TRUST_MAIL
               rm -f $log_filtre
	    fi
         fi
      fi
   fi
done
cd $TRUST_ROOT
echo " "
for Composant in $Composants
do
   PROJECT_ROOT=`dirname $TRUST_ROOT`/Composants/$Composant
   rm tmp.log 2>/dev/null
   for machine in $machines
   do
      # Check if valgrind for this composant:
      grep valgrind $PROJECT_ROOT/*$Composant*$machine.*prepare.log 2>/dev/null > list.log
      if [ -s list.log ]
      then
         echo "Verification of baltik $Composant on $machine"
	 grep "make_check " $PROJECT_ROOT/*$Composant*$machine.*make_check.log 2>/dev/null
	 [ $? != 0 ] && valgrind=0 && cat list.log >> tmp.log
         testko=`grep "make_check KO" $PROJECT_ROOT/*$Composant*$machine.*make_check.log`
         if [ "$testko" != "" ]
	 then
	    echo $testko
	    echo $machine >> tmp.log
            grep " CORE " $PROJECT_ROOT/*$Composant*$machine.*make_check.log | awk -F"|" '{print $NF}' >> tmp.log
            echo " " >> tmp.log
            # on retire ijk, polymac, triomc et mathys du critere de livraison TRUST/TrioCFD
            if [ "$Composant" != ijk ] && [[ "$ComposantsBeta" != *"$Composant"* ]] 
            then 
                valgrind=0
            fi
	 fi
      fi
      rm list.log
    done
    if [ -s tmp.log ]
    then
       echo " "
       if [[ "$ComposantsGit" = *"$Composant"* ]] # Test si Composant est dans la liste des composants GIT
       then
           BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
       else
          BALTIK_PROJECT_LEADER="TRUST_PROJECT_LEADER"
       fi
       cat tmp.log | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects $Composant errors on host:\" ${!BALTIK_PROJECT_LEADER} $TRUST_MAIL # $TMA_PROJECT_LEADER
    fi
    rm tmp.log 2>/dev/null
done
echo " "
echo "Analysis of $REP_NUIT/CR_* files"
OK=`grep "KVALGRIND=OK" $REP_NUIT/CR_* 2>/dev/null | wc -l`
KO=`grep "KVALGRIND=KO" $REP_NUIT/CR_* 2>/dev/null | wc -l`
let NB=$OK+$KO
if [ $KO != 0 ]
then
   grep "KVALGRIND=KO" $REP_NUIT/CR_*
   (
   grep "KVALGRIND=KO" $REP_NUIT/CR_*  | cut -d_ -f3 | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects TRUST errors with upwind test case on host:\" $TRUST_MAIL
   )
   #valgrind=0 # Test provisoire : en attente decision project leader
fi
echo " "
if [ $valgrind = 1 ]
then
   echo "Release criterion: Valgrind OK"
else
   echo "Release criterion: Valgrind KO"
fi
force_valgrind=~/force_valgrind && [ -f $force_valgrind ] && valgrind=1 && rm -f $force_valgrind
echo "$valgrind  Valgrind $valgrind (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$valgrind
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
echo " "
echo "############################"
echo "# Verify the code coverage #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
########
# GCOV #
########
repertoire_gcov=$TRUST_ROOT/MonoDir$COMM/src
machines=`liste_machines "\-all" "\-gcov"`
echo "Validation by -gcov on $machines"
if [ "$machines" = "" ]
then
   echo "  No coverage by gcov!!!" 
   echo "Warning: No host -all -gcov in liste.machines! No coverage by gcov." | mail_ -s\"[lance_test_nuit] GCOV: NO coverage!!!\" $TRUST_MAIL
fi
for machine_gcov in $machines # Compilation avec -gcov et passage de tous les cas tests
do
   hostname=`echo $machine_gcov | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'` 
   log=`awk -v adr=$machine_gcov '($2==adr) {print $4}' ~/.netrc | head -1`
   echo "  Recovery from $hostname"
   if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine_gcov -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "    KO $machine_gcov machine not accessible via ssh." 
      echo "    No $REP_NUIT/analyse_couverture_$hostname.log"
   else
      echo "    See $REP_NUIT/analyse_couverture_$hostname.log"
      workdir=`ssh $machine -n 'echo $WORKDIR'`
      if  [ "${hostname:0:2}" = "is" ]
      then
         scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/tests/analyse_couverture.log $REP_NUIT/analyse_couverture_$hostname.log
         scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/tests/GCDA/ana/monana_out $REP_NUIT/monana_out_$hostname.log
         scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_out $REP_NUIT/gcov_out_$hostname.log
         scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_err $REP_NUIT/gcov_err_$hostname.log
      else
         scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/tests/analyse_couverture.log $REP_NUIT/analyse_couverture_$hostname.log
         scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/monana_out $REP_NUIT/monana_out_$hostname.log
         scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_out $REP_NUIT/gcov_out_$hostname.log
         scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_err $REP_NUIT/gcov_err_$hostname.log
      fi
      # Copie cpp.gcov.tar.gz 
      file=cpp.gcov.tar.gz  
      #echo "    Copy $file to $TRUST_ROOT/doc/Coverage/" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
      echo "    Copy $file to $TRUST_TMP/"
      rm -f $TRUST_TMP/$file
      #scp $log@$machine_gcov:~/$WORKBASE$hostname/TRUST/doc/Coverage/$file $TRUST_TMP/$file
      if  [ "${hostname:0:2}" = "is" ]
      then
         scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
      else
         scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
      fi
      if [ "`diff $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file`" != "" ]
      then
         echo "    => updated"
         #CHECKOUT $TRUST_ROOT/doc/Coverage/$file 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         #mv -f $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file    # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
      else
         echo "    => NOT updated"
      fi
   fi
done
###########
# PROFILE #
###########
# Recuperer des informations de couverture du code (ce n'est pas encore un critere de livraison)
machines=`liste_machines "\-all" "\-prof"`
echo " "
echo "Validation by -prof on $machines"
if [ "$machines" = "" ]
then
   echo "  No coverage by prof!!!" 
   echo "Warning: No host -all -prof in liste.machines! No coverage by prof." | mail_ -s\"[lance_test_nuit] PROFILE: NO coverage!!!\" $TRUST_MAIL
fi
for machine in $machines # Compilation avec -prof et passage de tous les cas tests
do
   cd $TRUST_ROOT/doc/Coverage
   hostname=`echo $machine | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
   log=`awk -v adr=$machine '($2==adr) {print $4}' ~/.netrc | head -1`
   echo "  Recovery from $hostname"
   if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "    KO $machine machine not accessible via ssh." 
      echo "    No $REP_NUIT/make_Couverture_$hostname.log"
   else
      echo "    See $REP_NUIT/make_Couverture_$hostname.log"
      workdir=`ssh $machine -n 'echo $WORKDIR'`
      if [ "${hostname:0:2}" = "is" ]
      then
         scp $log@$machine:$workdir/.tmp_TRUST_$hostname/tests/make_Couverture.log $REP_NUIT/make_Couverture_$hostname.log
      else
         scp $log@$machine:~/.tmp_TRUST_$hostname/tests/make_Couverture.log $REP_NUIT/make_Couverture_$hostname.log
      fi
      error_log=`grep "Problem with the gprof command" $REP_NUIT/make_Couverture_$hostname.log`
      [ ${#error_log} != 0 ] && cat $REP_NUIT/make_Couverture_$hostname.log | mail_ -s\"[lance_test_nuit] Problem with the gprof command on $hostname in make_Couverture\" $TRUST_MAIL
      # Copie file 
      for file in list_methodes.gz list_methodes_non_appelees.gz dico.pkl.gz 
      do
         #echo "    Copy $file to $TRUST_ROOT/doc/Coverage/" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         echo "    Copy $file to $TRUST_TMP/"
         rm -f $TRUST_TMP/$file
         #scp $log@$machine:~/$WORKBASE$hostname/TRUST/doc/Coverage/$file $TRUST_TMP/$file
         if [ "${hostname:0:2}" = "is" ]
         then
            scp $log@$machine:$workdir/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
         else
            scp $log@$machine:~/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
         fi
         if [ -f $TRUST_TMP/$file ] && [ "`diff $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file`" != "" ]
         then
            echo "    => updated"
            #CHECKOUT $TRUST_ROOT/doc/Coverage/$file 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
            #mv -f $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file    # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         else
            echo "    => NOT updated"
         fi
         #rm -f $TRUST_TMP/$file                  # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         #ls -la $TRUST_ROOT"/doc/Coverage/"$file # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         # Recuperation du rapport gprof de l'ensemble des cas tests de non regression si cree
         if [ "`grep 'GMON_DIR=""' $TRUST_ROOT/bin/lance_test`" = "" ]
         then
            cpu=all_tests.cpu 
            echo "    Copy $cpu to $TRUST_ROOT/doc/Coverage/"
            #CHECKOUT $cpu 
            if [ "${hostname:0:2}" = "is" ]
	    then
               scp $log@$machine:$workdir/.tmp_TRUST_$hostname/tests/$cpu . #1>/dev/null 2>&1
	    else
               scp $log@$machine:~/.tmp_TRUST_$hostname/tests/$cpu . #1>/dev/null 2>&1
	    fi
            #CHECKIN $cpu
            ls -la $TRUST_ROOT"/doc/Coverage/"$cpu
         fi
      done
   fi
done
#
##########
# TGGCOV #
##########
# Mise a jour du repertoire doc/Coverage et verification que la couverture est a jour
cd $TRUST_ROOT/doc/Coverage
Build=$TRUST_ROOT/build/doc/Coverage
[ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
echo " "
echo "Verification of the coverage in `pwd`:"
# Creation des classes appellees ou non
(
cd $TRUST_ROOT/doc/Coverage
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -file"
listing=`mktemp_`
export PYTHONPATH=$PYTHONPATH:$TRUST_ROOT/bin/KSH
python -c "from Couv import nombre_de_cas_par_classe;nombre_de_cas_par_classe()" > $listing
rm $TRUST_ROOT/bin/KSH/Couv.pyc
# Classes non testees
for string in `$TRUST_Awk '/ 0 0/ {print $1}' $listing | sort`
do
   classe=`echo $string | $TRUST_Awk -F'|' '{print $1}'`
   path_fichier_cpp=`ViC $classe cpp -no_vi`
   if [ "$path_fichier_cpp" != "" ]
   then
      cpp=`basename $path_fichier_cpp`
      tc=`tggcov_ -file $cpp | awk '/File / {print "fichier couvert a "$1"%"}'`
   else
      # Fichier non trouve
      tc=""
   fi
   echo $ECHO_OPTS $string" \tdans \$TRUST_ROOT"${path_fichier_cpp#$TRUST_ROOT/.}" "$tc
done > $Build/liste_classes_non_testees
cat $Build/liste_classes_non_testees | grep Kernel > $Build/liste_classes_non_testees_Kernel
cat $Build/liste_classes_non_testees_Kernel | grep " 0.00" > $Build/liste_fichiers_Kernel_a_supprimer
for file in $Build/liste_classes_non_testees $Build/liste_classes_non_testees_Kernel $Build/liste_fichiers_Kernel_a_supprimer
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
# Classes testees
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -short -file"
html=$Build/liste_classes_testees.html
echo $ECHO_OPTS "<HTML><PRE>Critere\tCouvert\tTests\tClasse" > $html
for string in `$TRUST_Awk '!/ 0 0/ {print $1"|"$2"|"$3}' $listing`
do
   classe=`echo $string | $TRUST_Awk -F'|' '{print $1}'`
   nb_tests=`echo $string | $TRUST_Awk -F'|' '{print $2+$3}'`
   path_fichier_cpp=`ViC $classe cpp -no_vi`
   if [ "$path_fichier_cpp" != "" ]
   then
      fichier_cpp=`basename $path_fichier_cpp`
      taux_couverture=`tggcov_ -short -file $fichier_cpp | $TRUST_Awk '{print $1}'`
      critere=`echo $taux_couverture $nb_tests | $TRUST_Awk '{t=$1;n=$2;c=100*(0.01*t)**n;printf("%7.3f",c)}'`
   else
      fichier_cpp="not_found"
      taux_couverture="?????"
      critere="  0.000"
   fi
   echo $ECHO_OPTS "$critere\t$taux_couverture%\t$nb_tests\t<A HREF=cpp.gcov/$fichier_cpp.gcov>$classe</A>"
done | sort -nr >> $html
echo "</HTML>" >> $html
rm -f $listing
for file in $html
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
)
#
##########
# TGGCOV #
##########
# Calcul de la couverture du code par les cas tests
# Attention les .gcda et .gcno doivent etre du meme GCC
cd $repertoire_gcov
#On n'utilise plus ggcov car il faut le meme compilateur pour exploiter les .gcda et .gcno
#couverture_de_code=`tggcov -R all | $TRUST_Awk 'BEGIN {lines="??"} /Summary/ && /src/ {for (i=0;i<7;i++) getline;lines=$1} END {gsub("%","",lines);print lines}'`
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_"
echo "from `pwd`"
echo "    See $REP_NUIT/tggcov.log"
$TRUST_ROOT/bin/KSH/tggcov_ 1>$REP_NUIT/tggcov.log 2>&1
#tail -n2 $REP_NUIT/tggcov.log
couverture_de_code=`tggcov_ | $TRUST_Awk '/TRUST code/ {print $1}'`
cd - 1>/dev/null 2>&1
couverture_minimale=69.24 # 69.24 v1.8.4 ; 69.42 v1.8.3 (templates vdf) ; 65.88 v1.8.2 ; 57.86 v1.8.1 ; 60.03 v1.8.0 ; 66.73 v1.7.9 ; 67.49 v1.7.8 ; 69.05 v1.7.7 ; 69.42 v1.7.6 ; 69.87 v1.7.5 ; 70.04 v1.7.4 ; 69.61 v1.7.3 ; 69.28 v1.7.2 ; 65.26 v1.7.1
coverage=`echo $couverture_de_code | $TRUST_Awk -v m=$couverture_minimale '{if ($1>=m) print 1;else print 0}'`
if [ $coverage = 1 ]
then
   echo "    Code coverage $couverture_de_code% >= $couverture_minimale% of lines"
else
   echo "    Code coverage $couverture_de_code% < $couverture_minimale% of lines"
   cat $REP_NUIT/tggcov.log | mail_ -s\"[lance_test_nuit] Code coverage KO with $couverture_de_code% \< $couverture_minimale% of lines tested\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
(
# Creation du rapport html
cd $TRUST_ROOT/doc/Coverage
cd html
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -html"
echo "from `pwd`"
echo "    See $REP_NUIT/tggcov_html.log"
$TRUST_ROOT/bin/KSH/tggcov_ -html 1>$REP_NUIT/tggcov_html.log 2>&1
tail -n1 $REP_NUIT/tggcov_html.log
#echo "    Update html.tgz on $TRUST_ROOT/doc/Coverage" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
echo "    Update html.tgz on $TRUST_ROOT/doc/Coverage/html"
tar cfz html.tgz *.html
# Mise a jour si different
if [ "`diff -a html.tgz ../html.tgz 2>/dev/null;echo $?`" != 0 ]
then
   echo "    => updated"
   #CHECKOUT ../html.tgz 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
   #mv -f html.tgz ../html.tgz            # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
else
   echo "    => NOT updated"
   #rm -f html.tgz   # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
fi
#ls -la ../html.tgz  # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
)
cd $TRUST_ROOT/doc/Coverage
echo "  Call to make in $TRUST_ROOT/doc/Coverage"
make clean # dossier Coverage/html supprime et Coverage/html/index.html vide car non mis a jour dans l'archive TRUST + all baltik
make
CPP_GCOV=$TRUST_ROOT/doc/Coverage/html/cpp.gcov
echo "  Verification of $CPP_GCOV"
#grep $DATE $CPP_GCOV/MAIN.cpp.gcov # Build a ete retire des fichiers MAIN.cpp
#if [ "`grep $DATE $CPP_GCOV/MAIN.cpp.gcov 2>/dev/null`" = "" ]
#then
#   echo "    KO"
#   echo "$CPP_GCOV KO. See on $machine_gcov host with the gcov TRUST binairy: `grep build $CPP_GCOV/MAIN.cpp.gcov`" | mail_ -s\"[lance_test_nuit] Coverage KO on $hostname host\" $TRUST_MAIL
#else
#   echo "    OK"
#fi
ls -la $CPP_GCOV/MAIN.cpp.gcov
for file in list_methodes list_methodes_non_appelees
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
# Nouveau pour 1.6.3: Comparaison de la couverture de code fichier par fichier par rapport a la version precedante (sous $WORKDIR/tuleap/Maintenance)
(
cd $TRUST_ROOT/doc/Coverage/html/cpp.gcov
MAINTENANCE=$WORKDIR/tuleap/Maintenance/TRUST
echo " "
echo "Comparison of code coverage between new and old versions"
echo "from `pwd`"
echo " and $MAINTENANCE/doc/Coverage/html/cpp.gcov"
echo "Call to bin/KSH/tggcov_ -short -file *.gcov"
[ ! -d $MAINTENANCE ] && echo "  Verification of test coverage impossible because $MAINTENANCE not exist." #&& coverage=0
log=`mktemp_`
for gcov in *.gcov
do
   if [ -f $MAINTENANCE/doc/Coverage/html/cpp.gcov/$gcov ]
   then
      file=${gcov%.gcov}
      new_coverage=`tggcov_ -short -file $file`
      old_coverage=`export TRUST_ROOT=$MAINTENANCE;tggcov_ -short -file $file`
      # Regression de la couverture de code (Le nombre de lignes non testees augmente si la couverture est pas nulle)
      couverture=`echo $old_coverage | awk '{print $1}'`
      lignes_non_testees_en_plus=`echo $new_coverage $old_coverage | awk '{split($2,new,"/");split($6,old,"/");print (new_coverage[2]-new_coverage[1])-(old_coverage[2]-old_coverage[1])}'`
      if [ $lignes_non_testees_en_plus -gt 0 ] && [ $couverture != 0.00 ]
      then
         echo $ECHO_OPTS "$lignes_non_testees_en_plus lines not tested more in $file"
	 # echo "  "sdiff $TRUST_ROOT/doc/Coverage/html/cpp.gcov/$gcov $MAINTENANCE/doc/Coverage/html/cpp.gcov/$gcov
	 # Mise en echec du critere de livraison:
	 #coverage=0
      fi
   fi
done | tee $log
# Pas au point, donc on ne signale rien:
#[ -s $log ] && cat $log | mail_ -s\"[lance_test_nuit] Regression code coverage between `basename $TRUST_ROOT_MASTER` and Maintenance:\" $TRUST_MAIL
rm -f $log
cd - 1>/dev/null 2>&1
)
echo " "
if [ $coverage = 1 ]
then
   echo "Release criterion: Code coverage OK"
else
   echo "Release criterion: Code coverage KO"
fi
echo "$coverage  Code coverage $couverture_de_code% (>=$couverture_minimale% of lines)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$coverage
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
echo " "
echo "################################"
echo "# Verify the keywords coverage #"
echo "################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "  Analysis of $credoc_log"
grep OK $credoc_log
grep KO $credoc_log
error_log=`grep 'error Doxygen' $credoc_log`
[ ${#error_log} != 0 ] && echo | mail_ -s\"[credoc] Doxygen: Study of TRUST includes under `pwd`\" $TRUST_MAIL
#echo "    See $TRUST_ROOT/build/doc/TRUST/list_keywords_covered file"
#OK=`wc -l $TRUST_ROOT/build/doc/TRUST/list_keywords_covered | awk '{ print $1 }'`
#echo "    $OK keywords covered by test cases"
#echo "    See $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered file"
#KO=`wc -l $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered | awk '{ print $1 }'`
#echo "    $KO keywords NOT covered by test cases"
#let NB=$OK+$KO
# Mail de verification uniquement le week-end
#[ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ] && [ -f $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered ] && cat $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered | mail_ -s\"[lance_test_nuit] Tests coverage credoc: list of keywords NOT covered by test cases\" $TMA_PROJECT_LEADER $TRUST_MAIL
#keywords_minimal=77.37 #v1.7.5
#
echo "    See $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata* files"
NB=0
OK=0
KO=0
[ -f  $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata ] && NB=`wc -l $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata | awk '{ print $1 }'`
[ -f $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested ] && OK=`wc -l $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested | awk '{ print $1 }'`
let KO=$NB-$OK
echo "    $OK keywords covered by test cases"
echo "    $KO keywords NOT covered by test cases"
keywords_minimal=81.97 #81.40 v1.8.4 #80.03 v1.8.3 #78.89 v1.8.2 #78.70 v1.8.1 #78.60 v1.8.0 deplacement de la turbulence de TRUST a TrioCFD;  83.10 v1.7.8 suppression du mot-cle "espece lambda" ; 83.11 v1.7.7 classe de base avec ajout de commentaires XD ; 83.00 v1.7.6 ; 82.89 v1.7.5

echo " "
keywords=0
couverture_de_motcle=0
[ $NB != 0 ] && couverture_de_motcle=`echo $ECHO_OPTS "scale=2;100*$OK/$NB" | bc -l`
keywords=`echo $couverture_de_motcle | $TRUST_Awk -v m=$keywords_minimal '{if ($1>=m) print 1;else print 0}'`
if [ $keywords = 1 ]
then
   echo "    Keywords coverage $couverture_de_motcle% >= $keywords_minimal% tested "
else
   echo "    Keywords coverage $couverture_de_motcle% < $keywords_minimal% tested"
   if [ -f $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested ]
   then
      cat $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested | mail_ -s\"[lance_test_nuit] Keywords coverage KO with $couverture_de_motcle% \< $keywords_minimal% tested\" $TMA_PROJECT_LEADER $TRUST_MAIL
   else
      echo "No list_keywords_xdata_tested file" | mail_ -s\"[lance_test_nuit] Keywords coverage KO with $couverture_de_motcle% \< $keywords_minimal% tested\" $TMA_PROJECT_LEADER $TRUST_MAIL
   fi
fi
echo " "
if [ $keywords = 1 ]
then
   echo "Release criterion: Keywords coverage OK"
else
   echo "Release criterion: Keywords coverage KO"
fi
echo "$keywords  Keywords coverage $OK/$NB=$couverture_de_motcle% (>=$keywords_minimal% tested)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$coverage
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
##############
# Parallelisme
##############
echo " "
echo "#####################################"
echo "# Test the stability of parallelism #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
machine_=`liste_machines "\-Check_decoupage"`
machine=`liste_machines "\-Check_decoupage" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -Check_decoupage on $machine"
if  [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
then
   echo "  KO $machine machine not accessible via ssh." 
   echo "  No $REP_NUIT/Check_decoupage.ksh_$machine.log"
   echo | mail_ -s\"[lance_test_nuit] Error when receiving Check_decoupage log from $machine not accessible via ssh.\" $TRUST_MAIL
   stabilite_parallelisme=0
   resultat_parallelisme=0/0
   parallelism=0
   echo " "
   echo "Release criterion: Parallelism KO"
else
   echo "  See $REP_NUIT/Check_decoupage.ksh_$machine.log"
   log=`awk -v adr=$machine_ '($2==adr) {print $4}' ~/.netrc | head -1`
   if [ "${machine:0:2}" = "is" ]
   then
      #scp $log@$machine:$WORKDIR/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log
      workdir=`ssh $machine -n 'echo $WORKDIR'`
      scp $log@$machine:$workdir/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log 1>/dev/null 2>&1
      #[ $? != 0 ] && scp $log@$machine:/volatile/triou/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log
   else
      scp $log@$machine:~/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log
   fi
   error_log=`grep "Failure on " $REP_NUIT/Check_decoupage.ksh_$machine.log`
   [ ${#error_log} != 0 ] && cat $REP_NUIT/Check_decoupage.ksh_$machine.log | mail_ -s\"[lance_test_nuit] Check_decoupage.ksh on $machine KO\" $TRUST_MAIL
   file_log=$REP_NUIT"/PERF_TRUST"$COMM"_opt_linux_"$machine
   check_log=`mktemp_`
   echo "  Analysis of "$file_log" file" | tee -a $check_log
   if [ ! -f $REP_NUIT/Check_decoupage.ksh_$machine.log ]
   then
      stabilite_parallelisme=0
      resultat_parallelisme=0/0
      parallelism=0
   else
      grep "Decoupage...OK Execution...Arret Validite...KO" $file_log | tee -a $check_log
      grep "Failure on" $file_log | tee -a $check_log
      stabilite_parallelisme=`$TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print ok/procs}' $file_log`
      resultat_parallelisme=`$TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print ok"/"procs}' $file_log`
      $TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print cas " cases including "ok " OK to "procs" CPUs. Validity = "ok"/"procs" = "ok/procs" %"}' $file_log | tee -a $check_log
      parallelism=`echo $stabilite_parallelisme | $TRUST_Awk '{if ($1==1) print 1;else print 0}'`
   fi
   echo " " | tee -a $check_log
   if [ $parallelism = 1 ]
   then
      echo "Release criterion: Parallelism OK" | tee -a $check_log
   else
      echo "Release criterion: Parallelism KO" | tee -a $check_log
      echo "-------------------------------------------------------------------------------------------" >> $check_log
      echo " " >> $check_log
      [ "$error_log" != "" ] && cat $REP_NUIT/Check_decoupage.ksh_$machine.log >> $check_log
      cat $check_log | mail_ -s\"[lance_test_nuit] KO Check_decoupage script on $machine\" $TMA_PROJECT_LEADER $TRUST_MAIL
   fi
   rm -f $check_log
fi
force_check_decoupage=~/force_check_decoupage && [ -f $force_check_decoupage ] && parallelism=1 && rm -f $force_check_decoupage
echo "$parallelism  Parallelism $resultat_parallelisme=$stabilite_parallelisme (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$parallelism
# Desormais le week-end sur pc tma, on met a jour les cas tests
# pour la balise PARALLEL OK
# Dangereux car blocages possibles
#if [ "`date '+%u'`" -gt 5 ]
#then
#   Check_decoupage.ksh -all -update
#fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##############
# Performances
##############
echo " "
echo "########################"
echo "# Test the performance #"
echo "########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
total=0
machines=`liste_machines "\-benchmark" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -benchmarck on"
echo $machines
nb_machines=0
for machine in $machines
do
   PERF=`ls $REP_NUIT/PERF_TRUST_*$machine 2>/dev/null`  
   echo "  Analysis of "$PERF" file"
   if [ -f "$PERF" ] && [ "`grep Run_bench $PERF`" != "" ]
   then
      # Aucune efficacite en dessous de 0.60 sur 4 processeurs et aucun cpu au dessus de 8s sur 1 processeur:
      perf=`$TRUST_Awk 'BEGIN {p=0} ($1==4) && (NF==12) && /\|/ {if ($(NF-1)>0.60) p=p+0.25} ($1==1) && (NF==12) && /\|/ {if ($3<8) p=p+0.25} END {print p}' $PERF`
      ([ "`liste_machines cible | grep $machine`" != "" ] || [ "`liste_machines tache | grep $machine`" != "" ]) && total=`echo "$total+$perf" | bc -l`
      echo "Time VDF and VEF on 1 CPU: < 8s ?"
      $TRUST_Awk '($1==1) && (NF==12) && /\|/ {print $3}' $PERF
      echo "Efficacite VDF and VEF on 4 CPUs: > 0.60 ?"
      $TRUST_Awk '($1==4) && (NF==12) && /\|/ {print $(NF-1)}' $PERF
      if ([ "`liste_machines cible | grep $machine`" != "" ] || [ "`liste_machines tache | grep $machine`" != "" ])
      then
         echo "=> perf+=$perf (total=$total)"  
         let nb_machines=$nb_machines+1
      else
         echo "=> perf+=$perf"  
      fi
      [ $(echo " $perf < 1 " | bc) -eq 1 ] && cat $PERF | mail_ -s\"[lance_test_nuit] Benchmark on $machine KO\" $TRUST_MAIL
   else
      echo "File not exist => benchmark not executed on the machine: $machine"
   fi
done
#
if [ "$nb_machines" != 0 ]
then
   echo "Call to $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/Run_fiche"
   bench_log=$REP_NUIT"/benchmark_report_"$HOST".log"
   echo "  See $bench_log"
   echo "TRUST benchmarh report on $HOST the `date` ...">$bench_log
   echo>>$bench_log
   (Build=$TRUST_ROOT/build/tests/Reference/BENCHMARK;
    [ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build};
    rm -rf $Build/Rapport;
    cp -r $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport $Build/.;
    cd $Build/Rapport;Run_fiche 1>>$bench_log 2>&1
   )
   tail -n1 $bench_log
   if [ -f $TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf ]
   then
       # Envoi du rapport genere le week-end au project leader
      if [ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ]
      then
         echo "$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run_fiche" | mail_ -a\"$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Benchmark report generated `date '+%d/%m/%y'`\" $TMA_PROJECT_LEADER $TRUST_MAIL
      else
         echo "$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run_fiche" | mail_ -a\"$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Benchmark report generated `date '+%d/%m/%y'`\" $TRUST_MAIL
      fi
   else
      cat $TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run.log | mail_ -s\"[lance_test_nuit] KO Benchmark report NOT generated `date '+%d/%m/%y'`\" $TRUST_MAIL
   fi
else
   echo "...no machine with benchmark option in $TRUST_ROOT/bin/admin/liste.machines file"
   liste_machines benchmark | mail_ -s\"[lance_test_nuit] Performance KO because NO Benchmark on\" $TRUST_MAIL
fi
#nb_machines=`echo $machines | $TRUST_Awk '{print NF}'`
performances=0 && [ $total = $nb_machines ] && [ $total != 0 ] && performances=1
echo " "
if [ $performances = 1 ]
then
   echo "Release criterion: Performance OK"
else
   echo "Release criterion: Performance KO"
fi
force_performances=~/force_performances && [ -f $force_performances ] && performances=1 && rm -f $force_performances
# je force le critere performances
# performances=1
[ "$nb_machines" -eq 0 ] && nb_machines=-1
if [ "$nb_machines" -eq -1 ]
then
  echo "$performances  Performance $total/0="`echo $ECHO_OPTS "scale=3;$total/$nb_machines" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
  nb_machines=0
else
   echo "$performances  Performance $total/$nb_machines="`echo $ECHO_OPTS "scale=3;$total/$nb_machines" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$performances
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

###########
# ToDo list
###########
echo " "
echo "########################"
echo "# Verify the ToDo list #"
echo "########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $TRUST_ROOT/ToDo file"
nb_todo=`grep -c ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo`
echo "$nb_todo requests to do before the release of the next version"
nothing_todo=0 && [ "`grep ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo`" = "" ] && nothing_todo=1
# Envoi aux personnes concernees le mardi apres COSUIV
for qui in `$TRUST_Awk '!/Qui/ {print $2}' $TRUST_ROOT/ToDo | sort -u`
do
   grep $qui $TRUST_ROOT/ToDo | grep ${TRUST_VERSION%_beta} > $TRUST_TMP/ToDo
   [ -s $TRUST_TMP/ToDo ] && [ "`date '+%u'`" = 2 ] && cat $TRUST_TMP/ToDo | mail_ -s\"[lance_test_nuit] ToDo list for the version ${TRUST_VERSION%_beta}\" $TMA_PROJECT_LEADER $TRUST_MAIL $qui
done
# Envoi la liste complete le lundi au chef de projet avant COSUIV pour planning de la semaine
grep ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo > $TRUST_TMP/ToDo
#[ "`date '+%u'`" = 1 ] && cat $TRUST_TMP/ToDo | mail_ -s\"[lance_test_nuit] ToDo list for next Monday COSUIV\" $TMA_PROJECT_LEADER $TRUST_MAIL
rm -f $TRUST_TMP/ToDo
#
echo " "
if [ $nothing_todo = 1 ]
then
   echo "Release criterion: ToDo OK"
else
   echo "Release criterion: ToDo KO"
fi
echo "$nothing_todo  ToDo $nb_todo (=0)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$nothing_todo
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

########
# Etudes
########
echo " "
echo "#####################################"
echo "# Verify the results of study cases #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $REP_NUIT/run_Etudes.log file"
grep "Study OK " $REP_NUIT/run*.log 2>/dev/null
grep "Study KO " $REP_NUIT/run*.log 2>/dev/null
OK=`grep "Study OK " $REP_NUIT/run*.log 2>/dev/null | wc -l`
KO=`grep "Study KO " $REP_NUIT/run*.log 2>/dev/null | wc -l`
let NB=$OK+$KO
echo "  $OK/$NB studies verified"
[ "$NB" -eq 0 ] && NB=-1 
validation_etudes=0 && [ $OK = $NB ] && validation_etudes=1
echo " "
if [ $validation_etudes = 1 ]
then
   echo "Release criterion: Studies OK"
else
   echo "Release criterion: Studies KO"
   [ "$NB" -gt 0 ] && cat $REP_NUIT/run_Etudes.log | mail_ -s\"[lance_test_nuit] Results of study cases KO\" $TRUST_MAIL
fi
if [ $etude_activation = 1 ] 
then
   if [ "$NB" -gt 0 ] && [ -f $ETUDES/Rapport/build/rapport.pdf ]
   then
      # Envoi du rapport genere le week-end au project leader
      if [ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ]
      then
         echo "$ETUDES/Rapport/Run_fiche" | mail_ -a\"$ETUDES/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Studies report generated `date '+%d/%m/%y'`\" $TMA_PROJECT_LEADER $TRUST_MAIL
      else
         echo "$ETUDES/Rapport/Run_fiche" | mail_ -a\"$ETUDES/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Studies report generated `date '+%d/%m/%y'`\" $TRUST_MAIL
      fi
   else
      [ "$NB" -gt 0 ] && cat $ETUDES/Rapport/Run.log | mail_ -s\"[lance_test_nuit] KO Studies report NOT generated `date '+%d/%m/%y'`\" $TRUST_MAIL
   fi
fi
force_validation_etudes=~/force_validation_etudes && [ -f $force_validation_etudes ] && validation_etudes=1 && rm -f $force_validation_etudes
# je force le critere etude
# validation_etudes=1
if [ "$NB" -eq -1 ]
then
  echo "$validation_etudes  Studies $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)" >> $MESSAGES_NUIT
  NB=0
else
  echo "$validation_etudes  Studies $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)" >> $MESSAGES_NUIT
fi
[ "$NB" -eq -1 ] && NB=0 
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_etudes
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

###########################################
# PROJETS BALTIK BASES SUR LE KERNEL ONLY #
###########################################
# CC 01/09/2015: desormais MPCube issu de git teste via check_component
#echo " "
#echo "#########################################"
#echo "# Test the portability of baltik MPCube #"
#echo "#########################################"
#echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
## Voir si dans le futur on ne peut pas faire converger la procedure check_components sur
## les projets Baltik place sous la VOBS Composants et ce projet Baltik.
#PROJECT_ROOT=$WORKDIR/MPCube/mpcube-portage166	# MPCube a porter pour 1.6.2
##log=$PROJECT_ROOT/check_baltik_project.log
#log=$REP_NUIT"/baltik_MPCube_"$HOST"_Kernel.log"
## Necessaire de mettre entre () car initialisation du projet Baltik
#(
#source $WORKDIR/tuleap/Kernel/TRUST/env_TRUST.sh 1>/dev/null 2>&1
#cd $PROJECT_ROOT
#echo "Call to $WORKDIR/tuleap/Kernel/TRUST/bin/admin/check_baltik_project"
#echo "from `pwd`"
#echo "  See $log"
#echo "MPCube project baltik check on $HOST the `date` ...">$log
#echo>>$log
#$WORKDIR/tuleap/Kernel/TRUST/bin/admin/check_baltik_project 1>>$log 2>&1
#grep 'Projet Baltik' $log | grep OK
#cd - 1>/dev/null 2>&1
#)
#if [ "`grep 'Projet Baltik' $log | grep OK`" != "" ]
#then
#   validation_projets_baltik=1
#else
#   validation_projets_baltik=0
#   cat $log | mail_ -s\"[lance_test_nuit] Portability KO on Baltik $PROJECT_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
#fi
#echo " "
#if [ $validation_projets_baltik = 1 ]
#then
#   echo "Release criterion: MPCube OK"
#else
#   echo "Release criterion: MPCube KO"
#fi
#echo "$validation_projets_baltik  MPCube $validation_projets_baltik (=1) Baltik=$HOST:$PROJECT_ROOT" >> $MESSAGES_NUIT
#let total_criteres=$total_criteres+1
#let criteres_remplis=$criteres_remplis+$validation_projets_baltik
#echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########
# PROJETS
##########
force_composant=~/force_composant
for Composant in $Composants
do
   echo " "
   echo "###################################"
   echo "# Verify the portability of baltik $Composant "
   echo "###################################"
   echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
   PROJECT_ROOT=`dirname $TRUST_ROOT`/Composants/$Composant
   validation_composant=1
   baltik_pas_a_jour=""
   # Check if component is OK on $HOST:
   OK=0
   KO=0
   rm -f tmp.log
   for view in Livraison Maintenance Kernel
   do
      Gui_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"$view"_gui.log"
      if [ -f $Gui_log ]
      then
         echo "Analysis of "$Gui_log" file"
	 grep "Error" $Gui_log
	 grep "Validation XDATA=" $Gui_log
	 nb=`grep "Validation XDATA=OK" $Gui_log | wc -l`
         OK=`echo $(($OK+$nb))`
	 nb=`grep "Validation XDATA=KO" $Gui_log | wc -l`
         KO=`echo $(($KO+$nb))`
         BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
	 [ $nb != 0 ] && cat $Gui_log | mail_ -s\"[lance_test_nuit] XDATA $Composant $TRUST_VERSION KO\" $TRUST_MAIL ${!BALTIK_PROJECT_LEADER}
      fi
      Composant_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"$view".log"
      if [ -f $Composant_log ]
      then
         echo "Analysis of "$Composant_log" file" | tee -a tmp.log
         grep "because no $old version on this host" $Composant_log
         #grep "$Composant OK" $Composant_log | sed 1d | tee -a tmp.log # check only component without portability
         grep "$Composant OK" $Composant_log #| tee -a tmp.log
         (grep " KO" $Composant_log;grep KO $Composant_log | grep $Composant;grep " connect to host " $Composant_log | cut -d: -f2) | tee -a tmp.log
	 nb=`grep "$Composant OK" $Composant_log | wc -l`
         OK=`echo $(($OK+$nb))`
	 nb=`(grep " KO" $Composant_log;grep KO $Composant_log | grep $Composant;grep " connect to host " $Composant_log | cut -d: -f2) | wc -l`
         KO=`echo $(($KO+$nb))`
         [ "`grep KO $Composant_log | grep $Composant | grep Component`" != "" ] && validation_composant=0
         [ "`grep 'Baltik pas a jour' $Composant_log`" != "" ] && baltik_pas_a_jour="Baltik pas a jour"
      fi
      let NB=$OK+$KO
   done
   [ $NB = 0 ] && validation_composant=0
   # Check if portability is OK:
   nuit_log=$PROJECT_ROOT/nuit_$Composant.html
   nb_cible=0
   tot_cible=0
   nb_total=0
   tot_total=0
   if [ -f $nuit_log ]
   then
      echo "Analysis of "$nuit_log" file" | tee -a tmp.log
      grep "_OK" $nuit_log | tee -a tmp.log
      nb_cible=`$TRUST_Awk '/cible_OK/ {print $2}' $nuit_log`
      tot_cible=`$TRUST_Awk '/cible_OK/ {print $4}' $nuit_log`
      nb_total=`$TRUST_Awk '/total_OK/ {print $2}' $nuit_log`
      tot_total=`$TRUST_Awk '/total_OK/ {print $4}' $nuit_log`
   else
      validation_composant=0
      echo " " | tee -a tmp.log
      echo "No $REP_NUIT/nuit_$Composant.html report of $Composant on $TRUST_HOST_ADMIN KO!" | tee -a tmp.log	 
   fi
   [ $tot_cible != 0 ] && [ $nb_cible != $tot_cible ] && validation_composant=0
   [ $tot_cible = 0 ] && [ $nb_cible = 0 ] && validation_composant=0
   #if [ "`grep KO $PROJECT_ROOT/*.log | grep Info_global 2>/dev/null`" != "" ]
   if [ $KO != 0 ]
   then
      #validation_composant=0
      if [ -f $nuit_log ]
      then
         echo " " | tee -a tmp.log
         echo "Run: konqueror ftp://$TRUST_FTP/$SECRET/NUIT/nuit_$Composant.html" | tee -a tmp.log	 
      fi
   fi
   echo " "
   other_dest=""
   other_dest=`[ "$Composant" = "triocfd" ] && echo $triocfd_project_leader`
   other_dest=`[ "$Composant" = "cathare3D" ] && echo $cathare3D_project_leader`
   if [ $validation_composant = 1 ]
   then
      echo "Release criterion: $Composant OK"
      [ $nb_total != $tot_total ] && cat tmp.log | mail_ -s\"[lance_test_nuit] Portability KO on Baltik $Composant\" $TRUST_MAIL $other_dest
   else
      echo "Release criterion: $Composant KO"
      if [[ "$ComposantsGit" = *"$Composant"* ]] # Test si Composant est dans la liste des composants GIT
      then
         BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
      else
         BALTIK_PROJECT_LEADER="TRUST_PROJECT_LEADER"
      fi
      if [ $KO != 0 ]
      then
         if [ $tot_cible != 0 ]
	 then
	    cat tmp.log | mail_ -s\"[lance_test_nuit] Cible portability KO on Baltik $Composant\" $TRUST_MAIL $other_dest
	 else
	    cat tmp.log | mail_ -s\"[lance_test_nuit] Portability KO on Baltik $Composant\" $TRUST_MAIL $other_dest
	 fi
      fi
   fi
   rm -f tmp.log
   [ $KO != 0 ] && [ $nb_total = $tot_total ] && validation_composant=0
   [ -f $force_composant ] && validation_composant=1
   # Test sur l'ensemble des machines
   [ "$NB" -eq 0 ] && NB=-1
   if [ "$NB" -eq -1 ]
   then
      echo "$validation_composant  $Composant $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1) $baltik_pas_a_jour" #>> $MESSAGES_NUIT
      NB=0
   else
      echo "$validation_composant  $Composant $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1) $baltik_pas_a_jour" #>> $MESSAGES_NUIT
   fi
   # Test sur les machines cible
   [ "$tot_cible" -eq 0 ] && tot_cible=-1
   if [ "$tot_cible" -eq -1 ]
   then
      if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
      then
          echo "$validation_composant  $Composant $nb_cible/0="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1) $baltik_pas_a_jour" | tee -a $MESSAGES_NUIT
      else
          echo "$validation_composant  $Composant $nb_cible/0="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1) $baltik_pas_a_jour"
      fi
      tot_cible=0
   else
      if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
      then
         echo "$validation_composant  $Composant $nb_cible/$tot_cible="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1) $baltik_pas_a_jour" | tee -a $MESSAGES_NUIT
      else
         echo "$validation_composant  $Composant $nb_cible/$tot_cible="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1) $baltik_pas_a_jour"
      fi
   fi
#   if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
   if [ "$Composant" != ijk ] && [[ "$ComposantsBeta" != *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta ou pas ijk
   then
      let total_criteres=$total_criteres+1
      let criteres_remplis=$criteres_remplis+$validation_composant
   fi
   if [[ "$ComposantsOfficial" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Official
   then
      let baltik_ok=$baltik_ok+$validation_composant
   fi
   echo "<--- End at "`date '+%H:%M:%S %d/%m'`
done
rm -f $force_composant

####################
# SCRIPTS IMPORTANTS
####################
echo " "
echo "####################################"
echo "# Verify the validation of scripts #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $REP_NUIT/CR_* files"
grep "Script " $REP_NUIT/CR_* | grep OK 2>/dev/null
grep "Script " $REP_NUIT/CR_* | grep KO 2>/dev/null
validation_scripts=0
OKt=0
KOt=0
machines=`liste_machines cible | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
for machine in $machines
do
   if [ "`grep "Script " $REP_NUIT/CR_$machine`" != "" ]
   then
      OKm=`grep "Script " $REP_NUIT/CR_$machine | grep OK 2>/dev/null | wc -l`
      KOm=`grep "Script " $REP_NUIT/CR_$machine | grep KO 2>/dev/null | wc -l`
      OKt=`echo "$OKt+$OKm" | bc -l`
      KOt=`echo "$KOt+$KOm" | bc -l`
   fi
done
let NBt=$OKt+$KOt
OK=`grep "Script " $REP_NUIT/CR_* | grep OK 2>/dev/null | wc -l`
KO=`grep "Script " $REP_NUIT/CR_* | grep KO 2>/dev/null | wc -l`
let NB=$OK+$KO
if [ "`grep "Script " $REP_NUIT/CR_* | grep KO`" = "" ]
then
   validation_scripts=1
else
   if [ "$KOt" -eq 0 ]
   then
      grep "Script " $REP_NUIT/CR_* | grep KO | mail_ -s\"[lance_test_nuit] Validation of scripts KO on host:\" $TRUST_MAIL
   else
      grep "Script " $REP_NUIT/CR_* | grep KO | mail_ -s\"[lance_test_nuit] Validation of scripts KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
   fi
fi
[ "$KOt" -eq 0 ] && validation_scripts=1
echo " "
if [ $validation_scripts = 1 ]
then
   echo "Release criterion: Scripts OK"
else
   echo "Release criterion: Scripts KO"
fi
force_validation_scripts=~/force_validation_scripts && [ -f $force_validation_scripts ] && validation_scripts=1 && rm -f $force_validation_scripts
[ "$NB" -eq 0 ] && NB=-1
if [ "$NB" -eq -1 ]
then
   echo "$validation_scripts  Scripts $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)"
   NB=0
else
   echo "$validation_scripts  Scripts $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)"
fi
[ "$NBt" -eq 0 ] && NBt=-1
if [ "$NBt" -eq -1 ]
then
   echo "$validation_scripts  Scripts $OKt/0="`echo $ECHO_OPTS "scale=3;$OKt/$NBt" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
   NB=0
else
   echo "$validation_scripts  Scripts $OKt/$NBt="`echo $ECHO_OPTS "scale=3;$OKt/$NBt" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_scripts
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#########
# Doxygen
#########
echo " "
echo "####################################"
echo "# Verify the Doxygen documentation #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Search of $TRUST_ROOT/build/doc/doxygen*.err file"
validation_doxygen=1
if [ -f $TRUST_ROOT/build/doc/doxygen*.err ]
then
   ls -la $TRUST_ROOT/build/doc/doxygen*.*
   head -n1 $TRUST_ROOT/build/doc/doxygen*.out
   tail -n1 $TRUST_ROOT/build/doc/doxygen*.out
elif [ ! -f $TRUST_ROOT/build/doc/doxygen*.out ]
then
   validation_doxygen=0 && echo "TRUST Doxygen KO" && echo `ls -la $TRUST_ROOT/build/doc/doxygen*.*` | mail_ -s\"[lance_test_nuit] Validation of Doxygen documentation NOT\" $TRUST_MAIL
fi
[ -s $TRUST_ROOT/build/doc/doxygen*.err ] && validation_doxygen=0 && echo "TRUST Doxygen KO" && cat $TRUST_ROOT/build/doc/doxygen*.err | mail_ -s\"[lance_test_nuit] Validation of TRUST Doxygen documentation KO\" $TRUST_MAIL $TMA_PROJECT_LEADER
for Composant in $Composants
do
   if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
   then
      if [ "$Composant" != Test_Baltik ] && [ "$Composant" != ijk ] # on retire ijk du critere de livraison TRUST/TrioCFD
      then
         echo " "
         echo "Search of $TRUST_ROOT/../Composants/$Composant/build/doxygen*.err file"
         if [ -f $TRUST_ROOT/../Composants/$Composant/build/doxygen*.err ]
         then
            ls -la $TRUST_ROOT/../Composants/$Composant/build/doxygen*.*
            head -n1 $TRUST_ROOT/../Composants/$Composant/build/doxygen*.out
            tail -n1 $TRUST_ROOT/../Composants/$Composant/build/doxygen*.out
         elif [ ! -f $TRUST_ROOT/../Composants/$Composant/build/doxygen*.out ]
         then
            validation_doxygen=0 && echo "$Composant Doxygen KO" && echo `ls -la $TRUST_ROOT/../Composants/$Composant/build/doxygen*.*` | mail_ -s\"[lance_test_nuit] Validation of $Composant Doxygen documentation NOT\" $TRUST_MAIL
         fi
         BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
         [ -s $TRUST_ROOT/../Composants/$Composant/build/doxygen*.err ] && validation_doxygen=0 && echo "$Composant Doxygen KO" && cat $TRUST_ROOT/../Composants/$Composant/build/doxygen*.err | mail_ -s\"[lance_test_nuit] Validation of $Composant Doxygen documentation KO\" $TRUST_MAIL $TMA_PROJECT_LEADER ${!BALTIK_PROJECT_LEADER}
      fi
   fi
done
echo " "
if [ $validation_doxygen = 1 ]
then
   echo "Release criterion: Doxygen OK"
else
   echo "Release criterion: Doxygen KO"
fi
echo "$validation_doxygen  Doxygen $validation_doxygen (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_doxygen
min_criteres=`echo $ECHO_OPTS "scale=0\n$total_criteres*75/100" | bc -l` # 75% du nombre total de criteres pour release beta #
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo "Total: $criteres_remplis/$total_criteres criteria for the $new version" >> $MESSAGES_NUIT
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
#
#
#
echo " "
echo "------------------------------------------------------"
echo " "
echo "##############################"
echo "# Deliver and export version #"
echo "##############################"
echo " "
echo "###########################"
echo "# Test if Release version #"
echo "###########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`

########################################################################
# Feu vert de l'administrateur TRUST d'apres l'en tete de RELEASE_NOTES
########################################################################
echo "Analysis of $TRUST_ROOT/RELEASE_NOTES file"
export accord_admin=0 && [ ${new%_beta} = $new ] && accord_admin=1
export accord_beta=0
export label_pose=$new
label=v${new%_beta}
deja_livre=0
if [ $accord_admin = 1 ]
then
   echo ${new%_beta}" == "$new" => agreement_administrator = "$accord_admin
   # Add latest version of TRUST tutorials to git
   cp $TRUST_ROOT/doc/TRUST/Tutorial/TRUST_tutorial.pdf $TRUST_ROOT/doc/TRUST/
   cp $TRUST_ROOT/doc/TRUST/Tutorial/ICoCo_tutorial.pdf $TRUST_ROOT/doc/TRUST/
   cp $TRUST_ROOT/doc/TRUST/Tutorial/Baltik_tutorial.pdf $TRUST_ROOT/doc/TRUST/
   # Update the version in README.md file (displayed on github)
   sed -i "s/$old/$new/g" $TRUST_ROOT/README.md
   # Commit
   echo "Call git commit --u=no --all -m Commit before the $new version."
   git commit --u=no --all -m"Commit before the $new version."
else
   echo ${new%_beta}" >< "$new" => agreement_administrator = "$accord_admin
fi

####################################################################################################
# Si un certain nombre de criteres sont remplis, on propose une release (candidate ou intermediaire)
# Tous les jours si accord_admin = 1, label_rc=X.Y.Z_rc
# Le week-end seulement si accord_admin = 0, label_rc=X.Y.Z_beta
####################################################################################################
echo " "
echo "Analysis of $MESSAGES_NUIT file"
grep "Total:" $MESSAGES_NUIT
echo "  criteria:    "$criteres_remplis" != "$total_criteres
echo "  minimum:     "$criteres_remplis" -ge $min_criteres"
echo "  stability:   "$stabilite" = 1.000"
echo "  portability: "$portabilite" = 1"
echo "  baltikGIT:   "$baltik_ok" = "$total_baltik
cd $TRUST_ROOT
if [ $criteres_remplis != $total_criteres ] && [ $criteres_remplis -ge $min_criteres ] && [ $stabilite = "1.000" ] && [ $portabilite = 1 ] && [ $baltik_ok -ge $total_baltik ]
then
   echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
   echo -e "=> release OK\c"
   [ "`date '+%u'`" -gt 5 ] && accord_beta=1 # week-end
   [ "`date '+%u'`" = 1 ] && [ "`date '+%H'`" -lt 8 ] && accord_beta=1 # lundi matin
   [ -f ~/force_version_beta ] && accord_beta=1 && rm -f ~/force_version_beta
   [ -f ~/no_version_beta ] && accord_beta=0 #&& rm -f ~/no_version_beta
   if [ $accord_admin = 1 ] || [ $accord_beta = 1 ]
   then
      # On decide du nom du label specifique
      label_rc=$label"_rc" && release=candidate && [ $accord_admin = 0 ] && label_rc=$label"_beta" && release=beta
      numero=`git tag | grep $label_rc | wc -l` && [ "$numero" = "" ] && numero=0
      let numero=$numero+1
      label_pose=$label_rc$numero 
      echo " with label "$label_pose
      echo " "
      error_rc=0
      
      # Commit
      echo "  Call git commit --all -m Commit for a Release $release $label_pose version"
      git commit --all -m"Commit for a Release $release $label_pose version."
      # On pose le tag:
      echo "  Call git tag $label_pose"
      git tag $label_pose
      error_rc=$?
      # Push
      echo "  Call git push origin TMA"
      git_push -tags
      if [ $error_rc = 0 ]
      then  
         # On previent l'administrateur et le project leader
         cat $TRUST_ROOT/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] TRUST Release version - Tag a $release version: $label_pose \(See origin/triou/TMA branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER $TRUST_PROJECT_LEADER
      else
         echo "" | mail_ -s\"[lance_test_nuit] TRUST - Tag a $release version: $label_pose KO\" $TRUST_MAIL
      fi
      # On pose le meme tag sur externalpackages
      echo "  Update externalpackages:"
      cd $TRUST_ROOT/externalpackages
      echo "    Call git commit --all -m Commit for a Release $release $label_pose version"
      git commit --all -m"Commit for a Release $release $label_pose version."
      echo "    Call git tag $label_pose"
      git tag $label_pose
      error_rc=$?
      echo "    Call git push origin TMA"
      git push --tags origin Livraison:triou/TMA
      if [ $error_rc = 0 ]
      then  
         # On previent l'administrateur et le project leader
         cat $TRUST_ROOT/externalpackages/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] externalpackages Release version - Tag a $release version: $label_pose \(See origin/triou/TMA branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER
      else
         echo "" | mail_ -s\"[lance_test_nuit] externalpackages - Tag a $release version: $label_pose KO\" $TRUST_MAIL
      fi
      cd - 1>/dev/null 2>&1
      echo " "
      echo "Release of the $release version: $label_pose"
      echo "New version $label_pose : Not delivery" >> $MESSAGES_NUIT
      
      # On pose le meme tag sur les BALTIK
      for Composant in $ComposantsGit 
      do
         echo " "
         echo "  Update $Composant BALTIK:"
         cd $WORKDIR/tuleap/Livraison/Composants/$Composant
         error_rcb=0
         echo "    Call git commit --all -m Commit for a Release $release $label_pose version"
         git commit --all -m"Commit for a Release $release $label_pose version."
         echo "    Call git tag $label_pose"
         git tag $label_pose
         error_rcb=$?
         echo "    Call git push origin TMA"
         if [ $Composant != "flica5" ]
         then
            git push --tags origin Livraison:triou/TMA
         else
            git push origin Livraison:triou/TMA
         fi
         error_rcb=$?
         if [ $error_rcb = 0 ]
         then  
            # On previent l'administrateur et les project leader
	    BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
            cat $WORKDIR/tuleap/Livraison/Composants/$Composant/share/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] $Composant Release version - Tag a $release version: $label_pose \(See origin/triou/TMA branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER ${!BALTIK_PROJECT_LEADER}
         else
            echo "" | mail_ -s\"[lance_test_nuit] $Composant - Tag a $release version: $label_pose KO\" $TRUST_MAIL
         fi
      done
      cd $TRUST_ROOT
   else
      echo " without label"
   fi
else
   if [ $criteres_remplis != $total_criteres ]
   then
     echo "=> release KO"
     if [ $accord_admin = 1 ]
     then
        echo "New version $label : Not delivery because only $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
     else
        echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
     fi
   fi
fi

#############################################################
# Si tous les criteres sont remplis, on tamponne la version !
#############################################################
export livraison=0
if [ $criteres_remplis = $total_criteres ]
then
   echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
   echo -e "=> release OK\c"
   if [ $accord_admin = 0 ]
   then
      [ $deja_livre = 0 ] && echo "New version $label : Delivery possible if agreement of $TRUST_MAIL" >> $MESSAGES_NUIT
      [ $deja_livre = 1 ] && echo "New version $label : Delivery already made" >> $MESSAGES_NUIT
   else
      # On decide du nom du label specifique
      label_rc=$label"_rc" && release=candidate && [ $accord_admin = 0 ] && label_rc=$label"_beta" && release=beta
      numero=`git tag | grep $label_rc | wc -l` && [ "$numero" = "" ] && numero=0
      let numero=$numero+1
      label_pose=$label_rc$numero 
      # Le tag label est pose par Gauthier sur origin sinon conflit
      echo " with label "$label
      echo " "
      # Checkin et verification que tous les fichiers sont checkines
      erreur_checkin=""
      # Track again all files which were --assume-unchanged before:
      cd $TRUST_ROOT
      #Couverture de code genere sur l ensemble des baltiks et pas que sur TRUST donc on n ecrase pas...
      echo "  Call git update-index --no-assume-unchanged"
      for unchanged in `git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'`
      do
         git update-index --no-assume-unchanged $unchanged
      done
      # Commit & Push
      echo "  Call git commit --all -m Commit for an official Release $label version."
      git commit --all -m"Commit for an official Release $label version."
      echo "  Call git tag $label_pose"
      git tag $label_pose
      git_push -tags
      if [ "$erreur_checkin" != "" ]
      then
         echo "New version $label : Delivery canceled because some files could not be checkined: $erreur_checkin" >> $MESSAGES_NUIT
      else
	 echo "New version $label : Delivery in progress..." >> $MESSAGES_NUIT
	 livraison=1
	 accord_beta=0
	 echo "  Call git tag $label at "`date`
         git tag $label
         echo "  Call git push origin TMA"
         git push --tags origin Livraison:triou/TMA
         echo "  Call git push origin master"
         git push --tags origin Livraison:master
	 # On pose le meme tag sur externalpackages
         cd externalpackages
         git commit --all -m"Commit for an official Release $label version."
         git tag $label_pose
         git push --tags origin Livraison:triou/TMA
         git tag $label
         git push --tags origin Livraison:master
	 git fetch --all
         cd - 1>/dev/null 2>&1
	 # Creation des packages TRUST et externalpackages
	 echo " "
	 echo "  Creation of the packages of TRUST and externalpackages"
         echo "!!! See ARCHIVES_TRUST (Warning externalpackages) and ARCHIVES_triocfd !!!" | mail_ -s\"[lance_test_nuit] WARNING! TRUST v$new released: Ensure that packages for ftp website and github are correct...\" $TRUST_MAIL
         mise_a_jour_TRUST_tar
         GRAVAGE=$WORKDIR/archives/ARCHIVES_TRUST
         version_arch=TRUST-$new".tar.gz"
         mv $TRUST_ROOT/$version_arch $GRAVAGE/.
         version_arch=externalpackages-$new".tar"
         mv $TRUST_ROOT/$version_arch $GRAVAGE/.
	 # Changement de la vue Maintenance
	 echo " "
	 echo "Changing the Maintenance view"
         patch_old=patch_`echo $old`
	 patch_new=patch_`echo $new`
	 (
	    cd $WORKDIR/tuleap/Maintenance/TRUST
	    echo "from `pwd`"
	    echo "  Call git fetch --all"
            git fetch --all # Pour recuperer tous les tags
            # Creation de la branche depuis le tag (example: patch_XYZ depuis vX.Y.Z)
	    echo "  Call git checkout -b $patch_new $label"
            git checkout -b $patch_new $label
	    if [ $? = 0 ]
	    then
               # Positionnement de HEAD sur la branche (exemple: patch_XYZ)
               #git symbolic-ref HEAD refs/heads/$patch_new
	       git branch -D Maintenance
	       git branch -m $patch_new Maintenance
	       echo "  Call git symbolic-ref HEAD refs/heads/Maintenance"
               git symbolic-ref HEAD refs/heads/Maintenance
               # Push
	       #echo "  Call git push origin Maintenance"
               #git_push
	       touch $TRUST_ROOT/.RELEASE_NOTES
	    else
	       echo "" | mail_ -s\"[lance_test_nuit] Error for git checkout \-b $patch_new $label in Maintenance view\" $TRUST_MAIL
	    fi
	    # externalpackages
	    echo " "
            echo "Changing the Maintenance/externalpackages view"
	    cd externalpackages
	    git fetch --all
	    git checkout -b $patch_new $label
	    if [ $? = 0 ]
	    then
	       #git symbolic-ref HEAD refs/heads/$patch_new
	       git branch -D Maintenance
	       git branch -m $patch_new Maintenance
	       git symbolic-ref HEAD refs/heads/Maintenance
	    else
	       echo "" | mail_ -s\"[lance_test_nuit] Error for git checkout \-b $patch_new $label in Maintenance/externalpackages view\" $TRUST_MAIL
	    fi
	    cd - 1>/dev/null 2>&1
	 )
	 echo " "
	 echo "Creation of the packages of each Baltik component"
	 # Creation des packages de chaque composant BALTIK
	 cd $WORKDIR/tuleap/Livraison/TRUST
	 source env_TRUST.sh 1>/dev/null 2>&1
	 for Composant in $ComposantsGit 
	 do
	    cd $WORKDIR/tuleap/Livraison/Composants/$Composant
	    echo "from `pwd`"
	    # On pose le meme tag sur les BALTIK
            echo "    Call git commit --all -m Commit for an official Release $label version."
	    if [ "$Composant" = triocfd ]
	    then
	       cp share/doc_auto/TRUST_Generic_Guide.pdf share/doc/TRUST_Generic_Guide.pdf
	       if [ -f "share/doc_auto/TrioCFD_Reference_Manual.pdf" ]
	       then
	          cp share/doc_auto/TrioCFD_Reference_Manual.pdf share/doc/TrioCFD_Reference_Manual.pdf
	       #else
	       #   cp $TRUST_ROOT/doc/TRUST/TRUST_Reference_Manual.pdf share/doc/TRUST_Reference_Manual.pdf
	       fi
	       git checkout -- Multiphase/Front_tracking_discontinu/tests/Reference/Validation/ftd_gravite_jdd1/ftd_gravite_jdd1.data
	       # Update the version in README.md file (displayed on github)
	       sed -i "s/$old/$new/g" README.md
	    fi
            git commit --all -m"Commit for an official Release $label version."
            echo "    Call git tag $label"
	    git tag $label_pose
            if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
            then
               git tag "$label"b
            else
               git tag $label
            fi
            echo "    Call git push origin TMA"
            if [ $Composant != "flica5" ]
            then
               git push --tags origin Livraison:triou/TMA
            else
	       git push origin Livraison:triou/TMA
	       git push origin Livraison:triou/$label
            fi
	    if [ "$Composant" = triocfd ] # || [ "$Composant" = mpcube ]
            then
	       git push --tags origin Livraison:master
            fi
	    git fetch --all
	    # Appel du make distrib
	    echo "    Call make distrib"
	    make distrib_git
	    mkdir -p $WORKDIR/archives/ARCHIVES_$Composant
	    echo "    Copy $Composant.tar.gz to $WORKDIR/archives/ARCHIVES_$Composant/$Composant-$new.tar.gz"
            if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
            then
	       cp -f $Composant.tar.gz $WORKDIR/archives/ARCHIVES_$Composant/$Composant-$new"b.tar.gz"
            else
	       cp -f $Composant.tar.gz $WORKDIR/archives/ARCHIVES_$Composant/$Composant-$new.tar.gz
            fi
	    if [ $Composant = "triocfd" ]
            then
	       # Appel du Create_Light_archive.sh
	       echo "    Call Create_Light_archive.sh"
	       rm -rf Prov
	       ./share/Distribution/Create_light_archive.sh
               if [ $? != 0 ]
               then
                  mail_ -s\"[lance_test_nuit] Error with Create_Light_archive.sh v$new for $Composant\" $TRUST_MAIL
               else
	          cp -f TrioCFD_light.tar.gz $WORKDIR/archives/ARCHIVES_$Composant/$Composant"_light"-$new.tar.gz
               fi
	    fi
	    echo | mail_ -s\"[lance_test_nuit] $Composant v$new is released under $WORKDIR/archives/ARCHIVES_$Composant\" $TRUST_MAIL	 
	    # Changement de la vue Maintenance
            if [ -d $WORKDIR/tuleap/Maintenance/Composants/$Composant ]
            then
	       echo "    Call git symbolic-ref HEAD refs/heads/$patch_new"
	       cd $WORKDIR/tuleap/Livraison/Composants/$Composant
	       echo "from `pwd`"
	       git fetch --all
               if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
               then
	          git checkout -b $patch_new "$label"b
               else
	          git checkout -b $patch_new $label
               fi
	       if [ $? = 0 ]
	       then
	          #git symbolic-ref HEAD refs/heads/$patch_new
	          git branch -D Maintenance
	          git branch -m $patch_new Maintenance
	          git symbolic-ref HEAD refs/heads/Maintenance
	       else
	          echo "" | mail_ -s\"[lance_test_nuit] Error for git checkout \-b $patch_new $label in Maintenance/Composants/$Composant view\" $TRUST_MAIL
	       fi
	       cd - 1>/dev/null 2>&1
	    fi 
	    echo " "
	 done
	 cd $WORKDIR/tuleap/Livraison/TRUST
	 echo "Version $new : ...End" >> $MESSAGES_NUIT
         echo " "
         echo "Creation of the Stable version: $label"
      fi
   fi
fi
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo `date` >> $MESSAGES_NUIT
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
grep -A `echo $(($total_criteres+4))` -B 1 "Release criteria of the" $MESSAGES_NUIT > tmp_NUIT.txt
sed 's/$/ <BR>/g' tmp_NUIT.txt > tmp_NUIT.html
cat tmp_NUIT.html >> $REP_NUIT/NUIT.html
rm -f tmp_NUIT.txt tmp_NUIT.html
echo "<--- End at "`date '+%H:%M:%S %d/%m'`



####################################
# Envoi des binaires et des versions
####################################
echo " "
echo "####################"
echo "# Send to ftp site #"
echo "####################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
for Composant in $Composants
do
   if [ -d $TRUST_ROOT/../Composants/$Composant ]
   then
      cd $TRUST_ROOT/../Composants/$Composant
      mkdir -p build/portability
      mv $Composant*.log build/portability/.
      mv Run.liste debut nuit_$Composant.html build/portability/.
   fi
   if [ -d $WORKDIR/tuleap/Maintenance/Composants/$Composant ]
   then
     cd $WORKDIR/tuleap/Maintenance/Composants/$Composant
     mkdir -p build/portability/Maintenance
     mv $Composant*.log build/portability/Maintenance/.
     mv Run.liste debut nuit_$Composant.html build/portability/Maintenance/.
     cd -
   fi
done
cd $TRUST_ROOT
envoie_ftp_log=$REP_NUIT/envoie_ftp_cea_fr_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/envoie_ftp_cea_fr"
echo "  See $envoie_ftp_log"
echo "TRUST script on $HOST the `date` ...">$envoie_ftp_log
echo>>$envoie_ftp_log
envoie_ftp_cea_fr 1>>$envoie_ftp_log 2>&1
echo>>$envoie_ftp_log
echo "End at `date` ...">>$envoie_ftp_log
grep -i killed $envoie_ftp_log
grep -i Error $envoie_ftp_log
grep KO $envoie_ftp_log
grep local $envoie_ftp_log

#####################################
# Mises a jour diverses de $TRUST_FTP
#####################################
cd $TRUST_TMP
# Update the index.html file of the FTP site:
if [ $livraison = 1 ]
then
   echo " "
   echo "Call to "$TRUST_ROOT"/bin/admin/cree_index.html"
   echo "from `pwd`"
   cree_index.html
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#-------------------------------------------------------
echo " "
echo "###########################"
echo "# Send announcements mail #"
echo "###########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`

################################################################################################
# Le mail des RELEASES NOTES est envoye aux developpeurs tous les lundis ou lors de la livraison
# sinon uniquement a l'admin TRUST et au chef de projet
################################################################################################
if [ "`date '+%u'`" = 1 ] || [ $livraison = 1 ] || [ $accord_beta = 1 ]
then
   ALL_DEVELOPERS_TRUST_MAIL="trio_u_dev@saxifrage.saclay.cea.fr"
   echo " " >> $MESSAGES_NUIT
   echo "TRUST support team: $TRUST_MAIL  Web: http://triocfd.cea.fr" >> $MESSAGES_NUIT
   echo " " >> $MESSAGES_NUIT
   echo "To unsubscribe from this list, send an e-mail to $TRUST_MAIL " >> $MESSAGES_NUIT
else
   ALL_DEVELOPERS_TRUST_MAIL=$TRUST_MAIL" "$TMA_PROJECT_LEADER" "$triocfd_PROJECT_LEADER" "$genepi3_PROJECT_LEADER" "$trust_team_members
fi

#####################################
# Envoi d'un message aux developpeurs
#####################################
cd $TRUST_ROOT
dest=$ALL_DEVELOPERS_TRUST_MAIL
#for dest in $ALL_DEVELOPERS_TRUST_MAIL
#do
   echo "$MESSAGES_NUIT sent to $dest"
   if [ $livraison = 0 ]
   then
      if [ $accord_beta = 0 ]
      then
         mail_ -s \"Release criteria of TRUST $new on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
      else
         mail_ -s \"Tagged release criteria of TRUST $label_pose on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
      fi
   elif [ $livraison = 1 ]
   then
      mail_ -s \"Tagged release criteria of TRUST $label_pose on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
   fi
#done

############################################################################
# Annonce d'une version stable a tout le monde (developpeur et utilisateurs)
############################################################################
if [ $livraison = 1 ]
then
   ALL_USERS_TRUST_MAIL="trio_u_annonces@saxifrage.saclay.cea.fr"
   push_error=1 # Temporary
   [ $push_error = 1 ] && ALL_USERS_TRUST_MAIL=$TRUST_MAIL
   echo "!!! mail not sent to trio_u_annonces !!!" | mail_ -s \"[lance_test_nuit] WARNING! TRUST v$new released: Ensure that git push origin has been done manually...\" $TRUST_MAIL
   for dest in $ALL_USERS_TRUST_MAIL
   do
      echo "Stable release announcement sent to $dest"
      echo "
TRUST is a thermohydraulic software package for CFD simulations.
It was originally designed for incompressible monophasic flows, but an
increasing effort is made towards simulating real compressible multiphasic flows.
This software is OpenSource (BSD license).

-------------------------------------------------
New TRUST version released v$new is now available
-------------------------------------------------
on GitHub: https://github.com/cea-trust-platform/trust-code

-----------------
Table of contents
-----------------
1. How to install?
2. How to run preinstalled version?
3. TRUST Release notes
4. TRUST Developer notes
5. externalpackages Release notes
6. Version tested on several OS
7. Version portability with several compilers

TRUST support team: $TRUST_MAIL
Website: http://triocfd.cea.fr

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
      echo "
---------------------------------------------------------------------------------------------
1. How to install?
---------------------------------------------------------------------------------------------
# First method:
git clone https://github.com/cea-trust-platform/trust-code.git TRUST-$new
cd TRUST-$new
wget ftp://ftp.cea.fr/pub/TRUST/externalpackages/externalpackages-$new.tar
tar xf externalpackages-$new.tar
./configure -help # To see the possible configure options. On various OS, we configure TRUST with OPTIONS -force_provided_mpich (DO NOT use it on HPC clusters)
./configure \$OPTIONS # where \$OPTIONS is the list of selected options.
make

# Second method:
wget ftp://ftp.cea.fr/pub/TRUST/TRUST/Version$new/TRUST-$new.tar.gz
tar xzf TRUST-$new.tar.gz
cd TRUST-$new
./configure -help # To see the possible configure options. On various OS, we configure TRUST with OPTIONS -force_provided_mpich (DO NOT use it on HPC clusters)
./configure \$OPTIONS # where \$OPTIONS is the list of selected options.
make

Warning: Check carefully the MPI version you want to use for parallel computing before installing the code, especially onto a HPC cluster.
The command mpicxx should be found into the bin directory of the MPI version you plan to use, to check that, run:
type mpicxx
---------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "
----------------------------------------------------------------------------------------------------
2. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for CEA Saclay (PC Titania file system or orcus cluster):
source /home/trust_trio-public/env_TRUST-$new.sh

# for CEA Saclay (PC Thalie file system):
source /home/triou/env_TRUST_$new.sh

# for TOPAZE and IRENE (Skylake & AMD Rome) supercomputers (64-bit integers version):
source /ccc/cont002/home/den/triou/env_TRUST-$new-int64.sh

# for TOPAZE and IRENE (AMD Rome) supercomputers (GPU version):
source /ccc/cont002/home/den/triou/env_TRUST-$new-gpu.sh

# for IDRIS (jean-zay) supercomputer (64-bit integers version):
source /gpfswork/rech/fej/ugz82dj/env_TRUST-$new-int64.sh

# for IDRIS (jean-zay) supercomputer (GPU version):
source /gpfswork/rech/fej/ugz82dj/env_TRUST-$new-gpu.sh

# for CINES (occigen) supercomputer (64-bit integers version):
source /panfs/panasas/softs/applications/trio_u/TRUST/env_TRUST-$new-int64.sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
3. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/RELEASE_NOTES ] && echo $ECHO_OPTS "TRUST \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/RELEASE_NOTES >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
-------------------------------------------------------------
4. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/DEVELOPER_NOTES ] && echo $ECHO_OPTS "TRUST \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Developer notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/DEVELOPER_NOTES >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
5. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/externalpackages/RELEASE_NOTES ] && echo $ECHO_OPTS "externalpackages \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/externalpackages/RELEASE_NOTES >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "6. Version tested on several OS" >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      sed 's/<BR><LI>/ /g'  $REP_NUIT/os >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "7. Version portability with several compilers" >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      sed 's/<BR><LI>/ /g'  $REP_NUIT/CC >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      mail_ -s \"New TRUST v$new released\" $dest < $MESSAGES_LIVRAISON
      sleep 5
      mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_TRUST
   done
   for Composant in $ComposantsGit
   do
      if [ "$Composant" == triocfd ]
      then
         echo "
TrioCFD (previously named \"Trio_U\") is the Computational Fluid Dynamics (CFD) code 
based on the TRUST platform (\"TRUST\" with Front-Tracking, Radiation, ALE for fluid-structure interactions and Turbulence LES & RANS models).
This software is OpenSource (BSD license).

-----------------------------------
New TrioCFD version released v$new
-----------------------------------
is now available on Github: https://github.com/cea-trust-platform/TrioCFD-code

-----------------
Table of contents
-----------------
1. How to install?
2. How to run preinstalled version?
3. $Composant Release notes

TRUST/TrioCFD support team: $TRUST_MAIL
Website: http://triocfd.cea.fr

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
      echo "
---------------------------------------------------------------------------------------------
1. How to install?
---------------------------------------------------------------------------------------------
If TRUST-$new is not already installed, install it either with:
     $> git clone https://github.com/cea-trust-platform/trust-code.git TRUST-$new
     $> cd TRUST-$new
     $> wget ftp://ftp.cea.fr/pub/TRUST/externalpackages/externalpackages-$new.tar
     $> tar xf externalpackages-$new.tar
     $> ./configure \$OPTIONS
     $> make
or:
     $> wget ftp://ftp.cea.fr/pub/TRUST/TRUST/Version$new/TRUST-$new.tar.gz
     $> tar xzf TRUST-$new.tar.gz
     $> cd TRUST-$new
     $> ./configure \$OPTIONS
     $> make

Then, install TrioCFD-$new using one of these methods:
   # First method:
     $> git clone https://github.com/cea-trust-platform/TrioCFD-code.git TrioCFD-$new
     $> cd TrioCFD-$new
     $> source PathToTRUST-$new/env_TRUST.sh
     $> baltik_build_configure -execute
     $> make optim debug

   # Second method:
     $> wget ftp://ftp.cea.fr/pub/TRUST/TrioCFD/versions/v$new/TrioCFD-$new.tar.gz
     $> tar xzf TrioCFD-$new.tar.gz
     $> mv TrioCFD TrioCFD-$new
     $> cd TrioCFD-$new
     $> source PathToTRUST-$new/env_TRUST.sh
     $> baltik_build_configure -execute
     $> make optim debug
     
---------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "
----------------------------------------------------------------------------------------------------
2. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for CEA Saclay (PC Titania file system or orcus cluster):
source /home/trust_trio-public/env_TrioCFD-$new.sh

# for CEA Saclay (PC Thalie file system):
source /home/triou/env_TrioCFD_$new.sh

# for TOPAZE and IRENE (Skylake & AMD Rome) supercomputers (64-bit integers version):
source /ccc/cont002/home/den/triou/env_TrioCFD-$new-int64.sh

# for TOPAZE and IRENE (AMD Rome) supercomputers (GPU version):
source /ccc/cont002/home/den/triou/env_TrioCFD-$new-gpu.sh

# for IDRIS (jean-zay) supercomputer (64-bit integers version):
source /gpfswork/rech/fej/ugz82dj/env_TrioCFD-$new-int64.sh

# for IDRIS (jean-zay) supercomputer (GPU version):
source /gpfswork/rech/fej/ugz82dj/env_TrioCFD-$new-gpu.sh

# for CINES (occigen) supercomputer (64-bit integers version):
source /panfs/panasas/softs/applications/trio_u/TrioCFD/env_TrioCFD-$new.sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
3. \c" >> $MESSAGES_LIVRAISON
         [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && echo $ECHO_OPTS "$Composant \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES >> $MESSAGES_LIVRAISON
         echo " " >> $MESSAGES_LIVRAISON
         mail_ -s \"New TrioCFD v$new released\" $TRUST_MAIL < $MESSAGES_LIVRAISON
         sleep 5
         mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_$Composant
      elif [ "$Composant" == triomc ]
      then
#         echo "
#TrioMC is a subchannel code dedicated to the study of SFR subassemblies
#at the complete core scale. Through the MATHYS code, TrioMC can be coupled:
#- with the TrioCFD code to model the coupling between the core and the inter-wrapper region;
#- with the CATHARE code to model the local core behavior during reactor transients.
#TrioMC is based on the TRUST platform.
#
#-----------------------------------
#New TrioMC version released v"$new"b
#-----------------------------------
#1. How to run preinstalled version?
#2. $Composant Release notes
#
#TRUST/TrioMC support team: $TRUST_MAIL  Web: http://triocfd.cea.fr
#MATHYS support team: mathys@cea.fr
#
#To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
         echo "
TrioMC is a subchannel code dedicated to the study of SFR subassemblies
at the complete core scale. Through the MATHYS code, TrioMC can be coupled:
- with the TrioCFD code to model the coupling between the core and the inter-wrapper region;
- with the CATHARE code to model the local core behavior during reactor transients.
TrioMC is based on the TRUST platform.

-----------------------------------
New TrioMC version released v"$new"
-----------------------------------
1. How to run preinstalled version?
2. $Composant Release notes

TRUST/TrioMC support team: $TRUST_MAIL  Web: http://triocfd.cea.fr
MATHYS support team: mathys@cea.fr

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
# echo "
#----------------------------------------------------------------------------------------------------
#1. How to run preinstalled version?
#----------------------------------------------------------------------------------------------------
## for PC connected to CEA SESI network:
#source /soft/der/sesi/TrioMC2/env_TrioMC2-"$new"b.sh
#
## for CEA Cadarache cluster (mezel):
#source /soft/mezel/TRIO/env_TrioMC2-"$new"b.sh
#
## for CEA Saclay cluster (callisto):
#source /home/triou/env_TrioMC2_"$new"b.sh
#----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
 echo "
----------------------------------------------------------------------------------------------------
1. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for PC connected to CEA SESI network:
source /soft/der/sesi/TrioMC2/env_TrioMC2-"$new".sh

# for CEA Saclay cluster (callisto):
source /home/triou/env_TrioMC2_"$new".sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
2. \c" >> $MESSAGES_LIVRAISON
         [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && echo $ECHO_OPTS "$Composant \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES >> $MESSAGES_LIVRAISON
         echo " " >> $MESSAGES_LIVRAISON
         #mail_ -s \"New TrioMC v"$new"b released\" $TRUST_MAIL < $MESSAGES_LIVRAISON
         mail_ -s \"New TrioMC v"$new" released\" $TRUST_MAIL < $MESSAGES_LIVRAISON
         sleep 5
         mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_$Composant
      fi
   done
   ########################################################
   # On change les NOTES en augmentant le numero de version
   # car sinon on risque des ennuis le lendemain (Version1.5.3.tar+cle effaces dans ARCHIVES_TRUST)
   echo " "
   echo "Call CHECKOUT $TRUST_ROOT/RELEASE_NOTES $TRUST_ROOT/DEVELOPER_NOTES"
   CHECKOUT $TRUST_ROOT/RELEASE_NOTES $TRUST_ROOT/DEVELOPER_NOTES
   next_new=`echo $new | $TRUST_Awk -F"." '{if (NF==3) print $1"."$2"."$3+1"_beta";else if (NF==2) print $1"."$2".1_beta"}'`
   echo "--------------------------------------------------------------------------------------------------
Release notes version $next_new : Enhancements, modifications and corrected bugs since version $new :
--------------------------------------------------------------------------------------------------" > $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_ROOT/RELEASE_NOTES >> $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_TMP/RELEASE_NOTES > $TRUST_ROOT/RELEASE_NOTES
   echo "-------------------------------------------------------------
Developer notes version $next_new : Changes since version $new :
-------------------------------------------------------------" > $TRUST_TMP/DEVELOPER_NOTES
   cat $TRUST_ROOT/DEVELOPER_NOTES >> $TRUST_TMP/DEVELOPER_NOTES
   cat $TRUST_TMP/DEVELOPER_NOTES > $TRUST_ROOT/DEVELOPER_NOTES  
   cd $TRUST_ROOT/externalpackages
   echo "--------------------------------------------------------------------------------------------------
Release notes version $next_new : Enhancements, modifications and corrected bugs since version $new :
--------------------------------------------------------------------------------------------------" > $TRUST_TMP/RELEASE_NOTES
   cat RELEASE_NOTES >> $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_TMP/RELEASE_NOTES > RELEASE_NOTES
   cd - 1>/dev/null 2>&1
   for Composant in $ComposantsOfficial
   do
      cd $WORKDIR/tuleap/Livraison/Composants/$Composant
      echo "--------------------------------------------------------------------------------------------------
Release notes version $next_new : Enhancements, modifications and corrected bugs since version $new :
--------------------------------------------------------------------------------------------------" > RELEASE_NOTES
      cat share/RELEASE_NOTES >> RELEASE_NOTES
      cat RELEASE_NOTES > share/RELEASE_NOTES
      rm RELEASE_NOTES
      cd - 1>/dev/null 2>&1
   done
   # Commit immediately to differenciate master and patch branchs for setting the correct default branch after git clone
   # See http://git.661346.n2.nabble.com/git-clone-not-getting-the-correct-default-branch-td7476876.html
   echo " "
   #echo "Call git commit --all"
   #git commit --all -m"First automatic commit"
   cd $TRUST_ROOT
   ################################################
   # Installation a distance sur plusieurs machines
   ################################################
   echo " "
   echo "Call to "$TRUST_ROOT"/bin/admin/Installer_TRUST.ssh on:"
   liste_machines updated
   for machine in `liste_machines updated`
   do
      (
       install_stable_log=$REP_NUIT"/install_stable_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
       echo "-> Start of Installer_TRUST.ssh $machine $new -compile..."
       echo "  See $install_stable_log"
      )
   done
   for machine in `liste_machines updated`
   do
      (
      install_stable_log=$REP_NUIT"/install_stable_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
      echo "TRUST script on $HOST the `date` ...">$install_stable_log
      echo>>$install_stable_log
      $TRUST_ROOT/bin/admin/Installer_TRUST.ssh $machine $new -compile 1>>$install_stable_log 2>&1
      if [ $? != 0 ] || [ "`grep :error $install_stable_log | grep -iv warning | grep -v TRIOXDATA | grep -v Gmsh`" != "" ]
      then
         cat $install_stable_log | mail_ -s \"[lance_test_nuit] Failed to install stable version on $machine\" $TRUST_MAIL
      fi
      ) &
   done
   #wait
   echo " "
fi
echo `echo ~`"/CR sent to $TRUST_MAIL"
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "****************************************************"
echo "End of the `basename $0` script at `date '+%H:%M:%S'`."
echo `date`
echo "****************************************************"

mail_ -s\"[lance_test_nuit] Night report of TRUST ATELIER  on `date '+%d/%m/%y'`\" $TRUST_MAIL < ~/CR
# On deplace le CR
mv -f ~/CR $REP_NUIT/CR
cp -f $REP_NUIT/CR $REP_HIST/CR.$DATE

# On copie sur ftp NUIT
. connect_ftp 1>/dev/null 2>&1
cp_ftp $REP_NUIT/CR $SECRET/NUIT/.
cp_ftp $MESSAGES_NUIT $SECRET/NUIT/.

# On sauvegarde l'historique de la nuit
cd $REP_NUIT
git rm .nfs*
git add --all
git commit -m"Commit $DATE"
cd $TRUST_ROOT
