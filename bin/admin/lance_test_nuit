#!/bin/bash
check_components()
{
   for Composant in $Composants
   do
      if [ $* = tuleap/Maintenance ] && [[ "$ComposantsBeta" != *"$Composant"* ]]
      then
         [ -d $TRUST_ROOT/../Composants/$Composant ] && echo "  No check $Composant Component with $TRUST_VERSION version"
      else
      if [ ! -d $TRUST_ROOT/../Composants/$Composant ] && [ $* != tuleap/Kernel ]
      then
         # Create a link for some components
         cd $TRUST_ROOT/../Composants
         if [ -d ../TRUST/bin/baltik/templates/$Composant ] # baltik Test_Baltik ou basic
         then
            ln -sf ../TRUST/bin/baltik/templates/$Composant .
         fi
         if [ -d ../TRUST/doc/TRUST/exercices/$Composant ]   # baltik equation_convection_diffusion
         then
            ln -sf ../TRUST/doc/TRUST/exercices/$Composant .
         fi
         if [ -d ../TRUST/Outils/$Composant/$Composant_src ] # baltik ICoCo
         then
            ln -sf ../TRUST/Outils/$Composant/$Composant"_src" $Composant
         fi
         cd - 1>/dev/null 2>&1
      fi
      if [ -d $TRUST_ROOT/../Composants/$Composant ]
      then
         cd $TRUST_ROOT/../Composants/$Composant
         if [[ "$Composant" == "module3D" ]]
         then
           # module3D is a symlink, we use cd -P to go to the directory and remove C3_LIB.tar.gz to regenerate it
           echo "Cleaning archives/C3_LIB.tar.gz, archives/diff_prog_test, local and build_C3_LIB from $Composant"
           cd -P $TRUST_ROOT/../Composants/$Composant
           rm -f archives/C3_LIB.tar.gz archives/diff_prog_test
           rm -rf local build_C3_LIB
         fi
         rm -rf build/portability
         rm -f $Composant*.log
         Composant_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}".log"
         Gui_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}"_gui.log"
         Doc_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}"_doxygen.log"
         Modularity_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}"_modularity.log"
         BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
         echo "  Check `pwd`"
         echo "    See $Composant_log"
         (
            echo "TRUST script on $HOST the `date` ..."
            echo " "
            echo "Check $Composant Component for $TRUST_VERSION version"
            echo " "
            echo "******************************************************"
            echo " "
            [ $TRUST_ROOT = $TRUST_ROOT_MASTER ] && export MAKEATELIER_SEVERITY=1
            COMPOSANT_OK=0
            # First pass, reconfigure to clean properly (in the case where the TRUST_ROOT has changed):
            #[ "$Composant" != ICoCo ] && source env_$Composant.sh && make dist_clean
            #[ "$Composant" == ICoCo ] && source env_MED$Composant.sh && make dist_clean
            make dist_clean
            make_option="make check_all_optim"
            if [ "$Composant" = basic ]
            then
               make_option="make check_trust_optim"
            #elif [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
            #then
            ##   make_option=""
            #   make_option="make check_optim"
            ##   make_option="make check_all_optim"
            elif [ $* = tuleap/Kernel ]
            then
               make_option="make check_all_optim check_trust_optim"
            fi
            if [ "$Composant" = flica5 ]
            then
               make_option="make check_optim"
            fi
            if [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
            then
               # Test debug tous les jours sur Template, Tuto, ICoCo, TrioMC, MPCube, Genepi3 et Flica5
               if [ "$Composant" != Test_Baltik ] && [ "$Composant" != triocfd ] && [ "$Composant" != mathys ] && [ "$Composant" != flica5 ] && [ "$Composant" != pemfc ] &&  [ "$Composant" = sympy_to_TRUST ]
               then
                  make_option="make check_all_optim check_all_debug"
               elif [ "$Composant" = flica5 ]
               then
                  make_option="make check_optim check_debug"
               elif [ "$Composant" = pemfc ] || [ "$Composant" = sympy_to_TRUST ]
               then
                  make_option="make check_all_optim"
               fi
            fi
            $TRUST_ROOT/bin/baltik/bin/baltik_build_configure -execute &&
            make optim module_optim debug module_debug &&
            $make_option && echo "$Composant OK" && COMPOSANT_OK=1
            MODIF_TRUST_OK=1
            if [ -d share/kernel_official_sources ]
            then
               echo " "
               echo "Call to "$TRUST_ROOT"/bin/baltik/share/baltik/bin/baltik_check_TRUST_modif"
               if  [[ "$ComposantsGit" = *"$Composant"* ]] # Test si Composant est dans la liste des Composants GIT
               then
                  $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_TRUST_modif 1>tmp.log 2>&1
                  if [ $? != 0 ]
                  then
                     echo "Baltik pas a jour"
                     cat tmp.log
                     cat tmp.log | mail_ -s\"[lance_test_nuit] baltik_check_TRUST_modif KO for $Composant\" ${!BALTIK_PROJECT_LEADER} $TRUST_MAIL
                     echo "  KO"
                     MODIF_TRUST_OK=0
                  else
                     echo "  OK"
                  fi
                  rm tmp.log 1>/dev/null 2>&1
               fi
            fi
            #[ $MODIF_TRUST_OK = 0 ] && COMPOSANT_OK=0
            # Verification independance des sous BALTIKs de TrioCFD n'est plus necessaire suite a la fusion des sous-baltiks de triocfd
            DOC_PDF_OK=0
            if [ $* != tuleap/Kernel ]
            then
               echo " "
               # Pas de check_gui sur baltiks sans XD
               make gui 1>$Gui_log 2>&1 && echo $Composant"_Reference_Manual.pdf OK" && DOC_PDF_OK=1
               grep "Error" $Gui_log
               [ "`grep "Error" $Gui_log`" != "" ] && DOC_PDF_OK=0 && echo DOC_PDF_OK=0
               if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
               then
                  if [ "$Composant" != Test_Baltik ] && [ "$Composant" != "flica5" ] && [ "$Composant" != "mpcube" ] && [ "$Composant" != "TRUST_NK" ] && [ "$Composant" != "sides" ] && [ "$Composant" != "scorpio" ] && [ "$Composant" != "sympy_to_TRUST" ] && [ "$Composant" != "pemfc" ]
                  then
                     ([ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])) && make check_gui 1>>$Gui_log 2>&1 &
                  fi
                  make doxygen 1>$Doc_log 2>&1
               fi
            fi
            echo " "
            echo "******************************************************"
            echo " "
            echo $ECHO_OPTS "Component $Composant checked on $HOST with $TRUST_VERSION ...\c"
            if [ $COMPOSANT_OK = 0 ]
            then
               echo $ECHO_OPTS "KO."
               cat $Composant_log | mail_ -s\"[lance_test_nuit] check_components $Composant $TRUST_VERSION KO\" $TRUST_MAIL
            else
               echo $ECHO_OPTS "OK"
            fi
            if [ $* != tuleap/Kernel ]
            then
               echo $ECHO_OPTS "Reference Manual $Composant built on $HOST with $TRUST_VERSION ...\c"
               if [ $DOC_PDF_OK = 0 ]
               then
                  echo $ECHO_OPTS "KO."
                  cat $Gui_log | mail_ -s\"[lance_test_nuit] reference manual $Composant $TRUST_VERSION KO\" ${!BALTIK_PROJECT_LEADER} $TMA_PROJECT_LEADER $TRUST_MAIL
               else
                  echo $ECHO_OPTS "OK"
               fi
            fi
            echo " "
            echo "TRUST script on $HOST the `date` ..."
            echo " "
            rm -f Run.liste
            rm -f nuit_$Composant.html
            rm -f $Composant_%_*.log
            # On teste la portabilite uniquement si tout a fonctionne en local (pour eviter de bloquer d'autres PCs)
            #if [ $COMPOSANT_OK = 1 ] && [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
            #if [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
            if [ $TRUST_ROOT = $TRUST_ROOT_MASTER ] || [ $* = tuleap/Maintenance ] # Test a revoir !!!!
            then
               echo "Portability $Composant Component for $TRUST_VERSION version"
               echo " "
               echo "******************************************************"
               echo " "
               echo "  See `pwd`/Run.liste"
               # Machines en mode debug
               debug_machines=`liste_machines "\-g "` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               # Machines en mode semi_opt
               semi_opt_machines=`liste_machines "\-semi_opt"`
               # Machines en mode gcov
               gcov_machines="" && [ $* = tuleap/Maintenance ] && gcov_machines=`liste_machines "\-gcov"`
               # Machines en mode prof
               prof_machines="" && [ $* = tuleap/Maintenance ] && prof_machines=`liste_machines "\-prof"`
               # Machines en mode valgrind
               valgrind_machines=`liste_machines "\-check-valgrind"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               valgrind_machines=$valgrind_machines" "`liste_machines "\-ctest_valgrind"`
               # Machines en mode gui
               gui_machines=`liste_machines "\-gui"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               # Machines en mode check trust
               trust_machines=`liste_machines "\-platform"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               # Clusters
               updated_machines=`liste_machines limited ` #| awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               # Test compilation
               unruned_machines=`liste_machines "\-without_run"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               # Machines cible pour la sortie de version
               cible_machines=`liste_machines cible` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               cible_machines=$cible_machines" "`liste_machines get_binary` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               # Toutes les machines
               all_machines=`liste_machines`
               # Machines en test build64
               #build64_machines=`liste_machines "\-build64"` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               # Machines titania
               titania_machines=`liste_machines titania`
               # Machines sur lesquelles on ne garde pas la compilation des baltiks
               non_machines=`liste_machines non` # | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
               # Liste des machines a tester selon le baltik en question
               if [ "$Composant" = Test_Baltik ] || [ "$Composant" = basic ]
               then
                  machines=`liste_machines "\-TRUST"`
               elif [ "$Composant" = ICoCo ]
               then
                  # Machines en mode sequentiel
                  wompi_machines=`liste_machines "\-disable-mpi"`
                  wompi_machines=$wompi_machines" `liste_machines "\-disable-optionals"`"
                  wompi_machines=$wompi_machines" `liste_machines "\-disable "`"
                  wompi_machines=$wompi_machines" `liste_machines "\-openmp "`"
                  # Machines en mode parallele
                  machines=""
                  for machine in $all_machines
                  do
                     [[ "$wompi_machines" != *"$machine"* ]] && machines=$machines" $machine"
                  done
               elif [ "$Composant" = TrioCFD ] || [ "$Composant" = triocfd ]
               then
                  machines=`liste_machines "\-TrioCFD"`
               elif [ "$Composant" = ModeleCoeur ] || [ "$Composant" = triomc ]
               then
                  machines=`liste_machines "\-TrioMC"`
               elif [ "$Composant" = mathys ]
               then
                  machines=`liste_machines "\-MATHYS"`
               elif [ "$Composant" = module3D ]
               then
                  machines=`liste_machines "\-C3D"`
               elif [ "$Composant" = TRUST_NK ]
               then
                  machines=`liste_machines "\-TRUST_NK"`
               elif [ "$Composant" = sides ]
               then
                  machines=`liste_machines "\-SIDES"`
               elif [ "$Composant" = scorpio ]
               then
                  machines=`liste_machines "\-SCORPIO"`
               elif [ "$Composant" = pemfc ]
               then
                  machines=`liste_machines "\-PEMFC"`
               elif [ "$Composant" = sympy_to_TRUST ]
               then
                  machines=`liste_machines "\-STT"`
               elif [ "$Composant" = MPCube ] || [ "$Composant" = mpcube ]
               then
                  machines=`liste_machines "\-MPCube"`
               elif [ "$Composant" = Genepi3 ] || [ "$Composant" = genepi3 ]
               then
                  machines=`liste_machines "\-GENEPI3"`
               elif [ "$Composant" = pxp ]
               then
                  machines=`liste_machines "\-PAREX+"`
               elif [ "$Composant" = CoreComponent ] || [ "$Composant" = flica5 ]
               then
                  machines=`liste_machines "\-FLICA5"`
               else
                  machines=$all_machines
               fi
               for adr in $machines
               do
                  machine=`echo $adr` # | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`
                 # if [[ "$build64_machines" != *"$machine"* ]] # Test si machine n est pas dans la liste des machines build64 (test actuel uniquement sur TRUST)
                 # then
                     liste_options="--with-efface-dir-before"
                     if [[ "$liste_machines_KO" != *"$machine"* ]] # Test si machine n est pas dans la liste des machines KO
                     then
                        if [[ "$valgrind_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines valgrind
                        then
                           valgrind_option="--with-valgrind"
                           #if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
                           #then
                           #   valgrind_option=""
                           ## Test en valgrind seulement le vendredi car ne passe pas en une nuit sauf tous les jours sur Template, Tuto, ICoCo, PolyMAC, MPCube et Flica5
                           #elif [ "$Composant" = Test_Baltik ] || [ "$Composant" = triocfd ] || [ "$Composant" = triomc ] || [ "$Composant" = mathys ] || [ "$Composant" = genepi3 ]
                           if [ "$Composant" = Test_Baltik ] || [ "$Composant" = triocfd ] || [ "$Composant" = triomc ] || [ "$Composant" = mathys ] || [ "$Composant" = genepi3 ]
                           then
                              if [ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])
                              then
                                 valgrind_option="--with-valgrind"
                              else
                                 valgrind_option=""
                              fi
                           fi
                        else
                           valgrind_option=""
                        fi
                        if [[ "$gui_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines gui
                        then
                           mode_option="--with-mode=gui"
                        elif [[ "$semi_opt_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines semi_opt
                        then
                           mode_option="--with-mode=semi_optim"
                        elif [[ "$gcov_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines gcov
                        then
                           mode_option="--with-mode=gcov"
                        elif [[ "$prof_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines prof
                        then
                           mode_option="--with-mode=prof"
                        elif [[ "$debug_machines" = *"$adr"* ]] # Test si machine est dans la liste des machines debug
                        then
                           mode_option="--with-mode=debug"
                           # pas de valgrind en mode debug
                           if [[ "$valgrind_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines valgrind
                           then
                              mode_option="--with-mode=optim"
                           else
                              mode_option="--with-mode=debug"
                           fi
                           # Test en debug seulement le vendredi car ne passe pas en une nuit
                           if [ "$Composant" = triocfd ]
                           then
                              if [ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])
                              then
                                 mode_option="--with-mode=debug"
                              else
                                 mode_option="--with-mode=optim"
                              fi
                           fi
                        else
                           mode_option="--with-mode=optim"
                           if [[ "$valgrind_machines" = *"$machine"* ]]
                           then
                              # passage des tests en mode valgrind debug sur F5
                              [ "$Composant" = flica5 ] && mode_option="--with-mode=debug"
                           fi
                        fi
                        if [[ "$gui_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines gui
                        then
                           if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
                           then
                              check_option="--without-run"
                           else
                              check_option=""
                           fi
                        else
                           check_option="--check-all"
                           [ "$Composant" = TRUST_NK ] && check_option=""
                           if [[ "$updated_machines" = *"$machine"* ]] # Test si machine est dans la liste des machines updated
                           then
                              if [ "`date '+%u'`" -gt 5 ] || ([ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 17 ])
                              then
                                 check_option=$check_option
                              else
                                 check_option="--without-run"
                              fi
                              liste_options="--with-efface-dir-before"
                           fi
                           #if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
                           #then
                           ##   check_option="--without-run"
                           #   check_option=""
                           ##   check_option="--check-all"
                           #fi
                           [[ "$trust_machines" = *"$machine"* ]] && check_option="--check-trust"
                           [[ "$unruned_machines" = *"$machine"* ]] && check_option="--without-run"
                        fi
                        if [[ "$non_machines" = *"$machine"* ]] || [ $* = tuleap/Maintenance ] # Test si machine n est pas dans la liste des machines cible, get_binary et tache
                        then
                           liste_options=$liste_options" --clean-after-if-ok"
                        fi
                        if [[ "$cible_machines" = *"$machine"* ]] && [ $* != tuleap/Maintenance ] # Test si machine est dans la liste des machines cible
                        then
                           liste_options=$liste_options" --cible"
                        fi
                        machine=`echo $adr | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`
                        log=`awk -v adr=$adr '($2==adr) {print $4}' ~/.netrc | head -1`
                        BATCHMODE=" -o BatchMode=yes "
                        SSHP=""
                        if [ "`liste_machines ssh_pass | grep $adr`" != "" ]
                        then
                           SSHPASS=`awk -v adr=$adr '($2==adr) {print $6}' ~/.netrc | head -1`
                           SSHP="sshpass -p $SSHPASS "
                           BATCHMODE=""
                        fi

                        WORKTMP=`$SSHP ssh_ $BATCHMODE $log@$adr -n 'if [ "\$WORKDIR" = "" ]; then echo \$HOME;else echo \$WORKDIR;fi'`
                        if [ $* = tuleap/Maintenance ]
                        then
                           # Debut de partie a revoir !!!!
                           WORKBETA=""
                           trustversion=""
                           [ "$Composant" == "flica5" ] && trustversion=1.9.4
                           [ "$Composant" == "module3D" ] && trustversion=1.9.4
                           [ "$Composant" == "triomc" ] && trustversion=1.9.4
                           if  [ "${machine:0:5}" = "orcus" ] || [ "${machine:0:6}" = "altair" ]
                           then
                              WORKBETA=`$SSHP ssh_ $BATCHMODE $log@$adr -n 'source /home/trust_trio-public/env_TRUST-'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           elif  [ "${machine:0:9}" = "callisto-" ] || [ "${machine:0:11}" = "irene-ccrt-" ] || [ "${machine:0:7}" = "cobalt-" ]
                           then
                              WORKBETA=""
                           elif [ "${machine:0:10}" = "irene-ccrt" ] || [ "${machine:0:6}" = "topaze" ]
                           then
                              WORKBETA=`$SSHP ssh_ $BATCHMODE $log@$adr -n 'source /ccc/cont002/home/den/triou/env_TRUST-'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           elif [ "${machine:0:7}" = "cezanne" ]
                           then
                              WORKBETA=`$SSHP ssh_ $BATCHMODE $log@$adr -n 'source /soft/der/sesi/TRUST/env_TRUST-'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           elif  [ "${machine:0:2}" = "is" ]
                           then
                              WORKBETA=`$SSHP ssh_ $BATCHMODE $log@$adr -n 'source /home/trust_trio-public/env_TRUST-'$trustversion'.sh 1>/dev/null 2>&1; echo \$TRUST_ROOT;'`
                           fi
                           if [ "$WORKBETA" != "" ]
                           then
                              echo "$Composant.tar $WORKTMP/$WORKBASE$machine/ComposantsBeta/$Composant $log@$adr --with-TRUST=$WORKBETA $liste_options $mode_option $check_option $valgrind_option" >> Run.liste
                           else
                              echo "No check on $log@$adr because no $trustversion version on this host"
                           fi
                           # !!!! Fin de partie a revoir
                        else
                           if [ "$Composant" = flica5 ]
                           then
                               check_option=""
                           fi
                           echo "$Composant.tar $WORKTMP/$WORKBASE$machine/Composants/$Composant $log@$adr --with-TRUST=$WORKTMP/$WORKBASE$machine/TRUST $liste_options $mode_option $check_option $valgrind_option" >> Run.liste
                        fi
                     fi
                 # fi
               done
               echo " "
               cat Run.liste
               echo " "
               echo "Call to $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_portability Run.liste"
               echo " "
               $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_portability Run.liste & # Take care if run not with &, the second argument should be different for each project
            fi
         ) 1>$Composant_log 2>&1
         echo "    `grep "Component $Composant" $Composant_log`"
         cd $TRUST_ROOT
      #else
      #   echo "  Component $Composant KO not found here: $TRUST_ROOT/../Composants"
      fi
      fi
   done
}

# Push to repos (called several times, once at the beginning and sometimes at the end...)
git_push()
{
   tags=0
   force=0
   while [ "$1" != "" ]
   do
      if [ "${1%-tags}" != $1 ]
      then
         tags=1
      elif [ "${1%-force}" != $1 ]
      then
         force=1
      fi
      shift
   done
   git_branch=`git branch 2>/dev/null | awk '($1=="*") {print $2}'`
   repos=`git remote | grep -v irene`
   for repo in $repos
   do
      remote_branch="triou/TMA" && Tags="--tags"
      [ "$repo" = "github_write" ] && remote_branch="next" && Tags=""
      repo_log=$REP_NUIT"/git_"$repo"_"$git_branch"_"$HOST".log"
      echo "TRUST git push on $HOST the `date` ...">$repo_log
      echo>>$repo_log
      echo "  git push $repo $git_branch. See $repo_log"
      if [ "$tags" != 1 ]
      then
         if [ "$force" != 1 ]
         then
            if [ "$git_branch" != "Livraison" ]
            then
               git push $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push $repo $git_branch\" $TRUST_MAIL
            else
               git push $repo $git_branch":"$remote_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push $repo TMA\" $TRUST_MAIL
            fi
         else
            git push --force $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push force $repo $git_branch\" $TRUST_MAIL
         fi
      else
         if [ "$force" != 1 ]
         then
            if [ "$git_branch" != "Livraison" ]
            then
               git push $Tags $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push tags $repo $git_branch\" $TRUST_MAIL
            else
               git push $Tags $repo $git_branch":"$remote_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push tags $repo TMA\" $TRUST_MAIL
            fi
         else
            git push --force --tags $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST error for git push force tags $repo $git_branch\" $TRUST_MAIL
         fi
      fi
      cat $repo_log | tail -n +3
      if [ "$git_branch" != "Livraison" ]
      then
         [ "`grep 'Everything up-to-date' $repo_log`" = "" ] && cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST git push $repo $git_branch\" $TRUST_MAIL
      else
         [ "`grep 'Everything up-to-date' $repo_log`" = "" ] && cat $repo_log | mail_ -s\"[lance_test_nuit] TRUST git push $repo TMA\" $TRUST_MAIL
      fi
   done
}

############################################################################################################################################################

#########
# BEGIN #
#########
export LANG=C
echo "****************************************************"
echo `date`
echo "Beginning of the `basename $0` script at `date '+%H:%M:%S'` from:"
echo "\$TRUST_ROOT=${0%/bin/admin/lance_test_nuit}"
echo "****************************************************"
echo " "
echo "##########################"
echo "# Initialize environment #"
echo "##########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
if [ -f ~/.profile ]
then
   echo "Call to "`echo ~`"/.profile"
   . ~/.profile 1>/dev/null 2>&1
   echo "  HOST=$HOST"
   echo "  WORKDIR=$WORKDIR"
   echo "  WORKBASE=$WORKBASE"
else
   echo `echo ~`"/.profile file not exist!" && exit -1
fi
# ROOT
export TRUST_ROOT=${0%/bin/admin/lance_test_nuit}
export TRUST_ROOT_MASTER=$TRUST_ROOT # New variable to set Livraison workdir (master branch in git)

# On recupere les numeros de version dans le fichier RELEASE_NOTES
export old=`awk '/version/ {print $(NF-1);exit}' $TRUST_ROOT/RELEASE_NOTES`
export new=`awk '/version/ {print $4;exit}' $TRUST_ROOT/RELEASE_NOTES`
export Version=Version$new
echo " "
echo "Release notes old version: "$old
echo "Release notes new version: "$new

# DISPLAY
[ ${#DISPLAY} = 0 ] && export DISPLAY=":0"
[ "`echo -e`" != "-e" ] && ECHO_OPTS="-e"

#VOBS="Doc_TRUST Pre_Post_TRUST Tests_TRUST TRUST Composants"
VOBS="TRUST Composants"

# List of components tested with TRUST:
# TrioCFD est ajoute a la liste car est devenu un Baltik de TRUST suite au decoupage de Trio_U.
# ICoCo est devenu un Outil de TRUST.
# equation_convection_diffusion est un projet Baltik qui sert de tutorial a la formation developpeur.
# MPCube est un Baltik qui peut etre teste sur TRUST et sur le kernel.
ComposantsLns="Test_Baltik equation_convection_diffusion ICoCo"
ComposantsOfficial="triocfd mpcube genepi3 flica5 TRUST_NK sides scorpio sympy_to_TRUST pemfc module3D triomc"
export ComposantsBeta="flica5 module3D triomc"
#ComposantsGit=$ComposantsOfficial" "$ComposantsBeta
#ComposantsGit=`echo $ComposantsGit | xargs -n1 | sort -u | xargs`
# ND : I comment the 2 prev lines to check triocfd first
ComposantsGit="triocfd flica5 genepi3 mpcube TRUST_NK module3D sides scorpio sympy_to_TRUST pemfc triomc"
export Composants=$ComposantsLns" "$ComposantsGit

# Initialize environment TRUST:
echo " "
echo "Call to "$TRUST_ROOT"/env/TRUST.env"
. $TRUST_ROOT/env/TRUST.env #1>/dev/null 2>&1

# List of executables tested:
exec_debug=$TRUST_ROOT/exec/TRUST$COMM
exec_semi_opt=$TRUST_ROOT/exec/TRUST$COMM"_semi_opt"
exec_opt=$TRUST_ROOT/exec/TRUST$COMM"_opt"
liste_exec=$exec_debug" "$exec_semi_opt

# Initialize ftp connection:
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/connect_ftp"
. $TRUST_ROOT/bin/admin/connect_ftp -no_ftp #1>/dev/null 2>&1
echo "Public  ftp server: ftp://$TRUST_FTP/$PUBLIC"
echo "Private ftp server: ftp://$TRUST_FTP/$SECRET"
echo " "

# Backup de hostname
echo "Call to "`echo ~`"/bin/backup_pc_tma.sh via crontab"
echo "  See "`echo ~`"/bin/backup_pc_tma.log"
# NB: Now via crontab
#~/bin/backup_pc_tma.sh 1>~/bin/backup_pc_tma.log 2>&1
head -n1 ~/bin/backup_pc_tma.log
grep "Backup " ~/bin/backup_pc_tma.log
tail -n1 ~/bin/backup_pc_tma.log
echo " "

[ $HOST != $TRUST_HOST_ADMIN ] && echo "Error: You must be on $TRUST_HOST_ADMIN to do this action" && exit

export DATE=`date '+%d%m%y'`
export NUIT=1
REP_NUIT=/home/trust_trio/triou/tmptrust/tmptrust/Historique/NUIT
REP_HIST=/home/trust_trio/triou/tmptrust/tmptrust/Historique/HIST
MESSAGES_NUIT=$REP_NUIT/MESSAGES_NUIT
MESSAGES_LIVRAISON=~/MESSAGES_LIVRAISON

# On fait le menage :
echo "Cleaning of $REP_NUIT directory"
rm -f $REP_NUIT/CR_* $REP_NUIT/PERF_* $REP_NUIT/MAKE_* $REP_NUIT/*.log
rm -f $REP_NUIT/rsync_include_from $REP_NUIT/NUIT.html
rm -f $REP_NUIT/os $REP_NUIT/CC $REP_NUIT/CR
rm -f $MESSAGES_NUIT $REP_NUIT/nuit_*.html
rm -f $REP_NUIT/MESSAGES_LIVRAISON* $REP_NUIT/MESSAGES_NUIT
rm -rf $REP_NUIT/Maintenance
rm -f $REP_NUIT/.nfs*
mv ~/CR_* ~/tmp_CR/
# On cree :
[ ! -d $REP_NUIT ] && mkdir $REP_NUIT
[ ! -d $REP_NUIT/Maintenance ] && mkdir -p $REP_NUIT/Maintenance
[ ! -d $REP_HIST ] && mkdir $REP_HIST
ls -a $REP_NUIT
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "###########################"
echo "# Work on the new version #"
echo "###########################"

###################################
# Debut du travail sur la version #
###################################
echo " "
echo "############################"
echo "# Create the documentation #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
credoc_log=$REP_NUIT/credoc_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/KSH/credoc"
echo "  See $credoc_log"
echo "TRUST documentation creation on $HOST the `date` ...">$credoc_log
echo>>$credoc_log
$TRUST_ROOT/bin/KSH/credoc 1>>$credoc_log 2>&1
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "######################"
echo "# Update the sources #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $TRUST_ROOT
# Mise a jour des includes, des makefile de TRUST
config_log=$REP_NUIT/configure_$HOST.log
echo "Call to "$TRUST_ROOT"/configure"
echo "  See $config_log"
echo "TRUST configuration on $HOST the `date` ...">$config_log
echo>>$config_log
./configure -force_provided_mpich -std=c++14 1>>$config_log || exit -1
#grep -i error $config_log
grep KO $config_log
tail -n24 $config_log | head -n1
echo " "
echo "Call to "$TRUST_ROOT"/env_TRUST.sh"
source env_TRUST.sh #1>/dev/null 2>&1

# Verifie la qualite de la version
# Verifie si plusieurs classes ne sont pas instanciees avec le meme nom
# Verification de l'unicite du nom des classes dans les macros implemente_...
instanc_log=$REP_NUIT/verifie_instanciable_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/KSH/verifie_instanciable"
echo "  See $instanc_log"
echo "TRUST instanciable check on $HOST the `date` ...">$instanc_log
echo>>$instanc_log
verifie_instanciable 1>>$instanc_log 2>&1
grep -i error $instanc_log
tail -n1 $instanc_log


# Gestion externalpackages
cd $TRUST_ROOT/bin/gestion_externalpackages
external_log=$REP_NUIT/Verify_externalpackages_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/gestion_externalpackages/Verify_externalpackages.sh"
echo "  See $external_log"
echo "TRUST external packages check on $HOST the `date` ...">$external_log
echo>>$external_log
./Verify_externalpackages.sh 1>>$external_log 2>&1
nb_error=`grep "not in" $external_log | wc -l`
if [ $nb_error != 0 ]
then
   cat $external_log | mail_ -s\"[lance_test_nuit] Verify_externalpackages.sh KO on $HOST:$TRUST_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
   cat $external_log
   echo "  KO"
else
   echo "  OK"
fi
#liste_log=$REP_NUIT/Verify_liste_dep_$HOST.log
#echo " "
#echo "Call to "$TRUST_ROOT"/bin/gestion_externalpackages/Verify_liste_dep.sh"
#echo "  See $liste_log"
#echo "TRUST external packages liste dep on $HOST the `date` ...">$liste_log
#echo>>$liste_log
# NB: Verification complete (apres nettoyage) le vendredi
#[ "`date '+%u'`" = 5 ] && rm -r -f $TRUST_ROOT/build/bin/gestion_externalpackages/Test
#./Verify_liste_dep.sh 1>>$liste_log 2>&1
# les paquets suivants different:
# scalapack car path pour intel (-fo_port obsolete)
# med / medcoupling
#nb_error=`grep "FAILED" $liste_log | grep -v packagespy | grep -v scalapack | grep -v med-4.1.1 | grep -v osu-micro-benchmarks-3.8 | grep -v osqp-0.6.0 | grep -v configuration | grep -v medcoupling | grep -v xdata | grep -v hdf5 | grep -v Miniforge3-Linux-aarch64.sh | grep -v AmgX | grep -v viennacl-dc552a8 | grep -v SPARSKIT2 | grep -v rocALUTION | grep -v rocm | grep -v ccache/ccache-4.8.2-linux-x86_64 | grep -v kokkos | grep -v magma | grep -v petsc | grep -v slate | grep -v zfp | wc -l`

#if [ $nb_error != 0 ]
#then
#   liste_failed=`grep "FAILED" $liste_log | sed "s,: FAILED,," | grep -v packagespy | grep -v scalapack | grep -v med-4.1.1 | grep -v osu-micro-benchmarks-3.8 | grep -v osqp-0.6.0 | grep -v configuration | grep -v medcoupling | grep -v xdata | grep -v hdf5 | grep -v Miniforge3-Linux-aarch64.sh | grep -v AmgX | grep -v viennacl-dc552a8 | grep -v SPARSKIT2 | grep -v rocALUTION | grep -v rocm | grep -v ccache/ccache-4.8.2-linux-x86_64 | grep -v kokkos | grep -v magma | grep -v petsc | grep -v slate | grep -v zfp`
#   cd $TRUST_ROOT/build/bin/gestion_externalpackages/Test
#   rm -r -f old new
#   for package in $liste_failed
#   do
#      echo>>$liste_log
#      echo "Launch ../compare_archive $package">>$liste_log
#      $TRUST_ROOT/bin/gestion_externalpackages/compare_archive $package 1>>$liste_log 2>&1
#   done
#   cd - 1>/dev/null 2>&1
#   cat $liste_log | mail_ -s\"[lance_test_nuit] Verify_liste_dep.sh KO on $HOST:$TRUST_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
#   grep "computed checksums did NOT match" $liste_log
#   grep "FAILED" $liste_log
#   echo "  KO"
#else
#   echo "  OK"
#fi
cd $TRUST_ROOT

# Marque la version dans MAIN.cpp et mon_main.cpp
echo " "
echo "Mark new version in following files:"
MAIN=$TRUST_ROOT/src/Kernel/Utilitaires/TRUST_Version.h
CHECKOUT $MAIN 1>/dev/null 2>&1
version=`$TRUST_Awk '/TRUST_VERSION/ {print $3}' $MAIN`
echo "  "$version"=>"$new": "$MAIN
echo $ECHO_OPTS "1,$ s?TRUST_VERSION $version?TRUST_VERSION \"$new\"?g\nw" | ed $MAIN 1>/dev/null 2>&1
CHECKIN $MAIN 1>/dev/null 2>&1

index=$TRUST_ROOT/index.html
version=`$TRUST_Awk '/ Version / {print $4}' $index`
echo $ECHO_OPTS "1,$ s?$version?$new?g\nw $index.new" | ed $index 1>/dev/null 2>&1
if [ "`diff $index $index.new`" != "" ]
then
   echo "Mark new version in "$index
   CHECKOUT $index
   cat $index.new > $index
fi
rm -f $index.new
ref_manual=Outils/TRIOXDATA/XTriou/objet_u.py
version=`$TRUST_Awk '/ Manual V/ {print $5}' $ref_manual`
echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $ref_manual.new" | ed $ref_manual 1>/dev/null 2>&1
if [ "`diff $ref_manual $ref_manual.new`" != "" ]
then
   echo "Mark new version in "$ref_manual
   CHECKOUT $ref_manual
   cat $ref_manual.new > $ref_manual
fi
rm -f $ref_manual.new
tuto=doc/TRUST/Tutorial/TRUST_tutorial.tex
version=`$TRUST_Awk '/ Tutorial V/ {print $3}' $tuto`
echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}]{TRUST?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
version=`$TRUST_Awk '/ Tutorial V/ {print $5}' $tuto.new`
echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $tuto.new" | ed $tuto.new 1>/dev/null 2>&1
if [ "`diff $tuto $tuto.new`" != "" ]
then
   echo "Mark new version in "$tuto
   CHECKOUT $tuto
   cat $tuto.new > $tuto
fi
rm -f $tuto.new
tuto=doc/TRUST/exercices/Tutorial_solutions/Tutorial_solutions.tex
version=`$TRUST_Awk '/ Tutorial V/ {print $3}' $tuto`
echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
if [ "`diff $tuto $tuto.new`" != "" ]
then
   echo "Mark new version in "$tuto
   CHECKOUT $tuto
   cat $tuto.new > $tuto
fi
rm -f $tuto.new
tuto=doc/TRUST/Tutorial/Baltik_tutorial.tex
version=`$TRUST_Awk '/ Tutorial V/ {print $5}' $tuto`
echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}]{TRUST?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
version=`$TRUST_Awk '/ Tutorial V/ {print $9}' $tuto.new`
echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $tuto.new" | ed $tuto.new 1>/dev/null 2>&1
if [ "`diff $tuto $tuto.new`" != "" ]
then
   echo "Mark new version in "$tuto
   CHECKOUT $tuto
   cat $tuto.new > $tuto
fi
rm -f $tuto.new
tuto=doc/TRUST/Tutorial/ICoCo_tutorial.tex
version=`$TRUST_Awk '/ Tutorial V/ {print $4}' $tuto`
echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}]{TRUST?g\nw $tuto.new" | ed $tuto 1>/dev/null 2>&1
version=`$TRUST_Awk '/ Tutorial V/ {print $7}' $tuto.new`
echo $ECHO_OPTS "1,$ s?$version?V${new/"_"/}}?g\nw $tuto.new" | ed $tuto.new 1>/dev/null 2>&1
if [ "`diff $tuto $tuto.new`" != "" ]
then
   echo "Mark new version in "$tuto
   CHECKOUT $tuto
   cat $tuto.new > $tuto
fi
rm -f $tuto.new
echo " "


[ ! -d $TRUST_ROOT/.git ] && echo "Error: You must have $TRUST_ROOT/.git directory to do this action" && exit

# Update Git repos #
####################
# Must be done BEFORE envoie_TRUST_arch (git_cron or git_ssh process)
(
   # Assume unchanged some files (big one with a lot of changes):
   cd $TRUST_ROOT/doc
   echo "Update Git repos "`pwd`
   for assume_inchanged in TRUST/TRUST_Reference_Manual.pdf TRUST/Keywords.txt Coverage/cpp.gcov.tar.gz Coverage/list_methodes.gz Coverage/dico.pkl.gz Coverage/list_methodes_non_appelees.gz
   do
      if [ ! -f $assume_inchanged ]
      then
         echo | mail_ -s\"[lance_test_nuit] File $assume_inchanged not found, fix lance_test_nuit. \" $TRUST_MAIL
      else
         # Ignore the changes of the specified files
         git update-index --assume-unchanged $assume_inchanged
      fi
   done
   # List untracked files:
   echo "  List of files untracked with git update-index --assume-unchanged:"
   git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'
   cd - 1>/dev/null 2>&1
   # Push to repos
   echo " "
   echo "Call git push origin TMA"
   git_push -tags
   cd $TRUST_ROOT/externalpackages
   repos=`git remote | grep -v irene`
   for repo in $repos
   do
     remote_branch="triou/TMA" && tags_="--tags"
     echo " git push $repo TMA in `pwd`"
     git push $tags_ $repo Livraison:$remote_branch 1>tmp.log 2>&1
     cat tmp.log
     [ "`grep 'Everything up-to-date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] externalpackages git push $repo TMA\" $TRUST_MAIL
     rm tmp.log 1>/dev/null 2>&1
   done
   cd - 1>/dev/null 2>&1


   # BALTIK
   for Composant in $ComposantsGit
   do
      cd $WORKDIR/tuleap/Livraison/Composants/$Composant
      BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
      echo " git push origin TMA in `pwd`"
      if [[ "$Composant" != "triocfd" && "$Composant" != "flica5" && "$Composant" != "mpcube" && "$Composant" != "TRUST_NK" && "$Composant" != "module3D" && "$Composant" != "sides" && "$Composant" != "scorpio" && "$Composant" != "sympy_to_TRUST" && "$Composant" != "pemfc" && "$Composant" != "triomc" ]]
      then
         git push --tags origin Livraison:triou/TMA 1>tmp.log 2>&1
         cat tmp.log
         [ "`grep 'Everything up-to-date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant git push origin TMA\" $TRUST_MAIL
         rm tmp.log 1>/dev/null 2>&1
      elif [[ "$Composant" == "triocfd" ]]
      then
         git remote update origin
         git checkout .
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull KO \" $TRUST_MAIL
         else
            [ "`grep 'Already up to date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull OK \" $TRUST_MAIL
         fi
         cat tmp.log && rm tmp.log 1>/dev/null 2>&1
         #git push origin_irene-ccrt Livraison:triou/TMA 1>tmp.log 2>&1
         #cat tmp.log
         #[ "`grep 'Everything up-to-date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant git push origin_irene-ccrt TMA\" $TRUST_MAIL
         rm tmp.log 1>/dev/null 2>&1
         git push github_write Livraison:next 1>tmp.log 2>&1
         cat tmp.log
         [ "`grep 'Everything up-to-date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant git push github TMA\" $TRUST_MAIL
         rm tmp.log 1>/dev/null 2>&1
      elif [[ "$Composant" == "TRUST_NK" ]]
      then
         git remote update
         git checkout .
         git checkout next
         git reset --hard origin/next
      elif [[ "$Composant" == "flica5" ]]
      then
         git checkout .
         git pull 1>tmp.log 2>&1
         cat tmp.log
         [ "`grep 'Everything up-to-date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant git pull origin TMA\" $TRUST_MAIL
         rm tmp.log 1>/dev/null 2>&1
         cd $WORKDIR/tuleap/Maintenance/Composants/$Composant
         git remote update
         git checkout .
         git checkout master
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit_maintenance] $Composant : git pull master KO \" $TRUST_MAIL
         else
            [ "`grep 'Already up to date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit_maintenance] $Composant : git pull master OK \" $TRUST_MAIL
         fi
         cat tmp.log
         rm tmp.log 1>/dev/null 2>&1
         cd -
      elif [[ "$Composant" == "module3D" ]]
      then
         git remote update
         git checkout .
         git checkout Issue5698_portage195
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull Issue5698_portage195 KO \" $TRUST_MAIL
         else
            [ "`grep 'Already up to date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull Issue5698_portage195 OK \" $TRUST_MAIL
         fi
         cat tmp.log
         rm tmp.log 1>/dev/null 2>&1
         cd $WORKDIR/tuleap/Maintenance/Composants/$Composant
         git remote update
         git checkout .
         #git checkout master
         git checkout advance
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit_maintenance] $Composant : git pull master KO \" $TRUST_MAIL
         else
            [ "`grep 'Already up to date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit_maintenance] $Composant : git pull master OK \" $TRUST_MAIL
         fi
         cat tmp.log
         rm tmp.log 1>/dev/null 2>&1
         cd -
      elif [[ "$Composant" == "triomc" ]]
      then
         git remote update
         git checkout .
         git checkout portage
         git reset --hard origin/portage
         cd $WORKDIR/tuleap/Maintenance/Composants/$Composant
         git remote update
         git checkout .
         git checkout master
         git reset --hard origin/master
         cd -
      else
         git remote update
         git checkout .
         git checkout portage 1>tmp.log 2>&1
         [ $? != 0 ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git checkout portage KO\" $TRUST_MAIL
         rm tmp.log 1>/dev/null 2>&1
         git pull 1>tmp.log 2>&1
         if [ $? != 0 ]
         then
             git reset --hard origin/portage && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git reset hard portage \" $TRUST_MAIL
         else
            [ "`grep 'Already up to date' tmp.log`" = "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] $Composant : git pull portage OK \" $TRUST_MAIL
         fi
         cat tmp.log
         rm tmp.log 1>/dev/null 2>&1
         #git push origin Livraison:triou/TMA 1>tmp.log 2>&1
      fi
      cd - 1>/dev/null 2>&1
   done
)
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "#######################################"
echo "# Send the sources to remote machines #"
echo "#######################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
envoie_log=$REP_NUIT/envoie_TRUST_arch_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/envoie_TRUST_arch"
echo "  See $envoie_log"
echo "TRUST script on $HOST the `date` ...">$envoie_log
echo>>$envoie_log
touch liste_envoie_KO
# NB: Versions distantes automatiquement effacees le vendredi
envoie_TRUST_arch 1>>$envoie_log 2>&1
export liste_machines_KO=`cat liste_envoie_KO`
rm -f liste_envoie_KO
grep -i delete $envoie_log | head -n1
grep "KO " $envoie_log
#grep error $envoie_log
mv -f build/rsync_*.log $REP_NUIT/.
mv -f build/rsync_include_from $REP_NUIT/.
mv -f build/ssh_*.log $REP_NUIT/.
# On recupere le nom des machines sur lesquelles les sources n ont pu etre mises a jour
# Cette liste permettra de ne pas lancer la portabilite des baltiks sur ces machines
if [ ${#liste_machines_KO} != 0 ] # chaine non vide
then
   echo "  liste_machines_KO:"
   echo $liste_machines_KO
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "###############################################"
echo "# Compile and verify the old and new versions #"
echo "###############################################"
(
  # On allege le nombre de versions compilees:
  for vue in tuleap/Livraison tuleap/Maintenance tuleap/Kernel
  do
     if [ -d $WORKDIR/$vue ]
     then
        # Git workdir
        TRUST_ROOT=$WORKDIR/$vue/TRUST
        cd $TRUST_ROOT
        echo " "
        echo "#############################"
        echo "# On workdir: "$TRUST_ROOT
        echo "#############################"
        echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
        if [ $vue = tuleap/Kernel ]
        then
           # Kernel desormais workdir Git:
           #rebase_log=`mktemp_`
           rebase_log=$REP_NUIT"/rebase_"$HOST"_"${vue#*/}".log"
           echo "Call git rebase TMA"
           echo "  See $rebase_log"
           echo "git rebase on $HOST the `date` ...">$rebase_log
           echo>>$rebase_log
           echo "externalpackages">>$rebase_log
           cd $TRUST_ROOT/externalpackages
           git rebase Livraison 1>>$rebase_log 2>&1
           [ $? != 0 ] && echo "  KO rebase externalpackages"
           git rebase --continue 1>>$rebase_log 2>&1
           [ "`git rebase --continue 2>&1`" != "No rebase in progress?" ] && echo "  KO rebase externalpackages"
           cd - 1>/dev/null 2>&1
           echo>>$rebase_log
           for Composant in $ComposantsGit
           do
              if [ -d $TRUST_ROOT/../Composants/$Composant ]
              then
                 echo "Composants/$Composant">>$rebase_log
                 cd $TRUST_ROOT/../Composants/$Composant
                 git remote update
#                On teste uniquement mpcube sur la verison Kernel !
#                La branche est appelee portage car basee sur une version de developpement TRUST
                 git reset --hard origin/portage
                 cd - 1>/dev/null 2>&1
                 echo>>$rebase_log
              fi
           done
           cd $TRUST_ROOT
           git commit doc/.dico Outils/TRIOXDATA/XTriou/syno.py -m"Commit in Kernel before git rebase TMA" --u=no 1>>$rebase_log 2>&1
           git rebase Livraison 1>>$rebase_log 2>&1
           rebase_error=$?
           if [ $rebase_error != 0 ]
           then
              deleted_item=deleted_item
              compt=10
              while [ $rebase_error != 0 ] && [ "$deleted_item" != "" ] && [ $compt != 0 ]
              do
                 let compt=$compt-1
                 for deleted_item in `git status | awk '/deleted by them/ || /added by us/ {print $4}'`
                 do
                    git rm $deleted_item #1>>$rebase_log 2>&1
                 done
                 git rebase --continue 1>>$rebase_log 2>&1
                 rebase_error=$?
                 if [ "`git rebase --continue 2>&1`" = "No rebase in progress?" ]
                 then
                    rebase_error=0
                 fi
              done
           fi
           if [ $rebase_error != 0 ]
           then
              cat $rebase_log | mail_ -s\"[lance_test_nuit] Error when rebasing $vue workdir. Check.\" $TRUST_MAIL
           fi
           grep -i error $rebase_log
           echo "  rebase_error=$rebase_error"
           echo " "
           #rm -f $rebase_log
           # Delete non Kernel src if any:
           cd $TRUST_ROOT/src
           NonKernelTests=`find * -type d | grep -v Kernel | grep -v MAIN`
           if [ "$NonKernelTests" != "" ]
           then
              echo "Call git rm no $vue tests..."
              for NonKernelTest in $NonKernelTests
              do
                 git rm -r $NonKernelTest
              done
              #git commit --all -m"Non Kernel src suppressed from the branch Kernel"
              echo " "
           fi
           cd - 1>/dev/null 2>&1
           # Delete non Kernel tests if any:
           cd $TRUST_ROOT/tests
           NonKernelTests=`find * -type d | grep -v "/Kernel" | grep "/"`
           if [ "$NonKernelTests" != "" ]
           then
              echo "Call git rm no $vue tests..."
              for NonKernelTest in $NonKernelTests
              do
                 git rm -r $NonKernelTest
              done
              #git commit --all -m"Non Kernel tests suppressed from the branch Kernel"
              echo " "
           fi
           cd - 1>/dev/null 2>&1
           # Delete non Kernel verification if any:
           cd $TRUST_ROOT/Validation/Rapports_automatiques/Verification
           NonKernelTests=`find * -type d | grep -v Kernel | grep -v src |grep "/"`
           if [ "$NonKernelTests" != "" ]
           then
              echo "Call git rm no $vue tests..."
              for NonKernelTest in $NonKernelTests
              do
                 git rm -r $NonKernelTest
              done
              git commit --all -m"Non Kernel src, tests and verification suppressed from the branch Kernel"
              echo " "
           fi
           cd - 1>/dev/null 2>&1
           if [ $rebase_error = 0 ]
           then
              echo "Call git push origin Kernel"
              #git_push -tags -force
              git push --force origin Kernel:triou/Kernel 1>tmp.log 2>&1
              [ "`cat tmp.log`" != "Everything up-to-date" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] Kernel: git push origin TMA\" $TRUST_MAIL
              echo " "
           fi
        fi
        echo "Call to configure $vue version in `pwd`"
        ./configure -force_provided_mpich -std=c++14 1>/dev/null 2>&1
        source env_TRUST.sh 1>/dev/null 2>&1
        echo "TRUST_ROOT=$TRUST_ROOT"
        echo "TRUST_VERSION=$TRUST_VERSION"
        ###################################################
        # Boucle sur les differentes options de compilation
        ###################################################
        for OPT in _semi_opt_ _opt_ _ _opt_pg_ _opt_gcov_
        do
           case $OPT in
           _semi_opt_) TYPE="semi_opt";;
           _opt_) TYPE="opt";;
           _) TYPE="debug";;
           _opt_pg_) TYPE="prof";;
           _opt_gcov_) TYPE="gcov";;
           *) echo $OPT not coded in $0;  exit -1 ;;
           esac;
           OPT=${OPT%_} # <=> OPT=${OPT::-1}
           echo " "
           make_log=$REP_NUIT"/MAKE_TRUST"$COMM"_"$TYPE"_"$TRUST_ARCH"_"$HOST"_"${vue#*/}
           echo "Call to make $TYPE on `pwd`";
           echo "  See $make_log"
           echo "TRUST make on $HOST the `date` ...">$make_log
           echo>>$make_log
           make $TYPE 1>>$make_log 2>&1
           grep "BUILD_" $make_log
           grep error $make_log
           grep -i Stop $make_log
           grep KO $make_log | grep -v "LIBKOKKOS:OK"
           if [ "$TYPE" = "debug" ] && [ $vue = tuleap/Livraison ]
           then
              echo "grep -r linux_opt $TRUST_ROOT/MonoDir_mpi/src/CMakeFiles/TRUST_mpi.dir/*.make 2>/dev/null" > tmp.log
              error_link_or_include="`grep -r linux_opt $TRUST_ROOT/MonoDir_mpi/src/CMakeFiles/TRUST_mpi.dir/*.make 2>/dev/null`"
              echo "$error_link_or_include" >> tmp.log
              [ "$error_link_or_include" != "" ] && cat tmp.log | mail_ -s\"[lance_test_nuit] DEBUG error: link or includes done against an optimized library\" $TRUST_MAIL
              rm -f tmp.log
           fi
           if [ "$OPT" = "_semi_opt" ]
           then
              if [ $vue = tuleap/Livraison ]
              then
                 # Force une compilation statique pour:
                 # a) Instanciation manquante
                 # b) Sauve un exec en le zippant sous NUIT
                 echo " "
                 echo "Call to make with COMPIL_DYN=OFF on $TRUST_ROOT/MonoDir_mpi$OPT/src"
                 cd $TRUST_ROOT/MonoDir_mpi$OPT/src
                 cmake . -DCOMPIL_DYN=OFF
                    tmp=`mktemp_`
                 make 1>>$tmp 2>&1
                 tail -n2 $tmp
                 rm -f $tmp
                 gzip -c $exec > $REP_HIST/`basename $exec`"."$DATE".gz"
                 cd $TRUST_ROOT
                 echo " "
                 echo "Save "$REP_HIST/`basename $exec`"."$DATE".gz"
              elif [ $vue = tuleap/Maintenance ]
              then
                 echo " "
                 new_patch=1
                 echo "Special treatment..."
                 ################################
                 # Travaux sur la vue Maintenance
                 ################################
                 checkin_log=$REP_NUIT"/checkin_patch_"$HOST"_"${vue#*/}".log"
                 echo "Call to "$TRUST_ROOT"/bin/admin/checkin_patch.ct"
                 echo "  See $checkin_log"
                 echo "TRUST checkin patch on $HOST the `date` ...">$checkin_log
                 #$TRUST_ROOT/bin/admin/checkin_patch.ct 1>>$checkin_log 2>&1 # Test a revoir
                 wc -l $checkin_log
                 grep "diff --git" $checkin_log
                 if [ "`cat $checkin_log | tail -n +2`" != "" ]
                 then
                 cat $checkin_log | mail_ -s\"[checkin_patch.ct] Changes in the $TRUST_VERSION patch branch\" $TRUST_MAIL
                 #######################
                 # Construction du patch
                 #######################
                 patch_version=`awk '/version/ && /Release notes/ {print $4;exit}' RELEASE_NOTES`
                 rm -f $TRUST_TMP/patch
                 GRAVAGE=$WORKDIR/archives/ARCHIVES_TRUST
                 patch=$GRAVAGE/Patch-$patch_version".tar.gz" && rm -f $patch
                 echo " "
                 echo "Construction of the $patch patch..."
                 echo "from `pwd`"
                 # Git (On ne scrute que les VOBs TRUST):
                 cd $TRUST_ROOT
                 #echo "  Call git push origin Maintenance"
                 #git_push -tags
                 echo "  Files contained in the patch"
                 Build=$TRUST_ROOT/build
                 [ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
                 echo "    See $Build/patch.files"
                 git diff --name-only v$TRUST_VERSION > $Build/patch.files
                 patch_error=$?
                 if [ -s $Build/patch.files ]
                 then
                    # ajout du log pour identifier l'archive
                    git log -1 > .git_patch_log
                    echo .git_patch_log >> $Build/patch.files
                    # Ajout de Patch au fichier
                    #BASE=`basename $TRUST_ROOT`
                    #for file in `cat $Build/patch.files`
                    #do
                    #   if [ -f $file ]
                    #   then
                    #      echo $BASE/$file
                    #   fi
                    #done > Patch.files
                    # creation des archives
                    echo "  Files compressed in $patch"
                    tar zcf $patch `cat $Build/patch.files`
                    #cd ..
                    #tar zcf $patch  --transform=s?$BASE?Patch-${patch_version}? `cat $BASE/Patch.files`
                    #md5sum  $patch > $patch.md5
                 fi
                 cd $TRUST_ROOT
                 cat $Build/patch.files
                 rm -f Patch.files
                 if [ $patch_error = 0 ] && [ -s $Build/patch.files ]
                 then
                    # Envoi immediat sur ftp.cea.fr
                    echo "  Call to "$TRUST_ROOT"/bin/admin/connect_ftp"
                    . $TRUST_ROOT/bin/admin/connect_ftp
                    echo "  Call to "$TRUST_ROOT"/bin/admin/cp_ftp"
                    $TRUST_ROOT/bin/admin/cp_ftp $patch $PUBLIC/patch
                    # Mise a jour des versions patchees
                    echo " "
                    echo "Call to "$TRUST_ROOT"/bin/admin/Installer_TRUST.ssh on:"
                    liste_machines updated
                    for machine in `liste_machines updated`
                    do
                       (
                       install_patch_log=$REP_NUIT"/install_patch_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
                       echo "-> Start of Installer_TRUST.ssh $machine $patch_version -patch -compile..."
                       echo "  See $install_patch_log"
                       )
                    done
                    for machine in `liste_machines updated`
                    do
                       (
                       install_patch_log=$REP_NUIT"/install_patch_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
                       echo "TRUST script on $HOST the `date` ...">$install_patch_log
                       echo>>$install_patch_log
                       $TRUST_ROOT/bin/admin/Installer_TRUST.ssh $machine $patch_version -patch -compile 1>>$install_patch_log 2>&1
                       if [ $? != 0 ] || [ "`grep :error $install_patch_log | grep -iv warning | grep -v TRIOXDATA | grep -v Gmsh`" != "" ]
                       then
                          cat $install_patch_log | mail_ -s\"[lance_test_nuit] Failed to install patch version on $machine\" $TRUST_MAIL
                       fi
                       ) &
                       # Quels sont les conflits ?
                    done
                 elif [ $patch_error != 0 ]
                 then
                    echo "Not install on remote machine!" | mail_ -s\"[lance_test_nuit] Failed to create $TRUST_VERSION patch version\" $TRUST_MAIL
                 fi
                 else
                    echo "No patch"
                    new_patch=0
                 fi
                 echo "End special treatment."
              fi
           fi
        done
        ########################
        # Check non regression #
        ########################
        if ([ $vue = tuleap/Maintenance ] && [ $new_patch != 0 ]) || [ $vue = tuleap/Kernel ]
        then
           lance_test_log=$REP_NUIT"/lance_test_"$HOST"_"${vue#*/}".log"
           echo " "
           echo "-> Start of exec=$exec_opt trust -check all"
           echo "  See $lance_test_log"
           echo "TRUST script on $HOST the `date` ...">$lance_test_log
           echo>>$lance_test_log
           # Reduce priority with nice:
           exec=$exec_opt nice -n 19 $TRUST_ROOT/bin/trust -check all 1>>$lance_test_log 2>&1 &
        fi
        ###############################
        # Verification des composants #
        ###############################
        #if ([ $vue = tuleap/Maintenance ] && [ $new_patch != 0 ]) || [ $vue = tuleap/Kernel ]
        if [ $vue = tuleap/Maintenance ] || [ $vue = tuleap/Kernel ] # Test a revoir : pour livraison TrioMC qd TRUST est tagguee
        then
           echo " "
           echo "Call check_components for $TRUST_VERSION version from `pwd`"
           check_components $vue
        fi
        # ND 16/02/2024 : je desactive car maintenance n'est jamais mergee dans next, fix fait sur next directement
        #if [ $vue = tuleap/Livraison ]
        #then
        #   ##########################################
         #   # Merge needed from patch branch under Git
         #   ##########################################
        #   to_merge=`mktemp_`
          #   patch_branch=`cd $WORKDIR/tuleap/Maintenance/TRUST;git rev-parse --abbrev-ref HEAD`
          #   master_branch=`cd $WORKDIR/tuleap/Livraison/TRUST;git rev-parse --abbrev-ref HEAD`
        #   echo " "
         #   echo "Call `pwd`/git diff --name-status $master_branch...$patch_branch"
         #   git diff --name-status $master_branch...$patch_branch 1>$to_merge
        #   cat $to_merge
         #   if [ -s $to_merge ]
        #   then
        #      echo "  KO: Some stuff to merge in $master_branch from $patch_branch with command: fusion.git $patch_branch"
        #      cat $to_merge | mail_ -s\"[lance_test_nuit] Some stuff to merge in $master_branch from $patch_branch with command: fusion.git $patch_branch\" $TRUST_MAIL
        #   else
        #      echo "  OK: No stuff to merge in $master_branch from $patch_branch"
        #   fi
         #   rm -f $to_merge
        #fi
        echo "<--- End at "`date '+%H:%M:%S %d/%m'`
     fi
  done
)
TRUST_ROOT=${0%/bin/admin/lance_test_nuit}
cd $TRUST_ROOT
source env_TRUST.sh 1>/dev/null 2>&1

##############################################################
# verifie pere doit etre appele apres la compilation de TRUST
##############################################################

# Verifie la validite de la classe mere dans les instanciations
# Verification du nom de la classe pere dans les macros implemente_...
verif_log=$REP_NUIT/Verifie_pere_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/KSH/Verifie_pere"
echo "  See $verif_log"
echo "TRUST father class check on $HOST the `date` ...">$verif_log
echo>>$verif_log
Verifie_pere 1>>$verif_log 2>&1
verif_error=$?
tail -n1 $verif_log
if [ $verif_error != 0 ]
then
   echo>>$verif_log
   cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log
   cat $verif_log | mail_ -s\"[lance_test_nuit] Verifie_pere KO on $HOST:$TRUST_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
echo>>$verif_log
cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log
if [ $verif_error = 0 ]
then
   rm -rf $TRUST_TMP/Verifie_pere
fi

echo " "
echo "------------------------------------------------------"
echo " "
echo "########################"
echo "# Test the new version #"
echo "########################"

####################################################
# Lancement des etudes sur une machine de production
####################################################
ETUDES=$WORKDIR/tuleap/Etudes
echo " "
echo "##################"
echo "# On study cases #"
echo "##################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
# ND je desactive les etudes car souci sur irene
etude_activation=0
if [ `date '+%u'` -ge 5 ]
then
   # le vendredi soir on lance toutes les etudes
   etude_test=0
else
   # On ne lance qu'une etude
   etude_test=1
fi
# On lance toutes les etudes
etude_test=0

disable_etudes=~/disable_etudes && [ -f $disable_etudes ] && etude_test=1 && rm -f $disable_etudes
if [ $etude_activation = 1 ]
then
   cd $ETUDES 2>/dev/null
   if [ $? != 0 ]
   then
      echo "Error: $ETUDES not found !"
      echo "  You should create a git repo for Etudes and change the run script"
      echo "  or for the moment, you can create a link to Etudes directory."
      etude_activation=0
   fi
fi
# seulement si le script run de la veille est termine (ie run_Etudes.log deplace dans $REP_NUIT)
if [ $etude_activation = 1 ]  && [ -f run_Etudes.log ]
then
   echo "NOT launched because $ETUDES/run script not finished"
   echo "  See $ETUDES/run_Etudes.log"
   etude_activation=0
fi
if [ $etude_activation = 1 ]  && [ ! -f run_Etudes.log ] && [ $etude_test = 1 ]
then
   touch $ETUDES/run_Etudes.log
   echo "  See $REP_NUIT/run_EOLE_120_irene-amd.log"
   echo "TRUST script on irene-amd the `date` ...">run_EOLE_120_irene-amd.log
   echo>>run_EOLE_120_irene-amd.log
   (./run Studies/EOLE_120 -adr irene-amd-ccrt.ccc.cea.fr 1>>run_EOLE_120_irene-amd.log 2>&1;mv -f run_EOLE_120_irene-amd.log $REP_NUIT/.) &
   mv -f run_Etudes.log $REP_NUIT/.
fi
if [ $etude_activation = 1 ]  && [ ! -f run_Etudes.log ] && [ $etude_test = 0 ]
then
   echo "-> Start of "$ETUDES"/run -all"
   touch $ETUDES/run_Etudes.log
   echo "  See $REP_NUIT/run_Etudes.log"
   echo "TRUST script from $HOST the `date` ...">run_Etudes.log
   echo>>run_Etudes.log
   (./run -all 1>>run_Etudes.log 2>&1;mv -f run_Etudes.log $REP_NUIT/.) & # Deplace le log des etudes si script termine
fi
if [ $etude_activation = 0 ]
then
   echo "NOT executed"
   [ -f run_Etudes.log ] && cp run_Etudes.log $REP_NUIT/.
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################
# Lancement des tests sur Livraison #
#####################################
cd $TRUST_ROOT
vue="tuleap/Livraison"
lance_test_log=$REP_NUIT"/lance_test_"$HOST"_"${vue#*/}".log"
touch $lance_test_log
echo "TRUST script on $HOST the `date` ...">$lance_test_log
echo " "
echo "##########################"
echo "# On no-regression tests #"
echo "##########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "  See $lance_test_log"
for exec in $liste_exec
do
   cd $TRUST_ROOT
   TYPE=""
   [ $exec = "$exec_debug" ] && TYPE=debugged && PERF=$REP_NUIT/PERF_`basename $exec`"_debug_"$TRUST_ARCH"_"$HOST
   [ $exec = "$exec_semi_opt" ] && TYPE=semi-optimized && PERF=$REP_NUIT/PERF_`basename $exec`_$TRUST_ARCH"_"$HOST
   echo " "
   echo "MODE: $TYPE (exec=$exec)"
   echo "TRUST performance on $HOST the `date` ...">$PERF
   echo "--------------------------------------------------------" >> $PERF
   echo "hostname "$HOST >> $PERF
   OS="Os "`uname -s` && [ $TRUST_ARCH = linux ] && OS=$OS" "`cat /proc/cpuinfo | $TRUST_Awk '/MHz/ {print $4"Mhz";exit}'`
   echo $OS >> $PERF
   echo "release "`uname -r` >> $PERF
   echo "model "`uname -m` >> $PERF
########################################################
# La nuit, lance_test est lance avec l'executable exec :
########################################################
   if [ -f $exec ] && [ "`$exec 2>&1 | grep TRUST`" != "" ]
   then
      taille=`ls -la $exec | $TRUST_Awk '{print $5}'`
      taille=`echo $ECHO_OPTS "scale=1\n$taille/1000000" | bc -l`
      #type=`echo $taille | $TRUST_Awk '{type="Statique";if ($1<=2) type="Dynamique";print type}'`
      type=`ldd $exec | $TRUST_Awk 'END {type="Statique";if (NR>20) type="Dynamique";print type}'`
      if [ $type = Statique ]
      then
         echo "size "$taille" "$type >> $PERF
      elif [ $type = Dynamique ]
      then
         sl=`ls -la $TRUST_ROOT/lib/lib*.s* 2>/dev/null | $TRUST_Awk 'BEGIN {i=0} {i+=$5} END {print i}'`
         #echo "sl="$sl
         sl=`echo $ECHO_OPTS "scale=1\n$sl/1000000" | bc -l`
         #echo "sl="$sl
         echo "size "$taille"+"$sl" "$type >> $PERF
      fi
      echo "--------------------------------------------------------" >> $PERF
      echo "exec "$exec >> $PERF
      #######################################
      ### CHOIX DU NOMBRE DE TESTS PASSES ###
      N=0
      [ $exec = "$exec_debug" ] && N=VAHL_DAVIS
      #######################################
      echo "-> Start of echo $N | $TRUST_ROOT/bin/lance_test"
      echo "  See $PERF"
      fic_test=`dirname $exec`/.tests_`basename $exec`
      rm -f $fic_test
      echo " " >> $lance_test_log
      echo "######################################################" >> $lance_test_log
      echo " " >> $lance_test_log
      export PAR=0
      echo $ECHO_OPTS $N | lance_test $exec `dirname $exec` 2>/dev/null  >> $lance_test_log
      if [ -f $fic_test ]
      then
         #cat $fic_test".html" | grep "Mo|" >> $PERF
         cat $fic_test".html" | $TRUST_Awk -F":" '/ucces/ {print "succes "$2}' >> $PERF
         grep -A 5000 unsuccess $fic_test".html" >> $PERF
      fi
      # On fait l'executable share libs
      # CC: 16/02/2015 => Pourquoi fait-on ca ici et pas lors de la compilation plus haut ?
      #(cd $TRUST_ROOT/src/MAIN;make)
      (
      OPT=""
      [ $exec = "$exec_debug" ] && OPT=_
      [ $exec = "$exec_semi_opt" ] && OPT=_semi_opt_
      OPT=${OPT%_} # <=> OPT=${OPT::-1}
      if [ $type = Statique ]
      then
         echo "Call to make with COMPIL_DYN=OFF on $TRUST_ROOT/MonoDir_mpi$OPT/src"
         cd $TRUST_ROOT/MonoDir_mpi$OPT/src
         cmake . -DCOMPIL_DYN=OFF
      elif [ $type = Dynamique ]
      then
         echo "Call to make with COMPIL_DYN=ON  on $TRUST_ROOT/MonoDir_mpi$OPT/src"
         cd $TRUST_ROOT/MonoDir_mpi$OPT/src
         cmake . -DCOMPIL_DYN=ON
      fi
      tmp=`mktemp_`
      make 1>>$tmp 2>&1
      tail -n2 $tmp
      rm -f $tmp
      )
   fi
   # Suite au test `$exec 2>&1 | grep TRUST`
   rm -f convert_jdd hierarchie.dump TRUST.log TRUST.stop
done
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#################################################
# Verification de la portabilite des composants #
#################################################
cd $TRUST_ROOT
echo " "
echo "#################"
echo "# On components #"
echo "#################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Call check_components for $TRUST_VERSION version from `pwd`"
check_components $vue
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "#####################################"
echo "# Validate and save the new version #"
echo "#####################################"
cd $TRUST_ROOT
# Attente jusqu'a minuit le vendredi
# pour certains tests faits que le week-end
while [ "`date '+%u'`" = 5 ] && [ `date '+%H'` -gt 20 ]
do
   sleep 30
done
echo " "
echo "###################################"
echo "# Create the matrix of validation #"
echo "###################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
(
matrice_validation=0 # Non actualise
# Changement 164, on cree la matrice de validation le week-end
if [ $matrice_validation = 1 ] && [ "`date '+%u'`" -gt 5 ]
then
   cd $TRUST_ROOT/doc/Validation
   echo "-> Start of "$TRUST_ROOT"/doc/Validation/Matrice.sh"
   echo "  See `pwd`/Matrice_Validation.pdf"
   ./Matrice.sh -no_verbose # Utiliser l'option -no_verbose permet de conserve une trace dans le fichier Matrice.log du lance_test_modifie
   if [ -f Matrice.pdf ] && [ "`diff Matrice.pdf Matrice_Validation.pdf`" != "" ]
   then
      CHECKOUT Matrice_Validation.pdf 1>/dev/null 2>&1
      mv -f Matrice.pdf Matrice_Validation.pdf
   fi
   cd - 1>/dev/null 2>&1
else
   echo "NOT executed"
fi
) &
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "#####################################"
echo "# Use and execute cpplint.py script #"
echo "#####################################"
#echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
## le week-end uniquement
#if [ "`date '+%u'`" -gt 5 ]
#then
#   cd $TRUST_ROOT
#   echo "Call to $TRUST_ROOT/bin/KSH/cpplint.py"
#   echo "from `pwd`"
#   cpplint_log=$REP_NUIT"/cpplint_$HOST.log"
#   echo "  See $cpplint_log"
#   echo "TRUST script on $HOST the `date` ...">$cpplint_log
#   filter="--filter=-whitespace,-legal/copyright,-build/header_guard,-runtime/references,-readability/casting,\
#-build/include_what_you_use,-runtime/sizeof,-runtime/explicit,-runtime/printf,-runtime/int,\
#-readability/function,-readability/braces,-readability/streams,-readability/multiline_comment"
#   echo "====================================
#Running cpplint by filtering with --filter=$filter
#====================================" >> $cpplint_log
#   python $TRUST_ROOT/bin/KSH/cpplint.py $filter src/*/*.cpp src/*/*/*.cpp src/*/*/*/*.cpp src/*/*/*/*/*.cpp include/*.h 2>&1 | grep -v "Done processing" >> $cpplint_log
#   tail -n1 $cpplint_log
#   cat $cpplint_log | mail_ -s\"[lance_test_nuit] Google rules with cpplint on TRUST $new\" $TRUST_MAIL
#else
   echo "NOT executed since upgrade to python3"
#fi
#echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "######################"
echo "# Build the packages #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
GRAVAGE=$WORKDIR/archives/ARCHIVES_TRUST
echo "Deleting of _build_ packages in $GRAVAGE"
ls -f $GRAVAGE/*_build_*
rm -f $GRAVAGE/*_build_*
v=${Version#Version}
version_arch=TRUST-$v".tar.gz"
package_log=$REP_NUIT"/package_$HOST.log"
# Dans le paquet officiel, on ne met pas les tests de validation car cela prend trop de place
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/mise_a_jour_TRUST_tar -without_test_validation -without_version"
echo "  See $package_log"
echo "TRUST script on $HOST the `date` ...">$package_log
echo>>$package_log
mise_a_jour_TRUST_tar -without_test_validation -without_version 1>>$package_log
grep "Creation of" $package_log
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/cree_Version_TRUST $v"
echo "  See $package_log"
echo $ECHO_OPTS $v"\n" | cree_Version_TRUST 1>>$package_log
tail -n1 $package_log
echo " "
echo "Move $version_arch packages to $GRAVAGE"
mv $TRUST_ROOT/$version_arch $GRAVAGE/.
ls $GRAVAGE/$version_arch
cd $TRUST_ROOT
mv externalpackages.tar externalpackages-next.tar
cp_ftp externalpackages-next.tar $PUBLIC/../externalpackages/
rm -f TRUST.tar.gz externalpackages-next.tar
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
####################
# Release criteria #
####################
echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo `date` >> $MESSAGES_NUIT
if [ -f $TRUST_ROOT/RELEASE_NOTES ]
then
   echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
   echo "-------------------------------------- TRUST RELEASE NOTES ---------------------------------------" >> $MESSAGES_NUIT
   $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/RELEASE_NOTES | head -n -1 >> $MESSAGES_NUIT
   echo "" >> $MESSAGES_NUIT
fi
if [ -f $TRUST_ROOT/DEVELOPER_NOTES ]
then
   echo "---------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
   echo "-------------------------------------- TRUST DEVELOPER NOTES --------------------------------------" >> $MESSAGES_NUIT
   $TRUST_Awk '/Developer notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/DEVELOPER_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
   echo "" >> $MESSAGES_NUIT
fi
if [ -f $TRUST_ROOT/externalpackages/RELEASE_NOTES ]
then
   echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
   echo "--------------------------------- EXTERNALPACKAGES RELEASE NOTES ---------------------------------" >> $MESSAGES_NUIT
   $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/externalpackages/RELEASE_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
   echo "" >> $MESSAGES_NUIT
fi
Composant="triocfd"
if [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ]
then
   echo "--------------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
   echo "-------------------------------------- TrioCFD RELEASE NOTES -------------------------------------" >> $MESSAGES_NUIT
   $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES | tail -n +3 | head -n -1 >> $MESSAGES_NUIT
   echo "" >> $MESSAGES_NUIT
fi
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST WEB site:    https://cea-trust-platform.github.io" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD WEB site:    https://triocfd.cea.fr" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST's distribution site:   https://github.com/cea-trust-platform/trust-code" >> $MESSAGES_NUIT
#echo $ECHO_OPTS "TRUST<=1.8.3 distribution site:   http://sourceforge.net/projects/trust-platform" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD's distribution site: https://github.com/cea-trust-platform/TrioCFD-code" >> $MESSAGES_NUIT
#echo $ECHO_OPTS "TrioCFD<=1.8.3 distribution site: http://sourceforge.net/projects/triocfd" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST environment at Saclay:   source /home/trust_trio-public/env_TRUST-$old.sh" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD environment at Saclay: source /home/trust_trio-public/env_TrioCFD-$old.sh" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo $ECHO_OPTS "User TRUST TrioCFD     diffusion list http://saxifrage:3500/wws/info/trio_u_annonces" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Developer TRUST        diffusion list http://saxifrage:3500/wws/info/trio_u_dev" >> $MESSAGES_NUIT
echo $ECHO_OPTS "User TRUST TrioMC      diffusion list http://saxifrage:3500/wws/info/mc2_annonces" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST Kernel             mailing list http://saxifrage:3500/wws/info/trio_u_kernel" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST Post Processing    mailing list http://saxifrage:3500/wws/info/trio_u_post_traitement" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TrioCFD Front Tracking   mailing list http://saxifrage:3500/wws/info/trio_u_front_tracking" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
#echo $ECHO_OPTS "TRUST ftp site:          ftp://$TRUST_FTP/$PUBLIC/index.html" >> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST documentation:     ftp://$TRUST_FTP/$SECRET/doc" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Generic Guide:    ftp://$TRUST_FTP/$SECRET/doc/TRUST_Generic_documentation.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Reference Manual: ftp://$TRUST_FTP/$SECRET/doc/TRUST_Reference_Manual.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest Tutorial:         ftp://$TRUST_FTP/$SECRET/doc/TRUST_tutorial.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest list of builds:   ftp://$TRUST_FTP/$SECRET/NUIT/NUIT.html" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest TRUST binary:     ftp://$TRUST_FTP/$SECRET/exec/linux/TRUST_mpi_opt"_"$new"_build_"$DATE.gz" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo "Binaries of TRUST $new version are available here:" >> $MESSAGES_NUIT
for adr in `liste_machines | grep -v is1 | grep -v is2 | grep -v cezanne`
do
   machine=`echo $adr | awk -F. '{print $1}' | awk -F"-gw" '{print $1}'`
   log=`awk -v adr=$adr '($2==adr) {print $4}' ~/.netrc | head -1`
   SSHP=""
   if [ "`liste_machines ssh_pass | grep $adr`" != "" ]
   then
      SSHPASS=`awk -v adr=$adr '($2==adr) {print $6}' ~/.netrc | head -1`
      SSHP="sshpass -p $SSHPASS "
   fi

   $SSHP ssh_ $log@$machine -n 'echo -e "'$machine: '\c";ls ${WORKDIR:-$HOME}/$WORKBASE"'$machine'"/TRUST/exec/TRUST_mpi_opt 2>/dev/null || echo' 2>/dev/null
done >> $MESSAGES_NUIT
echo "Older binaries (> v1.7.1) are available here: ftp://$TRUST_FTP/$PUBLIC/" >> $MESSAGES_NUIT
echo "Older binaries (< v1.7.1) are available here: ftp://ftp.cea.fr/pub/TRUST/a87pour/" >> $MESSAGES_NUIT
#echo "Older binaries (< v1.6.6) are available here: file:///net/dibona/users/dibona/triou/version/" >> $MESSAGES_NUIT
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
##########################################################
# On checkine dans la vue si criteres suivants respectes :
##########################################################
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo "Release criteria of the $new version:" >> $MESSAGES_NUIT

criteres_remplis=0
total_criteres=0
baltik_ok=0
total_baltik=`echo $ComposantsOfficial | wc -w`
#nb=$(echo $ComposantsOfficial-1 | wc -w) # nb de baltik test\E9s pour les versions (beta, RC ou officielle)
#total_baltik=$(echo $nb-1 | bc -l)       # on retire Front_tracking_IJK du d\E9compte car il n'est pas encore au point

######################
# Tests d'installation
######################
echo " "
echo "############################################"
echo "# Test the installation to remote machines #"
echo "############################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
version_arch="TRUST-$TRUST_VERSION.tar.gz"
installation=1
machine1=`liste_machines "\-remote_install_TRUST_with_source"                 | head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [[ "$liste_machines_KO" != *"$machine1"* ]] # Test si machine n est pas dans la liste des machines KO
then
   remote1="-remote "`liste_machines "\-remote_install_TRUST_with_source"                 | head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
else
   remote1="-remote "`liste_machines "\-remote_install_TRUST_with_source"                 | tail -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
fi
machine2=`liste_machines "\-remote_install_TRUST_kernel_only"                 | head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [[ "$liste_machines_KO" != *"$machine2"* ]] # Test si machine n est pas dans la liste des machines KO
then
   remote2="-remote "`liste_machines "\-remote_install_TRUST_kernel_only"                 | head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
else
   remote2="-remote "`liste_machines "\-remote_install_TRUST_kernel_only"                 | tail -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
fi
# Version sans source devenue inutile depuis le passage en OpenSource
#remote3="-remote "`liste_machines "\-remote_install_TRUST_without_source"                 | head -1 | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
remote1_log=$REP_NUIT"/simule_install_TRUST_with_source_"`echo ${remote1##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote1_log
echo>>$remote1_log
remote2_log=$REP_NUIT"/simule_install_TRUST_kernel_only_"`echo ${remote2##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote2_log
echo>>$remote2_log
#remote3_log=$REP_NUIT"/simule_install_TRUST_without_source_"`echo ${remote3##* }`".log"
#echo "TRUST script on $HOST the `date` ...">$remote3_log
#echo>>$remote3_log
cd $GRAVAGE
echo "Call to $TRUST_ROOT/bin/admin/simule_install_TRUST $version_arch $remote1"
echo "  See $remote1_log"
echo "Call to $TRUST_ROOT/bin/admin/extract_Version_TRUST $version_arch -install $remote2 -kernel_only"
echo "  See $remote2_log"
#echo "Call to $TRUST_ROOT/bin/admin/extract_Version_TRUST $version_arch -install $remote3 -without_source"
#echo "  See $remote3_log"
# Test d'une extraction/installation d'une version avec les sources
(
simule_install_TRUST ./$version_arch $remote1                                         1>>$remote1_log 2>&1
echo " "
if [ "`grep "^BUILD_" $remote1_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote1_log 2>/dev/null`" != "" ]
then
   echo "Installation KO -with_source on $remote1"
   cat $remote1_log | mail_ -s\"[lance_test_nuit] Remote install with source failed on ${remote1##* }\" $TRUST_MAIL
   cp $remote1_log $TRUST_ROOT/simule_install_TRUST.log
else
   echo "Installation OK -with_source on $remote1"
fi
grep "Installation KO" $remote1_log
grep "^BUILD_" $remote1_log
) &
installation_id1=$!
# Test d'une extraction/installation d'une version kernel
(
extract_Version_TRUST ./$version_arch -install $remote2 -kernel_only                 1>>$remote2_log 2>&1
echo " "
if [ "`grep "^BUILD_" $remote2_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote2_log 2>/dev/null`" != "" ]
then
   echo "Installation KO -kernel_only on $remote2"
   cat $remote2_log | mail_ -s\"[lance_test_nuit] Remote install kernel only failed on ${remote2##* }\" $TRUST_MAIL
   cp $remote2_log $TRUST_ROOT/simule_install_TRUST_kernel_only.log
else
   echo "Installation OK -kernel_only on $remote2"
fi
grep "Installation KO" $remote2_log
grep "^BUILD_" $remote2_log
) &
installation_id2=$!
# Test d'une extraction/installation d'une version sans les sources
#(
#extract_Version_TRUST ./$version_arch -install $remote3 -without_source         1>>$remote3_log 2>&1
#echo " "
#if [ "`grep "BUILD_" $remote3_log | grep "KO" 2>/dev/null`" != "" ] || [ "`grep "Installation KO" $remote3_log 2>/dev/null`" != "" ]
#then
#   echo "Installation KO -without_source on $remote3"
#   cat $remote3_log | mail_ -s\"[lance_test_nuit] Remote install without source failed on ${remote3##* }\" $TRUST_MAIL
#   cp $remote3_log $TRUST_ROOT/simule_install_TRUST_without_source.log
#else
#   echo "Installation OK -without_source on $remote3"
#fi
#grep "Installation KO" $remote3_log
#grep "BUILD_" $remote3_log
#) &
#installation_id3=$!
# On attend la fin des installations lancees en parallele
#wait $installation_id1 $installation_id2 $installation_id3 1>/dev/null 2>&1
wait $installation_id1 $installation_id2 1>/dev/null 2>&1
# S'il n'y a pas de logs, c'est que les installations ont toutes reussies
NB=`ls $REP_NUIT/simule_install_TRUST*.log 2>/dev/null | wc -l`
KO=`ls $TRUST_ROOT/simule_install_TRUST*.log 2>/dev/null | wc -l`
let OK=$NB-$KO
[ $NB = 0 ] && installation=0
[ $KO != 0 ] && installation=0
rm -f $TRUST_ROOT/simule_install_TRUST*.log
################################
# Test de la taille du DVD grave
################################
echo " "
echo "Test the size of the $version_arch package if it can be written to a DVD"
limite_Mo=2000
package_size=`ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{print $5/1000000}'`
export package_size=`printf '%0.f' $package_size`
if [ "`ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{if ($5>limite_Mo*1000000) print "KO"}'`" = KO ]
then
   msg="The package $version_arch on $GRAVAGE is too large ($package_size>"$limite_Mo"Mo) to be written to a DVD."
   tmp=`mktemp_`
   echo $msg > $tmp
   echo "More large files (>2Mo) in each VOB:" >> $tmp
   (
   cd $TRUST_ROOT
   for contenu in *gz.files
   do
      VOB=${contenu%.tar.gz.files}
      cd $TRUST_ROOT/../$VOB
      echo $VOB >> $tmp
      for file in `cat $TRUST_ROOT/$contenu`
      do
         [ -f $file ] && echo $file
      done | xargs ls -l | awk '{if ($5>2000000) print $5" "$NF}' | sort -nr >> $tmp
      cd - 1>/dev/null 2>&1
   done
   )
   cat $tmp | mail_ -s\"[lance_test_nuit] Problem of $version_arch package size that is too large to be delivered.\" $TRUST_MAIL
   cat $tmp
   rm -f $tmp
   installation=0
   echo "  Size $package_size > "$limite_Mo"Mo KO"
elif [ $package_size = 0 ]
then
   installation=0
   echo "  Size $package_size >< "$limite_Mo"Mo KO"
else
   echo "  Size $package_size < "$limite_Mo"Mo OK"
fi
cd - 1>/dev/null 2>&1
echo " "
if [ $installation = 1 ]
then
   echo "Release criterion: Installation OK"
else
   echo "Release criterion: Installation KO"
fi
force_installation=~/force_installation && [ -f $force_installation ] && installation=1 && rm -f $force_installation
[ "$NB" -eq 0 ] && NB=-1
if [ "$NB" -eq -1 ]
then
   echo "$installation  Installation $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" + size="$package_size"Mo (=1+size<"$limite_Mo"Mo)" >> $MESSAGES_NUIT
   NB=0
else
   echo "$installation  Installation $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" + size="$package_size"Mo (=1+size<"$limite_Mo"Mo)" >> $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$installation
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################################################
# Attente jusqu'a pour attendre le retour des compilations eloignees:
#####################################################################
# sauf le week-end (on attend le dimanche car lance_test_nuit via crontab non lance le week-end)
if [ "`date '+%u'`" -lt 6 ]
then
   while [ `date '+%H'` -lt 6 ] || [ `date '+%H'` -gt 21 ]
   do
      sleep 30
   done
else
   # Attente jusqu'au lundi matin
   while [ "`date '+%u'`" -gt 5 ]
   do
      sleep 30
   done
fi

#####################################################
# Arret de la portabilite des baltik si non terminee:
#####################################################
echo " "
echo "##########################################"
echo "# Verify the end of baltik portabilities #"
echo "##########################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
for Composant in $Composants
do
   if [ -d $TRUST_ROOT/../Composants/$Composant ]
   then
      cd $TRUST_ROOT/../Composants/$Composant
      echo "Check $Composant"
      if [ ! -f  nuit_$Composant.html ] # Fichier non cree donc portabilite non terminee
      then
         #nbtot=`sed -n '$=' Run.liste` # Nombre total de machines surlesquelles c est teste
         (grep PID $Composant*.log | grep start | awk '{$NF=""; print $0}') 1>start.liste 2>/dev/null # Nombre de start (4 x nbtot)
         (grep PID $Composant*.log | grep stop | awk '{$NF=""; print $0}') 1>stop.liste 2>/dev/null # Nombre de stop
         sort start.liste stop.liste | uniq -u 1>kill.liste 2>/dev/null # Pour chaque start non stoppe, recuperer le nom de la machine et le PID
         if [ `cat kill.liste | wc -l` = 0 ]
         then
            echo "  => The portability was NOT launched"
         else
            cat kill.liste
            echo "  => KO: portability is NOT finished"
            old_IFS=$IFS  # sauvegarde du separateur de champ
            IFS=$'\n'     # nouveau separateur de champ, le caractere fin de ligne
            for line in $(cat kill.liste)
            do
              (
               PID=`echo $line | awk '{print $(NF)}'`
               adr=`echo $line | awk -F"@" '{print $2}' | awk -F"_" '{print $1}'`
               log=`echo $line | awk -F"@" '{print $1}' | awk -F"%" '{print $2}' | awk -F"_" '{print $2}'`
               machine=`echo $adr | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`
               BATCHMODE=" -o BatchMode=yes "
               SSHP=""
               if [ "`liste_machines ssh_pass | grep $adr`" != "" ]
               then
                  SSHPASS=`awk -v adr=$adr '($2==adr) {print $6}' ~/.netrc | head -1`
                  SSHP="sshpass -p $SSHPASS "
                  BATCHMODE=""
               fi
               WORKTMP=`$SSHP ssh_ $BATCHMODE $log@$adr -n 'if [ "\$WORKDIR" = "" ]; then echo \$HOME;else echo \$WORKDIR;fi'`
               echo "  Treatment of $PID on $machine"
               pids=$($SSHP ssh $log@$adr $WORKTMP/$WORKBASE$machine/TRUST/bin/baltik/share/baltik/bin/portability/list_pid_et_fils.sh $PID)
               echo "    ssh $log@$adr scancel $pids"
               $SSHP ssh $log@$adr scancel $pids
               $SSHP ssh $log@$adr scancel $pids
               echo "    ssh $log@$adr kill -9 $pids   # scancel ne marche pas sur pc"
               #ssh $log@$adr kill -19 $pids
               $SSHP ssh $log@$adr kill -9 $pids
              )
            done
            IFS=$old_IFS  # retablissement du separateur de champ par defaut
         fi
         rm -f start.liste stop.liste kill.liste
      else
         echo "  => OK: portability is finished"
         cp nuit_$Composant.html $REP_NUIT/nuit_$Composant.html
      fi
   fi
done
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#####################################################################
# Attente 1h pour attendre le retour des portabilites eloignees:
#####################################################################
if [ "`date '+%u'`" -lt 6 ]
then
   while [ `date '+%H'` -lt 7 ] || [ `date '+%H'` -gt 21 ]
   do
      sleep 30
   done
else
   while [ "`date '+%u'`" -gt 5 ]
   do
      sleep 30
   done
fi

#######################################################
# Arret des etudes lancees a distance si non terminees:
#######################################################
echo " "
echo "#################################"
echo "# Verify the end of studies run #"
echo "#################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $ETUDES
echo "Check $ETUDES"
if [ $etude_activation = 0 ]
then
   echo "  => The run_Etudes was NOT launched"
else
   if [ -f run_Etudes.log ] # Fichier non deplace dans REP_NUIT donc run non termine
   then
      grep PID run_Etudes.log
      echo "  => KO: run_Etudes is NOT finished"
      PID=`grep PID run_Etudes.log | grep start | awk '{$NF=""; print $0}' | awk '{print $(NF)}'`
      pids=$($TRUST_ROOT/bin/baltik/share/baltik/bin/portability/list_pid_et_fils.sh $PID)
      echo "    kill -9 $pids"
      echo "    KO: to do manually and check scancel on cluster" # Temporary
      #kill -19 $pids
      #kill -9 $pids
   else
      echo "  => OK: run_Etudes is finished"
   fi
fi
cd $TRUST_ROOT
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########################################################
# Recupere les executables et divers fichiers sur machines
##########################################################
echo " "
echo "#####################################################"
echo "# Receive from remote machines and copy on ftp site #"
echo "#####################################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
cd $TRUST_ROOT
export binaire=1
recupere_log=$REP_NUIT/recupere_TRUST_arch_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/recupere_TRUST_arch"
echo "  See $recupere_log"
echo "TRUST script on $HOST the `date` ...">$recupere_log
echo>>$recupere_log
# pour le lance seul :
# cd $TRUST_ROOT/bin/admin
# export new=`awk '/version/ {print $4;exit}' $TRUST_ROOT/RELEASE_NOTES`
# export Version=Version$new
# export DATE=`date '+%d%m%y'`
# REP_NUIT=/data/tmptrust/tmptrust/Historique/NUIT
# recupere_log=$REP_NUIT/recupere_TRUST_arch_$HOST.log
# recupere_TRUST_arch 1>>$recupere_log 2>&1
# cd $TRUST_ROOT
# envoie_ftp_log=$REP_NUIT/envoie_ftp_cea_fr_$HOST.log
# echo "TRUST script on $HOST the `date` ...">$envoie_ftp_log
# echo>>$envoie_ftp_log
# envoie_ftp_cea_fr 1>>$envoie_ftp_log 2>&1
recupere_TRUST_arch 1>>$recupere_log 2>&1
grep KO $recupere_log
grep -i portage $recupere_log
if [ ${#liste_machines_KO} != 0 ] # chaine non vide
then
   echo "  Recall liste_machines_KO:"
   echo $liste_machines_KO
fi
echo "  Creation of $REP_NUIT/NUIT.html"
ls -la $REP_NUIT"/NUIT.html"
cd $TRUST_ROOT

for file in `ls $REP_NUIT/install_patch_*.log 2>/dev/null`
do
   echo " "
   echo "Analysis of $file file"
   head -n4 $file | tail -n1
   grep "BUILD_" $file
   grep error $file
   grep Stop $file
   grep KO $file
done

for file in `ls $REP_NUIT/lance_test_*.log 2>/dev/null`
do
   echo " "
   echo "Analysis of $file file"
   fic_test=`grep "Complete results into the file" -A 1 $file | tail -n 1`
   grep "Error:" $fic_test
   grep "Successful tests cases" $fic_test
done

echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##################
# Stabilite TRUST
##################
echo " "
echo "############################"
echo "# Test the TRUST stability #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
rm -f tmp.log
#fic_test=$TRUST_ROOT"/exec/.tests_TRUST"$COMM
#echo "Analysis of "$fic_test" file" | tee -a tmp.log
#grep "Successful tests cases" $fic_test | tee -a tmp.log
#echo " " | tee -a tmp.log
fic_test=$TRUST_ROOT"/exec/.tests_TRUST"$COMM"_semi_opt" | tee -a tmp.log
echo "Analysis of "$fic_test" file" | tee -a tmp.log
grep "Successful tests cases" $fic_test | tee -a tmp.log
echo " " | tee -a tmp.log
if [ -f $fic_test ]
then
   stabilite1=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | head -1`
   stabilite2=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | tail -1`
   if [  "$stabilite1" = "1.000" ]
   then
      stabilite=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | tail -1`
      rstab=`$TRUST_Awk -F':' 'BEGIN {} /Successful tests cases/ {print $2}' $fic_test |  tail -1`
   else
      stabilite=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | head -1`
      rstab=`$TRUST_Awk -F':' 'BEGIN {} /Successful tests cases/ {print $2}' $fic_test | head -1`
   fi
else
   stabilite="0.000"
   rstab="0/0"
fi
if [ "$stabilite" = "1.000" ]
then
   echo "Release criterion: Stability OK"
else
   echo "Release criterion: Stability KO"
   cat tmp.log | mail_ -s\"[lance_test_nuit] $rstab=$stabilite TRUST stability KO\" $TRUST_MAIL
fi
force_stabilite=~/force_stabilite && [ -f $force_stabilite ] && stabilite="1.000" && rm -f $force_stabilite
echo `if [ "$stabilite" = "1.000" ]; then echo 1;else echo 0;fi`"  Stability $rstab=$stabilite (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+`if [ "$stabilite" = "1.000" ]; then echo 1;else echo 0;fi`
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

####################
# Portabilite TRUST
####################
echo " "
echo "###############################"
echo "# Test the TRUST portability #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step TRUST" $recupere_log
grep "step TRUST" $recupere_log | grep -v "1.000" > tmp.log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html | tee -a tmp.log
grep "TRUST portability" $REP_NUIT/NUIT.html
all_cible=`$TRUST_Awk '/Total number portability/ {print $9}' $REP_NUIT/NUIT.html`
nb_cible=`$TRUST_Awk '/Total number portability/ {print $7}' $REP_NUIT/NUIT.html`
portabilite_test=`$TRUST_Awk '/TRUST portability/ {print $1}' $REP_NUIT/NUIT.html`
portabilite_trust=`$TRUST_Awk '/TRUST portability/ {print $6}' $REP_NUIT/NUIT.html`
portabilite=0 && [ "`grep "Portable version" $REP_NUIT/NUIT.html`" != "" ] && portabilite=1
echo " "
if [ $portabilite = 1 ]
then
   echo "Release criterion: TRUST  OK"
else
   echo "Release criterion: TRUST  KO"
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST portability KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_portabilite=~/force_portabilite && [ -f $force_portabilite ] && portabilite=1 && rm -f $force_portabilite
limite=0.99 # cf recupere_TRUST_arch
echo "$portabilite  Portability $portabilite_trust=$portabilite_test + nb=$nb_cible (>$limite+nb=$all_cible)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$portabilite
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
force_cible=~/force_cible && [ -f $force_cible ] && nb_cible=$all_cible && rm -f $force_cible

###################
# Test d'un atelier
###################
echo " "
echo "#####################################"
echo "# Test the compilation of a atelier #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step atelier" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "TRUST atelier compilation" $REP_NUIT/NUIT.html
make_atelier=`$TRUST_Awk '/atelier compilation/ && /TRUST/ {print $1}' $REP_NUIT/NUIT.html`
port_atelier=`$TRUST_Awk '/atelier compilation/ && /TRUST/ {print $7}' $REP_NUIT/NUIT.html`
workshop=0
[ "$make_atelier" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && workshop=1
echo " "
grep "ATELIER=KO" $REP_NUIT/CR_* > tmp.log
if [ $workshop = 1 ]
then
   echo "Release criterion: Atelier OK"
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST atelier KO on host:\" $TRUST_MAIL
else
   echo "Release criterion: Atelier KO"
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST atelier KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_make_atelier=~/force_make_atelier && [ -f $force_make_atelier ] && workshop=1 && rm -f $force_make_atelier
echo "$workshop  Atelier $port_atelier=$make_atelier (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$workshop
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#######################
# Portabilite de BALTIK
#######################
echo " "
echo "###############################"
echo "# Test the Baltik portability #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step Baltik" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "Baltik portability" $REP_NUIT/NUIT.html
portabilite_baltik=`$TRUST_Awk '/Baltik portability/ && /TRUST/ {print $1}' $REP_NUIT/NUIT.html`
port_baltik=`$TRUST_Awk '/Baltik portability/ && /TRUST/ {print $8}' $REP_NUIT/NUIT.html`
testbaltik=0
[ "$portabilite_baltik" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && testbaltik=1
echo " "
grep "BALTIK=KO" $REP_NUIT/CR_* > tmp.log
if [ $testbaltik = 1 ]
then
   echo "Release criterion: Baltik  OK"
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST baltik KO on host:\" $TRUST_MAIL
else
   echo "Release criterion: Baltik  KO"
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST baltik KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_portabilite_baltik=~/force_portabilite_baltik && [ -f $force_portabilite_baltik ] && testbaltik=1 && rm -f $force_portabilite_baltik
echo "$testbaltik  Baltik $port_baltik=$portabilite_baltik (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$testbaltik
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

################################
# Test des assert de compilation
################################
echo " "
echo "###############################"
echo "# Test the compilation assert #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $recupere_log file"
grep "step assert" $recupere_log
echo "Analysis of $REP_NUIT/NUIT.html file"
grep "Total number portability" $REP_NUIT/NUIT.html
grep "Compilation assert test" $REP_NUIT/NUIT.html
test_assert=`$TRUST_Awk '/Compilation assert/ {print $1}' $REP_NUIT/NUIT.html`
port_assert=`$TRUST_Awk '/Compilation assert/ {print $7}' $REP_NUIT/NUIT.html`
assert=0
[ "$test_assert" = "1.000" ] && [ "$nb_cible" = "$all_cible" ] && assert=1
echo " "
grep "ASSERT=KO" $REP_NUIT/CR_* > tmp.log
if [ $assert = 1 ]
then
   echo "Release criterion: Assert OK"
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST assert KO on host:\" $TRUST_MAIL
else
   echo "Release criterion: Assert KO"
   grep "Empty PERF report of" $recupere_log >> tmp.log
   grep "No PERF report of" $recupere_log >> tmp.log
   [ -s tmp.log ] && cat tmp.log | mail_ -s\"[lance_test_nuit] TRUST assert KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
force_test_assert=~/force_test_assert && [ -f $force_test_assert ] && assert=1 && rm -f $force_test_assert
echo "$assert  Assert $port_assert=$test_assert (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$assert
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

############################
# Disponibilite des binaires
############################
# echo " "
# echo "######################################"
# echo "# Test the disponibility of binaries #"
# echo "######################################"
# echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
# nb_binaires=0
# porta_binaires=0
# dispo_binaires=0
# disponibilite_binaires=0
# machine=`liste_machines "get_binary" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}' | head -1`
# echo "Analysis of $WORKDIR/portages/PORTAGE_$new directory"
# binaires=`ls $WORKDIR/portages/PORTAGE_$new/*/TRUST/exec/TRUST*opt* 2>/dev/null`
# [ "$binaires" = "" ] && echo "See $REP_NUIT/CR_$machine" | mail_ -s\"[lance_test_nuit] No binary created under $WORKDIR/portages/PORTAGE_$new/*/TRUST/exec\" $TRUST_MAIL
# for binaire in $binaires
# do
#    let nb_binaires=$nb_binaires+1
#    cd $TRUST_TMP
#    rm -f nul.data
#    touch nul.data
#    echo $ECHO_OPTS "  Test of binary $binaire \c"
#    $binaire nul 1>binaire.out 2>&1
#    if [ $? != 0 ]
#    then
#       echo "KO"
#       cat binaire.out | mail_ -s\"[lance_test_nuit] Binary $binaire KO\" $TRUST_MAIL
#    else
#       let porta_binaires=$porta_binaires+1
#      echo "OK"
#    fi
#    cd - 1>/dev/null 2>&1
# done
# [ "$nb_binaires" != 0 ] && dispo_binaires=`echo $porta_binaires | $TRUST_Awk -v n=$nb_binaires '{print "scale=3\n"$1"/"n}' | bc -l`
# disponibilite_binaires=`echo $dispo_binaires | $TRUST_Awk '{if ($1>=1) print 1;else print 0}'`
# echo " "
# if [ $disponibilite_binaires = 1 ]
# then
#    echo "Release criterion: Binaries OK"
# else
#    echo "Release criterion: Binaries KO"
# fi
# force_disponibilite_binaires=~/force_disponibilite_binaires && [ -f $force_disponibilite_binaires ] && disponibilite_binaires=1 && rm -f $force_disponibilite_binaires
# echo "$disponibilite_binaires  Binairies $porta_binaires/$nb_binaires=$dispo_binaires (=1)" >> $MESSAGES_NUIT
# let total_criteres=$total_criteres+1
# let criteres_remplis=$criteres_remplis+$disponibilite_binaires
# echo "<--- End at "`date '+%H:%M:%S %d/%m'`

############
# Test XData
############
echo " "
echo "##################################"
echo "# Verify the validation of XData #"
echo "##################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
validation_xdata=""
machines_=`liste_machines "\-xdata"`
machines=`liste_machines "\-xdata" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -xdata on $machines"
# Si une machine a XData qui fonctionne c'est OK
for machine_ in $machines_
do
   machine=`echo $machine_ | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
   check_xdata_log=$REP_NUIT"/check_xdata_"$machine".log"
   rm -f $check_xdata_log
   log=`awk -v adr=$machine_ '($2==adr) {print $4}' ~/.netrc | head -1`
   BATCHMODE=" -o BatchMode=yes "
   SSHP=""
   if [ "`liste_machines ssh_pass | grep $machine`" != "" ]
   then
      SSHPASS=`awk -v adr=$machine_ '($2==adr) {print $6}' ~/.netrc | head -1`
      SSHP="sshpass -p $SSHPASS "
      BATCHMODE=""
   fi
   if  [ "`$SSHP ssh_ -o ConnectTimeout=30 $BATCHMODE $log@$machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "  KO $machine machine not accessible via ssh."
      echo "  No $check_xdata_log"
      validation_xdata=0
      echo | mail_ -s\"[lance_test_nuit] Error when receiving XData log from $machine not accessible via ssh.\" $TRUST_MAIL
   else
      echo "  See $check_xdata_log"

      workdir=`$SSHP ssh $log@$machine -n 'echo $WORKDIR'`
      if  [ "${machine:0:2}" = "is" ]
      then
         $SSHP scp $log@$machine:$workdir/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log 1>/dev/null 2>&1
         scp_error=$?
      else
         $SSHP scp $log@$machine:~/.tmp_TRUST_$machine/check_xdata.log $check_xdata_log
         scp_error=$?
      fi
      if [ $scp_error != 0 ]
      then
         echo | mail_ -s\"[lance_test_nuit] Error when receiving XData log from $machine. Check if not finished.\" $TRUST_MAIL
      else
         grep 'XDATA=' $check_xdata_log
      fi
      rm -f $scp_error
      if [ "`grep 'XDATA=OK' $check_xdata_log 2>/dev/null`" != "" ]
      then
         validation_xdata=1
      else
         [ "$validation_xdata" = "" ] && validation_xdata=0
         [ -f $check_xdata_log ] && cat $check_xdata_log | mail_ -s\"[lance_test_nuit] Check XData on $machine KO\" $TRUST_MAIL
      fi
   fi
done
echo " "
if [ $validation_xdata = 1 ]
then
   echo "Release criterion: XData OK"
else
   echo "Release criterion: XData KO"
fi
force_validation_xdata=~/force_validation_xdata && [ -f $force_validation_xdata ] && validation_xdata=1 && rm -f $force_validation_xdata
echo "$validation_xdata  XData $validation_xdata (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_xdata
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########################
# Verification des modules
##########################
#echo " "
#echo "####################################"
#echo "# Verify the validation of Modules #"
#echo "####################################"
#echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
#activation_verification_modules=0 # Non actualise
#if [ $activation_verification_modules = 1 ]
#then
#   cd $TRUST_ROOT/Validation/Modules
#   # Lancement d'un cas test par module:
#   echo "Call to $TRUST_ROOT/Validation/Modules/Test.sh"
#   ./Test.sh
#   if [ $? != 0 ]
#   then
#      echo "  Error in one case per module"
#      echo " "
#      echo "Release criterion: Modules KO"
#   else
#      echo "  Launching of one case per module OK"
#      # Recuperation de tous les cas tests par module
#      modules=`cd $TRUST_ROOT/Validation/Modules;ls */cree_liste_cas | $TRUST_Awk -F/ '{print $1}'`
#      echo " "
#      if [ "${#modules}" = 0 ]
#      then
#         ok=0
#         nb=-1
#         echo "Zero module in $TRUST_ROOT/Validation/Modules directory"
#      else
#         echo "Modules in $TRUST_ROOT/Validation/Modules directory:"
#         echo modules
#         ok=0
#         nb=0
#         for module in $modules
#         do
#            echo " "
#            echo "Verification of $TRUST_ROOT/Validation/Modules/$module"
#            cd $TRUST_ROOT/Validation/Modules/$module
#            rm -f $module.log
#            machine=`liste_machines "\-verification_module_$module"`
#            if [ "$machine" != "" ]
#            then
#               let nb=$nb+1
#               hostname=`echo $machine | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
#               module_log=$REP_NUIT"/Modules_"$module"_"$hostname".log"
#               echo "  Receive tests of $module module from $hostname"
#               log=`awk -v adr=$machine '($2==adr) {print $4}' ~/.netrc | head -1`
#               scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/$module.log . 2>/dev/null
#               scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/compare_resultat.log . 2>/dev/null
#               # On efface les rapports precedants
#               rm -f .tests_TRUST_*
#               scp $log@$machine:~/$WORKBASE$hostname/TRUST/Validation/Modules/$module/.tests_TRUST_* . 2>/dev/null
#               if [ ! -f $module.log ]
#               then
#                  echo | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host no made or no recovered.\" $TRUST_MAIL
#               else
#                  if [ "`grep $module=OK $module.log 2>/dev/null`" != "" ]
#                  then
#                     let ok=$ok+1
#                  else
#                     if [ "`grep $module=KO $module.log 2>/dev/null`" != "" ]
#                     then
#                        [ ! -f compare_resultat.log ] && ../compare_resultat .tests_TRUST_mpi_*
#                        cat compare_resultat.log | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host KO\" $TMA_PROJECT_LEADER $TRUST_MAIL
#                     else
#                        cat .tests_TRUST_mpi_* | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host not finished\" $TRUST_MAIL
#                     fi
#                  fi
#                  # Mise a jour de la reference
#                  if [ "`grep 'On change la reference' $module.log`" != "" ]
#                  then
#                     echo "  Update reference of $module module"
#                     CHECKOUT res_test_ref 1>/dev/null 2>&1
#                     new_rapport=`ls -rt .tests_TRUST_* | grep -v KO | grep -v OK 2>/dev/null | tail -1`
#                     [ "$new_rapport" != "" ] && cat $new_rapport > res_test_ref
#                  fi
#               fi
#               # Faire une page html regroupant l'ensemble des resultats
#            fi
#         done
#         [ $nb -eq 0 ] && nb=-1
#      fi
#      verification_modules=0 && [ $ok -eq $nb ] && verification_modules=1
#      echo " "
#      if [ $verification_modules = 1 ]
#      then
#         echo "Release criterion: Modules OK"
#      else
#         echo "Release criterion: Modules KO"
#      fi
#      force_verification_modules=~/force_verification_modules && [ -f $force_verification_modules ] && verification_modules=1 && rm -f $force_verification_modules
#      echo "$verification_modules  Modules $ok/$nb="`echo $ECHO_OPTS "scale=3;$ok/$nb" | bc -l`" (=1.000)" >> $MESSAGES_NUIT
#      let total_criteres=$total_criteres+1
#      let criteres_remplis=$criteres_remplis+$verification_modules
#   fi
#   cd $TRUST_ROOT
#else
#   echo "NOT executed"
#fi
#echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########
# Valgrind
##########
echo " "
echo "#####################################"
echo "# Verify the validation of Valgrind #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
# Recuperer le ANA.log sur les machines valgrind
cd $TRUST_ROOT/Validation/Valgrind
Build=$TRUST_ROOT/build/Validation/Valgrind
[ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
rm -f $Build/ANA_*.log $Build/casmem_* $Build/caserr_*
machines_=`liste_machines "\-check-valgrind"`
machines=`liste_machines "\-check-valgrind" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
if [ ${#machines} = 0 ]
then
   valgrind=0
else
   valgrind=1
   echo "Validation by -valgrind on"
   echo $machines
   echo " "
fi
for machine_ in $machines_
do
   machine=`echo $machine_ | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
   valgrind_log=$Build"/ANA_"$machine".log"
   log=`awk -v adr=$machine_ '($2==adr) {print $4}' ~/.netrc | head -1`
   BATCHMODE=" -o BatchMode=yes "
   SSHP=""
   if [ "`liste_machines ssh_pass | grep $machine`" != "" ]
   then
      SSHPASS=`awk -v adr=$machine_ '($2==adr) {print $6}' ~/.netrc | head -1`
      SSHP="sshpass -p $SSHPASS "
      BATCHMODE=""
   fi
   if  [ "`$SSHP ssh_ -o ConnectTimeout=30 $BATCHMODE $log@$machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "  KO $machine machine not accessible via ssh."
      echo "  No $valgrind_log"
      valgrind=0
      echo | mail_ -s\"[lance_test_nuit] Error when receiving Valgrind log from $machine not accessible via ssh.\" $TRUST_MAIL
   else
      echo "Verification of $valgrind_log"
      log=`awk -v adr=$machine_ '($2==adr) {print $4}' ~/.netrc | head -1`
      workdir=`$SSHP ssh $log@$machine -n 'echo $WORKDIR'`
      if [ "${machine:0:2}" = "is" ]
      then
         $SSHP scp $log@$machine:$workdir/.tmp_TRUST_$machine/ANA.log $valgrind_log 1>/dev/null 2>&1
         scp_error=$?
      else
         $SSHP scp $log@$machine:~/.tmp_TRUST_$machine/ANA.log $valgrind_log
         scp_error=$?
      fi
      if [ $scp_error != 0 ]
      then
         echo | mail_ -s\"[lance_test_nuit] Error when receiving Valgrind log from $machine. Check if not finished.\" $TRUST_MAIL
      fi
      rm -f $scp_error
      sleep 1
      if [ ! -f $valgrind_log ]
      then
         echo "  valgrind not finished"
         valgrind=0
      else
         if [ "${machine:0:2}" = "is" ]
         then
            $SSHP scp $log@$machine:$workdir/.tmp_TRUST_$machine/casmem $Build/casmem_$machine 1>/dev/null 2>&1
         else
            $SSHP scp $log@$machine:~/.tmp_TRUST_$machine/casmem $Build/casmem_$machine
         fi
         # [ ! -s $valgrind_log ] && echo "  Empty file" && valgrind=0
         cat $valgrind_log 2>/dev/null | $TRUST_Awk -F: '/ errors from /{gsub("\\.val","",$2);print $2}' > $Build/caserr_$machine
         valgrind_max=0
         valgrind_err=`cat $Build/caserr_$machine 2>/dev/null | wc -l`
         # On supprime les cas de casmem qui se retrouvent dans liste (cas qui se sont arretes)
         grep -v -f $TRUST_ROOT/exec/tests_TRUST$COMM"_semi_opt"/liste $Build/casmem_$machine > cas
         valgrind_leak=`cat cas 2>/dev/null | wc -l`
         rm -f cas
         let valgrind_err=$valgrind_err+$valgrind_leak
         echo "  valgrind $valgrind_err errors including $valgrind_leak memory leak ($valgrind_err<=$valgrind_max)"
         [ ! $valgrind_err = 0 ] && echo "    See $Build/caserr_$machine" #&& cat $Build/caserr_$machine
         [ ! $valgrind_leak = 0 ] && echo "    See $Build/casmem_$machine" #&& cat $Build/casmem_$machine
         if [ ${#valgrind_err} = 0 ] || [ $valgrind_err -gt $valgrind_max ]
         then
            valgrind=0
            # Envoi d'un mail pour prevenir immediatement
            cat $Build/caserr_$machine $Build/casmem_$machine >> $TRUST_TMP/cas
            if [ -s $TRUST_TMP/cas ]
            then
               log_filtre=`mktemp_`
               grep -v -f $TRUST_ROOT/exec/tests_TRUST$COMM"_semi_opt"/liste $valgrind_log 1>$log_filtre 2>&1
               echo "-----------" >>$log_filtre
               cat $TRUST_TMP/cas >>$log_filtre
               [ -s $log_filtre ] && cat $log_filtre | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects TRUST errors on $machine host\" $TRUST_MAIL
               rm -f $log_filtre
            fi
         fi
      fi
   fi
done
cd $TRUST_ROOT
echo " "
for Composant in $Composants
do
   PROJECT_ROOT=`dirname $TRUST_ROOT`/Composants/$Composant
   rm tmp.log 2>/dev/null
   for machine in $machines
   do
      # Check if valgrind for this composant:
      grep valgrind $PROJECT_ROOT/*$Composant*$machine.*prepare.log 2>/dev/null > list.log
      if [ -s list.log ]
      then
         echo "Verification of baltik $Composant on $machine"
         grep "make_check " $PROJECT_ROOT/*$Composant*$machine.*make_check.log 2>/dev/null
         [ $? != 0 ] && valgrind=0 && cat list.log >> tmp.log
         testko=`grep "make_check KO" $PROJECT_ROOT/*$Composant*$machine.*make_check.log`
         if [ "$testko" != "" ]
         then
            echo $testko
            echo $machine >> tmp.log
            grep " CORE " $PROJECT_ROOT/*$Composant*$machine.*make_check.log | awk -F"|" '{print $NF}' >> tmp.log
            echo " " >> tmp.log
            # on retire Front_tracking_IJK, polymac, triomc et mathys du critere de livraison TRUST/TrioCFD
            if [ "$Composant" != Front_tracking_IJK ] && [[ "$ComposantsBeta" != *"$Composant"* ]]
            then
                valgrind=0
            fi
         fi
      fi
      rm list.log
    done
    if [ -s tmp.log ]
    then
       echo " "
       if [[ "$ComposantsGit" = *"$Composant"* ]] # Test si Composant est dans la liste des composants GIT
       then
           BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
       else
          BALTIK_PROJECT_LEADER="TRUST_PROJECT_LEADER"
       fi
       cat tmp.log | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects $Composant errors on host:\" ${!BALTIK_PROJECT_LEADER} $TRUST_MAIL # $TMA_PROJECT_LEADER
    fi
    rm tmp.log 2>/dev/null
done
echo " "
echo "Analysis of $REP_NUIT/CR_* files"
OK=`grep "KVALGRIND=OK" $REP_NUIT/CR_* 2>/dev/null | wc -l`
KO=`grep "KVALGRIND=KO" $REP_NUIT/CR_* 2>/dev/null | wc -l`
let NB=$OK+$KO
if [ $KO != 0 ]
then
   grep "KVALGRIND=KO" $REP_NUIT/CR_*
   (
   grep "KVALGRIND=KO" $REP_NUIT/CR_*  | cut -d_ -f3 | mail_ -s\"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects TRUST errors with upwind test case on host:\" $TRUST_MAIL
   )
   #valgrind=0 # Test provisoire : en attente decision project leader
fi
echo " "
if [ $valgrind = 1 ]
then
   echo "Release criterion: Valgrind OK"
else
   echo "Release criterion: Valgrind KO"
fi
force_valgrind=~/force_valgrind && [ -f $force_valgrind ] && valgrind=1 && rm -f $force_valgrind
echo "$valgrind  Valgrind $valgrind (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$valgrind
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
echo " "
echo "############################"
echo "# Verify the code coverage #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
########
# GCOV #
########
repertoire_gcov=$TRUST_ROOT/MonoDir$COMM/src
machines=`liste_machines "\-all" "\-gcov"`
echo "Validation by -gcov on $machines"
if [ "$machines" = "" ]
then
   echo "  No coverage by gcov!!!"
   echo "Warning: No host -all -gcov in liste.machines! No coverage by gcov." | mail_ -s\"[lance_test_nuit] GCOV: NO coverage!!! \" $TRUST_MAIL
fi
for machine_gcov in $machines # Compilation avec -gcov et passage de tous les cas tests
do
   hostname=`echo $machine_gcov | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
   log=`awk -v adr=$machine_gcov '($2==adr) {print $4}' ~/.netrc | head -1`
   echo "  Recovery from $hostname"
   BATCHMODE=" -o BatchMode=yes "
   SSHP=""
   if [ "`liste_machines ssh_pass | grep $machine_gcov`" != "" ]
   then
      SSHPASS=`awk -v adr=$machine_gcov '($2==adr) {print $6}' ~/.netrc | head -1`
      SSHP="sshpass -p $SSHPASS "
      BATCHMODE=""
   fi
   if  [ "`$SSHP ssh_ -o ConnectTimeout=30 $BATCHMODE $log@$machine_gcov -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "    KO $machine_gcov machine not accessible via ssh."
      echo "    No $REP_NUIT/analyse_couverture_$hostname.log"
   else
      echo "    See $REP_NUIT/analyse_couverture_$hostname.log"
      workdir=`$SSHP ssh $log@$machine -n 'echo $WORKDIR'`
      if  [ "${hostname:0:2}" = "is" ]
      then
         $SSHP scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/tests/analyse_couverture.log $REP_NUIT/analyse_couverture_$hostname.log
         $SSHP scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/tests/GCDA/ana/monana_out $REP_NUIT/monana_out_$hostname.log
         $SSHP scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_out $REP_NUIT/gcov_out_$hostname.log
         $SSHP scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_err $REP_NUIT/gcov_err_$hostname.log
      else
         $SSHP scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/tests/analyse_couverture.log $REP_NUIT/analyse_couverture_$hostname.log
         $SSHP scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/monana_out $REP_NUIT/monana_out_$hostname.log
         $SSHP scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_out $REP_NUIT/gcov_out_$hostname.log
         $SSHP scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_err $REP_NUIT/gcov_err_$hostname.log
      fi
      # Copie cpp.gcov.tar.gz
      file=cpp.gcov.tar.gz
      #echo "    Copy $file to $TRUST_ROOT/doc/Coverage/" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
      echo "    Copy $file to $TRUST_TMP/"
      rm -f $TRUST_TMP/$file
      if  [ "${hostname:0:2}" = "is" ]
      then
         $SSHP scp $log@$machine_gcov:$workdir/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
      else
         $SSHP scp $log@$machine_gcov:~/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
      fi
      if [ "`diff $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file`" != "" ]
      then
         echo "    => updated"
         #CHECKOUT $TRUST_ROOT/doc/Coverage/$file 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         #mv -f $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file    # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
      else
         echo "    => NOT updated"
      fi
   fi
done
###########
# PROFILE #
###########
# Recuperer des informations de couverture du code (ce n'est pas encore un critere de livraison)
machines=`liste_machines "\-all" "\-prof"`
echo " "
echo "Validation by -prof on $machines"
if [ "$machines" = "" ]
then
   echo "  No coverage by prof!!!"
   echo "Warning: No host -all -prof in liste.machines! No coverage by prof." | mail_ -s\"[lance_test_nuit] PROFILE: NO coverage!!! \" $TRUST_MAIL
fi
for machine in $machines # Compilation avec -prof et passage de tous les cas tests
do
   cd $TRUST_ROOT/doc/Coverage
   hostname=`echo $machine | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
   log=`awk -v adr=$machine '($2==adr) {print $4}' ~/.netrc | head -1`
   BATCHMODE=" -o BatchMode=yes "
   SSHP=""
   if [ "`liste_machines ssh_pass | grep $machine`" != "" ]
   then
      SSHPASS=`awk -v adr=$machine '($2==adr) {print $6}' ~/.netrc | head -1`
      SSHP="sshpass -p $SSHPASS "
      BATCHMODE=""
   fi
   echo "  Recovery from $hostname"
   if  [ "`$SSHP ssh_ -o ConnectTimeout=30 $BATCHMODE $log@$machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      echo "    KO $machine machine not accessible via ssh."
      echo "    No $REP_NUIT/make_Couverture_$hostname.log"
   else
      echo "    See $REP_NUIT/make_Couverture_$hostname.log"
      workdir=`$SSHP ssh $log@$machine -n 'echo $WORKDIR'`
      if [ "${hostname:0:2}" = "is" ]
      then
         $SSHP scp $log@$machine:$workdir/.tmp_TRUST_$hostname/tests/make_Couverture.log $REP_NUIT/make_Couverture_$hostname.log
      else
         $SSHP scp $log@$machine:~/.tmp_TRUST_$hostname/tests/make_Couverture.log $REP_NUIT/make_Couverture_$hostname.log
      fi
      error_log=`grep "Problem with the gprof command" $REP_NUIT/make_Couverture_$hostname.log`
      [ ${#error_log} != 0 ] && cat $REP_NUIT/make_Couverture_$hostname.log | mail_ -s\"[lance_test_nuit] Problem with the gprof command on $hostname in make_Couverture\" $TRUST_MAIL
      # Copie file
      for file in list_methodes.gz list_methodes_non_appelees.gz dico.pkl.gz
      do
         #echo "    Copy $file to $TRUST_ROOT/doc/Coverage/" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         echo "    Copy $file to $TRUST_TMP/"
         rm -f $TRUST_TMP/$file
         if [ "${hostname:0:2}" = "is" ]
         then
            $SSHP scp $log@$machine:$workdir/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
         else
            $SSHP scp $log@$machine:~/.tmp_TRUST_$hostname/$file $TRUST_TMP/$file
         fi
         if [ -f $TRUST_TMP/$file ] && [ "`diff $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file`" != "" ]
         then
            echo "    => updated"
            #CHECKOUT $TRUST_ROOT/doc/Coverage/$file 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
            #mv -f $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file    # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         else
            echo "    => NOT updated"
         fi
         #rm -f $TRUST_TMP/$file                  # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         #ls -la $TRUST_ROOT"/doc/Coverage/"$file # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
         # Recuperation du rapport gprof de l'ensemble des cas tests de non regression si cree
         if [ "`grep 'GMON_DIR=""' $TRUST_ROOT/bin/lance_test`" = "" ]
         then
            cpu=all_tests.cpu
            echo "    Copy $cpu to $TRUST_ROOT/doc/Coverage/"
            #CHECKOUT $cpu
            if [ "${hostname:0:2}" = "is" ]
            then
               $SSHP scp $log@$machine:$workdir/.tmp_TRUST_$hostname/tests/$cpu . #1>/dev/null 2>&1
            else
               $SSHP scp $log@$machine:~/.tmp_TRUST_$hostname/tests/$cpu . #1>/dev/null 2>&1
            fi
            #CHECKIN $cpu
            ls -la $TRUST_ROOT"/doc/Coverage/"$cpu
         fi
      done
   fi
done
#
##########
# TGGCOV #
##########
# Mise a jour du repertoire doc/Coverage et verification que la couverture est a jour
cd $TRUST_ROOT/doc/Coverage
Build=$TRUST_ROOT/build/doc/Coverage
[ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build}
echo " "
echo "Verification of the coverage in `pwd`:"
# Creation des classes appellees ou non
(
cd $TRUST_ROOT/doc/Coverage
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -file"
listing=`mktemp_`
export PYTHONPATH=$PYTHONPATH:$TRUST_ROOT/bin/KSH
python -c "from Couv import nombre_de_cas_par_classe;nombre_de_cas_par_classe()" > $listing
rm -f $TRUST_ROOT/bin/KSH/Couv.pyc
# Classes non testees
for string in `$TRUST_Awk '/ 0 0/ {print $1}' $listing | sort`
do
   classe=`echo $string | $TRUST_Awk -F'|' '{print $1}'`
   path_fichier_cpp=`ViC $classe cpp -no_vi`
   if [ "$path_fichier_cpp" != "" ]
   then
      cpp=`basename $path_fichier_cpp`
      tc=`tggcov_ -file $cpp | awk '/File / {print "fichier couvert a "$1"%"}'`
   else
      # Fichier non trouve
      tc=""
   fi
   echo $ECHO_OPTS $string" \tdans \$TRUST_ROOT"${path_fichier_cpp#$TRUST_ROOT/.}" "$tc
done > $Build/liste_classes_non_testees
cat $Build/liste_classes_non_testees | grep Kernel > $Build/liste_classes_non_testees_Kernel
cat $Build/liste_classes_non_testees_Kernel | grep " 0.00" > $Build/liste_fichiers_Kernel_a_supprimer
for file in $Build/liste_classes_non_testees $Build/liste_classes_non_testees_Kernel $Build/liste_fichiers_Kernel_a_supprimer
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
# Classes testees
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -short -file"
html=$Build/liste_classes_testees.html
echo $ECHO_OPTS "<HTML><PRE>Critere\tCouvert\tTests\tClasse" > $html
for string in `$TRUST_Awk '!/ 0 0/ {print $1"|"$2"|"$3}' $listing`
do
   classe=`echo $string | $TRUST_Awk -F'|' '{print $1}'`
   nb_tests=`echo $string | $TRUST_Awk -F'|' '{print $2+$3}'`
   path_fichier_cpp=`ViC $classe cpp -no_vi`
   if [ "$path_fichier_cpp" != "" ]
   then
      fichier_cpp=`basename $path_fichier_cpp`
      taux_couverture=`tggcov_ -short -file $fichier_cpp | $TRUST_Awk '{print $1}'`
      critere=`echo $taux_couverture $nb_tests | $TRUST_Awk '{t=$1;n=$2;c=100*(0.01*t)**n;printf("%7.3f",c)}'`
   else
      fichier_cpp="not_found"
      taux_couverture="?????"
      critere="  0.000"
   fi
   echo $ECHO_OPTS "$critere\t$taux_couverture%\t$nb_tests\t<A HREF=cpp.gcov/$fichier_cpp.gcov>$classe</A>"
done | sort -nr >> $html
echo "</HTML>" >> $html
rm -f $listing
for file in $html
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
)
#
##########
# TGGCOV #
##########
# Calcul de la couverture du code par les cas tests
# Attention les .gcda et .gcno doivent etre du meme GCC
cd $repertoire_gcov
#On n'utilise plus ggcov car il faut le meme compilateur pour exploiter les .gcda et .gcno
#couverture_de_code=`tggcov -R all | $TRUST_Awk 'BEGIN {lines="??"} /Summary/ && /src/ {for (i=0;i<7;i++) getline;lines=$1} END {gsub("%","",lines);print lines}'`
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_"
echo "from `pwd`"
echo "    See $REP_NUIT/tggcov.log"
$TRUST_ROOT/bin/KSH/tggcov_ 1>$REP_NUIT/tggcov.log 2>&1
#tail -n2 $REP_NUIT/tggcov.log
couverture_de_code=`tggcov_ | $TRUST_Awk '/TRUST code/ {print $1}'`
cd - 1>/dev/null 2>&1
couverture_minimale=74.23 # 74.23 v1.9.1 ; 72.27 v1.9.0 ; 69.24 v1.8.4 ; 69.42 v1.8.3 (templates vdf) ; 65.88 v1.8.2 ; 57.86 v1.8.1 ; 60.03 v1.8.0 ; 66.73 v1.7.9 ; 67.49 v1.7.8 ; 69.05 v1.7.7 ; 69.42 v1.7.6 ; 69.87 v1.7.5 ; 70.04 v1.7.4 ; 69.61 v1.7.3 ; 69.28 v1.7.2 ; 65.26 v1.7.1
coverage=`echo $couverture_de_code | $TRUST_Awk -v m=$couverture_minimale '{if ($1>=m) print 1;else print 0}'`
if [ $coverage = 1 ]
then
   echo "    Code coverage $couverture_de_code% >= $couverture_minimale% of lines"
else
   echo "    Code coverage $couverture_de_code% < $couverture_minimale% of lines"
   cat $REP_NUIT/tggcov.log | mail_ -s\"[lance_test_nuit] Code coverage KO with $couverture_de_code% \< $couverture_minimale% of lines tested\" $TMA_PROJECT_LEADER $TRUST_MAIL
fi
(
# Creation du rapport html
cd $TRUST_ROOT/doc/Coverage
cd html
echo "  Call to $TRUST_ROOT/bin/KSH/tggcov_ -html"
echo "from `pwd`"
echo "    See $REP_NUIT/tggcov_html.log"
$TRUST_ROOT/bin/KSH/tggcov_ -html 1>$REP_NUIT/tggcov_html.log 2>&1
tail -n1 $REP_NUIT/tggcov_html.log
#echo "    Update html.tgz on $TRUST_ROOT/doc/Coverage" # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
echo "    Update html.tgz on $TRUST_ROOT/doc/Coverage/html"
tar cfz html.tgz *.html
# Mise a jour si different
if [ "`diff -a html.tgz ../html.tgz 2>/dev/null;echo $?`" != 0 ]
then
   echo "    => updated"
   #CHECKOUT ../html.tgz 1>/dev/null 2>&1 # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
   #mv -f html.tgz ../html.tgz            # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
else
   echo "    => NOT updated"
   #rm -f html.tgz   # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
fi
#ls -la ../html.tgz  # Recuperer fichier depuis TRUST + all baltik (ici TRUST seul)
)
cd $TRUST_ROOT/doc/Coverage
echo "  Call to make in $TRUST_ROOT/doc/Coverage"
make clean # dossier Coverage/html supprime et Coverage/html/index.html vide car non mis a jour dans l'archive TRUST + all baltik
make
CPP_GCOV=$TRUST_ROOT/doc/Coverage/html/cpp.gcov
echo "  Verification of $CPP_GCOV"
#grep $DATE $CPP_GCOV/MAIN.cpp.gcov # Build a ete retire des fichiers MAIN.cpp
#if [ "`grep $DATE $CPP_GCOV/MAIN.cpp.gcov 2>/dev/null`" = "" ]
#then
#   echo "    KO"
#   echo "$CPP_GCOV KO. See on $machine_gcov host with the gcov TRUST binairy: `grep build $CPP_GCOV/MAIN.cpp.gcov`" | mail_ -s\"[lance_test_nuit] Coverage KO on $hostname host\" $TRUST_MAIL
#else
#   echo "    OK"
#fi
ls -la $CPP_GCOV/MAIN.cpp.gcov
for file in list_methodes list_methodes_non_appelees
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
# Nouveau pour 1.6.3: Comparaison de la couverture de code fichier par fichier par rapport a la version precedante (sous $WORKDIR/tuleap/Maintenance)
(
cd $TRUST_ROOT/doc/Coverage/html/cpp.gcov
MAINTENANCE=$WORKDIR/tuleap/Maintenance/TRUST
echo " "
echo "Comparison of code coverage between new and old versions"
echo "from `pwd`"
echo " and $MAINTENANCE/doc/Coverage/html/cpp.gcov"
echo "Call to bin/KSH/tggcov_ -short -file *.gcov"
[ ! -d $MAINTENANCE ] && echo "  Verification of test coverage impossible because $MAINTENANCE not exist." #&& coverage=0
log=`mktemp_`
for gcov in *.gcov
do
   if [ -f $MAINTENANCE/doc/Coverage/html/cpp.gcov/$gcov ]
   then
      file=${gcov%.gcov}
      new_coverage=`tggcov_ -short -file $file`
      old_coverage=`export TRUST_ROOT=$MAINTENANCE;tggcov_ -short -file $file`
      # Regression de la couverture de code (Le nombre de lignes non testees augmente si la couverture est pas nulle)
      couverture=`echo $old_coverage | awk '{print $1}'`
      lignes_non_testees_en_plus=`echo $new_coverage $old_coverage | awk '{split($2,new,"/");split($6,old,"/");print (new_coverage[2]-new_coverage[1])-(old_coverage[2]-old_coverage[1])}'`
      if [ $lignes_non_testees_en_plus -gt 0 ] && [ $couverture != 0.00 ]
      then
         echo $ECHO_OPTS "$lignes_non_testees_en_plus lines not tested more in $file"
         # echo "  "sdiff $TRUST_ROOT/doc/Coverage/html/cpp.gcov/$gcov $MAINTENANCE/doc/Coverage/html/cpp.gcov/$gcov
         # Mise en echec du critere de livraison:
         #coverage=0
      fi
   fi
done | tee $log
# Pas au point, donc on ne signale rien:
#[ -s $log ] && cat $log | mail_ -s\"[lance_test_nuit] Regression code coverage between `basename $TRUST_ROOT_MASTER` and Maintenance:\" $TRUST_MAIL
rm -f $log
cd - 1>/dev/null 2>&1
)
echo " "
if [ $coverage = 1 ]
then
   echo "Release criterion: Code coverage OK"
else
   echo "Release criterion: Code coverage KO"
fi
force_code_coverage=~/force_code_coverage && [ -f $force_code_coverage ] && coverage=1 && rm -f $force_code_coverage
echo "$coverage  Code coverage $couverture_de_code% (>=$couverture_minimale% of lines)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$coverage
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
echo " "
echo "################################"
echo "# Verify the keywords coverage #"
echo "################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "  Analysis of $credoc_log"
grep OK $credoc_log
grep KO $credoc_log
error_log=`grep 'error Doxygen' $credoc_log`
[ ${#error_log} != 0 ] && echo | mail_ -s\"[credoc] Doxygen: Study of TRUST includes under `pwd`\" $TRUST_MAIL
#echo "    See $TRUST_ROOT/build/doc/TRUST/list_keywords_covered file"
#OK=`wc -l $TRUST_ROOT/build/doc/TRUST/list_keywords_covered | awk '{ print $1 }'`
#echo "    $OK keywords covered by test cases"
#echo "    See $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered file"
#KO=`wc -l $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered | awk '{ print $1 }'`
#echo "    $KO keywords NOT covered by test cases"
#let NB=$OK+$KO
# Mail de verification uniquement le week-end
#[ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ] && [ -f $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered ] && cat $TRUST_ROOT/build/doc/TRUST/list_keywords_NOT_covered | mail_ -s\"[lance_test_nuit] Tests coverage credoc: list of keywords NOT covered by test cases\" $TMA_PROJECT_LEADER $TRUST_MAIL
#keywords_minimal=77.37 #v1.7.5
#
echo "    See $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata* files"
NB=0
OK=0
KO=0
[ -f  $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata ] && NB=`wc -l $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata | awk '{ print $1 }'`
[ -f $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested ] && OK=`wc -l $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested | awk '{ print $1 }'`
let KO=$NB-$OK
echo "    $OK keywords covered by test cases"
echo "    $KO keywords NOT covered by test cases"
keywords_minimal=77.25 #77.35 v1.9.4 #77.87 v1.9.3 #78.47 v1.9.2 #80.02 v1.9.1 #81.40 v1.8.4 #80.03 v1.8.3 #78.89 v1.8.2 #78.70 v1.8.1 #78.60 v1.8.0 deplacement de la turbulence de TRUST a TrioCFD;  83.10 v1.7.8 suppression du mot-cle "espece lambda" ; 83.11 v1.7.7 classe de base avec ajout de commentaires XD ; 83.00 v1.7.6 ; 82.89 v1.7.5

echo " "
keywords=0
couverture_de_motcle=0
[ $NB != 0 ] && couverture_de_motcle=`echo $ECHO_OPTS "scale=2;100*$OK/$NB" | bc -l`
keywords=`echo $couverture_de_motcle | $TRUST_Awk -v m=$keywords_minimal '{if ($1>=m) print 1;else print 0}'`
if [ $keywords = 1 ]
then
   echo "    Keywords coverage $couverture_de_motcle% >= $keywords_minimal% tested "
else
   echo "    Keywords coverage $couverture_de_motcle% < $keywords_minimal% tested"
   if [ -f $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested ]
   then
      cat $TRUST_ROOT/build/Outils/TRIOXDATA/XTriou/list_keywords_xdata_tested | mail_ -s\"[lance_test_nuit] Keywords coverage KO with $couverture_de_motcle% \< $keywords_minimal% tested\" $TMA_PROJECT_LEADER $TRUST_MAIL
   else
      echo "No list_keywords_xdata_tested file" | mail_ -s\"[lance_test_nuit] Keywords coverage KO with $couverture_de_motcle% \< $keywords_minimal% tested\" $TMA_PROJECT_LEADER $TRUST_MAIL
   fi
fi
echo " "
if [ $keywords = 1 ]
then
   echo "Release criterion: Keywords coverage OK"
else
   echo "Release criterion: Keywords coverage KO"
fi
echo "$keywords  Keywords coverage $OK/$NB=$couverture_de_motcle% (>=$keywords_minimal% tested)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$coverage
echo "<--- End at "`date '+%H:%M:%S %d/%m'`
#
#
#
##############
# Parallelisme
##############
echo " "
echo "#####################################"
echo "# Test the stability of parallelism #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
machine_=`liste_machines "\-Check_decoupage"`
machine=`liste_machines "\-Check_decoupage" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -Check_decoupage on $machine"
log=`awk -v adr=$machine_ '($2==adr) {print $4}' ~/.netrc | head -1`
BATCHMODE=" -o BatchMode=yes "
SSHP=""
if [ "`liste_machines ssh_pass | grep $machine_`" != "" ]
then
   SSHPASS=`awk -v adr=$machine_ '($2==adr) {print $6}' ~/.netrc | head -1`
   SSHP="sshpass -p $SSHPASS "
   BATCHMODE=""
fi

if  [ "`$SSHP ssh_ -o ConnectTimeout=30 $BATCHMODE $log@$machine -n pwd 1>/dev/null 2>&1;echo $?`" != 0 ]
then
   echo "  KO $machine machine not accessible via ssh."
   echo "  No $REP_NUIT/Check_decoupage.ksh_$machine.log"
   echo | mail_ -s\"[lance_test_nuit] Error when receiving Check_decoupage log from $machine not accessible via ssh.\" $TRUST_MAIL
   stabilite_parallelisme=0
   resultat_parallelisme=0/0
   parallelism=0
   echo " "
   echo "Release criterion: Parallelism KO"
else
   echo "  See $REP_NUIT/Check_decoupage.ksh_$machine.log"
   if [ "${machine:0:2}" = "is" ]
   then
      workdir=`$SSHP ssh $machine -n 'echo $WORKDIR'`
      $SSHP scp $log@$machine:$workdir/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log 1>/dev/null 2>&1
   else
      $SSHP scp $log@$machine:~/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log
   fi
   error_log=`grep "Failure on " $REP_NUIT/Check_decoupage.ksh_$machine.log`
   [ ${#error_log} != 0 ] && cat $REP_NUIT/Check_decoupage.ksh_$machine.log | mail_ -s\"[lance_test_nuit] Check_decoupage.ksh on $machine KO\" $TRUST_MAIL
   file_log=$REP_NUIT"/PERF_TRUST"$COMM"_opt_linux_"$machine
   check_log=`mktemp_`
   echo "  Analysis of "$file_log" file" | tee -a $check_log
   if [ ! -f $REP_NUIT/Check_decoupage.ksh_$machine.log ]
   then
      stabilite_parallelisme=0
      resultat_parallelisme=0/0
      parallelism=0
   else
      grep "Decoupage...OK Execution...Arret Validite...KO" $file_log | tee -a $check_log
      grep "Failure on" $file_log | tee -a $check_log
      stabilite_parallelisme=`$TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print ok/procs}' $file_log`
      resultat_parallelisme=`$TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print ok"/"procs}' $file_log`
      $TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print cas " cases including "ok " OK to "procs" CPUs. Validity = "ok"/"procs" = "ok/procs" %"}' $file_log | tee -a $check_log
      parallelism=`echo $stabilite_parallelisme | $TRUST_Awk '{if ($1==1) print 1;else print 0}'`
   fi
   echo " " | tee -a $check_log
   if [ $parallelism = 1 ]
   then
      echo "Release criterion: Parallelism OK" | tee -a $check_log
   else
      echo "Release criterion: Parallelism KO" | tee -a $check_log
      echo "-------------------------------------------------------------------------------------------" >> $check_log
      echo " " >> $check_log
      [ "$error_log" != "" ] && cat $REP_NUIT/Check_decoupage.ksh_$machine.log >> $check_log
      cat $check_log | mail_ -s\"[lance_test_nuit] KO Check_decoupage script on $machine\" $TMA_PROJECT_LEADER $TRUST_MAIL
   fi
   rm -f $check_log
fi
force_check_decoupage=~/force_check_decoupage && [ -f $force_check_decoupage ] && parallelism=1 && rm -f $force_check_decoupage
echo "$parallelism  Parallelism $resultat_parallelisme=$stabilite_parallelisme (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$parallelism
# Desormais le week-end sur pc tma, on met a jour les cas tests
# pour la balise PARALLEL OK
# Dangereux car blocages possibles
#if [ "`date '+%u'`" -gt 5 ]
#then
#   Check_decoupage.ksh -all -update
#fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##############
# Performances
##############
echo " "
echo "########################"
echo "# Test the performance #"
echo "########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
total=0
machines=`liste_machines "\-benchmark" | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
echo "Validation by -benchmarck on"
echo $machines
nb_machines=0
for machine in $machines
do
   PERF=`ls $REP_NUIT/PERF_TRUST_*$machine 2>/dev/null`
   echo "  Analysis of "$PERF" file"
   if [ -f "$PERF" ] && [ "`grep Run_bench $PERF`" != "" ]
   then
      # Aucune efficacite en dessous de 0.60 sur 4 processeurs et aucun cpu au dessus de 8s sur 1 processeur:
      perf=`$TRUST_Awk 'BEGIN {p=0} ($1==4) && (NF==12) && /\|/ {if ($(NF-1)>0.60) p=p+0.25} ($1==1) && (NF==12) && /\|/ {if ($3<8) p=p+0.25} END {print p}' $PERF`
      ([ "`liste_machines cible | grep $machine`" != "" ] || [ "`liste_machines tache | grep $machine`" != "" ]) && total=`echo "$total+$perf" | bc -l`
      echo "Time VDF and VEF on 1 CPU: < 8s ?"
      $TRUST_Awk '($1==1) && (NF==12) && /\|/ {print $3}' $PERF
      echo "Efficacite VDF and VEF on 4 CPUs: > 0.60 ?"
      $TRUST_Awk '($1==4) && (NF==12) && /\|/ {print $(NF-1)}' $PERF
      if ([ "`liste_machines cible | grep $machine`" != "" ] || [ "`liste_machines tache | grep $machine`" != "" ])
      then
         echo "=> perf+=$perf (total=$total)"
         let nb_machines=$nb_machines+1
      else
         echo "=> perf+=$perf"
      fi
      [ $(echo " $perf < 1 " | bc) -eq 1 ] && cat $PERF | mail_ -s\"[lance_test_nuit] Benchmark on $machine KO\" $TRUST_MAIL
   else
      echo "File not exist => benchmark not executed on the machine: $machine"
   fi
done
#
if [ "$nb_machines" != 0 ]
then
   echo "Call to $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/Run_fiche"
   bench_log=$REP_NUIT"/benchmark_report_"$HOST".log"
   echo "  See $bench_log"
   echo "TRUST benchmarh report on $HOST the `date` ...">$bench_log
   echo>>$bench_log
   (Build=$TRUST_ROOT/build/tests/Reference/BENCHMARK;
    [ ! -d ${Build} ] && echo Creating ${Build} directory && mkdir -p ${Build};
    rm -rf $Build/Rapport;
    cp -r $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport $Build/.;
    cd $Build/Rapport;Run_fiche 1>>$bench_log 2>&1
   )
   tail -n1 $bench_log
   if [ -f $TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf ]
   then
       # Envoi du rapport genere le week-end au project leader
      if [ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ]
      then
         echo "$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run_fiche" | mail_ -a\"$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Benchmark report generated `date '+%d/%m/%y'`\" $TMA_PROJECT_LEADER $TRUST_MAIL
      else
         echo "$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run_fiche" | mail_ -a\"$TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Benchmark report generated `date '+%d/%m/%y'`\" $TRUST_MAIL
      fi
   else
      cat $TRUST_ROOT/build/tests/Reference/BENCHMARK/Rapport/Run.log | mail_ -s\"[lance_test_nuit] KO Benchmark report NOT generated `date '+%d/%m/%y'`\" $TRUST_MAIL
   fi
else
   echo "...no machine with benchmark option in $TRUST_ROOT/bin/admin/liste.machines file"
   liste_machines benchmark | mail_ -s\"[lance_test_nuit] Performance KO because NO Benchmark on\" $TRUST_MAIL
fi
#nb_machines=`echo $machines | $TRUST_Awk '{print NF}'`
performances=0 && [ $total = $nb_machines ] && [ $total != 0 ] && performances=1
echo " "
if [ $performances = 1 ]
then
   echo "Release criterion: Performance OK"
else
   echo "Release criterion: Performance KO"
fi
force_performances=~/force_performances && [ -f $force_performances ] && performances=1 && rm -f $force_performances
# je force le critere performances
# performances=1
[ "$nb_machines" -eq 0 ] && nb_machines=-1
if [ "$nb_machines" -eq -1 ]
then
  echo "$performances  Performance $total/0="`echo $ECHO_OPTS "scale=3;$total/$nb_machines" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
  nb_machines=0
else
   echo "$performances  Performance $total/$nb_machines="`echo $ECHO_OPTS "scale=3;$total/$nb_machines" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$performances
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

###########
# ToDo list
###########
echo " "
echo "########################"
echo "# Verify the ToDo list #"
echo "########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $TRUST_ROOT/ToDo file"
nb_todo=`grep -c ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo`
echo "$nb_todo requests to do before the release of the next version"
nothing_todo=0 && [ "`grep ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo`" = "" ] && nothing_todo=1
# Envoi aux personnes concernees le mardi apres COSUIV
for qui in `$TRUST_Awk '!/Qui/ {print $2}' $TRUST_ROOT/ToDo | sort -u`
do
   grep $qui $TRUST_ROOT/ToDo | grep ${TRUST_VERSION%_beta} > $TRUST_TMP/ToDo
   [ -s $TRUST_TMP/ToDo ] && [ "`date '+%u'`" = 2 ] && cat $TRUST_TMP/ToDo | mail_ -s\"[lance_test_nuit] ToDo list for the version ${TRUST_VERSION%_beta}\" $TMA_PROJECT_LEADER $TRUST_MAIL $qui
done
# Envoi la liste complete le lundi au chef de projet avant COSUIV pour planning de la semaine
grep ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo > $TRUST_TMP/ToDo
#[ "`date '+%u'`" = 1 ] && cat $TRUST_TMP/ToDo | mail_ -s\"[lance_test_nuit] ToDo list for next Monday COSUIV\" $TMA_PROJECT_LEADER $TRUST_MAIL
rm -f $TRUST_TMP/ToDo
#
echo " "
if [ $nothing_todo = 1 ]
then
   echo "Release criterion: ToDo OK"
else
   echo "Release criterion: ToDo KO"
fi
echo "$nothing_todo  ToDo $nb_todo (=0)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$nothing_todo
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

########
# Etudes
########
echo " "
echo "#####################################"
echo "# Verify the results of study cases #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $REP_NUIT/run_Etudes.log file"
grep "Study OK " $REP_NUIT/run*.log 2>/dev/null
grep "Study KO " $REP_NUIT/run*.log 2>/dev/null
OK=`grep "Study OK " $REP_NUIT/run*.log 2>/dev/null | wc -l`
KO=`grep "Study KO " $REP_NUIT/run*.log 2>/dev/null | wc -l`
let NB=$OK+$KO
echo "  $OK/$NB studies verified"
[ "$NB" -eq 0 ] && NB=-1
validation_etudes=0 && [ $OK = $NB ] && validation_etudes=1
echo " "
if [ $validation_etudes = 1 ]
then
   echo "Release criterion: Studies OK"
else
   echo "Release criterion: Studies KO"
   [ "$NB" -gt 0 ] && cat $REP_NUIT/run_Etudes.log | mail_ -s\"[lance_test_nuit] Results of study cases KO\" $TRUST_MAIL
fi
if [ $etude_activation = 1 ]
then
   if [ "$NB" -gt 0 ] && [ -f $ETUDES/Rapport/build/rapport.pdf ]
   then
      # Envoi du rapport genere le week-end au project leader
      if [ "`date '+%u'`" = 1 ] && [ `date '+%H'` -lt 8 ]
      then
         echo "$ETUDES/Rapport/Run_fiche" | mail_ -a\"$ETUDES/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Studies report generated `date '+%d/%m/%y'`\" $TMA_PROJECT_LEADER $TRUST_MAIL
      else
         echo "$ETUDES/Rapport/Run_fiche" | mail_ -a\"$ETUDES/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Studies report generated `date '+%d/%m/%y'`\" $TRUST_MAIL
      fi
   else
      [ "$NB" -gt 0 ] && cat $ETUDES/Rapport/Run.log | mail_ -s\"[lance_test_nuit] KO Studies report NOT generated `date '+%d/%m/%y'`\" $TRUST_MAIL
   fi
fi
force_validation_etudes=~/force_validation_etudes && [ -f $force_validation_etudes ] && validation_etudes=1 && rm -f $force_validation_etudes
# je force le critere etude
# validation_etudes=1
if [ "$NB" -eq -1 ]
then
  echo "$validation_etudes  Studies $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)" >> $MESSAGES_NUIT
  NB=0
else
  echo "$validation_etudes  Studies $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)" >> $MESSAGES_NUIT
fi
[ "$NB" -eq -1 ] && NB=0
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_etudes
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

###########################################
# PROJETS BALTIK BASES SUR LE KERNEL ONLY #
###########################################
# CC 01/09/2015: desormais MPCube issu de git teste via check_component
#echo " "
#echo "#########################################"
#echo "# Test the portability of baltik MPCube #"
#echo "#########################################"
#echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
## Voir si dans le futur on ne peut pas faire converger la procedure check_components sur
## les projets Baltik place sous la VOBS Composants et ce projet Baltik.
#PROJECT_ROOT=$WORKDIR/MPCube/mpcube-portage166        # MPCube a porter pour 1.6.2
##log=$PROJECT_ROOT/check_baltik_project.log
#log=$REP_NUIT"/baltik_MPCube_"$HOST"_Kernel.log"
## Necessaire de mettre entre () car initialisation du projet Baltik
#(
#source $WORKDIR/tuleap/Kernel/TRUST/env_TRUST.sh 1>/dev/null 2>&1
#cd $PROJECT_ROOT
#echo "Call to $WORKDIR/tuleap/Kernel/TRUST/bin/admin/check_baltik_project"
#echo "from `pwd`"
#echo "  See $log"
#echo "MPCube project baltik check on $HOST the `date` ...">$log
#echo>>$log
#$WORKDIR/tuleap/Kernel/TRUST/bin/admin/check_baltik_project 1>>$log 2>&1
#grep 'Projet Baltik' $log | grep OK
#cd - 1>/dev/null 2>&1
#)
#if [ "`grep 'Projet Baltik' $log | grep OK`" != "" ]
#then
#   validation_projets_baltik=1
#else
#   validation_projets_baltik=0
#   cat $log | mail_ -s\"[lance_test_nuit] Portability KO on Baltik $PROJECT_ROOT\" $TMA_PROJECT_LEADER $TRUST_MAIL
#fi
#echo " "
#if [ $validation_projets_baltik = 1 ]
#then
#   echo "Release criterion: MPCube OK"
#else
#   echo "Release criterion: MPCube KO"
#fi
#echo "$validation_projets_baltik  MPCube $validation_projets_baltik (=1) Baltik=$HOST:$PROJECT_ROOT" >> $MESSAGES_NUIT
#let total_criteres=$total_criteres+1
#let criteres_remplis=$criteres_remplis+$validation_projets_baltik
#echo "<--- End at "`date '+%H:%M:%S %d/%m'`

##########
# PROJETS
##########
force_composant=~/force_composant
for Composant in $Composants
do
   echo " "
   echo "###################################"
   echo "# Verify the portability of baltik $Composant "
   echo "###################################"
   echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
   PROJECT_ROOT=`dirname $TRUST_ROOT`/Composants/$Composant
   validation_composant=1
   baltik_pas_a_jour=""
   # Check if component is OK on $HOST:
   OK=0
   KO=0
   rm -f tmp.log
   for view in Livraison Maintenance Kernel
   do
      Gui_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"$view"_gui.log"
      if [ -f $Gui_log ]
      then
         echo "Analysis of "$Gui_log" file"
         grep "Error" $Gui_log
         grep "Validation XDATA=" $Gui_log
         nb=`grep "Validation XDATA=OK" $Gui_log | wc -l`
         OK=`echo $(($OK+$nb))`
         nb=`grep "Validation XDATA=KO" $Gui_log | wc -l`
         KO=`echo $(($KO+$nb))`
         BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
         [ $nb != 0 ] && cat $Gui_log | mail_ -s\"[lance_test_nuit] XDATA $Composant $TRUST_VERSION KO\" $TRUST_MAIL ${!BALTIK_PROJECT_LEADER}
      fi
      Composant_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"$view".log"
      if [ -f $Composant_log ]
      then
         echo "Analysis of "$Composant_log" file" | tee -a tmp.log
         grep "because no $old version on this host" $Composant_log
         #grep "$Composant OK" $Composant_log | sed 1d | tee -a tmp.log # check only component without portability
         grep "$Composant OK" $Composant_log #| tee -a tmp.log
         (grep " KO" $Composant_log;grep KO $Composant_log | grep $Composant;grep " connect to host " $Composant_log | cut -d: -f2) | tee -a tmp.log
         nb=`grep "$Composant OK" $Composant_log | wc -l`
         OK=`echo $(($OK+$nb))`
         nb=`(grep " KO" $Composant_log;grep KO $Composant_log | grep $Composant;grep " connect to host " $Composant_log | cut -d: -f2) | wc -l`
         KO=`echo $(($KO+$nb))`
         [ "`grep KO $Composant_log | grep $Composant | grep Component`" != "" ] && validation_composant=0
         [ "`grep 'Baltik pas a jour' $Composant_log`" != "" ] && baltik_pas_a_jour="Baltik pas a jour"
      fi
      let NB=$OK+$KO
   done
   [ $NB = 0 ] && validation_composant=0
   # Check if portability is OK:
   nuit_log=$PROJECT_ROOT/nuit_$Composant.html
   nb_cible=0
   tot_cible=0
   nb_total=0
   tot_total=0
   # If no html report, we try to generate it
   if [ ! -f $nuit_log ]
   then
      echo "No $REP_NUIT/nuit_$Composant.html report of $Composant ... we try to generate it " | tee -a tmp.log
      (cd $PROJECT_ROOT/ ; sh $TRUST_ROOT/bin/baltik/share/baltik/bin/portability/build_report.sh $Composant)
      [ -f $nuit_log ] && cp $nuit_log $REP_NUIT/nuit_$Composant.html
   fi
   if [ -f $nuit_log ]
   then
      echo "Analysis of "$nuit_log" file" | tee -a tmp.log
      grep "_OK" $nuit_log | tee -a tmp.log
      nb_cible=`$TRUST_Awk '/cible_OK/ {print $2}' $nuit_log`
      tot_cible=`$TRUST_Awk '/cible_OK/ {print $4}' $nuit_log`
      nb_total=`$TRUST_Awk '/total_OK/ {print $2}' $nuit_log`
      tot_total=`$TRUST_Awk '/total_OK/ {print $4}' $nuit_log`
   else
      validation_composant=0
      echo " " | tee -a tmp.log
      echo "No $REP_NUIT/nuit_$Composant.html report of $Composant on $TRUST_HOST_ADMIN KO!" | tee -a tmp.log
   fi
   [ $tot_cible != 0 ] && [ $nb_cible != $tot_cible ] && validation_composant=0
   [ $tot_cible = 0 ] && [ $nb_cible = 0 ] && validation_composant=0
   #if [ "`grep KO $PROJECT_ROOT/*.log | grep Info_global 2>/dev/null`" != "" ]
   if [ $KO != 0 ]
   then
      #validation_composant=0
      if [ -f $nuit_log ]
      then
         echo " " | tee -a tmp.log
         echo "Run: konqueror ftp://$TRUST_FTP/$SECRET/NUIT/nuit_$Composant.html" | tee -a tmp.log
      fi
   fi
   echo " "
   if [ $validation_composant = 1 ]
   then
      echo "Release criterion: $Composant OK"
      [ $nb_total != $tot_total ] && cat tmp.log | mail_ -s\"[lance_test_nuit] Portability KO on Baltik $Composant\" $TRUST_MAIL ${!BALTIK_PROJECT_LEADER}
   else
      echo "Release criterion: $Composant KO"
      if [[ "$ComposantsGit" = *"$Composant"* ]] # Test si Composant est dans la liste des composants GIT
      then
         BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
      else
         BALTIK_PROJECT_LEADER="TRUST_PROJECT_LEADER"
      fi
      if [ $KO != 0 ]
      then
         if [ $tot_cible != 0 ]
         then
            cat tmp.log | mail_ -s\"[lance_test_nuit] Cible portability KO on Baltik $Composant\" $TRUST_MAIL ${!BALTIK_PROJECT_LEADER}
         else
            cat tmp.log | mail_ -s\"[lance_test_nuit] Portability KO on Baltik $Composant\" $TRUST_MAIL ${!BALTIK_PROJECT_LEADER}
         fi
      fi
   fi
   rm -f tmp.log
   [ $KO != 0 ] && [ $nb_total = $tot_total ] && validation_composant=0
   [ -f $force_composant ] && validation_composant=1
   # Test sur l'ensemble des machines
   [ "$NB" -eq 0 ] && NB=-1
   if [ "$NB" -eq -1 ]
   then
      echo "$validation_composant  $Composant $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1) $baltik_pas_a_jour" #>> $MESSAGES_NUIT
      NB=0
   else
      echo "$validation_composant  $Composant $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1) $baltik_pas_a_jour" #>> $MESSAGES_NUIT
   fi
   # Test sur les machines cible
   [ "$tot_cible" -eq 0 ] && tot_cible=-1
   if [ "$tot_cible" -eq -1 ]
   then
      if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
      then
          echo "$validation_composant  $Composant $nb_cible/0="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1) $baltik_pas_a_jour" | tee -a $MESSAGES_NUIT
      else
          echo "$validation_composant  $Composant $nb_cible/0="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1) $baltik_pas_a_jour"
      fi
      tot_cible=0
   else
      if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
      then
         echo "$validation_composant  $Composant $nb_cible/$tot_cible="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1) $baltik_pas_a_jour" | tee -a $MESSAGES_NUIT
      else
         echo "$validation_composant  $Composant $nb_cible/$tot_cible="`echo $ECHO_OPTS "scale=3;$nb_cible/$tot_cible" | bc -l`" (=1) $baltik_pas_a_jour"
      fi
   fi
#   if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
   if [[ "$ComposantsBeta" != *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
   then
      let total_criteres=$total_criteres+1
      let criteres_remplis=$criteres_remplis+$validation_composant
   fi
   if [[ "$ComposantsOfficial" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Official
   then
      let baltik_ok=$baltik_ok+$validation_composant
   fi
   echo "<--- End at "`date '+%H:%M:%S %d/%m'`
done
rm -f $force_composant

####################
# SCRIPTS IMPORTANTS
####################
echo " "
echo "####################################"
echo "# Verify the validation of scripts #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Analysis of $REP_NUIT/CR_* files"
grep "Script " $REP_NUIT/CR_* | grep OK 2>/dev/null
grep "Script " $REP_NUIT/CR_* | grep KO 2>/dev/null
validation_scripts=0
OKt=0
KOt=0
machines=`liste_machines cible | $TRUST_Awk -F. '{print $1}' | $TRUST_Awk -F"-gw" '{print $1}'`
for machine in $machines
do
   if [ "`grep "Script " $REP_NUIT/CR_$machine`" != "" ]
   then
      OKm=`grep "Script " $REP_NUIT/CR_$machine | grep OK 2>/dev/null | wc -l`
      KOm=`grep "Script " $REP_NUIT/CR_$machine | grep KO 2>/dev/null | wc -l`
      OKt=`echo "$OKt+$OKm" | bc -l`
      KOt=`echo "$KOt+$KOm" | bc -l`
   fi
done
let NBt=$OKt+$KOt
OK=`grep "Script " $REP_NUIT/CR_* | grep OK 2>/dev/null | wc -l`
KO=`grep "Script " $REP_NUIT/CR_* | grep KO 2>/dev/null | wc -l`
let NB=$OK+$KO
if [ "`grep "Script " $REP_NUIT/CR_* | grep KO`" = "" ]
then
   validation_scripts=1
else
   if [ "$KOt" -eq 0 ]
   then
      grep "Script " $REP_NUIT/CR_* | grep KO | mail_ -s\"[lance_test_nuit] Validation of scripts KO on host:\" $TRUST_MAIL
   else
      grep "Script " $REP_NUIT/CR_* | grep KO | mail_ -s\"[lance_test_nuit] Validation of scripts KO on cible host:\" $TMA_PROJECT_LEADER $TRUST_MAIL
   fi
fi
[ "$KOt" -eq 0 ] && validation_scripts=1
echo " "
if [ $validation_scripts = 1 ]
then
   echo "Release criterion: Scripts OK"
else
   echo "Release criterion: Scripts KO"
fi
force_validation_scripts=~/force_validation_scripts && [ -f $force_validation_scripts ] && validation_scripts=1 && rm -f $force_validation_scripts
[ "$NB" -eq 0 ] && NB=-1
if [ "$NB" -eq -1 ]
then
   echo "$validation_scripts  Scripts $OK/0="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)"
   NB=0
else
   echo "$validation_scripts  Scripts $OK/$NB="`echo $ECHO_OPTS "scale=3;$OK/$NB" | bc -l`" (=1)"
fi
[ "$NBt" -eq 0 ] && NBt=-1
if [ "$NBt" -eq -1 ]
then
   echo "$validation_scripts  Scripts $OKt/0="`echo $ECHO_OPTS "scale=3;$OKt/$NBt" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
   NB=0
else
   echo "$validation_scripts  Scripts $OKt/$NBt="`echo $ECHO_OPTS "scale=3;$OKt/$NBt" | bc -l`" (=1)" | tee -a $MESSAGES_NUIT
fi
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_scripts
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#########
# Doxygen
#########
echo " "
echo "####################################"
echo "# Verify the Doxygen documentation #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
echo "Search of $TRUST_ROOT/build/doc/doxygen*.err file"
validation_doxygen=1
if [ -f $TRUST_ROOT/build/doc/doxygen*.err ]
then
   ls -la $TRUST_ROOT/build/doc/doxygen*.*
   head -n1 $TRUST_ROOT/build/doc/doxygen*.out
   tail -n1 $TRUST_ROOT/build/doc/doxygen*.out
elif [ ! -f $TRUST_ROOT/build/doc/doxygen*.out ]
then
   validation_doxygen=0 && echo "TRUST Doxygen KO" && echo `ls -la $TRUST_ROOT/build/doc/doxygen*.*` | mail_ -s\"[lance_test_nuit] Validation of Doxygen documentation NOT\" $TRUST_MAIL
fi
[ "`grep 'Doxygen documentation failed' $TRUST_ROOT/build/doc/doxygen*.err 2>/dev/null`" != "" ] && validation_doxygen=0 && echo "TRUST Doxygen KO" && cat $TRUST_ROOT/build/doc/doxygen*.err | mail_ -s\"[lance_test_nuit] Validation of TRUST Doxygen documentation KO\" $TRUST_MAIL $TMA_PROJECT_LEADER
for Composant in $Composants
do
   if [[ "$ComposantsOfficial" = *"$Composant"* ]] || [[ "$ComposantsLns" = *"$Composant"* ]] # Test si Composant n est pas dans la liste des composants Beta
   then
      if [ "$Composant" != Test_Baltik ] # on retire Test_Baltik du critere de livraison TRUST/TrioCFD. ND 26/09/2022 : on remet ijk
      then
         echo " "
         echo "Search of $TRUST_ROOT/../Composants/$Composant/build/doxygen*.err file"
         if [ -f $TRUST_ROOT/../Composants/$Composant/build/doxygen*.err ]
         then
            ls -la $TRUST_ROOT/../Composants/$Composant/build/doxygen*.*
            head -n1 $TRUST_ROOT/../Composants/$Composant/build/doxygen*.out
            tail -n1 $TRUST_ROOT/../Composants/$Composant/build/doxygen*.out
         elif [ ! -f $TRUST_ROOT/../Composants/$Composant/build/doxygen*.out ]
         then
            validation_doxygen=0 && echo "$Composant Doxygen KO" && echo `ls -la $TRUST_ROOT/../Composants/$Composant/build/doxygen*.*` | mail_ -s\"[lance_test_nuit] Validation of $Composant Doxygen documentation NOT\" $TRUST_MAIL
         fi
         BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
         [ "`grep 'Doxygen documentation failed' $TRUST_ROOT/../Composants/$Composant/build/doxygen*.err 2>/dev/null`" != "" ] && validation_doxygen=0 && echo "$Composant Doxygen KO" && cat $TRUST_ROOT/../Composants/$Composant/build/doxygen*.err | mail_ -s\"[lance_test_nuit] Validation of $Composant Doxygen documentation KO\" $TRUST_MAIL $TMA_PROJECT_LEADER ${!BALTIK_PROJECT_LEADER}
      fi
   fi
done
echo " "
if [ $validation_doxygen = 1 ]
then
   echo "Release criterion: Doxygen OK"
else
   echo "Release criterion: Doxygen KO"
fi
echo "$validation_doxygen  Doxygen $validation_doxygen (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_doxygen
min_criteres=`echo $ECHO_OPTS "scale=0\n$total_criteres*75/100" | bc -l` # 75% du nombre total de criteres pour release beta #
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo "Total: $criteres_remplis/$total_criteres criteria for the $new version" >> $MESSAGES_NUIT
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
#
#
#
echo " "
echo "------------------------------------------------------"
echo " "
echo "##############################"
echo "# Deliver and export version #"
echo "##############################"
echo " "
echo "###########################"
echo "# Test if Release version #"
echo "###########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`

########################################################################
# Feu vert de l'administrateur TRUST d'apres l'en tete de RELEASE_NOTES
########################################################################
echo "Analysis of $TRUST_ROOT/RELEASE_NOTES file"
export accord_admin=0 && [ ${new%_beta} = $new ] && accord_admin=1
export accord_beta=0
export label_pose=$new
label=v${new%_beta}
deja_livre=0
if [ $accord_admin = 1 ]
then
   echo ${new%_beta}" == "$new" => agreement_administrator = "$accord_admin
   # Add latest version of TRUST tutorials to git
   cp $TRUST_ROOT/doc/TRUST/Tutorial/TRUST_tutorial.pdf $TRUST_ROOT/doc/TRUST/
   cp $TRUST_ROOT/doc/TRUST/Tutorial/ICoCo_tutorial.pdf $TRUST_ROOT/doc/TRUST/
   cp $TRUST_ROOT/doc/TRUST/Tutorial/Baltik_tutorial.pdf $TRUST_ROOT/doc/TRUST/
   cp $TRUST_ROOT/doc/TRUST/exercices/Tutorial_solutions/Tutorial_solutions.pdf $TRUST_ROOT/doc/TRUST/exercices/
   # Update the version in README.md file (displayed on github)
   sed -i "s/$old/$new/g" $TRUST_ROOT/README.md
   # Commit
   echo "Call git commit --u=no --all -m Commit before the $new version."
   git commit --u=no --all -m"Commit before the $new version."
else
   echo ${new%_beta}" >< "$new" => agreement_administrator = "$accord_admin
fi

####################################################################################################
# Si un certain nombre de criteres sont remplis, on propose une release (candidate ou intermediaire)
# Tous les jours si accord_admin = 1, label_rc=X.Y.Z_rc
# Le week-end seulement si accord_admin = 0, label_rc=X.Y.Z_beta
#####################################################################l###############################
echo " "
echo "Analysis of $MESSAGES_NUIT file"
grep "Total:" $MESSAGES_NUIT
echo "  criteria:    "$criteres_remplis" != "$total_criteres
echo "  minimum:     "$criteres_remplis" -ge $min_criteres"
echo "  stability:   "$stabilite" = 1.000"
echo "  portability: "$portabilite" = 1"
echo "  baltikGIT:   "$baltik_ok" = "$total_baltik
cd $TRUST_ROOT
if [ $criteres_remplis != $total_criteres ] && [ $criteres_remplis -ge $min_criteres ] && [ $stabilite = "1.000" ] && [ $portabilite = 1 ] && [ $baltik_ok -ge $total_baltik ]
then
   echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
   echo -e "=> release OK\c"
   [ "`date '+%u'`" -gt 5 ] && accord_beta=1 # week-end
   [ "`date '+%u'`" = 1 ] && [ "`date '+%H'`" -lt 8 ] && accord_beta=1 # lundi matin
   [ -f ~/force_version_beta ] && accord_beta=1 && rm -f ~/force_version_beta
   [ -f ~/no_version_beta ] && accord_beta=0 #&& rm -f ~/no_version_beta
   if [ $accord_admin = 1 ] || [ $accord_beta = 1 ]
   then
      # On decide du nom du label specifique
      label_rc=$label"_rc" && release=candidate && [ $accord_admin = 0 ] && label_rc=$label"_beta" && release=beta
      numero=`git tag | grep $label_rc | wc -l` && [ "$numero" = "" ] && numero=0
      let numero=$numero+1
      label_pose=$label_rc$numero
      echo " with label "$label_pose
      echo " "
      error_rc=0

      # Commit
      echo "  Call git commit --all -m Commit for a Release $release $label_pose version"
      git commit --all -m"Commit for a Release $release $label_pose version."
      # On pose le tag:
      echo "  Call git tag $label_pose"
      git tag $label_pose
      error_rc=$?
      # Push
      echo "  Call git push origin TMA"
      git_push -tags
      if [ $error_rc = 0 ]
      then
         # On previent l'administrateur et le project leader
         cat $TRUST_ROOT/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] TRUST Release version - Tag a $release version: $label_pose \(See origin/triou/TMA branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER $TRUST_PROJECT_LEADER
      else
         echo "" | mail_ -s\"[lance_test_nuit] TRUST - Tag a $release version: $label_pose KO\" $TRUST_MAIL
      fi
      # On pose le meme tag sur externalpackages
      echo "  Update externalpackages:"
      cd $TRUST_ROOT/externalpackages
      echo "    Call git commit --all -m Commit for a Release $release $label_pose version"
      git commit --all -m"Commit for a Release $release $label_pose version."
      echo "    Call git tag $label_pose"
      git tag $label_pose
      error_rc=$?
      echo "    Call git push origin TMA"
      git push --tags origin Livraison:triou/TMA
      if [ $error_rc = 0 ]
      then
         # On previent l'administrateur et le project leader
         cat $TRUST_ROOT/externalpackages/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] externalpackages Release version - Tag a $release version: $label_pose \(See origin/triou/TMA branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER
      else
         echo "" | mail_ -s\"[lance_test_nuit] externalpackages - Tag a $release version: $label_pose KO\" $TRUST_MAIL
      fi
      cd - 1>/dev/null 2>&1
      echo " "
      echo "Release of the $release version: $label_pose"
      echo "New version $label_pose : Not delivery" >> $MESSAGES_NUIT

      # On pose le meme tag sur les BALTIK
      for Composant in $ComposantsGit
      do
         echo " "
         if [ "$Composant" = genepi ]
         then
            echo "  Update $Composant BALTIK:"
            cd $WORKDIR/tuleap/Livraison/Composants/$Composant
            error_rcb=0
            echo "    Call git commit --all -m Commit for a Release $release $label_pose version"
            git commit --all -m"Commit for a Release $release $label_pose version."
            echo "    Call git tag $label_pose"
            git tag $label_pose
            error_rcb=$?
            echo "    Call git push origin TMA"
            if [ $Composant != "flica5" ]
            then
               git push --tags origin Livraison:triou/TMA
            else
               git push origin Livraison:triou/TMA
            fi
            error_rcb=$?
            if [ $error_rcb = 0 ]
            then
               # On previent l'administrateur et les project leader
               BALTIK_PROJECT_LEADER=$Composant"_PROJECT_LEADER"
               cat $WORKDIR/tuleap/Livraison/Composants/$Composant/share/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] $Composant Release version - Tag a $release version: $label_pose \(See origin/triou/TMA branch\)\" $TRUST_MAIL $TMA_PROJECT_LEADER ${!BALTIK_PROJECT_LEADER}
            else
               echo "" | mail_ -s\"[lance_test_nuit] $Composant - Tag a $release version: $label_pose KO\" $TRUST_MAIL
            fi
         else
            echo " without label on baltik $Composant"
         fi
      done
      cd $TRUST_ROOT
   else
      echo " without label"
   fi
else
   if [ $criteres_remplis != $total_criteres ]
   then
     echo "=> release KO"
     if [ $accord_admin = 1 ]
     then
        echo "New version $label : Not delivery because only $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
     else
        echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
     fi
   fi
fi

#############################################################
# Si tous les criteres sont remplis, on tamponne la version !
#############################################################
export livraison=0
if [ $criteres_remplis = $total_criteres ]
then
   echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
   echo -e "=> release OK\c"
   if [ $accord_admin = 0 ]
   then
      [ $deja_livre = 0 ] && echo "New version $label : Delivery possible if agreement of $TRUST_MAIL" >> $MESSAGES_NUIT
      [ $deja_livre = 1 ] && echo "New version $label : Delivery already made" >> $MESSAGES_NUIT
   else
      # On decide du nom du label specifique
      label_rc=$label"_rc" && release=candidate && [ $accord_admin = 0 ] && label_rc=$label"_beta" && release=beta
      numero=`git tag | grep $label_rc | wc -l` && [ "$numero" = "" ] && numero=0
      let numero=$numero+1
      label_pose=$label_rc$numero
      # Le tag label est pose par Gauthier sur origin sinon conflit
      echo " with label "$label
      echo " "
      # Checkin et verification que tous les fichiers sont checkines
      erreur_checkin=""
      # Track again all files which were --assume-unchanged before:
      cd $TRUST_ROOT
      #Couverture de code genere sur l ensemble des baltiks et pas que sur TRUST donc on n ecrase pas...
      echo "  Call git update-index --no-assume-unchanged"
      for unchanged in `git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'`
      do
         git update-index --no-assume-unchanged $unchanged
      done
      # Commit & Push
      echo "  Call git commit --all -m Commit for an official Release $label version."
      git commit --all -m"Commit for an official Release $label version."
      echo "  Call git tag $label_pose"
      git tag $label_pose
      git_push -tags
      if [ "$erreur_checkin" != "" ]
      then
         echo "New version $label : Delivery canceled because some files could not be checkined: $erreur_checkin" >> $MESSAGES_NUIT
      else
         echo "New version $label : Delivery in progress..." >> $MESSAGES_NUIT
         livraison=1
         accord_beta=0
         echo "  Call git tag $label at "`date`
         git tag $label
         echo "  Call git push origin TMA"
         git push --tags origin Livraison:triou/TMA
         echo "  Call git push origin master"
         git push --tags origin Livraison:master
         # On pose le meme tag sur externalpackages
         cd externalpackages
         git commit --all -m"Commit for an official Release $label version."
         git tag $label_pose
         git push --tags origin Livraison:triou/TMA
         git tag $label
         git push --tags origin Livraison:master
         git fetch --all
         cd - 1>/dev/null 2>&1
         # Creation des packages TRUST et externalpackages
         echo " "
         echo "  Creation of the packages of TRUST and externalpackages"
         echo "!!! See ARCHIVES_TRUST (Warning externalpackages) and ARCHIVES_triocfd !!!" | mail_ -s\"[lance_test_nuit] WARNING! TRUST v$new released: Ensure that packages for ftp website and github are correct...\" $TRUST_MAIL
         mise_a_jour_TRUST_tar
         GRAVAGE=$WORKDIR/archives/ARCHIVES_TRUST
         version_arch=TRUST-$new".tar.gz"
         mv $TRUST_ROOT/$version_arch $GRAVAGE/.
         version_arch=externalpackages-$new".tar"
         mv $TRUST_ROOT/$version_arch $GRAVAGE/.

         echo " "
         echo "Creation of the packages of each Baltik component"
         # Creation des packages de chaque composant BALTIK
         cd $WORKDIR/tuleap/Livraison/TRUST
         source env_TRUST.sh 1>/dev/null 2>&1
         for Composant in $ComposantsGit
         do
            cd $WORKDIR/tuleap/Livraison/Composants/$Composant
            echo "from `pwd`"
            if [ "$Composant" = genepi ]
            then
               # On pose le meme tag sur le BALTIK genepi, les autres on y touche pas
               echo "    Call git commit --all -m Commit for an official Release $label version."
               git commit --all -m"Commit for an official Release $label version."
               echo "    Call git tag $label"
               git tag $label_pose
               if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
               then
                  git tag "$label"b
               else
                  git tag $label
               fi
               echo "    Call git push origin TMA"
               if [ $Composant != "flica5" ]
               then
                  git push --tags origin Livraison:triou/TMA
               else
                  git push origin Livraison:triou/TMA
                  git push origin Livraison:triou/$label
               fi
               if [ "$Composant" = triocfd ] # || [ "$Composant" = mpcube ]
               then
                  git push --tags origin Livraison:master
               fi
               git fetch --all
            fi
            # Appel du make distrib
            echo "    Call make distrib"
            make distrib_git
            mkdir -p $WORKDIR/archives/ARCHIVES_$Composant
            echo "    Copy $Composant.tar.gz to $WORKDIR/archives/ARCHIVES_$Composant/$Composant-$new.tar.gz"
            if [[ "$ComposantsBeta" = *"$Composant"* ]] # Test si Composant est dans la liste des composants Beta
            then
               cp -f $Composant.tar.gz $WORKDIR/archives/ARCHIVES_$Composant/$Composant-$new"b.tar.gz"
            else
               cp -f $Composant.tar.gz $WORKDIR/archives/ARCHIVES_$Composant/$Composant-$new.tar.gz
            fi
            echo | mail_ -s\"[lance_test_nuit] $Composant v$new is released under $WORKDIR/archives/ARCHIVES_$Composant\" $TRUST_MAIL
            echo " "
         done
         cd $WORKDIR/tuleap/Livraison/TRUST
         echo "Version $new : ...End" >> $MESSAGES_NUIT
         echo " "
         echo "Creation of the Stable version: $label"
      fi
   fi
fi
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo `date` >> $MESSAGES_NUIT
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
grep -A `echo $(($total_criteres+4))` -B 1 "Release criteria of the" $MESSAGES_NUIT > tmp_NUIT.txt
sed 's/$/ <BR>/g' tmp_NUIT.txt > tmp_NUIT.html
cat tmp_NUIT.html >> $REP_NUIT/NUIT.html
rm -f tmp_NUIT.txt tmp_NUIT.html
echo "<--- End at "`date '+%H:%M:%S %d/%m'`



####################################
# Envoi des binaires et des versions
####################################
echo " "
echo "####################"
echo "# Send to ftp site #"
echo "####################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`
for Composant in $Composants
do
   if [ -d $TRUST_ROOT/../Composants/$Composant ]
   then
      cd $TRUST_ROOT/../Composants/$Composant
      mkdir -p build/portability
      mv $Composant*.log build/portability/.
      mv Run.liste debut nuit_$Composant.html build/portability/.
   fi
   if [ -d $WORKDIR/tuleap/Maintenance/Composants/$Composant ]
   then
     cd $WORKDIR/tuleap/Maintenance/Composants/$Composant
     mkdir -p build/portability/Maintenance
     mv $Composant*.log build/portability/Maintenance/.
     mv Run.liste debut nuit_$Composant.html build/portability/Maintenance/.
     cd -
   fi
done
cd $TRUST_ROOT
envoie_ftp_log=$REP_NUIT/envoie_ftp_cea_fr_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/envoie_ftp_cea_fr"
echo "  See $envoie_ftp_log"
echo "TRUST script on $HOST the `date` ...">$envoie_ftp_log
echo>>$envoie_ftp_log
envoie_ftp_cea_fr 1>>$envoie_ftp_log 2>&1
echo>>$envoie_ftp_log
echo "End at `date` ...">>$envoie_ftp_log
grep -i killed $envoie_ftp_log
grep -i Error $envoie_ftp_log
grep KO $envoie_ftp_log
grep local $envoie_ftp_log

#####################################
# Mises a jour diverses de $TRUST_FTP
#####################################
cd $TRUST_TMP
# Update the index.html file of the FTP site:
if [ $livraison = 1 ]
then
   echo " "
   echo "Call to "$TRUST_ROOT"/bin/admin/cree_index.html"
   echo "from `pwd`"
   cree_index.html
fi
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

#-------------------------------------------------------
echo " "
echo "###########################"
echo "# Send announcements mail #"
echo "###########################"
echo "---> Begin at "`date '+%H:%M:%S %d/%m'`

################################################################################################
# Le mail des RELEASES NOTES est envoye aux developpeurs tous les lundis ou lors de la livraison
# sinon uniquement a l'admin TRUST et au chef de projet
################################################################################################
if [ "`date '+%u'`" = 1 ] || [ $livraison = 1 ] || [ $accord_beta = 1 ]
then
   ALL_DEVELOPERS_TRUST_MAIL="trio_u_dev@saxifrage.saclay.cea.fr"
   echo " " >> $MESSAGES_NUIT
   echo "TRUST support team: $TRUST_MAIL  Web: https://triocfd.cea.fr" >> $MESSAGES_NUIT
   echo " " >> $MESSAGES_NUIT
   echo "To unsubscribe from this list, send an e-mail to $TRUST_MAIL " >> $MESSAGES_NUIT
else
   ALL_DEVELOPERS_TRUST_MAIL=$TRUST_MAIL" "$TMA_PROJECT_LEADER" "$triocfd_PROJECT_LEADER" "$genepi3_PROJECT_LEADER" "$trust_team_members
fi

#####################################
# Envoi d'un message aux developpeurs
#####################################
cd $TRUST_ROOT
dest=$ALL_DEVELOPERS_TRUST_MAIL
#for dest in $ALL_DEVELOPERS_TRUST_MAIL
#do
   echo "$MESSAGES_NUIT sent to $dest"
   if [ $livraison = 0 ]
   then
      if [ $accord_beta = 0 ]
      then
         mail_ -s \"Release criteria of TRUST $new on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
      else
         mail_ -s \"Tagged release criteria of TRUST $label_pose on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
      fi
   elif [ $livraison = 1 ]
   then
      mail_ -s \"Tagged release criteria of TRUST $label_pose on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
   fi
#done

############################################################################
# Annonce d'une version stable a tout le monde (developpeur et utilisateurs)
############################################################################
if [ $livraison = 1 ]
then
   ALL_USERS_TRUST_MAIL="trio_u_annonces@saxifrage.saclay.cea.fr"
   push_error=1 # Temporary
   [ $push_error = 1 ] && ALL_USERS_TRUST_MAIL=$TRUST_MAIL
   echo "!!! mail not sent to trio_u_annonces !!!" | mail_ -s \"[lance_test_nuit] WARNING! TRUST v$new released: Ensure that git push origin has been done manually...\" $TRUST_MAIL
   for dest in $ALL_USERS_TRUST_MAIL
   do
      echo "Stable release announcement sent to $dest"
      echo "
TRUST is a thermalhydraulic software package for CFD simulations.
It was originally designed for incompressible single-phase and Low Mach Number
flows, but now also allows simulating real compressible multi-phase flows.
TRUST is also being progressively ported to support GPU acceleration (NVidia/AMD).
This software is OpenSource (BSD license).

A pre-installed TRUST v1.9.3 version on Ubuntu 20 is available on demand (experimental).

-------------------------------------------------
New TRUST version released v$new is now available
-------------------------------------------------
on GitHub: https://github.com/cea-trust-platform/trust-code

-----------------
Table of contents
-----------------
1. How to install?
2. How to run preinstalled version?
3. TRUST Release notes
4. TRUST Developer notes
5. externalpackages Release notes
6. Version tested on several OS
7. Version portability with several compilers

TRUST support team: $TRUST_MAIL
Website: https://cea-trust-platform.github.io

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
      echo "
---------------------------------------------------------------------------------------------
1. How to install?
---------------------------------------------------------------------------------------------
# First method:
git clone https://github.com/cea-trust-platform/trust-code.git TRUST-$new
cd TRUST-$new
wget ftp://ftp.cea.fr/pub/TRUST/externalpackages/externalpackages-$new.tar
tar xf externalpackages-$new.tar
./configure -help # To see the possible configure options.
./configure \$OPTIONS # where \$OPTIONS is the list of selected options.
make

# Second method:
wget ftp://ftp.cea.fr/pub/TRUST/TRUST/Version$new/TRUST-$new.tar.gz
tar xzf TRUST-$new.tar.gz
cd TRUST-$new
./configure -help # To see the possible configure options. On various OS, we configure TRUST with OPTIONS -force_provided_mpich (DO NOT use it on HPC clusters)
./configure \$OPTIONS # where \$OPTIONS is the list of selected options.
make

Warning: Check carefully the MPI version you want to use for parallel computing before installing the code, especially onto a HPC cluster.
The command mpicxx should be found into the bin directory of the MPI version you plan to use, to check that, run:
type mpicxx
---------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "
----------------------------------------------------------------------------------------------------
2. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for CEA Saclay (PC Titania file system or orcus cluster):
source /home/trust_trio-public/env_TRUST-$new.sh

# for TOPAZE and IRENE (Skylake & AMD Rome) supercomputers (64-bit integers version):
source /ccc/cont002/home/den/triou/env_TRUST-$new-int64.sh

# for TOPAZE and IRENE (AMD Rome) supercomputers (GPU version):
source /ccc/cont002/home/den/triou/env_TRUST-$new-gpu.sh

# for IDRIS (jean-zay) supercomputer (64-bit integers version):
source /gpfswork/rech/fej/ugz82dj/env_TRUST-$new-int64.sh

# for IDRIS (jean-zay) supercomputer (GPU version):
source /gpfswork/rech/fej/ugz82dj/env_TRUST-$new-gpu.sh

# for mezel supercomputer:
source /soft/commun/CODES/TRUST/env_TRUST-$new.sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
3. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/RELEASE_NOTES ] && echo $ECHO_OPTS "TRUST \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/RELEASE_NOTES >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
-------------------------------------------------------------
4. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/DEVELOPER_NOTES ] && echo $ECHO_OPTS "TRUST \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Developer notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/DEVELOPER_NOTES >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
5. \c" >> $MESSAGES_LIVRAISON
      [ -f $TRUST_ROOT/externalpackages/RELEASE_NOTES ] && echo $ECHO_OPTS "externalpackages \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/externalpackages/RELEASE_NOTES >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "6. Version tested on several OS" >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      sed 's/<BR><LI>/ /g'  $REP_NUIT/os >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "7. Version portability with several compilers" >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      sed 's/<BR><LI>/ /g'  $REP_NUIT/CC >> $MESSAGES_LIVRAISON
      echo "---------------------------------------------" >> $MESSAGES_LIVRAISON
      echo " " >> $MESSAGES_LIVRAISON
      mail_ -s \"New TRUST v$new released\" $dest < $MESSAGES_LIVRAISON
      sleep 5
      mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_TRUST
   done
   for Composant in $ComposantsGit
   do
      if [ "$Composant" == triocfd ]
      then
         echo "
TrioCFD (previously named \"Trio_U\") is the Computational Fluid Dynamics (CFD) code
based on the TRUST platform (\"TRUST\" with Front-Tracking, Radiation, ALE for fluid-structure interactions and Turbulence LES & RANS models).
This software is OpenSource (BSD license).

-----------------------------------
New TrioCFD version released v$new
-----------------------------------
is now available on Github: https://github.com/cea-trust-platform/TrioCFD-code

-----------------
Table of contents
-----------------
1. How to install?
2. How to run preinstalled version?
3. $Composant Release notes

TRUST/TrioCFD support team: $TRUST_MAIL
Website: https://triocfd.cea.fr

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
      echo "
---------------------------------------------------------------------------------------------
1. How to install?
---------------------------------------------------------------------------------------------
If TRUST-$new is not already installed, install it either with:
     $> git clone https://github.com/cea-trust-platform/trust-code.git TRUST-$new
     $> cd TRUST-$new
     $> wget ftp://ftp.cea.fr/pub/TRUST/externalpackages/externalpackages-$new.tar
     $> tar xf externalpackages-$new.tar
     $> ./configure \$OPTIONS
     $> make
or:
     $> wget ftp://ftp.cea.fr/pub/TRUST/TRUST/Version$new/TRUST-$new.tar.gz
     $> tar xzf TRUST-$new.tar.gz
     $> cd TRUST-$new
     $> ./configure \$OPTIONS
     $> make

Then, install TrioCFD-$new using one of these methods:
   # First method:
     $> git clone https://github.com/cea-trust-platform/TrioCFD-code.git TrioCFD-$new
     $> cd TrioCFD-$new
     $> source PathToTRUST-$new/env_TRUST.sh
     $> baltik_build_configure -execute
     $> make optim debug

   # Second method:
     $> wget ftp://ftp.cea.fr/pub/TRUST/TrioCFD/versions/v$new/TrioCFD-$new.tar.gz
     $> tar xzf TrioCFD-$new.tar.gz
     $> mv TrioCFD TrioCFD-$new
     $> cd TrioCFD-$new
     $> source PathToTRUST-$new/env_TRUST.sh
     $> baltik_build_configure -execute
     $> make optim debug

---------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo "
----------------------------------------------------------------------------------------------------
2. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for CEA Saclay (PC Titania file system or orcus cluster):
source /home/trust_trio-public/env_TrioCFD-$new.sh

# for TOPAZE and IRENE (Skylake & AMD Rome) supercomputers (64-bit integers version):
source /ccc/cont002/home/den/triou/env_TrioCFD-$new-int64.sh

# for TOPAZE and IRENE (AMD Rome) supercomputers (GPU version):
source /ccc/cont002/home/den/triou/env_TrioCFD-$new-gpu.sh

# for IDRIS (jean-zay) supercomputer (64-bit integers version):
source /gpfswork/rech/fej/ugz82dj/env_TrioCFD-$new-int64.sh

# for IDRIS (jean-zay) supercomputer (GPU version):
source /gpfswork/rech/fej/ugz82dj/env_TrioCFD-$new-gpu.sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
3. \c" >> $MESSAGES_LIVRAISON
         [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && echo $ECHO_OPTS "$Composant \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES >> $MESSAGES_LIVRAISON
         echo " " >> $MESSAGES_LIVRAISON
         mail_ -s \"New TrioCFD v$new released\" $TRUST_MAIL < $MESSAGES_LIVRAISON
         sleep 5
         mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_$Composant
      elif [ "$Composant" == triomc ]
      then
#         echo "
#TrioMC is a subchannel code dedicated to the study of SFR subassemblies
#at the complete core scale. Through the MATHYS code, TrioMC can be coupled:
#- with the TrioCFD code to model the coupling between the core and the inter-wrapper region;
#- with the CATHARE code to model the local core behavior during reactor transients.
#TrioMC is based on the TRUST platform.
#
#-----------------------------------
#New TrioMC version released v"$new"b
#-----------------------------------
#1. How to run preinstalled version?
#2. $Composant Release notes
#
#TRUST/TrioMC support team: $TRUST_MAIL  Web: https://triocfd.cea.fr
#MATHYS support team: mathys@cea.fr
#
#To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
         echo "
TrioMC is a subchannel code dedicated to the study of SFR subassemblies
at the complete core scale. Through the MATHYS code, TrioMC can be coupled:
- with the TrioCFD code to model the coupling between the core and the inter-wrapper region;
- with the CATHARE code to model the local core behavior during reactor transients.
TrioMC is based on the TRUST platform.

-----------------------------------
New TrioMC version released v"$new"
-----------------------------------
1. How to run preinstalled version?
2. $Composant Release notes

TRUST/TrioMC support team: $TRUST_MAIL  Web: https://triocfd.cea.fr
MATHYS support team: mathys@cea.fr

To unsubscribe from this list, send an e-mail to $TRUST_MAIL " > $MESSAGES_LIVRAISON
# echo "
#----------------------------------------------------------------------------------------------------
#1. How to run preinstalled version?
#----------------------------------------------------------------------------------------------------
## for PC connected to CEA SESI network:
#source /soft/der/sesi/TrioMC2/env_TrioMC2-"$new"b.sh
#
## for CEA Cadarache cluster (mezel):
#source /soft/mezel/TRIO/env_TrioMC2-"$new"b.sh
#
## for CEA Saclay cluster (callisto):
#source /home/triou/env_TrioMC2_"$new"b.sh
#----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
 echo "
----------------------------------------------------------------------------------------------------
1. How to run preinstalled version?
----------------------------------------------------------------------------------------------------
# for PC connected to CEA SESI network:
source /soft/der/sesi/TrioMC2/env_TrioMC2-"$new".sh

# for CEA Saclay cluster (callisto):
source /home/triou/env_TrioMC2_"$new".sh
----------------------------------------------------------------------------------------------------" >> $MESSAGES_LIVRAISON
      echo $ECHO_OPTS "
--------------------------------------------------------------------------------------------------
2. \c" >> $MESSAGES_LIVRAISON
         [ -f $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES ] && echo $ECHO_OPTS "$Composant \c" >> $MESSAGES_LIVRAISON && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/../Composants/$Composant/share/RELEASE_NOTES >> $MESSAGES_LIVRAISON
         echo " " >> $MESSAGES_LIVRAISON
         #mail_ -s \"New TrioMC v"$new"b released\" $TRUST_MAIL < $MESSAGES_LIVRAISON
         mail_ -s \"New TrioMC v"$new" released\" $TRUST_MAIL < $MESSAGES_LIVRAISON
         sleep 5
         mv -f $MESSAGES_LIVRAISON $REP_NUIT/MESSAGES_LIVRAISON_$Composant
      fi
   done
   ########################################################
   # On change les NOTES en augmentant le numero de version
   # car sinon on risque des ennuis le lendemain (Version1.5.3.tar+cle effaces dans ARCHIVES_TRUST)
   echo " "
   echo "Call CHECKOUT $TRUST_ROOT/RELEASE_NOTES $TRUST_ROOT/DEVELOPER_NOTES"
   CHECKOUT $TRUST_ROOT/RELEASE_NOTES $TRUST_ROOT/DEVELOPER_NOTES
   next_new=`echo $new | $TRUST_Awk -F"." '{if (NF==3) print $1"."$2"."$3+1"_beta";else if (NF==2) print $1"."$2".1_beta"}'`
   echo "--------------------------------------------------------------------------------------------------
Release notes version $next_new : Enhancements, modifications and corrected bugs since version $new :
--------------------------------------------------------------------------------------------------" > $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_ROOT/RELEASE_NOTES >> $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_TMP/RELEASE_NOTES > $TRUST_ROOT/RELEASE_NOTES
   echo "-------------------------------------------------------------
Developer notes version $next_new : Changes since version $new :
-------------------------------------------------------------" > $TRUST_TMP/DEVELOPER_NOTES
   cat $TRUST_ROOT/DEVELOPER_NOTES >> $TRUST_TMP/DEVELOPER_NOTES
   cat $TRUST_TMP/DEVELOPER_NOTES > $TRUST_ROOT/DEVELOPER_NOTES
   cd $TRUST_ROOT/externalpackages
   echo "--------------------------------------------------------------------------------------------------
Release notes version $next_new : Enhancements, modifications and corrected bugs since version $new :
--------------------------------------------------------------------------------------------------" > $TRUST_TMP/RELEASE_NOTES
   cat RELEASE_NOTES >> $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_TMP/RELEASE_NOTES > RELEASE_NOTES
   cd - 1>/dev/null 2>&1
   for Composant in $ComposantsOfficial
   do
      cd $WORKDIR/tuleap/Livraison/Composants/$Composant
      echo "--------------------------------------------------------------------------------------------------
Release notes version $next_new : Enhancements, modifications and corrected bugs since version $new :
--------------------------------------------------------------------------------------------------" > RELEASE_NOTES
      cat share/RELEASE_NOTES >> RELEASE_NOTES
      cat RELEASE_NOTES > share/RELEASE_NOTES
      rm RELEASE_NOTES
      cd - 1>/dev/null 2>&1
   done
   # Commit immediately to differenciate master and patch branchs for setting the correct default branch after git clone
   # See http://git.661346.n2.nabble.com/git-clone-not-getting-the-correct-default-branch-td7476876.html
   echo " "
   #echo "Call git commit --all"
   #git commit --all -m"First automatic commit"
   cd $TRUST_ROOT
   ################################################
   # Installation a distance sur plusieurs machines
   ################################################
   echo " "
   echo "Call to "$TRUST_ROOT"/bin/admin/Installer_TRUST.ssh on:"
   liste_machines updated
   for machine in `liste_machines updated`
   do
      (
       install_stable_log=$REP_NUIT"/install_stable_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
       echo "-> Start of Installer_TRUST.ssh $machine $new -compile..."
       echo "  See $install_stable_log"
      )
   done
   for machine in `liste_machines updated`
   do
      (
      install_stable_log=$REP_NUIT"/install_stable_"`echo $machine | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'`"_"${vue#*/}".log"
      echo "TRUST script on $HOST the `date` ...">$install_stable_log
      echo>>$install_stable_log
      $TRUST_ROOT/bin/admin/Installer_TRUST.ssh $machine $new -compile 1>>$install_stable_log 2>&1
      if [ $? != 0 ] || [ "`grep :error $install_stable_log | grep -iv warning | grep -v TRIOXDATA | grep -v Gmsh`" != "" ]
      then
         cat $install_stable_log | mail_ -s \"[lance_test_nuit] Failed to install stable version on $machine\" $TRUST_MAIL
      fi
      ) &
   done
   #wait
   echo " "
fi
echo `echo ~`"/CR sent to $TRUST_MAIL"
echo "<--- End at "`date '+%H:%M:%S %d/%m'`

echo " "
echo "****************************************************"
echo "End of the `basename $0` script at `date '+%H:%M:%S'`."
echo `date`
echo "****************************************************"

mail_ -s\"[lance_test_nuit] Night report of TRUST ATELIER  on `date '+%d/%m/%y'`\" $TRUST_MAIL < ~/CR
# On deplace le CR
mv -f ~/CR $REP_NUIT/CR
cp -f $REP_NUIT/CR $REP_HIST/CR.$DATE

# On copie sur ftp NUIT
. connect_ftp 1>/dev/null 2>&1
# Ne plus copier CR...
#cp_ftp $REP_NUIT/CR $SECRET/NUIT/.
cp_ftp $MESSAGES_NUIT $SECRET/NUIT/.

# On sauvegarde l'historique de la nuit
cd $REP_NUIT
git rm .nfs*
git add --all
git commit -m"Commit $DATE"
cd $TRUST_ROOT
