#!/bin/bash
# Git supported
# Dans la journee, pour forcer la compilation a distance
# Desormais le mise_a_jour_TRUST_tar est appele si necessaire
# depuis cette procedure
ssh_command()
{
    # Le sh devant mise_a_jour_TRUST_arch est important sur titane!!
    # Comprends pas pourquoi...
    # Creation d'un fichier de commandes car probleme si le SHELL n'est pas bash 1> 2> pas reconnu
    command=`mktemp_`
    echo > $command
    # Sur certaines machines un Killed by signal 1 empeche l'execution (supermuc par exemple)
    [ $adr != supermuc.lrz.de ] && echo ". ~/.bashrc 1>/dev/null 2>&1" >> $command
    echo $* >> $command
    scp -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $command $log@$adr:~/command_$machine 1>/dev/null 2>&1
    rm -f $command
    # Add -X to have DISPLAY ?
    ssh -X -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'chmod +x ./command_'$machine';./command_'$machine 2>/dev/null
}
echo "Usage: `basename $0` [machine1 machine2 ...]"
all=1 && [ ${#1} != 0 ] && all=0 && machines=$*

# Teste la connection :
[ ${#Version} = 0 ] && Version=Version_dev
[ ${#Version} = 0 ] && echo "What version?" && exit
. connect_ftp -no_ftp
eval `/usr/bin/ssh-agent` 1>/dev/null 2>&1

echo "------------------------------------"
# Ne marche pas : !!!
#LISTE_TRUST_ROOT="*.tgz"
a_jour_TRUST_tgz_files=0
a_jour_TRUST_tgz=0

#LISTE_DIPHA_ROOT="Diphasique.tar.gz lib.tar.gz"
[ ${#DIPHA_ROOT} = 0 ] && DIPHA_ROOT=`dirname $TRUST_ROOT`/Diphasique && export DIPHA_ROOT

liste_machines=$TRUST_ROOT/bin/admin/liste.machines

######################
# Liste des machines #
######################
liste=`liste_machines`
if [ $all = 1 ]
then
   liste_adr=$liste
else
   for machine in $machines
   do
      reconnue=0
      for adr in $liste
      do 
         [ $adr = $machine ] && liste_adr=$liste_adr" "$adr && reconnue=1 && break
      done
      [ $reconnue = 0 ] && echo "$machine not found in $TRUST_ROOT/bin/admin/liste.machines..." && exit
   done
fi

# Determination si un repertoire a ete checkoute et donc
# un fichier potentiellement renomme ou efface (auquel cas on doit faire un delete)
# On le fait aussi le vendredi
#VOBS="Doc_TRUST Pre_Post_TRUST Tests_TRUST TRUST"
VOBS="TRUST"
if [ "$delete_version_machine_cible" = "" ]
then
   delete_version_machine_cible=0
   if [ -d $TRUST_ROOT/.git ]
   then 
      #if [ "`git log --since=1.days..HEAD --name-status | grep ^D | grep -v ^Date`" != "" ]
      # Look for the last commit where at least on file was deleted:
      last_commit=`git log --diff-filter=D | awk '/commit / {print substr($2,1,7)}' | head -1`
      # Check if this commit is in the last day compared to the HEAD or if future commit contains deleted files:
      if [ "`git log --since=1.days..HEAD --name-status | grep $last_commit`" != "" ] || [ "`git status --u=no | grep deleted:`" != "" ]
      then
         delete_version_machine_cible=1
	 echo "Several files were moved or deleted in Git since yesterday then we must make a delete on remote machines." 
     fi 
   else
      if [ -d $TRUST_ROOT/externalpackages/.git ]
      then
         cd $TRUST_ROOT/externalpackages
         # Look for the last commit where at least on branch was merged:
         last_commit=`git log --merges | awk '/commit / {print substr($2,1,7)}' | head -1`
         # Check if this commit is in the last day compared to the HEAD or if future commit contains merged branchs:
         if [ "`git log --since=1.days..HEAD | grep $last_commit`" != "" ]
         then
            delete_version_machine_cible=1
            echo "Several branchs were merged in Git since yesterday then we must make a delete on remote machines." 
         fi
         cd -
      else
         echo "Detection of a deleted file not implemented yet outside Git." 1>/dev/null 2>&1
      fi
   fi
fi
# Versions distantes automatiquement effacees le vendredi
[ "`date '+%u'`" = 5 ] && delete_version_machine_cible=1 && echo "We delete the version on the machines of type cible on Friday."
# Versions distantes ponctuellement effacees avec un "touch ~/delete_version_machine_cible"
[ -f ~/delete_version_machine_cible ] && delete_version_machine_cible=1 && echo "We delete the version on the machines of type cible promptly." && rm -f ~/delete_version_machine_cible

#########################
# Boucle sur les machines
#########################
echo "------------------------------------"
liste_machines_KO=""
for adr in $liste_adr
do
   #machine=`echo $adr | awk -F"." '{print $1}'`
   machine=`echo $adr | awk -F"." '{print $1}' | awk -F"-gw" '{print $1}'` # 09/2015 Modification des acces SSH au TGCC *-gw.ccc.cea.fr
   version=$WORKBASE$machine
   log=`awk -v adr=$adr '($2==adr) {print $4}' ~/.netrc | head -1`      
   ssh_log=$TRUST_ROOT/ssh_$machine.log
   echo "ssh on $machine the `date` ...">$ssh_log
   if [ "$log" = "" ]
   then
      echo "KO $adr machine not reported in ~/.netrc"
      liste_machines_KO=$liste_machines_KO" "$adr
   # Les machines git_cron ne sont pas accessibles par ssh
   elif [ "`liste_machines git_cron | grep $adr`" = "" ] && [ "`ssh_ -o ConnectTimeout=30 -o BatchMode=yes $log@$adr -n pwd 1>>$ssh_log 2>&1;echo $?`" != 0 ]
   then
      echo "KO $adr machine not accessible via ssh. See $ssh_log" 
      liste_machines_KO=$liste_machines_KO" "$adr
   else
      ##################################################
      # Determination de WORKDIR si accessible par ssh #
      ##################################################
      if [ "`liste_machines git_cron | grep $adr`" = "" ]
      then
         WORKDIR=`ssh_command 'if [ "\$WORKDIR" = "" ]; then echo \$HOME;else echo \$WORKDIR;fi'`
         WORKBASE=`ssh_command 'if [ "\$WORKBASE" = "" ]; then echo Version_beta_;else echo \$WORKBASE;fi'`
         echo "We have WORKDIR=$WORKDIR and WORKBASE=$WORKBASE on host $adr"
         [ "$WORKDIR" = "" ] && echo "KO $adr WORKDIR empty! See rsync_$adr.log" && echo "WORKDIR empty on $log@$adr" | mail_ -s\"[envoie_TRUST_arch] Configuration $machine KO\" $TRUST_MAIL
         [ "$WORKBASE" = "" ] && echo "KO $adr WORKBASE empty! See rsync_$adr.log" && echo "WORKBASE empty on $log@$adr" | mail_ -s\"[envoie_TRUST_arch] Configuration $machine KO\" $TRUST_MAIL
      fi
      ##########################################################################
      # 4 modes supportes:
      # git_cron  : git des sources depuis la machine et build lance par crontab  => no updated with TRUST
      # git_ssh   : git des sources depuis la machine et build lance par ssh      => no updated with TRUST
      # rsync_ssh : rsync des sources vers la machine et build lance par ssh
      # sftp_ssh  : sftp des sources vers la machine et build lance par ssh 
      # sinon     : scp des sources vers la machine et build lance par ssh 
      ##########################################################################
          
      #################
      # Mode git_cron #
      #################
      if [ "`liste_machines git_cron | grep $adr`" != "" ]
      then
         # Donc on ne fait rien:
	 echo "Sources updated by Git on $log@$adr at "`date '+%H:%M:%S'`      
	 #echo "Launching the update by crontab on $log@$adr at "`date '+%H:%M:%S'`
	 
	 # no updated with TRUST
         echo "KO $adr machine => git_cron mode no supported with TRUST for the moment!" 
         liste_machines_KO=$liste_machines_KO" "$adr
	 
      ################
      # Mode git_ssh #
      ################ 
      elif [ "`liste_machines git_ssh | grep $adr`" != "" ]
      then
	 echo "Sources updated by Git on $log@$adr:$WORKDIR/$version at "`date '+%H:%M:%S'` 
	 # Si premiere installation:
	 #if [ "`ssh_ -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n ls $WORKDIR/$version/TRUST/.git 1>/dev/null 2>&1;echo $?`" != 0 ]
	 #then
	 #   ssh_command "git clone $TRUST_GIT_OFFICIAL $WORKDIR/$version/TRUST;cd $WORKDIR/$version/TRUST;git checkout -b master origin/master"
	 #fi
	 #ssh_command "export WORKBASE=$WORKBASE;cd $WORKDIR/$version/TRUST/bin/admin;./mise_a_jour_TRUST_arch -git 1>~/CR_$machine 2>&1" &     
	 #echo "Launching the update by ssh on $log@$adr at "`date '+%H:%M:%S'`   
	 
	 # no updated with TRUST
         echo "KO $adr machine => git_ssh mode no supported with TRUST for the moment!" 
         liste_machines_KO=$liste_machines_KO" "$adr
	 
      ##################
      # Mode rsync_ssh #
      ##################
      # On teste si rsync marche sinon on bascule sur le mode scp+ssh
      elif [ "`liste_machines rsync_ssh | grep $adr`" != "" ]
      then
	 rsync_log=$TRUST_ROOT/rsync_$machine.log
	 echo "rsync on $machine the `date` ...">$rsync_log
         if [ "`rsync -e 'ssh -o StrictHostKeyChecking=no' --dirs --delete --dry-run $TRUST_ROOT/RELEASE_NOTES $log@$adr:/tmp 1>/dev/null 2>&1;echo $?`" = 0 ]
         then
	    if [ "$a_jour_TRUST_tgz_files" != 1 ]
	    then
	       echo " "
	       echo "Searching for files to rsync..."
	       a_jour_TRUST_tgz_files=1
	       mise_a_jour_TRUST_tar -files_only -without_version
	       # Creation du fichier pattern pour --include-from
	       cd $TRUST_ROOT
	       rm -f rsync_include_from
	       for file in TRUST.files
	       do
	          VOB=${file%.files}
		  echo $VOB >> rsync_include_from
		  cat $file >> rsync_include_from
	       done
	       echo "$TRUST_ROOT/rsync_include_from updated."
	       echo " "
	    fi
            
	    # Creation eventuelle du repertoire:
	    ssh_command '[ ! -d '$WORKDIR/$version'/TRUST ] && mkdir -p '$WORKDIR/$version'/TRUST'
	    
	    # Cas ou l'on efface la version
	    if [ "$delete_version_machine_cible" = 1 ]
	    then
	       # On fait en 2 passes (car sinon conflit possible)
	       echo "Deleting $WORKDIR/$version on $log@$adr..."
	       ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=30 -o BatchMode=yes $log@$adr -n 'cd '$WORKDIR/$version';mv -f TRUST trashT;mkdir -p TRUST'
	       ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=30 -o BatchMode=yes $log@$adr -n 'rm -r -f '$WORKDIR/$version'/trashT 1>/dev/null 2>&1' & 
	       ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=30 -o BatchMode=yes $log@$adr -n 'cd '$WORKDIR/$version';mv -f Composants trashC;mkdir -p Composants'
	       ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=30 -o BatchMode=yes $log@$adr -n 'rm -r -f '$WORKDIR/$version'/trashC 1>/dev/null 2>&1' & 
            fi
	    
	    echo "rsync of sources on $log@$adr:$WORKDIR/$version at "`date '+%H:%M:%S'`
	    cd $TRUST_ROOT/.. #sinon rsync plante...
            for VOB in $VOBS
	    do
	       # -delete ne marche pas avec --files-from. A savoir. Voir: http://stackoverflow.com/questions/1813907/rsync-delete-files-from-list-dest-does-not-delete-unwanted-files
	       rsync -e 'ssh -o StrictHostKeyChecking=no' --stats -aiHD --delete --files-from=$TRUST_ROOT/$VOB.files --timeout=1000 . $log@$adr:$WORKDIR/$version
	    done | grep -v "^\." 1>>$rsync_log 2>&1 # On filtre pour n'avoir que les fichiers modifies/deleted remotely
	    if [ $? != 0 ]
	    then
               echo "KO $adr machine: rsync error. See $rsync_log" 
               liste_machines_KO=$liste_machines_KO" "$adr
	    fi
	    cd $TRUST_ROOT	 
            
	    # Creation eventuelle du lien:
	    ssh_command '[ "$WORKDIR" != "" ] && [ "$WORKDIR" != "$HOME" ] && cd $HOME && rm -f '$version' && ln -s -f $WORKDIR/'$version' .'
	    
	    # Lancement par ssh:
	    option=""
	    if [ "$machine" = airain ] || [ "$machine" = curie-ccrt ]
	    then
	       # CR bugges sur CCRT, on debugge:
	       option="sh -xv "
               option=""
	       # machine=$machine".bak" # Pourquoi CR_$machine est abime?
            fi
	    ssh_command "export WORKBASE=$WORKBASE;cd $WORKDIR/$version/TRUST/bin/admin;$option./mise_a_jour_TRUST_arch -rsync 1>~/CR_$machine 2>&1" &
	    echo "Launching in background the update by ssh on $log@$adr at "`date '+%H:%M:%S'`
	 
	 else
            rsync -e 'ssh -o StrictHostKeyChecking=no' --dirs --delete --dry-run $TRUST_ROOT/RELEASE_NOTES $log@$adr:/tmp 1>>$rsyn_log 2>&1
            echo "KO $adr machine => rsync_ssh mode error. See $rsync_log" 
            liste_machines_KO=$liste_machines_KO" "$adr
	 fi

      #################
      # Mode sftp_ssh #
      ################# 	 
      elif [ "`liste_machines sftp_ssh | grep $adr`" != "" ]
      then
	 # Cas ou l'on efface la version
	 if [ "$delete_version_machine_cible" = 1 ]
	 then
	    # On fait en 2 passes (car sinon conflit possible)
	    echo "Deleting $WORKDIR/$version on $log@$adr..."
	    ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'cd '$WORKDIR/$version';mv -f TRUST trashT;mkdir -p TRUST'
	    ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'rm -r -f '$WORKDIR/$version'/trashT 1>/dev/null 2>&1' &  
	    ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'cd '$WORKDIR/$version';mv -f Composants trashC;mkdir -p Composants'
	    ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'rm -r -f '$WORKDIR/$version'/trashC 1>/dev/null 2>&1' &  
         fi	 
	 
	 # Construction des paquets si necessaire
	 [ "$a_jour_TRUST_tgz" != 1 ] && echo " " && mise_a_jour_TRUST_tar -without_version && echo " " && a_jour_TRUST_tgz=1	
	  
	 echo "Sending by sftp of sources on $log@$adr:$WORKDIR/$version at "`date '+%H:%M:%S'`
	 echo "
-cd $WORKDIR
-mkdir $version  
-cd $version
-lcd $TRUST_ROOT
-rm *.tgz
-mput *.tgz" > $TRUST_TMP/ssh_com
          sftp -o ConnectTimeout=10 -o BatchMode=yes -b $TRUST_TMP/ssh_com $log@$adr 1>/dev/null 2>&1
          # On coupe en deux car cd ou cd $HOME pas reconnu par sftp: copie de mise_a_jour* sous ~/ ie $HOMEDIR
          echo "
-lcd $TRUST_ROOT/bin/admin
-put mise_a_jour_TRUST_arch
-chmod 755 mise_a_jour_TRUST_arch" > $TRUST_TMP/ssh_com
         sftp -o ConnectTimeout=10 -o BatchMode=yes -b $TRUST_TMP/ssh_com $log@$adr 1>/dev/null 2>&1	 
         
	 # Creation eventuelle du lien:
	 ssh_command '[ "$WORKDIR" != "" ] && [ "$WORKDIR" != "$HOME" ] && cd $HOME && rm -f '$version' && ln -s -f $WORKDIR/'$version' .'
	 
	 # Lancement par ssh à partir de $HOMEDIR
         ssh_command "export WORKBASE=$WORKBASE;./mise_a_jour_TRUST_arch -sftp 1>~/CR_$machine 2>&1" &
	 echo "Launching in background the update by ssh on $log@$adr"

      #################
      # Mode scp_ssh #
      ################# 	 
      else
	 # Cas ou l'on efface la version
	 if [ "$delete_version_machine_cible" = 1 ]
	 then
	    # On fait en 2 passes (car sinon conflit possible)
	    echo "Deleting $WORKDIR/$version on $log@$adr..."
	    ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'cd '$WORKDIR/$version';mv -f TRUST trashT;mkdir -p TRUST'
	    ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'rm -r -f '$WORKDIR/$version'/trashT 1>/dev/null 2>&1' &  
	    ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'cd '$WORKDIR/$version';mv -f Composants trashC;mkdir -p Composants'
	    ssh -o "StrictHostKeyChecking no" -o ConnectTimeout=10 -o BatchMode=yes $log@$adr -n 'rm -r -f '$WORKDIR/$version'/trashC 1>/dev/null 2>&1' &  
         fi
	 
	 # Construction des paquets si necessaire
	 [ "$a_jour_TRUST_tgz" != 1 ] && echo " " && mise_a_jour_TRUST_tar -without_version && echo " " && a_jour_TRUST_tgz=1
	 
	 echo "Sending by scp of sources on $log@$adr:$WORKDIR/$version at "`date '+%H:%M:%S'`
	 ssh_command "cd $WORKDIR; mkdir $version; cd $version; rm *.tgz"
	 scp -o ConnectTimeout=10 -o BatchMode=yes $TRUST_ROOT/*.tgz $log@$adr:$WORKDIR/$version/.
	 scp -o ConnectTimeout=10 -o BatchMode=yes $TRUST_ROOT/bin/admin/mise_a_jour_TRUST_arch $log@$adr:~/.
	 ssh_command "cd ~; chmod 755 mise_a_jour_TRUST_arch"	 
         
	 # Creation eventuelle du lien:
	 ssh_command '[ "$WORKDIR" != "" ] && [ "$WORKDIR" != "$HOME" ] && cd $HOME && rm -f '$version' && ln -s -f $WORKDIR/'$version' .'
	 
	 # Lancement par ssh
         ssh_command "export WORKBASE=$WORKBASE;./mise_a_jour_TRUST_arch -sftp 1>~/CR_$machine 2>&1" &
	 echo "Launching in background the update by ssh on $log@$adr"
      fi
   fi
   echo "------------------------------------"
done
if [ ${#liste_machines_KO} != 0 ] # chaine non vide
then
   echo "liste_machines_KO="$liste_machines_KO
fi
echo "------------------------------------"
[ "$NUIT" = "1" ] && echo $liste_machines_KO > liste_envoie_KO # cf lance_test_nuit
eval `/usr/bin/ssh-agent -k` 1>/dev/null 2>&1
echo "End at `date` ..."
