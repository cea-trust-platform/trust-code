####################################
# Solveurs matrices non symetriques:
####################################

# Solveur Optimal
let i=$i+1;solver[$i]="Optimal        { seuil $seuil impr }"        						;sym[$i]=0                  	

# GMRES DIAG/ILU
let i=$i+1;solver[$i]="Petsc GMRES    { seuil $seuil precond DIAG { } restart 30 impr }"					;rank[$i]=4;
#let i=$i+1;solver[$i]="Petsc GMRES   { seuil $seuil precond ILU { level 1 } impr }"	
#let i=$i+1;solver[$i]="Petsc GMRES   { seuil $seuil precond PILUT { level 20 epsilon 0.01 } impr }"	
let i=$i+1;solver[$i]="Petsc GMRES    { seuil $seuil precond BLOCK_JACOBI_ILU { level 0 } impr }"				;rank[$i]=8;		

# BICGSTAB
let i=$i+1;solver[$i]="Petsc CLI      { -ksp_type bcgs -pc_type sor -ksp_atol $seuil }"	
let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond DIAG { } impr }"							;rank[$i]=3;
let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond SSOR { omega 1 } impr }"	# EISENSTAT ne marche pas 3.0.0 mais OK avec 3.1.0
let i=$i+1;solver[$i]="Petsc CLI      { -ksp_type bcgs -pc_type hypre -pc_hypre_type pilut -pc_hypre_pilut_factorrowsize 20 -pc_hypre_pilut_tol 0.01 -ksp_atol $seuil }"	;
let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond SPAI { level 2 epsilon 0.2 } impr }"	
let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond BLOCK_JACOBI_ILU { level 0 } impr }"				;rank[$i]=0;
let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond BLOCK_JACOBI_ICC { level 0 } impr }"		;sym[$i]=1 	
let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond BLOCK_JACOBI_ICC { level 1 ordering rcm } impr }"	;sym[$i]=1 	;rank[$i]=1;
#let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond ILU { level 0 } impr }"
#let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond PILUT { level 1 } impr }"	# PILUT instead ILUT because CHANGES in the PETSc 3.6 Version: Removed -pc_hypre_type euclid due to bit-rot
#let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond ILU { level 1 } impr }"	
#let i=$i+1;solver[$i]="Petsc BICGSTAB { seuil $seuil precond PILUT { level 20 epsilon 0.01 } impr }"	

# iBCGSTAB+BLOCK_JACOBI_ILU/ICC
let i=$i+1;solver[$i]="Petsc IBICGSTAB { seuil $seuil precond BLOCK_JACOBI_ILU { level 0 } impr }"				;rank[$i]=2;
let i=$i+1;solver[$i]="Petsc IBICGSTAB { seuil $seuil precond BLOCK_JACOBI_ICC { level 1 ordering rcm } impr }"	;sym[$i]=1	;rank[$i]=2;

# Reference TRUST GMRES+DIAG
let i=$i+1;solver[$i]="Gmres          { seuil $seuil diag controle_residu 1 impr }"				;sym[$i]=0	;rank[$i]=5;
# Reference TRUST BICGSTAB+DIAG
let i=$i+1;solver[$i]="Gen            { seuil $seuil solv_elem bicgstab precond ilu { type 0 filling 10 } impr }" ;sym[$i]=0	;rank[$i]=0;

################################
# Solveurs matrices symetriques:
################################
# References TRUST (GC+SSOR - Cholesky)
let i=$i+1;solver[$i]="GCP            { seuil $seuil precond ssor { omega 1.65 } impr }"			;sym[$i]=1	;rank[$i]=1;
# Marche pas en VEF:
#let i=$i+1;solver[$i]="GCP            { optimized seuil $seuil precond ssor { omega 1.65 } impr }"		;sym[$i]=1	

# Solveur Optimal
let i=$i+1;solver[$i]="Optimal        { seuil $seuil impr }"        						;sym[$i]=1                  	

# Cholesky Mumps (Fonctionne en non symetrique mais aucun interet pour TRUST)
let i=$i+1;solver[$i]="Petsc Cholesky { impr }"									;sym[$i]=1 	;rank[$i]=3;
let i=$i+1;solver[$i]="Petsc Cholesky_mumps_blr { impr }"							;sym[$i]=1 	;rank[$i]=3;
let i=$i+1;solver[$i]="Petsc Cholesky_mumps_blr { dropping_parameter 1.e-6 impr }"						;sym[$i]=1 	;rank[$i]=3;
let i=$i+1;solver[$i]="Petsc Cholesky { ordering metis impr }"							;sym[$i]=1 	;rank[$i]=4;
if [ -f /usr/bin/bison ]
then
let i=$i+1;solver[$i]="Petsc Cholesky { ordering scotch impr }"							;sym[$i]=1 	;rank[$i]=5;
let i=$i+1;solver[$i]="Petsc Cholesky { ordering pt-scotch impr }"				;par[$i]=1	;sym[$i]=1 	;rank[$i]=7;
fi
let i=$i+1;solver[$i]="Petsc Cholesky { ordering parmetis impr }"				;par[$i]=1	;sym[$i]=1 	;rank[$i]=6;
let i=$i+1;solver[$i]="Petsc Cholesky_out_of_core { impr }"							;sym[$i]=1 
# Si PETSc est construit avec SuperLu:
if [ "`grep -i superlu $TRUST_ENV/make.liba`" != "" ]
then
   i=$i+1;solver[$i]="Petsc Cholesky_SuperLU { impr }"								;sym[$i]=1 
fi
#if [ $exec = $exec_opt ] # Pastix crashes in debug...
#then
# Crash also in optimized when feenableexcept activated
#   let i=$i+1;solver[$i]="Petsc Cholesky_Pastix { impr }"							;sym[$i]=1 
#fi
let i=$i+1;solver[$i]="Petsc Cholesky_Umfpack { impr }"						;par[$i]=0	;sym[$i]=1 
let i=$i+1;solver[$i]="Petsc Cholesky_Lapack { impr }"						;par[$i]=0	;sym[$i]=1 

# GC + SSOR / EISENSTAT / ASM 
let i=$i+1;solver[$i]="Petsc GCP      { seuil $seuil precond SSOR { omega 1.65 } impr }"			;sym[$i]=1	;rank[$i]=2;
let i=$i+1;solver[$i]="Petsc GCP      { seuil $seuil precond SSOR { omega 1.65 } impr aij }"			;sym[$i]=1	;rank[$i]=2;
let i=$i+1;solver[$i]="Petsc GCP      { seuil $seuil precond EISENSTAT { omega 1.65 } impr }"			;sym[$i]=1	# OK avec 3.1.0 mais apporte rien

# GC / ASM ILU(0)
let i=$i+1;solver[$i]="Petsc CLI      { -ksp_type cg -pc_type asm -ksp_atol $seuil }"				;sym[$i]=1	

# GC / ASM SOR
# Impossible d'arriver a faire converger ASM mieux que BJACOBI, bizarre, niter augmente si pc_asm_overlap augmente
# Marche mieux avec ICC(1) voir le cas PAR_Cx 2 (reduit le nombre d'iterations mais bjacobi_icc(1) toujours le plus rapide)
let i=$i+1;solver[$i]="Petsc CLI      { -ksp_type cg -pc_type asm -sub_pc_type sor -sub_pc_sor_omega 1.65 -pc_asm_overlap 0 -ksp_atol $seuil }"	;sym[$i]=1 # Identique a SSOR

# CG + ILU HYPRE
#let i=$i+1;solver[$i]="Petsc GCP      { seuil $seuil precond ILU { level 1 } impr }"				;sym[$i]=1	# Hypre decevant, on prend ILU petsc meilleur
#let i=$i+1;solver[$i]="Petsc GCP      { seuil $seuil precond PILUT { level 20 epsilon 0.01 } impr }"		;sym[$i]=1	# PILUT instead ILUT because CHANGES in the PETSc 3.6 Version: Removed -pc_hypre_type euclid due to bit-rot

# CG + BLOCK JACOBI ILU PETSC
let i=$i+1;solver[$i]="Petsc GCP      { seuil $seuil precond BLOCK_JACOBI_ICC { level 1 } impr }"		;sym[$i]=1	;rank[$i]=8;		

# GC + SPAI
let i=$i+1;solver[$i]="Petsc GCP      { seuil $seuil precond SPAI { level 2 epsilon 0.2 } impr }"		;sym[$i]=1	

# GMRES + BOOMERAMG
let i=$i+1;solver[$i]="Petsc GMRES      { seuil $seuil precond BOOMERAMG { } CLI { -pc_hypre_boomeramg_strong_threshold 0.9 } impr }"	;sym[$i]=1	

# PIPECG + SSOR
let i=$i+1;solver[$i]="Petsc PIPECG   { seuil $seuil precond SSOR { omega 1.65 } impr }"			;sym[$i]=1

##########################
# Solveurs tested on GPU #
##########################
let i=$i+1;solver[$i]="Petsc     GCP  { seuil $seuil precond SSOR { omega 1.6 } impr }"				;gpu[$i]=1	;sym[$i]=1
let i=$i+1;solver[$i]="Petsc     GCP  { seuil $seuil precond DIAG { } impr }"					;gpu[$i]=1	;sym[$i]=1
# cusparse and hyb format seems the fastest (confirmed on curie) and according to: https://www.epcc.ed.ac.uk/sites/default/files/Dissertations/2010-2011/PramodKumbhar.pdf
let i=$i+1;solver[$i]="Petsc_GPU CLI  { -ksp_type cg -pc_type jacobi -mat_type aijcusparse -mat_cusparse_storage_format hyb -mat_cusparse_mult_storage_format hyb -ksp_atol $seuil }"	;gpu[$i]=1	;sym[$i]=1
let i=$i+1;solver[$i]="Petsc_GPU CLI  { -ksp_type cg -pc_type jacobi -mat_type aijcusparse -mat_cusparse_storage_format ell -mat_cusparse_mult_storage_format ell -ksp_atol $seuil }"	;gpu[$i]=1	;sym[$i]=1
let i=$i+1;solver[$i]="Petsc_GPU CLI  { -ksp_type cg -pc_type jacobi -mat_type aijcusparse 									  -ksp_atol $seuil }"	;gpu[$i]=1	;sym[$i]=1 
# cusp format and try with ell and dia format (crashes with ell_matrix fill-in would exceed maximum tolerance)
#let i=$i+1;solver[$i]="Petsc_GPU CLI  { -ksp_type cg -pc_type jacobi -mat_type aijcusp -mat_cusp_storage_format dia -mat_cusp_mult_storage_format dia -ksp_atol $seuil }"		;gpu[$i]=1	;sym[$i]=1
#let i=$i+1;solver[$i]="Petsc_GPU CLI  { -ksp_type cg -pc_type jacobi -mat_type aijcusp -mat_cusp_storage_format ell -mat_cusp_mult_storage_format ell -ksp_atol $seuil }"		;gpu[$i]=1	;sym[$i]=1
let i=$i+1;solver[$i]="Petsc_GPU GCP  { seuil $seuil precond DIAG { } impr }"					;gpu[$i]=1	;sym[$i]=1
#let i=$i+1;solver[$i]="Petsc_GPU CLI  { -ksp_type cg -pc_type bjacobi -sub_pc_type ilu -ksp_atol $seuil }"	;gpu[$i]=1	;sym[$i]=1 	;par[$i]=0 # Bug submitted to PETSc ?
#let i=$i+1;solver[$i]="Petsc_GPU CLI  { -ksp_type cg -pc_type asm -sub_pc_type ilu -ksp_atol $seuil }"		;gpu[$i]=1	;sym[$i]=1 	;par[$i]=0 # Bug submitted to PETSc ?
let i=$i+1;solver[$i]="Petsc_GPU BICGSTAB { seuil $seuil precond DIAG { } impr }"				;gpu[$i]=1	;sym[$i]=1
let i=$i+1;solver[$i]="Petsc_GPU Cholesky_cholmod { impr }"							;gpu[$i]=1	;sym[$i]=1

###############################
# AMGX solveurs tested on GPU #
###############################
# ToDo: blocage en // + plantages non deterministes en sequentil
let i=$i+1;solver[$i]="Petsc      GCP      { precond SSOR { omega 1.6 } seuil $seuil impr }"			;amgx[$i]=1	;sym[$i]=1
let i=$i+1;solver[$i]="Petsc_AMGX GCP      { precond SSOR { omega 1.6 } seuil $seuil }" 			;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
let i=$i+1;solver[$i]="Petsc_AMGX GCP      { precond DIAG { } seuil $seuil }" 					;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
let i=$i+1;solver[$i]="Petsc_AMGX GCP      { precond BLOCK_JACOBI_ILU { level 0 } seuil $seuil }" 		;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
let i=$i+1;solver[$i]="Petsc_AMGX GCP      { precond BLOCK_JACOBI_ILU { level 1 } seuil $seuil }" 		;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
let i=$i+1;solver[$i]="Petsc_AMGX GCP      { precond ILU  { level 0 } seuil $seuil }" 				;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
let i=$i+1;solver[$i]="Petsc_AMGX GCP      { precond ILU  { level 1 } seuil $seuil }" 				;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
let i=$i+1;solver[$i]="Petsc_AMGX GMRES    { precond DIAG { } seuil $seuil }" 					;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
let i=$i+1;solver[$i]="Petsc_AMGX CLI      { solver=PCG preconditioner=MULTICOLOR_GS tolerance=$seuil }" 	;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
# Crash: let i=$i+1;solver[$i]="Petsc_AMGX BICGSTAB { precond SSOR { omega 1.6 } seuil $seuil }"			;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
# gamg:
let i=$i+1;solver[$i]="Petsc_AMGX CLI      { solver(s)=PCG s:tolerance=$seuil s:preconditioner(p)=AMG s:use_scalar_norm=1 s:monitor_residual=1 s:store_res_history=1 p:error_scaling=0 p:print_grid_stats=1 p:max_iters=1 p:cycle=V p:min_coarse_rows=2 p:max_levels=100 p:smoother(smoother)=BLOCK_JACOBI p:presweeps=1 p:postsweeps=1 p:coarsest_sweeps=1 p:coarse_solver=DENSE_LU_SOLVER p:dense_lu_num_rows=2 p:algorithm=CLASSICAL p:selector=HMIS p:interpolator=D2 p:strength=AHAT smoother:relaxation_factor=0.8 }" 	;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0
# amg:
let i=$i+1;solver[$i]="Petsc_AMGX CLI      { solver(s)=PCG s:tolerance=$seuil s:preconditioner(p)=AMG s:use_scalar_norm=1 s:monitor_residual=1 s:store_res_history=1 p:error_scaling=0 p:print_grid_stats=1 p:max_iters=1 p:cycle=V p:min_coarse_rows=2 p:max_levels=100 p:smoother(smoother)=BLOCK_JACOBI p:presweeps=1 p:postsweeps=1 p:coarsest_sweeps=1 p:coarse_solver=DENSE_LU_SOLVER p:dense_lu_num_rows=2 p:algorithm=AGGREGATION p:selector=SIZE_2 p:max_matching_iterations=100000 p:max_unassigned_percentage=0.0 smoother:relaxation_factor=0.8 }" 	;amgx[$i]=1	;sym[$i]=1 ;par[$i]=0

