#!/bin/bash
# Lancement de TRUST par clavier avec comme argument 
# le nom du jeu de donnees et le nombre de processeurs
# Possibilite de fixer des noeuds en specifiant un fichier machinefile
# Variables d'environnements qui influencent le script: 
# exec (fixe au chemin global de l'executable a utiliser)
# bigmem (fixee a 1 elle permet de lancer en batch sur des noeuds a 4Go de tantale)
# node (fixee a 1 elle permet d'utiliser tous les processeurs d'un noeud)
# prod (fixee a 1 elle permet d'utiliser la queue de production)
# Chargement d'un environnement eventuel contenu dans ld_env.sh
if [ -f ld_env.sh ]
then
   . ./ld_env.sh
fi

qsub_interactif()
{   
   # Provisoire qsub ne marche pas donc on lance direct:
   id=`cat $sub_file | qsub | $TRUST_Awk -F . '{print $1}'`
   # Attente de la fin du job
   while [ "`qstat -a | grep $id`" != "" ]
   do
      sleep 3
   done
}
bsub_interactif()
{
   # Provisoire bsub -I desactive sur argent donc on lance direct:
   id=`cat $sub_file | bsub | $TRUST_Awk '{gsub("<","",$2);gsub(">","",$2);print $2}'`
   # Attente de la fin du job
   while [ "`qstat -a | grep $id`" != "" ]
   do
      sleep 3
   done
}
sbatch_interactif()
{
   # Submit the job and returns the id:
   err=1
   while [ "$err" = 1 ]
   do
      id=`sbatch $sub_file 2>&1`
      err=$?
      # Wait if several jobs launched
      if [ $err = 1 ]
      then
         if [ "`echo $id | grep 'Job violates accounting'`" != "" ]
         then
	    echo "Waiting, cause several jobs submitted:"
	    squeue -u $me -p $queue
	    sleep 60
	 else
	    # Unknown error
            echo $id && exit -1 
	 fi
      fi     
   done
   id=`echo $id | $TRUST_Awk '/Submitted batch/ {print $NF}'`
   echo "Job $id submitted."
   echo "Waiting the end of the job $id..."
   while [ "`squeue -h -j $id 2>/dev/null`" != "" ]
   do
      sleep 3
   done
}
# Sur les dernieres machines du CCRT on utilise desormais un wrapper ccc_msub (au lieu de qsub, bsub,...) 
# Il faut aussi utiliser ccc_mdel au lieu de qdel et ccc_mstat au lieu de qstat...
ccc_msub_interactif()
{
   # Submit the job and returns the id:
   err=1
   while [ "$err" = 1 ]
   do
      id=`ccc_msub $sub_file 2>&1`
      err=$?
      # Wait if several jobs launched
      if [ $err = 1 ]
      then
         if [ "`echo $id | grep 'Job violates accounting'`" != "" ]
         then
	    echo "Waiting, cause several jobs submitted:"
	    #qstat -u $me $queue
	    #ccc_mpstat -u $me $queue
	    squeue -u $me -p $queue
	    sleep 60
	 else
	    # Unknown error
            echo $id && exit -1 
	 fi
      fi     
   done
   id=`echo $id | $TRUST_Awk '/Session/ {print $4}'`
   echo "Job $id submitted."
   echo "Waiting the end of the job $id..."
   #while [ "`qstat -u $me | grep $id`" != "" ]
   #while [ "`ccc_mpstat -u $me | grep $id`" != "" ]
   while [ "`squeue -h -j $id 2>/dev/null`" != "" ]
   do
      sleep 3
   done
}

help()
{
   echo "Usage: `basename $0` [option] datafile [nb_cpus] [1>file.out] [2>file.err]"
   echo "Where option may be:"
   echo "-help|-h                : List options."
   echo "-index                  : Access to TRUST ressources index."
   echo "-doc                    : Access to TRUST user's manual."
   echo "-config nedit|vim|emacs : Configure nedit or vim or emacs with TRUST keywords."
   echo "-mesh                   : Visualize the mesh(es) contained in the data file."
   echo "-monitor                : Run and monitor the progress of the TRUST calculation."
   echo "-probes                 : Monitor the TRUST calculation only."
   echo "-evol                   : Monitor the TRUST calculation only (new)."
   echo "-prm                    : Write a prm file and generate the corresponding pdf file in the build directory."
   echo "-clean                  : Clean the current directory from all the generated files by TRUST."
   echo "-copy                   : Copy the test case datafile from the TRUST database under the present directory."
   echo "-check all|testcase|function|class|method::class : Check the non regression of all the test cases or a single test case or a list of tests cases covering a function, a class or a class method."
   echo "-gdb                    : Run under gdb debugger."
   echo "-valgrind               : Run under valgrind."
   echo "-valgrind_strict        : Run under valgrind with no suppressions."
   echo "-create_sub_file        : Create a submission file only."
   echo "-c n                    : Use n cores per task for a parallel calculation."
   echo "-queue queue            : Create a submission file with the specified queue and submit the job."
   echo "-prod                   : Create a submission file and submit the job on the main production class."
   echo "-bigmem                 : Create a submission file and submit the job on the big memory production class."
   [ "$PETSC_HAVE_CUDA" = 1 ] && echo "-gpu                    : Create a submission file and submit the job on production class with GPU cards."
   [ -d /ccc ] && echo "-ipm                    : Use ipm to report MPI statistics."
   echo "-help_trust             : Print options of TRUST_EXECUTABLE [CASE[.data]] [options]."

   echo "If no option is given, create a submission file and submit the job on the test class."
   exit 0
}
binary=$exec
ici=`pwd`   
me=`whoami`
mesh=""
monitor=""
probes=""
prm=""
copy=""
gdb=""
mail=""
core_per_task=""
queue_choisie=""
[ "$prod" = "" ] && prod=0
bigmem=0
gpu=0
node=0
USE_MPIRUN=0

####################
# Loop for options #
####################
supported_option=1
while [ "$supported_option" = 1 ]
do
   if [ "$1" = "" ] || [ "$1" = -help ] || [ "$1" = -h ]
   then
      help
      exit 0
   elif [ "$1" = "-config" ]
   then
      shift
      if [ "$1" = nedit ]
      then
         # Configure nedit
	 Language_mode_TRUST.sh #-no_verbose
	 exit 0
      elif [ "$1" = vim ]
      then
         # Configure vim
	 configure_vim.sh && exit 0
      elif [ "$1" = emacs ]
      then
         # Configure emacs
	 configure_emacs.sh && exit 0
      else
         help
      fi
   elif [ "$1" = "-doc" ]
   then
      doc=$TRUST_ROOT/doc/TRUST/User_Manual_TRUST.pdf
      if [ -f $doc ]
      then
	 for app in xpdf kpdf evince okular
	 do
            $app $doc 1>/dev/null 2>&1 && exit 0
	 done
	 echo "No PDF reader found!"
	 exit -1
      else
	 echo "$doc not found!" 
	 exit -1
      fi
   elif [ "$1" = "-index" ]
   then
      ($WEBBROWSER $TRUST_ROOT/index.html &) && exit 0  
   elif [ "$1" = "-copy" ]
   then
      copy=1
   elif [ "$1" = "-mesh" ]
   then
      mesh=1
   elif [ "$1" = "-c" ]
   then
      shift && core_per_task=$1
   elif [ "$1" = "-monitor" ]
   then
      monitor=1
   elif [ "$1" = "-probes" ]
   then
      probes=1
   elif [ "$1" = "-evol" ]
   then
      probes=2
   elif [ "$1" = "-create_sub_file" ]
   then
      create_sub_file=1 && prod=1 && mail=1
   elif [ "$1" = "-queue" ]
   then
      shift && queue_choisie=$1
   elif [ "$1" = "-prod" ]
   then
      prod=1
   elif [ "$1" = "-gpu" ]
   then
      gpu=1
   elif [ "$1" = "-bigmem" ]
   then
      bigmem=1
   elif [ "$1" = "-ipm" ]
   then
      ipm=1
   elif [ "$1" = "-valgrind" ]
   then 
      VALGRIND=1
   elif [ "$1" = "-valgrind_strict" ]
   then
      VALGRIND_STRICT=1
   elif [ "$1" = "-gdb" ]
   then
      gdb=gdb.sh && mpirun_options="-gdb"
   elif [ "$1" = "-prm" ]
   then
      prm=1 
   elif [ "$1" = "-check" ]
   then
      shift
      if [ "$1" = "" ]
      then
	 help
      elif [ "$1" = all ]
      then
	 # All test cases
	 option=0 
      # elif [ "`ls $TRUST_TESTS/*/$1/$1.lml.gz 2>/dev/null`" != "" ]
      elif [ "`find $TRUST_TESTS/ -follow -name $1.lml.gz -print 2>/dev/null | sort`" != "" ]
      then
	 # Single test case
	 option=$1   
      else
	 # Test cases covering a method::class
	 Qui $1 || exit -1
	 option=liste_cas
      fi
      echo $option | lance_test
      exit $?
   elif [ "$1" = "-clean" ]
   then
      for ext in lata sons son out lml dt_ev TU log stop err xyz sauv dump face out_err plan
      do 
	 echo "rm *.$ext files."
	 rm -f *.$ext
      done
      # echo "rm *.lata.* core.* err.* out.*"
      # rm -f *.lata.* core.* err.* out.*
	  # A priori c est un peu fort : err.* out.* ne sont pas crees au run. 
      echo "rm *.lata.* core.* convert_jdd"
      rm -f *.lata.* core.* convert_jdd
      exit 0
   else
      # Unknown option
      supported_option=0
   fi 
   # Option is known, jump to next
   [ "$supported_option" = 1 ] && shift
done
# deplace pas besoin d exec pour clean help ....
[ "$exec" = "" ] && echo "Error: the variable \$exec containing TRUST binary path is undefined." && exit -1
[ ! -f $exec ] && echo "Error: the binary pointed by the variable \$exec=$exec does NOT exist." && exit -1  

############
# Filename #
############
NOM=`basename $ici` && [ ${#1} != 0 ] && NOM=$1 && NOM=${NOM%.data} && shift

###############
# CPU numbers #
###############
# si $1 non vide et pas de tiret au debut
#export NB_PROCS=1 && [ ${#1} != 0 ] && [ ${1#-} = $1 ] && NB_PROCS=$1 && USE_MPIRUN=1 && shift
export NB_PROCS=1 
[ $1 -eq 0 ] 2>/dev/null
code_retour=$?
# verifie que $1 est une valeur numerique
if [ $code_retour -eq 0 -o $code_retour -eq 1 ]
then 
  [ ${#1} != 0 ] && [ ${1#-} = $1 ] && export NB_PROCS=$1 && USE_MPIRUN=1 && shift
fi

#################
# PETSc options #
#################
[ "$PETSC_OPTIONS" = "" ] && PETSC_OPTIONS=$*
if [ "`echo $PETSC_OPTIONS | grep -i cusp`" != "" ]
then
   gpu=1 # Activate also GPU option if some gpu option is passed through the command line option:
fi

###########################################
# Lancement en interactif avec monitoring #
###########################################
if [ "$monitor" = 1 ]
then
   Run_sonde $binary $NOM
   exit $?
fi

########################
# Monitoring seulement #
########################
if [ "$probes" = 1 ]
then
   Run_sonde $NOM
   exit $?
fi
if [ "$probes" = 2 ]
then 
  $TRUST_ROOT/exec/PLOT_2D/Plot2d.sh  `dirname $NOM` "residu=max|Ri|"
  exit $?
fi
#################
# Visu maillage #
#################
if [ "$mesh" = 1 ]
then
   Check_maillage.ksh $NOM
   exit $?
fi

#####################
# Generate pdf file #
#####################
if [ "$prm" = 1 ]
then
   create_basic_prm_from_lata.sh $NOM
   exit $?
fi

################
# Copy a study #
################
if [ "$copy" = 1 ]
then
   echo "Try to extract $NOM test case from $TRUST_TESTS database..."
   copie_cas_test $NOM
   err=$?
   if [ "$err" = 0 ]
   then
      echo "Directory `pwd`/$NOM created with files inside:" && ls $NOM
   else
      echo "ERROR: Directory `pwd`/$NOM NOT created !!!"
   fi
   exit $err
fi

############
# VALGRIND #
############
if [ "$VALGRIND" = "1" ] || [ "$VALGRIND_STRICT" = "1" ] || [ "$VALGRIND_GDB" = "1" ]
then
    val=`which valgrind`    
    suppressions=""
    if [ "$VALGRIND_STRICT" != "1" ]
    then
        suppressions="--gen-suppressions=all"
	if [ "`$Mpirun --version 2>&1 | grep 1.2.9`" != "" ]
	then
	   # Ajout de suppressions supplementaires pour OpenMPI 1.2.9
	   cat $TRUST_ROOT/Outils/valgrind/suppressions_openmpi_129 $TRUST_ROOT/Outils/valgrind/suppressions > $TRUST_TMP/suppressions
	   suppressions=$suppressions" --suppressions=$TRUST_TMP/suppressions"
	else
	   suppressions=$suppressions" --suppressions=$TRUST_ROOT/Outils/valgrind/suppressions"
	fi
    fi
    if [ "$gdb" != "" ] || [ "$VALGRIND_GDB" = "1" ]
    then
       MonoDir=$TRUST_ROOT/`ls -rt $TRUST_ROOT | grep MonoDir | tail -1`
       XTERM="/usr/bin/xterm -e"
       ATTACH="--extra-debuginfo-path=$MonoDir/src --db-attach=yes --db-command=\'/usr/bin/gdb --readnow --directory $MonoDir/src --directory $MonoDir/include -nw %f %p\'"
       gdb=""
       log_file=""
    fi
    if [ "$VALGRIND_LOG_FILE" = 1 ]
    then
       # Call from testval:
       log_file="--log-file=tmp_log%p" 
    else
       # Too slow in testval:
       more_info_but_slower="--track-origins=yes"
    fi
    #  more_info_but_slower=""      # --track-origins=yes"
    # GF sinon on a des erreurs au demarrage de mpi
    [ $NB_PROCS -ge 2 ] && log_file="--log-file=tmp_log%p" 
    #  log_file="--log-file=tmp_log%p" 
    # Still reachable only checked for OpenMPI 1.2.9: 
    if [ "`$Mpirun --version | grep 1.2.9`" != "" ]
    then
       reachable=yes
    else
       reachable=yes
       # Cause MPI_irecv, a table is allocated but not freed, see 4.8.6 in https://wiki.uiowa.edu/download/attachments/109785161/Valgrind-Quick-Start.pdf?version=1&modificationDate=1385057441990&api=v2
    fi
    exec="$XTERM $val --error-exitcode=1 --leak-check=full --show-leak-kinds=all --errors-for-leak-kinds=all   --show-reachable=$reachable --num-callers=15 $log_file $more_info_but_slower $suppressions $ATTACH $binary"
fi

###############################################
# Utilisation de Petsc dans le jeu de donnees ?
# et eventuellement dans le JDD du baltik MC2 ?
###############################################
USE_PETSC=0
if [ -f $NOM.data ]
then 
   # To avoid dos problems:
   dos2unix_ $NOM.data
   USE_PETSC=`sed "s/\t/ /g" $NOM.data | $TRUST_Awk 'BEGIN {IGNORECASE=1;use_petsc=0} \
                            // {n=split($0,a,"#")-1;if (n>0) dieses+=n} \
                            /^fin/ && (dieses%2==0) && (NF==1) {exit} \
                            / petsc / || / petsc_gpu / || / optimal / || / resoudremultiassemblage / {use_petsc=1;exit}
	                    END {print use_petsc}'`
   USE_PETSC_GPU=`sed "s/\t/ /g" $NOM.data | $TRUST_Awk 'BEGIN {IGNORECASE=1;use_petsc_gpu=0} \
                            // {n=split($0,a,"#")-1;if (n>0) dieses+=n} \
                            /^fin/ && (dieses%2==0) && (NF==1) {exit} \
                            / petsc_gpu / {use_petsc_gpu=1;exit}
	                    END {print use_petsc_gpu}'`
fi
if [ $PETSC_HAVE_CUDA = 1 ] && [ $USE_PETSC = 1 ]
then
   gpu=1
fi

######################
# Selon les machines #
######################
soumission=999
sub="" 
queue=""
qos=""
cpu=""
project=""
ram=""
noeuds=""
export prod
export bigmem
export gpu
# See HOST_???.sh file called in TRUST.env
if [ "$TRUST_WITHOUT_HOST" = 0 ]
then
   source $TRUST_ROOT/env/HOST_$HOST_BUILD.sh
else
   source $TRUST_ROOT/env/HOST_default.sh
fi
define_soumission_batch

######################################
# Check the datafile with VerifData on 
# clusters with job scheduling if exec
# is a TRUST binary
######################################
if [ $soumission != 999 ] && [ ${binary#TRUST} != $binary ] && [ "`VerifData 1>/dev/null 2>&1;echo $?`" = 0 ]
then
   echo $ECHO_OPTS "Checking the syntax of the data file before submitting the job...\c"
   VerifData $NOM.data 1>/dev/null 2>&1
   if [ $? != 0 ]
   then
       echo KO
       echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
       echo "Check your data file. Syntax error detected:"
       echo "============================================"
       VerifData $NOM.data
       exit -1
   else
       echo OK
   fi
fi

# En sequentiel, si l'utilisateur n'a pas force l'utilisation de MPI_RUN et 
# si le Kernel est compile avec MPI_INIT_NEEDS_MPIRUN, alors on utilise mpi_run sauf si
# on est sur de ne pas utiliser un solveur PETSC ou OPTIMAL dans le jeu de donnees
if  [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 0 ]
then
   petsc_for_kernel=$PETSC_ROOT/$TRUST_ARCH/include/petsc_for_kernel.h
   if [ ! -f $petsc_for_kernel ] || [ "`grep 'define MPI_INIT_NEEDS_MPIRUN' $petsc_for_kernel 2>/dev/null`" != "" ]
   then
      if [ -f $NOM.data ]
      then
	 USE_MPIRUN=$USE_PETSC
      else
	 USE_MPIRUN=1
      fi
   fi
fi

# Si l'on a un gestionnaire de batch (soumission!=999a et que USE_MPIRUN est mis avec NB_PROCS=1, alors soumission est mis a 1
[ $soumission != 999 ] && [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 1 ] && soumission=1

# Pour eviter un message d'erreur semget depuis la compilation de MPICH en shared memory
# on vide la table des semaphores (voir la raison dans lib/src/LIBMPI/Installer_mpich)
# Attention! cleanipcs tue les tous les processes paralleles en cours utilisant cette table donc les calculs TRUST!
# C'est pourquoi on fait un test sur les mpirun tournant...
[ -f $MPI_ROOT/sbin/cleanipcs ] && [ "`ps -fl -U $me | grep 'mpirun ' | grep TRUST_mpich | grep -v grep | grep -v $$`" = "" ] && $MPI_ROOT/sbin/cleanipcs

# Surcharge de la queue
[ "$queue_choisie" != "" ] && queue=$queue_choisie 
[ "$queue" != "" ] && echo "Partition $queue selected (soumission=$soumission ; NB_PROCS=$NB_PROCS ; USE_MPIRUN=$USE_MPIRUN)."

###############################
# Soumission batch interactif #
###############################
sub_file=.sub_file_$NOM
if [ "$create_sub_file" ]
then
   sub_file=sub_file && [ -f sub_file ] && mv -f sub_file sub_file.old
   echo "***************************************************"
   echo "Submission file $sub_file created but not submitted."
   echo "You can modify it, then submit the job with the command:"
fi
rm -f $sub_file
if [ $NB_PROCS -ge $soumission ]
then
   ###########################################
   # En test du sub_file selon le gestionnaire 
   ###########################################
   case $sub in
   	SLURM)
		echo "#!/bin/sh"					>> $sub_file	# Shell
		echo "#SBATCH -J $NOM" 					>> $sub_file	# Job name
		[ "$queue" != "" ] && echo "#SBATCH -p $queue"		>> $sub_file	# Partition
		[ "$qos" != "" ] && echo "#SBATCH --qos=$qos"		>> $sub_file	# Quality of service
		echo "#SBATCH -t $cpu"					>> $sub_file	# Time in minutes
		echo "#SBATCH -o myjob.%j.o"				>> $sub_file	# Output log
		echo "#SBATCH -e myjob.%j.e"				>> $sub_file	# Error log
		[ "$project" != "" ] && echo "#SBATCH -A $project"	>> $sub_file	# Account
		echo "#SBATCH -n $NB_PROCS"				>> $sub_file	# Number of tasks
		[ "$noeuds" != "" ] && echo "#SBATCH -N $noeuds"        >> $sub_file    # Number of nodes
		[ "$core_per_task" != "" ] && echo "#SBATCH -c $core_per_task"	>> $sub_file	# Number of cores per task	
		[ "$qos" != test ] && echo "#SBATCH --exclusive"	>> $sub_file	# Exclusive use of nodes during production run	
		[ "$ram" != "" ] && echo "#SBATCH --mem=$ram"           >> $sub_file    # Real memory required per node in MegaBytes
		echo "cd \$SLURM_SUBMIT_DIR" >> $sub_file # Submit directory for reprise_auto script
		;;
   	POE)	echo "#!/bin/bash" 					>> $sub_file
		echo "#@ job_name = $NOM"				>> $sub_file
		echo "#@ job_type = parallel"				>> $sub_file
		echo "#@ wall_clock_limit = $cpu"			>> $sub_file
		echo "#@ class = $queue" 				>> $sub_file
		echo "#@ network.MPI = sn_all,,us"			>> $sub_file
		echo "#@ total_tasks = $NB_PROCS"			>> $sub_file
		[ "$core_per_task" != "" ] 	&& echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
		echo "#@ node = `echo "1+($NB_PROCS-1)/16" | bc`"	>> $sub_file 	# ceil($NB_PROCS/16)
		echo "#@ output = job\$(jobid).out"			>> $sub_file
		echo "#@ error = job\$(jobid).err"			>> $sub_file
		echo "#@ initialdir = $ici"				>> $sub_file
		echo "#@ node_topology = island"			>> $sub_file
		echo "#@ island_count = `echo "1+($NB_PROCS-1)/8192" | bc`" 	>> $sub_file	#  ceil($NB_PROCS/8192)
		echo "#@ energy_policy_tag = NONE"			>> $sub_file
		echo "#@ queue"						>> $sub_file
		;;		
   	LSF) 	echo "#BSUB -J $NOM
#BSUB -n $NB_PROCS
#BSUB -o out.%J
#BSUB -e err.%J" >> $sub_file
		[ "$core_per_task" != "" ] 	&& echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
		[ ${#mail} != 0 ] 		&& echo "#BSUB -B -N" 		>> $sub_file
      		[ ${#queue} != 0 ] 		&& echo "#BSUB -q $queue" 	>> $sub_file
      		[ ${#cpu} != 0 ]		&& echo "#BSUB -W $cpu" 	>> $sub_file      		
      		[ ${#ram} != 0 ] 		&& echo "#BSUB -M $ram" 	>> $sub_file
      		[ ${#node} != 0 ] 		&& echo "#BSUB -ext \"SLURM[mincpus=4]\"" 	>> $sub_file	
		echo "cd \$LS_SUBCWD" >> $sub_file
 		;;
	CCC)	echo "#!/bin/bash" 				>> $sub_file 
		echo "#MSUB -r $NOM" 				>> $sub_file 
		[ ${#noeuds} != 0 ] && echo "#MSUB -N $noeuds" 	>> $sub_file 
		echo "#MSUB -n $NB_PROCS" 			>> $sub_file 
      		if [ ${#cpu} != 0 ]
		then
		   if [ "`echo $cpu | grep :`" != "" ]
		   then
		      # Exprime en HH:MM:SS
		      echo "#BSUB -W $cpu" 			>> $sub_file 
                   else
		      # Exprime en SSSSS
		      echo "#MSUB -T $cpu" 			>> $sub_file 
		   fi
		fi 
		if [ "$core_per_task" != "" ]
		then
		   echo "#MSUB -c $core_per_task" 		>> $sub_file 
		fi
		# RAM
		[ "$ram" != "" ] && echo "#MSUB -M $ram" 	>> $sub_file 
		# Ajout projet
		project=`ccc_myproject 2>/dev/null | $TRUST_Awk '/project/ {print $4;exit}'`
		if [ "$project" != "" ]
		then
		   echo "#MSUB -A $project" 			>> $sub_file 
		fi
		# Prevent from restart:
		echo "#MSUB -E \"--no-requeue\""                >> $sub_file
		[ ${#qos} != 0 ]   && echo "#MSUB -Q $qos"	>> $sub_file 
		[ ${#queue} != 0 ] && echo "#MSUB -q $queue"	>> $sub_file     	
		echo "#MSUB -o out.%J"				>> $sub_file
		echo "#MSUB -e err.%J" 				>> $sub_file
		echo "cd \$BRIDGE_MSUB_PWD" 			>> $sub_file
 		;;
	SGE) 	echo "#$ -N $NOM"				>> $sub_file
		[ "$reseau" != "" ] && echo "#$ -pe $reseau"	>> $sub_file
		echo "#$ -cwd" 					>> $sub_file
		echo "#$ -S /bin/bash"				>> $sub_file
		[ "$balise" != "" ]	&& echo $balise		>> $sub_file
		[ "$mail" != "" ] 	&& echo "#$ -m be" 	>> $sub_file
      		[ "$queue" != "" ] 	&& echo "#$ -q $queue" 	>> $sub_file
		[ "$core_per_task" != "" ] 	&& echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
		echo "cd \$SGE_CWD_PATH" 			>> $sub_file
		;;
	NQS) 	echo "#QSUB -r $NOM
#QSUB -lt $cpu
#QSUB -n $NB_PROCS" >> $sub_file
		[ "$core_per_task" != "" ] 	&& echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
                echo "cd $ici" >> $sub_file
		;;
	PBS) 	echo "#PBS -N `echo $NOM | cut -c 1-15`
#PBS -o out.log
#PBS -e err.log
#PBS -l select=$select:ncpus=$ncpus:mpiprocs=$mpiprocs
#PBS -l walltime=$cpu" >> $sub_file
		[ "$core_per_task" != "" ] 	&& echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
		[ "$ram" != "" ] && echo "#PBS -l mem=$ram" >> $sub_file
		echo "cd \$PBS_O_WORKDIR" >> $sub_file
		;;
	*) echo "sub=$sub non prevu." && exit -1
		;;
   esac	   
   #######
   # IPM #
   #######
   if [ "$ipm" = 1 ]
   then
      echo "module load ipm" 				>> $sub_file
      echo "export LD_PRELOAD=\$IPM_ROOT/lib/libipm.so" >> $sub_file
   fi
   ##########
   # VAMPIR #
   ##########
   if [ "$VAMPIRTRACE_ROOT" != "" ]
   then
      echo "export VT_IOTRACE=yes" 	>> $sub_file
      echo "export VT_MAX_FLUSHES=0" 	>> $sub_file
   fi
   ######################
   # Commandes de calculs
   ######################
   echo "[ -f ld_env.sh ] && . ./ld_env.sh # To load an environment file if necessary" >> $sub_file
   if [ "$create_sub_file" = 1 ]
   then
      OUTPUT=$NOM
   else
      # En interactif OUTPUT=.$NOM et non OUTPUT=$NOM car sinon conflit avec lance_test (trust NOM 1>$NOM.out 2>$NOM.err)
      # et blocage possible sur castor avec Baltik par exemple !!!
      OUTPUT=.$NOM   
   fi
   if [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 0 ]
   then
      echo "$exec $NOM $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
   else
      if [ "$mpirun" != "" ]
      then
         if [ "$sub" = "SLURM" ]
	 then
            echo "$mpirun $machinefile $exec $NOM \$SLURM_NTASKS $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
	 else
            echo "$mpirun $machinefile $exec $NOM $NB_PROCS $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
	 fi
      else
         echo "$TRUST_ROOT/bin/mpirun -np $NB_PROCS $machinefile $exec $NOM $NB_PROCS $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
      fi
   fi   
   #######
   # IPM #
   #######
   if [ "$ipm" = 1 ]
   then
      echo "report=\`ls -rt triou.*.*.0 | tail -1\`" >> $sub_file
      echo "ipm_parse -full \$report 1>>$OUTPUT.out 2>>$OUTPUT.err" >> $sub_file
      echo "ipm_parse -html \$report" >> $sub_file
   fi   
   if [ "$create_sub_file" ]
   then
      case $sub in
        SLURM) echo "sbatch $sub_file";;
      	POE) echo "llsubmit $sub_file";;
      	LSF) echo "bsub < $sub_file";;
	CCC) echo "ccc_msub $sub_file";;
	SGE) echo "qsub $sub_file";;
	NQS) echo "qsub $sub_file";;
	PBS) echo "qsub $sub_file";;
      esac
      echo "***************************************************"
      exit
   fi
   if [ "`type qstat 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      # Commande qstat non trouvee, elle est necessaire pour la suite
      echo "No command qstat found for listing jobs..."
      qstat
      exit -1
   fi   
   ##############################################
   # Soumission du sub_file selon le gestionnaire 
   ##############################################
   case $sub in
   	SLURM)	sbatch_interactif;;
   	POE) 	llsubmit -s $sub_file;;
   	LSF) 	cat $sub_file | bsub -I;;
	CCC) 	ccc_msub_interactif;;
	SGE) 	qsub -S /bin/bash -sync yes $sub_file;;
	NQS) 	qsub -I $sub_file;;
	PBS) 	qsub_interactif;;
   esac	
   err=$?   
   [ $err = 0 ] && rm -f $sub_file
   # On envoit $OUTPUT.out et $OUTPUT.err vers les bonnes sorties afin que "trust jdd 1>jdd.out 2>jdd.err" envoie ce qu'il faut dans jdd.out et jdd.err
   # A cause de platine (permission denied), on utilise plutot les chemins pointes /proc/self/fd/1 et 2
   [ -f $OUTPUT.out ] && cat $OUTPUT.out >> "/proc/self/fd/1" #cat $OUTPUT.out > "/dev/stdout"
   [ -f $OUTPUT.err ] && cat $OUTPUT.err >> "/proc/self/fd/2" #cat $OUTPUT.err > "/dev/stderr"
   # Check for TRUST calculation only (cause coupled MC2 calculation DO NOT produce this message for example):
   if [ "`grep 'Executable: ' $OUTPUT.err 2>/dev/null`" != "" ] && [ "`grep 'Arret des processes.' $OUTPUT.err`" = "" ]
   then
      err=1
   fi
   # Try to detect crashes (if it is not a TRUST binary, example PETSc test case)
   if [ "`grep 'invalid device function' $OUTPUT.err`" != "" ] || [ "`grep 'Signal: Aborted' $OUTPUT.err`" != "" ]
   then
      err=1
   fi
   exit $err
else
   [ "$core_per_task" != "" ] 	&& echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
   if [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 0 ]
   then
      ###############################
      # Calcul direct en sequentiel #
      ############################### 
      run="$gdb $exec $NOM $PETSC_OPTIONS" 
   else
      ##############################
      # Calcul direct en parallele #
      ##############################     
      run="$TRUST_ROOT/bin/mpirun `[ "$gdb" != "" ] && echo -gdb` -np $NB_PROCS $exec $NOM $NB_PROCS $PETSC_OPTIONS"
   fi
   if [ "$create_sub_file" ]
   then
      echo $run > $sub_file
      chmod +x $sub_file
      echo "./$sub_file"  
      echo "***************************************************"
      exit
   fi
   if [ "$TRUST_USE_Sjob" = "1" ]
       then
       # export PATH=$PATH:$TRUST_ROOT/bin/Sjob
       sub_file=s${NB_PROCS}_$NOM
       sub_file=`echo $sub_file | sed "s/\//_/g"`
       echo "#!/bin/bash" > $sub_file
       echo $run  >> $sub_file
       chmod +x  $sub_file
       $TRUST_ROOT/bin/Sjob/Salloc -n $NB_PROCS $PWD/$sub_file
       err=$?
       [ $err -eq 0 ] && rm -f $sub_file
   else
       eval $run
       err=$?
   fi
fi

[ "$log_file" != "" ] && sleep 1 && cat $(ls -rt tmp_log* | tail -$NB_PROCS)
exit $err

