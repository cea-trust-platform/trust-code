#!/bin/bash
# Script de recherche automatique de
# certaines variables d'environnement
# Strategie :
# Une liste de variable par defaut :
# On verifie qu'une d'entre elle existe par whence
# Puis eventuellement, on fait un find.... Dans le cas ou le compte
# est mal configure

Display_Missing_packages()
{
   echo ""
   echo "These packages are missing:"
   echo "---------------------------"
   cat $TRUST_ROOT/NON_INSTALLED
   [ "$multiple_choices" = 1 ] && echo "(*) Only one command is needed but none has been found."
   echo "Contact your system administrator to install it."
}


########################################################
make_()
{
   directory_package=$1
   cd $directory_package
   package_name=$2 && [ "$package_name" = "" ] && package_name=`basename $directory_package`
   package_log=$3 && [ "$package_log" = "" ] && package_log=`pwd`/`basename $directory_package`".log"
   echo $ECHO_OPTS "Trying to install $package_name...\c"
   # On lance la compilation
   make 1>$package_log 2>&1
   if [ $? = 0 ]
   then
      echo "OK"
   else
      echo "KO (See $package_log)"
      echo "You need $1 installed correctly. Contact TRUST support."
      echo "Error while installing $package_name. " >> $TRUST_ROOT/NON_INSTALLED
      echo "See $package_log" >> $TRUST_ROOT/NON_INSTALLED
      echo "You need $1 installed correctly." >> $TRUST_ROOT/NON_INSTALLED
      if [ "$package_name" = "Tcl/Tk" ] ; then
         echo "=> You may have to first install libX11-dev" >> $TRUST_ROOT/NON_INSTALLED
         echo "=> You can run ./configure by adding: -disable-tcl_tk"
      elif [ "$package_name" = "mpich" ] && [ "$TRUST_DISABLE_CCACHE" != 1 ] ; then
         #echo "=> Adding the option -disable-ccache in the configure step may fix this problem." >> $TRUST_ROOT/NON_INSTALLED
         echo "=> Try using another MPI package, for instance -force_latest_mpich in the configure step, to fix this problem." >> $TRUST_ROOT/NON_INSTALLED
      fi
      echo "---" >> $TRUST_ROOT/NON_INSTALLED
      exit -1 # Penible de ne pas voir le probleme immediatement...
   fi
   # On ecrit dans prog.log pour la desinstallation
   echo `pwd` | sed "s?$TRUST_ROOT/??" >> $TRUST_ROOT/env/prog.log
   cd - 1>/dev/null 2>&1
}

########################################################
run_test_mpi()
{
   test_mpi=$1
   rm -f $test_mpi.log
   # Pour aider on ajoute le LD_LIBRARY_PATH de MPI (ex: mars,eris)
   lib=`dirname $mpiCC`
   lib=$lib/../`\ls $lib/.. | grep lib`
   # On essaie d'executer en sequentiel
   LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$lib ./$test_mpi 1>$test_mpi.log 2>&1 &
   $TRUST_ROOT/bin/KSH/wait_for $! 30
   if [ ! -s $test_mpi.log ]
   then
      err=0
   elif [ "`grep coucou $test_mpi.log`" = "" ]
   then
      err=1
   fi
}
run_test_mpi_par()
{
   test_mpi=$1
   rm -f $test_mpi.log
   lib=`dirname $mpiCC`
   # On essaie d'executer en parallele
   $lib/mpirun -np 2 ./$test_mpi 2 1>$test_mpi.log 2>&1 &
   $TRUST_ROOT/bin/KSH/wait_for $! 30
   if [ ! -s $test_mpi.log ]
   then
      err=0
   #elif [ "`grep mpi-abort $test_mpi.log`" != "" ]
   elif [ "`grep coucou $test_mpi.log`" = "" ]
   then
      err=1
   fi
}

########################################################
configure_compilateur_ccache()
{
   if [ -d $TRUST_ROOT/exec/ccache ]
   then
      variable=`echo $e | awk -F= '{print $1}'`
      chemin=`echo $e | awk -F\" '{print $2}'`
      if [ "$chemin" = "" ]
      then
         eval $e
         if [ "$TRUST_CC_BASE" = "" ]
         then
            [ "$TRUST_STDCPP" = c++14 ] && echo "Error! No C++14 compiler found. For a GNU compiler, you would need a version>=5.3.0" && exit -1
            [ "$TRUST_STDCPP" = c++17 ] && echo "Error! No C++17 compiler found. For a GNU compiler, you would need a version>=8.2.0 or configure for a C++14 compiler with: ./configure -std=c++14 which needs version>=5.3.0" && exit -1
            echo "Error! -std=$TRUST_STDCPP is not supported." && exit -1
         fi
      elif [ "${chemin%nvc++}" != "$chemin" ]
      then
         chemin=$chemin" -noswitcherror" # Pour que nvc++ reconnu dans Clion
      fi
      compilateur=`basename $chemin`
      # On cree un script g++ et gcc
      eval $e
      script=$TRUST_ROOT/exec/ccache/$compilateur
      echo $ECHO_OPTS "#!/bin/bash" > $script
      # Trick to boost nvc/nvcc/nvc++ build by using RAM for temporary files:
      [ ! -d /ccc ] && [ -d /dev/shm ] && [ "`basename $chemin | grep nvc`" != "" ] && echo "TMPDIR=/dev/shm" >> $script
      # Trick to use mix HIP/OMPT compilers according source:
      if [ "$TRUST_USE_ROCM" = 1 ] && [ "$TRUST_USE_KOKKOS_HIP" = 1 ]
      then
         echo $ECHO_OPTS ". \$TRUST_ROOT/env_src/gpu/share/crayCC \"\$@\"" >> $script
         echo $ECHO_OPTS "\$TRUST_ROOT/exec/ccache/bin/ccache $chemin \$flags" >> $script
      else
         echo $ECHO_OPTS "\$TRUST_ROOT/exec/ccache/bin/ccache $chemin \"\$@\"" >> $script
      fi
      chmod +x $script
      e=$variable=\""\$TRUST_ROOT/exec/ccache/$compilateur\" && export $variable"
   fi
}

########################################################
whence_()
{
   # Existe ?
   if [ -f $1 ]
   then
      echo $1
   elif [ `uname -s` = Darwin ]; then
       which "$1"
   else
      # Test de whence sinon whereis -b
      if [ "`uname -s`" = OSF1 ]
      then
	 err=1
      else
	 a=`whence ls 2>/dev/null`
	 err=$?
      fi
      if [ $err = 0 ]
      then
	 # Comportement etrange sur DEC de `whence $file` !
	 # Si `whence $file` = "" alors a=`whence $file` contient n'importe quoi !
	 #w=`whence $file`
	 # Solution : Passer par un fichier :
	 whence $1 > .toto
	 cat .toto
      else
	 # On essaie type car cherche aussi
	 # dans le PATH contrairement a whereis...
	 a=`type $1 2>/dev/null | awk '{print $NF}'`
	 if [ $? = 0 ] && [ -f $a ]
	 then
            echo $a
	 else
            whereis -b $1 | awk '{if (NF>1) print $2}'
	 fi
      fi
   fi
}

########################################################
update_file()
{
   # Usage: update_file file1 file2
   if [ "$1" = "" ] || [ ! -f $1 ]
   then
      echo "$1 not defined or not found!"
   else
      if [ ! -f $2 ]
      then
         # mv -f $1 $2
	 # cat et pas mv car mktemp ne suit pas le umask !
         cat $1 > $2
	 rm -f $1
	 echo "File $2 created."
      elif [ "`diff $1 $2 2>/dev/null`" != "" ]
      then
	 #mv -f $1 $2
	 # cat et pas mv car mktemp ne suit pas le umask !
         cat $1 > $2
	 rm -f $1
	 echo "File $2 updated. TRUST version built with $2 will be cleaned now or later and rebuilt."
	 # On efface de suite la version (pour les librairies si make.$TRUST_ARCH"_opt" ou make.$TRUST_ARCH"_semi_opt" modifie
	 if [ ${2%_opt} != $2 ]
	 then
	    echo "Cleaning now..."
	    (cd $TRUST_ROOT;make clean 1>/dev/null 2>&1 )
	 fi
      else
	 rm -f $1
      fi
   fi
}

########################################################
OK()
{
   if [ $1 = 0 ]
   then
      echo $ECHO_OPTS "OK!"
   else
      echo $ECHO_OPTS "KO!"
   fi
}

########################################################
cherche_file()
{
   word=$1
   liste=$*
   liste=${liste#$word}
   for file in $liste
   do
      fic=`whence_ $file`
      if [ ${#fic} != 0 ] && [ "`xxx $fic`" = 1 ]
      then
	 # Set TRUST_ROOT in the path if necessary:
	 [ $fic != ${fic#$TRUST_ROOT} ] && fic="\$TRUST_ROOT"${fic#$TRUST_ROOT}
	 # New 1.6.8: We do NOT take a path from other TRUST installation
	 if [ "`echo $fic | grep /TRUST/`" = "" ]
         then
	    echo "$word=\"$fic\" && export $word" && exit
	 fi
      fi
      for rep in `cat $TRUST_ROOT/env/.rep`
      do
	 fic=$rep/$file
	 if [ -f $fic ]
	 then
            # On detecte desormais les includes et les librairies aussi
            include=0 && [ $fic != ${fic%.h} ] && include=1
	    library=0 && [ $fic != ${fic%.a} ] && library=1;[ $fic != ${fic%.so} ] && library=1
            binary=0 && [ "`xxx $fic`" = 1 ] && binary=1
            if [ $include = 1 ] || [ $binary = 1 ] || [ $library = 1 ]
            then
	       # Eviter les chemins en dur dans le fichier machine.env
	       [ $fic != ${fic#$TRUST_ROOT} ] && fic="\$TRUST_ROOT"${fic#$TRUST_ROOT}
               echo "$word=\"$fic\" && export $word"
               [ "`grep $rep .path`" = "" ] && echo $ECHO_OPTS $rep >> .path
	       exit
            fi
	 fi
      done
   done
   echo "$word=\"\" && export $word"
}

########################################################
ecrit()
{
   chaine=$*
   m=`echo $chaine | cut -f1 -d"|"`
   e=`echo $chaine | cut -f2 -d"|"`
   env=`echo $chaine | cut -f3 -d"|"`
   echo $m" : "$e;echo $e"       "$m >> $env
}

########################################################
# Pour verifier que l'on a bien un executable :
xxx()
   {
   f=$1
   # Faux si lien absolu :
   #[ -L $f ] && f=`dirname $f`/`ls -la $f | awk '{print $NF}'`
   l=`ls -la $f`;ok=1
   # Bug decouvert: un compilo peut etre installe root et ne pas etre executable par root
   # Donc il faut x pour group et other
   # if [ "`echo $l | cut -c7`" != x ] || [ "`echo $l | cut -c10`" != x ]
   # on ne verifie plus other
   if [ "`echo $l | cut -c4`" = - ] || [ "`echo $l | cut -c7`" = - ] # || [ "`echo $l | cut -c10`" = - ]
   then
      ok=0
   else
   # Verifie en plus si les compilos marchent ou le browser marche :
      log=`basename $f`.log
      case $word in
	   TRUST_CC_BASE) if [ "`echo $f | grep /ccache/`" != "" ]
	   then
	      ok=0 # We don't take ccache/g++ version for the moment (eg:Fedora 18)
	   else
	      # Ajout du test du support obligatoire de C++14
	      if [ "$TRUST_STDCPP" = c++14 ]
	      then
	         echo $ECHO_OPTS "#include <memory>\n#include <iostream>\nauto func(int i) { return [i=std::move(i)](int b){return b+i;}; }\nint main() { int num = func(3)(5);std::cerr<<num<<std::endl;return 0; }" > main.cpp
	      # Ajout du test du support de C++17
	      elif [ "$TRUST_STDCPP" = c++17 ]
	      then
	         echo $ECHO_OPTS "#include <iostream>\n#include <tuple>\nstd::tuple<int, std::string> vals() {return {1,\"one\"};}\nint main() { auto [a, b] = vals(); std::cout << a << b << std::endl; return 0; }" > main.cpp
	      else
	         echo "Option -std=$TRUST_STDCPP not supported." && exit -1
	      fi
	      $f -std=$TRUST_STDCPP -o test_exec main.cpp 1>$log 2>&1;./test_exec 1>>$log 2>&1;[ $? != 0 ] && ok=0
	   fi;;
	   TRUST_cc_BASE) if [ "`echo $f | grep /ccache/`" != "" ]
	   then
	      ok=0 # We don't take ccache/gcc version for the moment (eg:Fedora 18)
	   else
	      echo "int main() {return 0;}" > main.c;$f -o test_exec main.c 1>$log 2>&1;./test_exec 1>>$log 2>&1;[ $? != 0 ] && ok=0
	   fi;;
	   TRUST_F77_BASE) echo $ECHO_OPTS "      PROGRAM main\n      END\n      SUBROUTINE TOTO\n      RETURN\n      END" > $TRUST_ENV/main.f;$f -o test_exec_f $TRUST_ENV/main.f 1>$log 2>&1;./test_exec_f 1>>$log 2>&1;[ $? != 0 ] && ok=0;;
	   # GUI plus supporte: on ne teste plus le browser trouve.
	   #TRUST_WEBBROWSER) if [ "`echo $f | grep -i acrobat`" != "" ]
	   #then
	      # On passe le script netscape livre avec Acrobat
	      # car cela bloque la configuration (ex: PC verde...)
	      # Attention, il semble aussi que mozilla -v bloque
	      # aussi parfois (ex: PC verde...)
	      #ok=0
	   #else
	   #   rm -f $log
           #   $f -v 1>$log 2>&1 &
	   #   $TRUST_ROOT/bin/KSH/wait_for $! 2
	   #   [ $! != 0 ] && ok=0 		# Blocage
	   #   [ ! -s $log ] && ok=0	# Si le navigateur fonctionne, un log doit etre ecrit
	   #fi;;
	   # On cherche le MPI natif donc pas celui livre:
	   Mpirun) [ $f = $TRUST_ROOT/bin/mpirun ] && ok=0;;
	   mpiCC)  [ "`echo $f | grep lib/src/LIBMPI`" != "" ] && ok=0; # Elimination d'une version MPI livree avec TRUST
		   # Elimination de LAM qui n est pas supporte par TRUST et en voie d obsolescence:
		   [ "`echo $f | grep LAM6`" != "" ] && ok=0;
		   [ -f /usr/bin/mpirun ] && [ "`/usr/bin/mpirun -v 2>&1 | grep LAM/MPI`" != "" ] && ok=0;
		   # Elimination de mpiCC sur RedHat Enterprise qui compile en 32 bits (-m32) sur des machines 64 bits
		   [ "`$f --show 2>/dev/null | grep m32`" != "" ] && ok=0;
		   # Elimination de mpicxx sur tantale
		   [ "`basename $f`" = mpicxx ] && [ -f /opt/hpmpi/bin/mpiCC ] && ok=0;
		   # Elimination si mpif77 n'est pas trouve au meme endroit (ex: buda)
		   [ ! -f "`dirname $f`"/mpif77 ] && [ ! -f "`dirname $f`"/mpxlf_r ] && ok=0;
		   # Elimination du OpenMPI 1.3.3 trouve (blocages vus sur is212958)
		   [ -f /usr/bin/mpirun ] && [ "`/usr/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.3.3'`" != "" ] && ok=0;
		   # Elimination du OpenMPI 1.7.2 trouve (blocages cas test PETSc)
		   [ -f /usr/lib64/openmpi/bin/mpirun ] && [ "`/usr/lib64/openmpi/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.7.2'`" != "" ] && ok=0;
		   ;;
	   *);;
      esac
   fi
   # Detruit car sinon pb de droit pour les autres users
   rm -f main.c test_exec
   echo $ok
}

########################################################
cherche_include_systeme()
{
   # Nouveau: recherche des repertoires includes systemes pour la commande makedepend -I....
   # PL: 1.5.7 ftsream.h->fstream, iostream.h->iostream, new.h supprime
   echo $ECHO_OPTS "#include<fstream>\n#include<iostream>\n#include<stdarg.h>\n#include<stddef.h>\n#include<strstream>" > es.cxx
   includes=`$TRUST_CC -M es.cxx | grep -v es.cxx | awk '{print $1}'`
   Y=/usr/include/sys
   # -Y ne marche que pour 1 repertoire (et on prend astucieusement /usr/include/sys pour eviter des nested includes)
   SYSINC_DEP="-Y$Y "`for include in $includes
   do
      dir=\`dirname $include\`
      cd $dir # Astuce pour ne pas avoir de chemins trops longs en ../../..
      dir=\`pwd\` && [ "$dir" != $Y ] && echo $dir
   done | sed "s/\/bits//g" | sort -u | awk '{printf("-I%s ",$1)}'`
   rm -f es.cxx
}

########################################################
print_OS()
{
   if [ -f /etc/os-release ]
   then
      (. /etc/os-release && echo "# OS for the machine : $NAME $VERSION_ID")
   else
      for file in /etc/system-release /etc/release /etc/issue.net /etc/issue
      do
         if [ -f $file ]
         then
            echo "# OS for the machine : `head -1 $file`"
	    break
            # En 2 fois pour supprimer les \n \l qui empechent une comparaison correcte
            #chaine=`head -1 /etc/issue`
            #echo "# OS for the machine : `echo $ECHO_OPTS $chaine | head -1`"
         fi
      done
   fi
}

########################################################
print_GNU_VERSION()
{
   # Verifie que le compilateur est bien GNU:
   [ "${TRUST_CC_BASE%g++}" != "$TRUST_CC_BASE" ] && $TRUST_CC_BASE -v 2>&1 | awk '/gcc / && /version / {i=1;while(split($(i),a,".")==1) i++;print $(i)}'
}

########################################################
print_CLANG_VERSION()
{
   # Renvoi la version CLANG si utilise pour configurer TRUST: Pour aocc, clang++ -v renvoi AOCCxxx clang version x.y.z donc je retire AOCCxxx du resultat
   [ "${TRUST_CC_BASE%clang++}" != "$TRUST_CC_BASE" ] && $TRUST_CC_BASE -v 2>&1 | grep -o "clang.*" | awk '/clang / && /version / {i=1;while(split($(i),a,".")==1) i++;print $(i)}'
}
########################################################
clean_previous_install()
{
   cd $TRUST_ROOT
   echo "TRUST_ROOT changed since previous install... cleaning TRUST installation"
   rm -rf exec/python MonoDir* Outils/ICoCo/ICoCo_src/configure
   for f in `find ThirdPart Outils -type f -name "?akefile"` ; do
      touch $f
   done
   cd -
}
#
#########################################################################################################################################################################
#########################################################################################################################################################################
#
###################
# Debut du script #
###################
if [ "$1" = -check ]
then
   # On verifie que le machine.env est correct
   if [ -f $TRUST_ROOT/env/machine.env ]
   then
      err=""
      OS_changed=0
      [ "$TRUST_DISABLE_CHECK_OS" = "1" ] && echo "Warning: You are loading TRUST environment with TRUST_DISABLE_CHECK_OS, contact TRUST support team at $TRUST_MAIL"
      # Check if the OS has changed:
      OS=`print_OS`
      if [ "$OS" != "" ] && [ "`grep 'OS for the machine' $TRUST_ROOT/env/machine.env`" != "" ] && [ "`grep "$OS" $TRUST_ROOT/env/machine.env`" = "" ] && [ "$TRUST_DISABLE_CHECK_OS" != "1" ]
      then
         err="The OS of your machine has changed"
	 OS_changed=1
      else
	 GNU_VERSION=`print_GNU_VERSION`
	 if [ "$GNU_VERSION" != "" ]
	 then
	    GNU_VERSION_ENV=`awk '/TRUST_VERSION_GNU/ {print $1}' $TRUST_ROOT/env/machine.env | awk -F= '{print $2}'`
            # Check if the machine.env file is corrupted:
	    if [ "$GNU_VERSION_ENV" = "" ]
	    then
	       err="The configure has failed (machine.env is incomplete)."
	    # Check if the GNU compiler has changed:
	    elif [ "$GNU_VERSION" != "$GNU_VERSION_ENV" ]
	    then
	       err="The compiler of your machine has changed ($GNU_VERSION_ENV -> $GNU_VERSION) since the TRUST installation."
	    fi
	 fi
      fi
      if [ "$err" != "" ]
      then
         echo "**********************************************************************"
	 echo "$err"
	 echo "The TRUST installation (or configure) MUST be done again"
	 echo "cause it is now broken because of the previous change."
	 if [ $OS_changed = 1 ]
	 then
	    echo ""
	    echo "Tip: you can load TRUST environment by:"
	    echo "   export TRUST_DISABLE_CHECK_OS=1"
	    echo "   source $TRUST_ROOT/env_TRUST.sh"
	    echo "Contact TRUST support team at: $TRUST_MAIL"
	 fi
	 echo "**********************************************************************"
	 exit -1
      fi
      exit 0
   else
      echo "machine.env file not found. Please run: ./configure under $TRUST_ROOT"
      exit -1
   fi
fi

if [ "$1" = -TRUST_NB_PROCS ]
then
   TRUST_NB_PROCS=1
   if [ -f /proc/cpuinfo ]
   then
      TRUST_NB_PROCS=`$TRUST_Awk '/processor/ {n++} END {print n}' /proc/cpuinfo`
      # Limitations sur certaines frontales de clusters: sur TGCC, build TRUST/src plante si pas de limite, je met TRUST_NB_PROCS a 8
      if [ -d /ccc ] || [ $HOST = jean-zay ] # || [ ${HOST#orcus-} != $HOST ]
      then
        TRUST_NB_PROCS=24
      elif [ "${HOST#aar}" != $HOST ] || [ "${HOST#grenx}" != $HOST ] || [ "${HOST#gutta}" != $HOST ] || [ "${HOST#mezel}" != $HOST ]
      then
        TRUST_NB_PROCS=4
      elif [ "${HOST#summer}" != $HOST ]
      then
        TRUST_NB_PROCS=1
      elif [ "${HOST#uruk}" != $HOST ]
      then
        TRUST_NB_PROCS=40
      fi
   elif [ `uname -s` = "Darwin" ]; then
     TRUST_NB_PROCS=$(sysctl -n hw.perflevel0.logicalcpu)
   fi
   echo $TRUST_NB_PROCS
   exit 0
fi

# Nettoyage des programmes installes par le configure
if [ "$1" = clean ]
then
   if [ -f prog.log ]
   then
      for prog in `cat prog.log`
      do
         cd ../$prog
         make clean
         cd -
      done
   fi
   cd $TRUST_ROOT
   rm -r -f $TRUST_ROOT/env_TRUST.sh $TRUST_ROOT/env/ $TRUST_ROOT/lib $TRUST_ROOT/exec $TRUST_ROOT/include $TRUST_ROOT/Makefile $TRUST_ROOT/MonoDir* $TRUST_ROOT/build
   rm -f $TRUST_ROOT/configure.log
   rm -f  $TRUST_ROOT/tags $TRUST_ROOT/TAGS  $TRUST_ROOT/compile*log
   rm -f $TRUST_ROOT/.toto
   # Plus on efface le $TRUST_TMP
   rm -r -f $TRUST_TMP
   rm -r -f $TRUST_ROOT/Outils/Salome/SALOME-*
   # on efface aussi les instancie_src_*  et src/**/CMakeLists.txt car generes automatiquement
   rm -f $(find $TRUST_ROOT/src -name instancie_src_*)
   rm -f $TRUST_ROOT/src/MAIN/instancie_appel*
   rm -f $(find $TRUST_ROOT/src -name CMakeLists.txt)
   rm -f $(find $TRUST_ROOT/src -name .check_sources.ok)
   # on efface aussi les fichiers ignores et log
   rm -f $(find $TRUST_ROOT/Validation/Rapports_automatiques -name .form.md5sum)
   rm -f $TRUST_ROOT/Validation/Rapports_automatiques/.check_of_all_validation_forms
   rm -rf $(find $TRUST_ROOT/Validation -name build)
   rm -rf $(find $TRUST_ROOT/Validation -name Run.log)
   rm -f $(find $TRUST_ROOT/Outils/VisIt/ -name visit-install"*" | grep -v 3_3_3)
   rm -f $TRUST_ROOT/doc/TRUST/exercices/Tutorial_solutions/Tutorial_solutions.pdf
   rm -f $TRUST_ROOT/doc/TRUST/Tutorial/*_tutorial.pdf
   rm -f $TRUST_ROOT/Outils/TRIOXDATA/test_complet/lance_test_modif

   exit 0
else
   rm -f prog.log
fi

###########################
# Definition de TRUST_ROOT
###########################
export TRUST_ROOT=`pwd`
TRUST_ROOT=${TRUST_ROOT%/env}
echo TRUST_ROOT=$TRUST_ROOT
export TRUST_ENV=$TRUST_ROOT/env
# Pour des commandes comme mktemp_
export PATH=$TRUST_ROOT/bin/KSH:$PATH
# liste="pwd whoami uname find cut"
# for com in $liste
# do
#    if [ "`whence_ $com`" = "" ]; then
#       echo "$com command not accessible: host misconfigured."
#       exit
#    fi
# done

rm -f $TRUST_ENV/.path
touch $TRUST_ENV/.path
# Probleme du echo /usr/ucb/echo "\c" -> /usr/bin/echo "\c" OK
# Probleme du grep ?
rep=/usr/bin
[ -d $rep ] && [ -d /usr/ucb ] && PATH=$rep:$PATH && export PATH

##################################
# Cherche la liste des repertoires
##################################
echo "/" > $TRUST_ROOT/env/.rep
echo "Looking for system directories..."
#liste="/bin /etc /lib /opt /product /sbin /usr /var"
# Rajout /usr/lpp pour IBM Orleans (14/10/03)
# On supprime /usr/local et /usr/lpp trop longs sur IBM Orleans
liste=$TRUST_FORCE_SEARCH" /bin /sbin /usr/bin /usr/ibmcxx /usr/sbin /usr/dt /usr/bsd /usr/etc /usr/X11R6 /usr/freeware /usr/ccs /usr/lib /usr/lib32 /usr/lib64 /usr/local"
for rep in $liste
do
   # Essai avec -follow ?
   # Certaines machines ne connaissent pas follow
   # Rajout du -print necessaire pour Fujitsu
   # F="" && find . -follow -print 1>/dev/null 2>/dev/null && F="-follow"
   # Essayer sans follow pour accelerer...
   F=""
   [ -d $rep ] && echo $rep && find $rep $F -type d -print 2>/dev/null | grep -v ".snapshot" 1>>$TRUST_ROOT/env/.rep
done

######################
# Fichier machine.env:
######################
env=$TRUST_ROOT/env/machine.env
[ -f $env ] && cp -f $env $env".old"
echo "# Environment file created during the install" > $env
echo "# uname -a : `uname -a`" | tee -a $env
print_OS | tee -a $env
echo "# hostname : `hostname`" | tee -a $env
echo "# domainname : `domainname 2>/dev/null`" | tee -a $env

#################
# Variable HOST #
#################
. ./HOST.env
# Variables define_modules_config
if [ "$TRUST_WITHOUT_HOST" = 0 ]
then
   . ./HOST_$HOST_BUILD.sh
else
   . ./HOST_default.sh
fi

#####################
# Modules ou config #
#####################
TRUST_VERSION=`awk '/version/ && /Release notes/ {print $4;exit}' $TRUST_ROOT/RELEASE_NOTES`
ligne_supp=""
# See HOST_???.sh file called above
define_modules_config

#######################
# Variable TRUST_TMP #
#######################
cd $TRUST_ROOT/env
. ./TRUST_TMP.env

###################################
# Si configure a cree des variables
###################################
if [ -f configure.env ]
then
   echo "TRUST_WITHOUT_HOST=$TRUST_WITHOUT_HOST && export TRUST_WITHOUT_HOST	# Disable/enable reading of HOST file"	>> configure.env
   if [ "${HOST#irene}" != $HOST ] || [ "${HOST#topaze}" != $HOST ]
   then
       TRUST_DISABLE_JUPYTER=1 # sur CCRT, jupyter desactive car ~30k inodes
   fi
   # TRUST_DISABLE_CHECK_SRC=1 sur clusters (machine de production parfois lente a compiler):
   [ "$TRUST_WITHOUT_HOST" = 0 ] && TRUST_DISABLE_CHECK_SRC=1
   echo "TRUST_DISABLE_CHECK_SRC=$TRUST_DISABLE_CHECK_SRC && export TRUST_DISABLE_CHECK_SRC # No check sources before compiling (set by user or since TRUST_WITHOUT_HOST=0)" >> configure.env
   echo "TRUST_DISABLE_JUPYTER=$TRUST_DISABLE_JUPYTER && export TRUST_DISABLE_JUPYTER  # disable jupyter build." >> configure.env
   . ./configure.env
fi

#######################
# Quelle norme C++ ?
#######################
if [ "$TRUST_STDCPP" = c++14 ]
then
   if [ "$TRUST_USE_KOKKOS_SIMD" = 1 ] || [ "$TRUST_USE_KOKKOS_OPENMP" = 1 ] || [ "$TRUST_USE_CUDA" = 1 ] || [ "$TRUST_USE_ROCM" = 1 ]
   then
      echo "You need a C++17 compiler to use Kokkos SIMD or OpenMP or CUDA or ROCM/HIP." && exit -1
   fi
fi

#######################
# Quelle architecture ?
#######################
arch=`uname -s`
case $arch in
   Linux) TRUST_ARCH=linux
	TRUST_EDITOR="gedit nedit kate kedit xemacs xedit emacs"
	# On met Intel en 1er/GNU car plus rapide que GNU
	cuda="" && [ "$TRUST_USE_CUDA" = 1 ] && cuda="cuda-" # Uniquement si on demande Cuda, recherche en priorite des wrappers pour les compilateurs GNU
	TRUST_CC_BASE=" FCC icpc  icpx armclang++ "$cuda"g++      g++"  # icpx is the CXX compiler in inteloneAPI 2023
	TRUST_F77_BASE="frt ifort ifx  armflang   "$cuda"gfortran gfortran"
	TRUST_cc_BASE=" fc  icc   icx  armclang   "$cuda"gcc      gcc"
	# Support compilateur NVidia:
	if [ "$TRUST_USE_CUDA" = 1 ]
	then
	   if [ "$TRUST_USE_OPENMP" = 1 ]
	   then
        TRUST_CC_BASE="nvc++ "$TRUST_CC_BASE
        TRUST_F77_BASE="nvfortran "$TRUST_F77_BASE
        TRUST_cc_BASE="nvc "$TRUST_cc_BASE
        # Si n'est pas dans le PATH, on download NVHPC (attention pas encore teste). Utile sur Fedora CEA:
        # Normalement, sur Ubuntu on charge le PATH du module NVHPC
        nvc++ -help 1>/dev/null 2>&1
        if [ $? != 0 ]
        then
           source ../env_src/gpu/install_nvhpc_sdk_toolkit.sh
           # Attention, on met NVHPC en dernier car on prendre de preference le nvcc du CUDA Toolkit:
           echo "ADD_PATH_AFTER $NVHPC/bin" >>$env
           echo "ADD_LD_LIBRARY_PATH_AFTER $NVHPC/lib" >>$env
           export PATH=$PATH:$NVHPC/bin # PATH to $INSTALL/nvhpc-$SDK_VERSION/Linux_x86_64/$SDK_VERSION/compilers/bin
           export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$NVHPC/lib # PATH to $INSTALL/nvhpc-$SDK_VERSION/Linux_x86_64/$SDK_VERSION/compilers/lib
        fi
        nvc++ -help 1>/dev/null 2>&1
        [ $? != 0 ] && echo "Erreur, nvc++ not installed." && exit -1
#     else
#        # If Kokkos requested without OpenMP, put nvcc_wrapper in priority
#        if [ "$TRUST_USE_KOKKOS" = 1 ]
#        then
#           TRUST_CC_BASE="nvcc_wrapper "$TRUST_CC_BASE
#           TRUST_F77_BASE="gfortran "$TRUST_F77_BASE
#           TRUST_cc_BASE="gcc "$TRUST_cc_BASE
#
#           # Check already done in configure, but who knows ...
#           nvcc_wrapper --help 1>/dev/null 2>&1
#           [ $? != 0 ] && echo "Kokkos: error, nvc_wrapper not correctly installed!" && exit -1
#        fi
     fi
	fi
	# Support compilateur cray et AOMP de AMD: https://github.com/ROCm-Developer-Tools/aomp/blob/aomp-dev/docs/UBUNTUINSTALL.md
	if [ "$TRUST_USE_ROCM" = 1 ] && [ "$TRUST_USE_OPENMP" = 1 ]
	then
           PATH=$PATH:/opt/rocm/bin # Pour trouver les compilateurs si necessaire
           TRUST_CC_BASE="crayCC   amdclang++ "$TRUST_CC_BASE
           # Attention flang amdflang s'ils n'utilisent pas -fopenmp linke avec libompstub et Kokkos::initialize() ne trouve pas la carte GPU...
           # See https://github.com/flang-compiler/flang-driver/pull/24
           # On prend donc gfortran en priorite...
           TRUST_F77_BASE="crayftn gfortran flang amdflang "$TRUST_F77_BASE
           TRUST_cc_BASE="craycc   amdclang   "$TRUST_cc_BASE
	fi

	# On rajoute les autres compilateurs
	TRUST_CC_BASE=$TRUST_CC_BASE" pgCC"
	TRUST_F77_BASE=$TRUST_F77_BASE" pgf90 f90 pgf77 f77"
	TRUST_cc_BASE=$TRUST_cc_BASE" pgcc cc"
	Dtterm="xterm dtterm nxterm rxvt konsole"
	IP=`$TRUST_ROOT/bin/admin/ping_ $HOSTNAME | awk '/PING/ {print $3}'`
	;;
   CYGWIN*) TRUST_ARCH=cygwin
	TRUST_EDITOR="nedit kedit xemacs xedit emacs"
	TRUST_CC_BASE="g++ icpc icc ecc"
	TRUST_F77_BASE="gfortran ifort ifc efc"
	TRUST_cc_BASE="gcc icc ecc"
	# On rajoute les autres compilateurs
	TRUST_CC_BASE=$TRUST_CC_BASE" pgCC"
	TRUST_F77_BASE=$TRUST_F77_BASE" pgf90 f90 pgf77 f77"
	TRUST_cc_BASE=$TRUST_cc_BASE" pgcc cc"
	Dtterm="xterm dtterm nxterm rxvt konsole"
	IP=`$TRUST_ROOT/bin/admin/ping_ $HOSTNAME | awk '/PING/ {print $3}'`
	;;
   Darwin) TRUST_ARCH=darwin
	TRUST_EDITOR="nano"
	# par defaut, clang/clang++ (fourni par MacOS) / gfortran (a installer par l'utilisateur)
	TRUST_CC_BASE=$TRUST_CC_BASE" clang++"
	TRUST_F77_BASE=$TRUST_F77_BASE" gfortran"
	TRUST_cc_BASE=$TRUST_cc_BASE" clang"
	Dtterm="xterm"
	IP=`$TRUST_ROOT/bin/admin/ping_ $HOSTNAME | awk '/PING/ {print $3}'`
	;;
   *) TRUST_ARCH=autre
	TRUST_EDITOR="nedit xedit dtpad xemacs"
	TRUST_CC_BASE="g++ CC"
	TRUST_F77_BASE="g77 f77 fort77"
	TRUST_cc_BASE="gcc cc"
	Dtterm="dtterm xterm"
	;;
esac
# Si on ne trouve pas f77, on essaie avec g77 et f90 (TRUST a deja marche sur HP avec f90)
TRUST_F77_BASE=$TRUST_F77_BASE" g77 f90"
# On ajoute en priorite le compilateur donne par option
TRUST_CC_BASE=$TRUST_FORCE_CC" "$TRUST_CC_BASE
TRUST_cc_BASE=$TRUST_FORCE_cc" "$TRUST_cc_BASE
TRUST_F77_BASE=$TRUST_FORCE_F77" "$TRUST_F77_BASE
echo "# IP machine: $IP" | tee -a $env
m="# Simplified machine name ";e="HOST=$HOST && export HOST";ecrit $m"|"$e"|"$env
m="# Building machine name ";e="HOST_BUILD=$HOST_BUILD && export HOST_BUILD";ecrit $m"|"$e"|"$env
##############################################
shell=`basename $SHELL` && echo "# The login shell is : $shell"
m="# Machine architecture";e="TRUST_ARCH=$TRUST_ARCH && export TRUST_ARCH";ecrit $m"|"$e"|"$env;eval $e
ECHO_OPTS="" && [ "`echo -e`" != "-e" ] && ECHO_OPTS="-e" && export ECHO_OPTS
m="# Echo option";e="ECHO_OPTS=\"$ECHO_OPTS\" && export ECHO_OPTS";ecrit $m"|"$e"|"$env
m="# Login of the TRUST install";e="TRUST_LOGIN=`whoami` && export TRUST_LOGIN";ecrit $m"|"$e"|"$env
# Verification de l'existence de certaines variables :
m="# Path to awk command";e="`cherche_file TRUST_Awk gawk awk nawk oawk mawk`";ecrit $m"|"$e"|"$env;eval $e
m="# Path to an text editor";e="`cherche_file TRUST_EDITOR $TRUST_EDITOR`";ecrit $m"|"$e"|"$env

# Nouveau 2010, on regarde le nombre de processeurs disponibles des machines Linux:
TRUST_NB_PROCS=`./configurer_env -TRUST_NB_PROCS`
# Variable TRUST_MAKE for the parallel builds:
TRUST_MAKE="make -j $TRUST_NB_PROCS"
if [ -f /proc/cpuinfo ]
then
   # Nombre de processeurs physiques:
   procs=`grep "physical id" /proc/cpuinfo | sort -u | wc -l` && [ "$procs" = 0 ] && procs=1
   cores_per_proc=`grep "core id" /proc/cpuinfo | sort -u | wc -l` && [ "$cores_per_proc" = 0 ] && cores_per_proc=1
   total_cores=`echo $procs $cores_per_proc | awk '{print $1*$2}'`
   echo "# Detected $procs processors of $cores_per_proc cores means a total of $total_cores physical cores." | tee -a $env
   CACHE_SIZE=`awk '/cache size/ {if ($(NF-1)>cs) cs=$(NF-1)} END {print cs}' /proc/cpuinfo | sort -u`
   echo "# Detected a size cache of $CACHE_SIZE KB." | tee -a $env
elif [ `uname -s` = "Darwin" ]; then
   total_cores=$(sysctl -n hw.perflevel0.logicalcpu)
fi
m="# Number of physical cores";e="TRUST_NB_PHYSICAL_CORES=$total_cores && export TRUST_NB_PHYSICAL_CORES";ecrit $m"|"$e"|"$env;eval $e
m="# Number of logical cores used for build";e="TRUST_NB_PROCS=$TRUST_NB_PROCS && export TRUST_NB_PROCS";ecrit $m"|"$e"|"$env;eval $e
m="# Path to make command used";e="TRUST_MAKE=\"$TRUST_MAKE\" && export TRUST_MAKE";ecrit $m"|"$e"|"$env;eval $e

###############################################################################################################
# Contournement d'un probleme rencontre sur Fedora 18 ou ccache/gcc trouve en premier au lieu de /usr/bin/gcc #
# Le CCACHE_DIR pointait vers un repertoire inexistant suite a un configure clean et le ccache/gcc plantait...#
###############################################################################################################
unset CCACHE_DIR
unset CCACHE_PREFIX
export CCACHE_DISABLE=1 # pas de ccache lors de la configuration

###############################################################################################################
# Contournement d'un pb rencontre lors du deplacement/renommage d'une installation TRUST. touch des makefile  #
# plus efficace que make clean : si MPI installee lors du configure, make clean de TRUST ne la nettoie pas    #
###############################################################################################################
conda="$TRUST_ROOT/exec/python/bin/conda"
[ -f $conda ] && [ "`grep $TRUST_ROOT/exec/python $conda 2>/dev/null`" = "" ] && clean_previous_install

########################################################################################
# Installation de ccache pour instaurer un cache du preprocessing lors de la compilation
########################################################################################
INSTALL_CCACHE=0
[ "$TRUST_DISABLE_CCACHE" != "1" ] && [ $TRUST_ARCH = linux ] && INSTALL_CCACHE=1
if [ $INSTALL_CCACHE =  1 ]
then
   make_ $TRUST_ROOT/env/ccache ccache $TRUST_ROOT/exec/ccache.log
fi
rm -f $TRUST_ROOT/exec/ccache/g??

#########################################################################
# On utilise python de conda pour PETSc, Run_fiche, MED, MEDCOUPLING, IHM
#########################################################################
unset PYTHONPATH # We get a warning from conda if we do not unset this variable

# check the previous install of conda and conda packages if it exists
model=`uname -m`
system=`uname -s` && [ "$system" = Darwin ] && system=MacOSX
# we add ncurses and libffi to overcome an issue with vi on Ub20 if env_for_python.sh loaded
pkgs="pyqt nomkl numpy matplotlib swig cmake scipy sympy libgd pandas bison psutil `[ "$TRUST_DISABLE_JUPYTER" != 1 ] && echo jupyter pandoc` pydantic"
local_channel="-c file://$TRUST_ROOT/externalpackages/Miniforge/local_channel --override-channels"
[ "$model" = aarch64 ] && local_channel="" && pkgs="nomkl numpy matplotlib swig cmake scipy sympy libgd pandas bison psutil `[ "$TRUST_DISABLE_JUPYTER" != 1 ] && echo jupyter pandoc`" && [ -d /ccc ] && pkgs="" # Pas internet au CCRT

# Pour Mac, on force numpy version a 1
[ "$model" = arm64 ] && local_channel="" && pkgs="nomkl pydantic=2.9.2 numpy=1 matplotlib pyqt swig cmake scipy sympy libgd pandas bison psutil `[ "$TRUST_DISABLE_JUPYTER" != 1 ] && echo jupyter pandoc`" # internet OK sous Mac

if [ -d $TRUST_ROOT/exec/python/bin ] && [ -f $TRUST_ROOT/exec/python/bin/conda ]
then
   if [ "$TRUST_WITHOUT_CONDA" = "1" ]; then
       echo "WARNING: Option without CONDA requested ... cleaning previous installation ..."
       rm -rf $TRUST_ROOT/exec/python
       echo "         Done."
       INSTALL_CONDA=0
   else
       # check of python version
       PYTHON_VERSION_OK=`$TRUST_ROOT/exec/python/bin/python --version 2>&1 | awk '/Python/ {split($2,a,".");v=a[1]*1000+a[2]*10+a[3];print (v==3125?1:0)}'`
       PYTHON_TEST_OK=1 && [ "`$TRUST_ROOT/exec/python/bin/python ./test.py 1>/dev/null 2>&1;echo $?`" != 0 ] && PYTHON_TEST_OK=0
       INSTALL_OK=1

       # list of packages already-installed/to-install in conda, we ignore mpi4py since installed with pip
       $TRUST_ROOT/exec/python/bin/conda list | grep -v mpi4py | grep -v ^coolprop > conda_list.check
       if [ "$system" = "Linux" ] && [ $model = "x86_64" ] #&& [ -f $TRUST_ROOT/exec/conda_list.ref ]
       then
          # Strict check of conda packages
          if [ "$TRUST_DISABLE_JUPYTER" != 1 ]
          then
             cat $TRUST_ROOT/externalpackages/Miniforge/conda_list_ref | sed "s?TRUSTR?$TRUST_ROOT?g" | cut -f1 -d',' > conda_list.ref
          else
             cat $TRUST_ROOT/externalpackages/Miniforge/conda_list_ref | sed "s?TRUSTR?$TRUST_ROOT?g" | grep -v jupyter > conda_list.ref
          fi

          if [ `diff conda_list.ref conda_list.check 1>/dev/null 2>&1; echo $?` != 0 ]
          then
             echo "# The current conda install contains some supplementary or missing packages, we clean it..."
             INSTALL_OK=0
          else
             rm -f conda_list.ref
          fi
       else
          # pour mac, on verifie pas strictement le numero de version python, par contre on teste que ce python fonctionne
          [ "$system" = "MacOSX" ] && PYTHON_VERSION_OK=1
          for pkg in $pkgs
          do
            pkg=`echo $pkg | awk -F= '{print $1}'` # Pour ne pas avoir le numero de version
            [ "`grep $pkg conda_list.check`" = "" ] && INSTALL_OK=0
          done
       fi
       rm -f conda_list.check
       if [ "$PYTHON_VERSION_OK" != 1 ] || [ "$PYTHON_TEST_OK" != 1 ] || [ "$INSTALL_OK" != 1 ]
       then
          INSTALL_CONDA=1
       else
          echo "# The current install of python, python packages, swig and cmake from conda seems OK... we skip it"
       fi
    fi
else
   if [ "$TRUST_WITHOUT_CONDA" = "1" ]; then
      INSTALL_CONDA=0
   else
      INSTALL_CONDA=1
   fi
fi

#if [ "$(uname -a | grep CYGWIN)" != "" ]
#then
#  INSTALL_CONDA=0
#  mkdir -p $TRUST_ROOT/exec
#  (cd $TRUST_ROOT/exec/; ln -sf $(dirname $(dirname $(which python))) python )
#fi

if [ "$INSTALL_CONDA" = 1 ]
then
    # If a previous installation folder exists, we remove it.
    [ -d $TRUST_ROOT/exec/python ] && rm -rf $TRUST_ROOT/exec/python
    # remove libxml2 too
    [ -d $TRUST_ROOT/exec/utils/libxml2 ] && rm -rf $TRUST_ROOT/exec/utils/libxml2

    # Detect if conda env is activated. This breaks the install of a new conda
    if [ "x$CONDA_PREFIX" != "x" ]
    then
       echo "Error: TRUST cannot be installed since a conda env is already activated!"
       echo "Please run: conda deactivate"
       echo "then re-run configure"
       exit -1
    fi

    # Then we install conda and the different packages
    conda_installer=`cd $TRUST_ROOT/externalpackages/Miniforge;ls Mini*3*-$system"-"$model.sh`
    echo "Trying to install $conda_installer"
    # PL: Change le TMPDIR car par defaut sur /tmp et pb si mis a noexec
    TMPDIR=$TRUST_TMP $TRUST_ROOT/externalpackages/Miniforge/$conda_installer -p $TRUST_ROOT/exec/python/ -b 1>$TRUST_ROOT/exec/conda_python.log 2>&1
    [ $? != 0 ] && echo "Error while installing $conda_installer. See $TRUST_ROOT/exec/conda_python.log" >> $TRUST_ROOT/NON_INSTALLED && exit -1

    # Installing packages from local channel
    cd $TRUST_ROOT/exec/python/bin
    # Vu sur certaines machines conda_installer ne modifie pas correctement le chemin vers python
    sed -i "s?/usr/bin/env python?$PWD/python?" ./conda
    FASTER_CONDA_INSTALL=1
    if [ "$FASTER_CONDA_INSTALL" = 1 ]
    then
       for pkg in $pkgs
       do
          echo "Installing $pkg..."
       done
       ./conda install $local_channel $pkgs -y 1>>$TRUST_ROOT/exec/conda_python.log 2>&1
       [ $? != 0 ] && echo "Error while installing packages from conda-forge local_channel. See $TRUST_ROOT/exec/conda_python.log" && exit -1
    else
       for pkg in $pkgs
       do
         echo "Installing $pkg ... "
         time ./conda install $local_channel $pkg -y 1>>$TRUST_ROOT/exec/conda_python.log 2>&1
         [ $? != 0 ] && echo "Error while installing '$pkg' from conda-forge local_channel. see $TRUST_ROOT/exec/conda_python.log" >> $TRUST_ROOT/NON_INSTALLED
       done
    fi
    [ `uname -s` = Darwin ] && ln -s python3-config python-config #on MacOS, we need python-config to point to the Conda install
    cd - 1>/dev/null 2>&1
    # If a package has not been correctly installed, we exit with an error
    [ -f $TRUST_ROOT/NON_INSTALLED ] && [ "`grep Miniforge $TRUST_ROOT/NON_INSTALLED`" != "" ] &&  Display_Missing_packages && exit -1
    # clean of the install folder
    rm -rf $TRUST_ROOT/exec/python/pkgs
    mkdir -p $TRUST_ROOT/exec/python/pkgs
elif [ "$TRUST_WITHOUT_CONDA" = "1" ]; # Do not install conda, use system python
then
    # Error medcoupling library build on Fedora30 => force python3
    #ze_python=`which python`
    ze_python=`which python3`
    PYTHON_VERSION_OK=`$ze_python --version 2>&1 | awk '/Python/ {split($2,a,".");v=a[1]*100+a[2];print (v>=306?1:0)}'`
    if [ "$PYTHON_VERSION_OK" != 1 ]
    then
       echo "ERROR: Installing without conda - The following (automatically detected)"
       echo "       $ze_python"
       echo "       is older than minimum required (3.6); you need to provide at least python 3.6 to install TRUST"
       exit -1
    fi
    echo "WARNING: Installing without conda - The following (automatically detected) Python will be used and is sym-linked in exec/python/bin:"
    echo "         $ze_python"
    mkdir -p $TRUST_ROOT/exec/python/bin
    ln -nsf $ze_python $TRUST_ROOT/exec/python/bin/python
fi

# We touch all conda files, otherwise it will be deleted from SCRATCH of clusters (e.g. jean-zay)
[ "${TRUST_ROOT#*scratch/}" != "$TRUST_ROOT" ] && [ "$TRUST_WITHOUT_CONDA" != "1" ] && find $TRUST_ROOT/exec/python -exec touch {} +
# export PATH
echo "export PYTHONLIBS_ROOT_DIR=\$TRUST_ROOT/exec/python" >> $env
echo "export PYTHONINTERP_ROOT_DIR=\$PYTHONLIBS_ROOT_DIR/bin" >> $env
echo "ADD_PATH \$PYTHONLIBS_ROOT_DIR/bin" >> $env
echo "unset PYTHONPATH" >> $env # Pour la CentOS6.5, PYTHONPATH contient le chemin vers python2.6

# Gestion d'une librairie systeme plus recente que conda (ex: libtinfo.so.6.0.29 sur Ubuntu 20 et Debian 10), on vire:
tinfo_conda=`cd $TRUST_ROOT/exec/python/lib 2>/dev/null;ls libtinfo.so.6.* 2>/dev/null | cut -d'.' -f3-5`
if [ "$tinfo_conda" != "" ]
then
    libtinfo_sys=`ls /usr/lib*/libtinfo.so.6.* /usr/lib*/*64-linux-gnu/libtinfo.so.6.* 2>/dev/null | head -1`
    tinfo_sys=`echo $libtinfo_sys | $TRUST_Awk -F/ '{print $NF}' | cut -d'.' -f3-5`
    remove_libtinfo_conda=0 && [ "$tinfo_sys" != "" ] && remove_libtinfo_conda=`echo $tinfo_sys $tinfo_conda | awk '{ print ($1>=$2?1:0) }'`
    if [ $remove_libtinfo_conda -eq 1 ]
    then
       echo "We remove libtinfo and libncursesw from conda and create symlinks from system libs"
       rm -r $TRUST_ROOT/exec/python/lib/libtinfo.so* $TRUST_ROOT/exec/python/lib/libncursesw.so*
       dirlibtinfo=`dirname $libtinfo_sys`
       for file in `ls $dirlibtinfo/libtinfo.so* $dirlibtinfo/libncursesw.so* 2>/dev/null`
       do
          echo "Creating a link: ln -s -f `dirname $libtinfo_sys`/`basename $file` $TRUST_ROOT/exec/python/lib/`basename $file`"
          ln -s -f `dirname $libtinfo_sys`/`basename $file` $TRUST_ROOT/exec/python/lib/`basename $file`
       done
    fi
fi

# Adding utility package 'stats' and 'trustutils' in PYTHONPATH
echo "export PYTHONPATH=\$TRUST_ROOT/Outils/TRUST_STATS_JUPYTER:\$PYTHONPATH" >> $env
echo "export PYTHONPATH=\$TRUST_ROOT/Validation/Outils:\$PYTHONPATH" >> $env

if [ "$TRUST_DISABLE_JUPYTER" != 1 ]
then
   PYTHON_VERSION=`$TRUST_ROOT/exec/python/bin/python -c "import sys; print(str(sys.version_info.major)+'.'+str(sys.version_info.minor))"`
   # Disable autosave in jupyter
   jupyter_config_js=$TRUST_ROOT/exec/python/lib/python$PYTHON_VERSION/site-packages/notebook/static/custom/custom.js
   if [ -f $jupyter_config_js ] && [ "`grep 'Jupyter.notebook.set_autosave_interval(0)' $jupyter_config_js 2>/dev/null`" = "" ]
   then
      echo "Disabling autosave in jupyter-notebook"
      echo "Jupyter.notebook.set_autosave_interval(0); // disable autosave" >> $jupyter_config_js
   fi

   # Install pre_save hook for Jupyter notebook
   jupyter_nb_exe=$TRUST_ROOT/exec/python/bin/jupyter-notebook
   if [ "`grep 'sys.argv.append' $jupyter_nb_exe 2>/dev/null`" = "" ]
   then
      echo "Installing pre_save hook in jupyter-notebook"
      s="
    import os
    tr=os.environ['TRUST_ROOT']
    s=os.path.join(tr, 'env_src', 'jupyter_notebook_config.py')
    sys.argv.append('--config')
    sys.argv.append(s)

    sys.exit(main())
"
      $TRUST_Awk -v r="$s" '{gsub(/sys.exit\(main\(\)\)/,r)}1' $jupyter_nb_exe > jupyter-notebook_tmp
      cat jupyter-notebook_tmp | sed "s@$TRUST_ROOT/exec/python/bin/python@/usr/bin/env python@" > $jupyter_nb_exe
      rm -f jupyter-notebook_tmp
   fi

   # Increase number of attemp when connecting to Jupyter Kernel (to avoid exception: "zmq.error.ZMQError: Address already in use"
   jy_kernel_app=$TRUST_ROOT/exec/python/lib/python$PYTHON_VERSION/site-packages/ipykernel/kernelapp.py
   if [ -f $jy_kernel_app ]
   then
      sed -i "s@max_attempts = 1 if port else 100@max_attempts = 100 if port else 100@" $jy_kernel_app
   fi

   # Allow to move install
   jy_nbconvert=$TRUST_ROOT/exec/python/bin/jupyter-nbconvert
   if [ "`grep "/usr/bin/env" $jy_nbconvert 2>/dev/null`" = "" ]
   then
      sed -i "s@$TRUST_ROOT/exec/python/bin/python@/usr/bin/env python@" $jy_nbconvert
   fi

   # Allow to move install
   jy_kernel=$TRUST_ROOT/exec/python/share/jupyter/kernels/python3/kernel.json
   if [ "`grep "/usr/bin/env" $jy_kernel 2>/dev/null`" = "" ]
   then
      sed -i "s@$TRUST_ROOT/exec/python/bin/python@/usr/bin/env\",\n  \"python@" $jy_kernel
   fi
fi

####################
# Compilateurs C/C++
####################
m="# Path to C++ compiler";e="`cherche_file TRUST_CC_BASE $TRUST_CC_BASE`";configure_compilateur_ccache;ecrit $m"|"$e"|"$env;eval $e
m="# Path to C compiler";e="`cherche_file TRUST_cc_BASE $TRUST_cc_BASE`";configure_compilateur_ccache;ecrit $m"|"$e"|"$env;eval $e
TRUST_ARCH_CC="$TRUST_ARCH"_`echo $TRUST_CC_BASE | awk -F/ '{print $NF}'`
m="# Machine-compiler architecture";e="TRUST_ARCH_CC=$TRUST_ARCH_CC && export TRUST_ARCH_CC";ecrit $m"|"$e"|"$env
[ "${TRUST_ARCH_CC%icpx}" != "$TRUST_ARCH_CC" ] && TRUST_F77_BASE="ifx "$TRUST_F77_BASE
m="# Path to Fortran compiler";e="`cherche_file TRUST_F77_BASE $TRUST_F77_BASE`";ecrit $m"|"$e"|"$env;eval $e
TRUST_VERSION_GNU=`print_GNU_VERSION`
m="# C++ standard to use to build TRUST (c++17 by default)";e="TRUST_STDCPP=$TRUST_STDCPP && export TRUST_STDCPP";ecrit $m"|"$e"|"$env;eval $e
####################################################
# Verification que les compilateurs ont ete trouves.
####################################################
compiler_found=1
if [ "$TRUST_CC_BASE" = "" ]
then
   if [ "$TRUST_STDCPP" = c++14 ]
   then
      echo "Error! No C++14 compiler found. For a GNU compiler, you would need a version>=5.0"
   elif [ "$TRUST_STDCPP" = c++17 ]
   then
      echo "Error! No C++17 compiler found. For a GNU compiler, you would need a version>=8.2.0"
      echo "       or configure for a C++14 compiler with: ./configure -std=c++14 (For GNU compilers, version>=5.3.0 needed)"
   else
     echo "Error! -std=$TRUST_STDCPP is not supported."
   fi
   compiler_found=0
fi
[ "$TRUST_cc_BASE" = "" ] && echo "C compiler not found. Please install a C compiler." && compiler_found=0
[ "$TRUST_F77_BASE" = "" ] && echo "Fortran compiler not found. Please install a Fortran compiler." && compiler_found=0
if [ "$compiler_found" = 0 ] ; then
  echo "Then install again the code."
  [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
  exit -1
fi
######################################################
# Compilateur alternatif pour extp (librairies, tools)
######################################################
# Si pas deja defini dans les fichiers HOST.machine, avec certains compilateurs, on compile les extp (librairies, tools) avec GNU:
if [ "$TRUST_CC_BASE_EXTP" = "" ]
then
   CC_BASE=`basename $TRUST_CC_BASE`
   if [ "$CC_BASE" = nvc++ ] || [ "$CC_BASE" = crayCC ] || [ "$CC_BASE" = amdclang++ ] || [ "$CC_BASE" = nvcc_wrapper ]
   then
      TRUST_CC_BASE_EXTP=g++       && [ -f /usr/bin/cuda-g++ ]      && TRUST_CC_BASE_EXTP=/usr/bin/cuda-g++
      TRUST_cc_BASE_EXTP=gcc       && [ -f /usr/bin/cuda-gcc ]      && TRUST_cc_BASE_EXTP=/usr/bin/cuda-gcc
      TRUST_F77_BASE_EXTP=gfortran && [ -f /usr/bin/cuda-gfortran ] && TRUST_F77_BASE_EXTP=/usr/bin/cuda-gfortran
   fi
   export TRUST_CC_BASE_EXTP TRUST_cc_BASE_EXTP TRUST_F77_BASE_EXTP
fi

# Installing xml2 without dependency to icu, necessary on some systems (Rocky/Fedora 34) for ld and/or mpicxx
# see https://github.com/conda-forge/libxml2-feedstock/issues/41
# keep here to be able to use $TRUST_cc_BASE (seen on adastra)
if [ "$system" = "Linux" ] && [ $model = "x86_64" ]
then
   if [ "$TRUST_WITHOUT_CONDA" = "1" ] || [ "$INSTALL_CONDA" = 1 ]
   then
      make_ $TRUST_ROOT/Outils/libxml2 libxml2 $TRUST_ROOT/exec/libxml2.log
   fi
fi

# Gestion d'une librairie systeme plus recente que conda (ex: libstdc++.so.6.0.29 sur Fedora>=34 pour libstdc++.so.6.0.28 dans conda avec libstdcxx-ng=9.3.0), on vire:
# Le pb se produit au niveau du test Python de l'import MEDCoupling ou d'un editeur comme gedit: GLIBCXX_X.Y.Z not found
stdcpp_conda=`cd $TRUST_ROOT/exec/python/lib 2>/dev/null;ls libstdc++.so.6.0.* 2>/dev/null | cut -d'.' -f3-6`
if [ "$stdcpp_conda" != "" ]
then
    root_gnu=`dirname $TRUST_F77_BASE` && root_gnu=`dirname $root_gnu`
    [ "$GCC_PREFIX" != "" ] && libstd_sys=`$GCC_PREFIX/*/lib64/libstdc++.so.6.0.?? 2>/dev/null`
    libstd_sys=`ls $root_gnu/lib64/libstdc++.so.6.0.?? /usr/lib64/libstdc++.so.6.0.* /usr/lib*/*64-linux-gnu/libstdc++.so.6.0.* $libstd_sys 2>/dev/null | head -1`
    stdcpp_sys=`echo $libstd_sys | $TRUST_Awk -F/ '{print $NF}' | cut -d'.' -f3-6`
    remove_stdcpp_conda=0 && [ "$stdcpp_sys" != "" ] && remove_stdcpp_conda=`echo $stdcpp_sys $stdcpp_conda | awk '{ print ($1>$2?1:0) }'`
    if [ $remove_stdcpp_conda -eq 1 ]
    then
       echo "Warning! Look for a newer conda package than libstdcxx-ng installed in conda to avoid this hack:"
       #rm $TRUST_ROOT/exec/python/lib/libstdc++.so*
       #dirlibstd=`dirname $libstd_sys`
       for file in `ls $TRUST_ROOT/exec/python/lib/libstdc++.so* 2>/dev/null`
       do
          echo "Creating a link: ln -s -f $libstd_sys $file"
          ln -s -f $libstd_sys $file
       done
    fi
fi

###############################
# Linker setup - will use 'mold' if found:
###############################
echo "# Checking if linker is overriden (you can set configure option '-linker=' to do this) or if 'mold' is present ..."
if [ "$TRUST_FORCE_LINKER" != "" ] && [ "$TRUST_FORCE_LINKER" != "default" ]
then
   echo "# TRUST linker forced to: $TRUST_FORCE_LINKER"
   m="# TRUST linker (set by TRUST_FORCE_LINKER env variable)" && e="TRUST_LINKER=\"$TRUST_FORCE_LINKER\"  && export TRUST_LINKER" && ecrit $m"|"$e"|"$env;eval $e
elif [[ "$TRUST_ARCH_CC" = "linux_g++" && "`echo $TRUST_VERSION_GNU | awk -F. '{if ($1*100+$2*10+$3>=1210) print 1}'`" = "1" ]] || [ "$TRUST_ARCH_CC" = "linux_clang++" ]
then
   # for GNU>12.1.0 and clang, we use mold linker if installed, otherwise default linker is used
   # see https://github.com/rui314/mold#how-to-use
   # for intel, only bfd, gold and lld are avail: https://www.intel.com/content/www/us/en/docs/cpp-compiler/developer-guide-reference/2021-8/fuse-ld.html
   mold=`whence_ mold`
   if [ "$mold" != "" ] && [ "$TRUST_FORCE_LINKER" == "" ]
   then
      echo "# 'mold' linker detected: $mold (if you want to not use it, set configure option -linker=default)"
      m="# TRUST linker (if you do not need mold, use ./configure -linker=default)" && e="TRUST_LINKER=\"mold\"  && export TRUST_LINKER" && ecrit $m"|"$e"|"$env;eval $e
   fi
fi

#####################
# ddterm / xterm
#####################
m="# Path to dtterm command";e="`cherche_file Dtterm $Dtterm`";ecrit $m"|"$e"|"$env;eval $e
m="# Path to xterm command";e="`cherche_file Xterm xterm rxvt konsole`";ecrit $m"|"$e"|"$env;eval $e
[ ${#Dtterm} = 0 ] || [ ${#Xterm} = 0 ] && echo "Warning. Some TRUST tools (e.g. gdb on a parallel case) will not work cause Dtterm or Xterm not found. "

#################################################################
# Si on ne trouve pas la librairie graphique Tcl/Tk on l'installe
#################################################################
m="# Path to Tcl/Tk";e="`cherche_file TRUST_WISH /usr/bin/wish /bin/wish wish`";eval $e
if [ "$TRUST_WISH" = "" ] && [ "$TRUST_DISABLE_TCL_TK" != "1" ]
then
   make_ $TRUST_ROOT/Outils/tcl_tk Tcl/Tk $TRUST_ROOT/exec/tcl_tk.log
   e="`cherche_file TRUST_WISH $TRUST_ROOT/exec/tcl_tk/bin/wish`";
fi
ecrit $m"|"$e"|"$env

#################################################################
# Recherche de GNU make>=3.81 (3.80 ne marche pas avec Metis 5.0)
#################################################################
e="`cherche_file gmake gmake make`";eval $e
GMAKE_VERSION_OK=`$gmake --version 2>&1 | awk '/GNU Make/ && ($3>=3.81) {print 1}'`
if [ "$GMAKE_VERSION_OK" != 1 ]
then
   make_ $TRUST_ROOT/env/gmake gmake $TRUST_ROOT/exec/gmake.log
fi

# On efface les paquets inutiles si installation
[ "$install" = 1 ] && \ls *gz | grep -v $TRUST_ARCH | xargs rm -f
cd $TRUST_ROOT/env
# Mozilla est desormais supporte mais Konqueror pas encore completement ...
#echo $ECHO_OPTS "Trying to find and test a browser...\c"
m="# Path to a browser";e="`cherche_file TRUST_WEBBROWSER google-chrome firefox mozilla-firefox mozilla netscape`";ecrit $m"|"$e"|"$env

###############
# NATIVE BLAS #
###############
TRUST_BLAS_LAPACK=""
# Try to improve detection of MKL (Intel):
[ "$MKLROOT" = "" ] && MKLROOT=$MKL_ROOTDIR # Sur sagittarius
[ "$MKLROOT" = "" ] && MKLROOT=$MKL_ROOT # Intel 20
[ "$MKLROOT" = "" ] && MKLROOT=`type -p icpc 2>/dev/null | awk -F/bin '{print $1}'`
if [ "$MKLROOT" != "" ]
then
   # MKL: Math Kernel Library d'INTEL detecte (seems to work with Intel or Gnu compilers)
   TRUST_BLAS_LAPACK=`ls $MKLROOT/lib/*64*/libmkl_core.a $MKL_BASE/lib/*64*/libmkl_core.a 2>/dev/null | head -1`
   [ "$TRUST_BLAS_LAPACK" != "" ] && TRUST_BLAS_LAPACK=`dirname $TRUST_BLAS_LAPACK`
fi
m="# Path to optimized BLAS";e="TRUST_BLAS_LAPACK=\"$TRUST_BLAS_LAPACK\" && export TRUST_BLAS_LAPACK";ecrit $m"|"$e"|"$env

########
# CUDA #
########
if [ "$TRUST_USE_CUDA" = 1 ]
then
   [ "$TRUST_DISABLE_PETSC" = 1 ] && echo "Error, you need PETSc with -cuda option to build AmgXWrapper/AmgX." && exit -1
   #########################
   # To active CUDA support:
   #########################
   # Fedora: See https://forums.developer.nvidia.com/t/cuda-10-installation-on-fedora-30-with-gcc-9-1-1-20190503/74989/7
   # -Drivers NVidia installed
   # -Cuda Compilateur nvcc found or installed
   # SDK     : CUDA_ROOT=/opt/nvidia/hpc_sdk	$CUDA_ROOT/include
   ################
   # Detection nvcc
   ################
   # Ajout du nvcc local en priorite si trouve pour coherence avec driver
   # local_nvcc=`ls /usr/local/*/bin/nvcc 2>/dev/null | tail -1` && [ "$local_nvcc" != "" ] && export PATH=`dirname $local_nvcc`:$PATH
   m="# Wrapper to CUDA compiler";e="`cherche_file TRUST_NVCC nvcc`";eval $e;CUDA_NVCC=$TRUST_NVCC;configure_compilateur_ccache
   # Verifie si NVIdia SDK que l'on pointe vers une version specifique du Cuda Toolkit integree et non sur /compilers/bin/nvcc:
   #if [ "`echo $CUDA_NVCC | grep Linux_x86_64`" != "" ]
   #then
   #   echo "Using NVidia SDK."
   #   if [ "`echo $CUDA_NVCC | grep /compilers/`" != "" ]
   #   then
   #     #echo "Error, you should specify a specific Cuda Toolkit version inside the HPC SDK:"
   #     #ls `dirname $CUDA_NVCC`/../../cuda | grep "\."
   #     #echo "Add -cuda=X.Y to configure option."
   #     #exit -1
   #     NVHPC_ROOT=`echo $CUDA_NVCC | sed "1,$ s?/compilers/bin/nvcc??g"`
   #     NVCC_VERSION=`ls $NVHPC_ROOT/cuda | grep "\." | tail -1`
   #     echo "Warning, using last Cuda version of the NVidia SDK: $NVCC_VERSION"
   #     PATH=$NVHPC_ROOT/cuda/$NVCC_VERSION/bin:$PATH
   #     e="`cherche_file CUDA_NVCC nvcc`";
   #   fi
   #fi
   ecrit $m"|"$e"|"$env;eval $e
   #m="# Path to CUDA compiler";e="CUDA_NVCC=\"$CUDA_NVCC\" && export CUDA_NVCC";ecrit $m"|"$e"|"$env
   # Version que le compilateur fonctionne (typiquement GNU trop recent par rapport a nvcc, build echoue ensuite dans PETSc ou AmgX)
   CCBIN=$TRUST_CC_BASE && [ "$TRUST_CC_BASE_EXTP" != "" ] && CCBIN=$TRUST_CC_BASE_EXTP
   check_nvcc="touch test.cu && $CUDA_NVCC -ccbin $CCBIN -c ./test.cu -o test"
   eval $check_nvcc
   [ $? != 0 ] && echo "Error: $CUDA_NVCC -ccbin $CCBIN is not working." && exit -1
   # Verifie la version de nvcc:
   NVCC_VERSION=`$CUDA_NVCC --version 2>/dev/null | awk -F, '/release/ {gsub("release","",$2);gsub(" ","",$2);print $2}'`
   echo "Cuda compiler version: $NVCC_VERSION"
   #NVCC_VERSION_SUPPORTED=11.2
   #NVCC_VALIDE=`echo $NVCC_VERSION $NVCC_VERSION_SUPPORTED | awk '{if (1.0*$1<=1.0*$2) print 1}'`
   #if [ "$NVCC_VALIDE" = "" ]
   #then
   #   echo "Warning, no valid cuda compiler (nvcc<=$NVCC_VERSION_SUPPORTED) found:"
   #   echo "`$CUDA_NVCC --version 2>/dev/null`"
   #   echo "Load Cuda module or use ./configure -cuda=download to download Cuda toolkit $NVCC_VERSION_SUPPORTED."
   #   exit -1
   #fi
   # Verification par rapport au driver CUDA (ToDo: mieux detecter sur cluster: trust -gpu nvidia-smi)
   NVIDIA_VERSION=`nvidia-smi 2>/dev/null | awk '/CUDA Version/ {print $(NF-1)}'`
   if [ "$NVIDIA_VERSION" != "" ]
   then
      echo "NVidia driver version: $NVIDIA_VERSION"
      NVCC_VALIDE=`echo $NVCC_VERSION $NVIDIA_VERSION | awk '{if (1.0*$1<=1.0*$2) print 1}'`
      if [ "$NVCC_VALIDE" = "" ]
      then
         echo "The NVidia drivers are too old for your Cuda compiler."
         echo "You will experience possible error code:222, reason: the provided PTX was compiled with an unsupported toolchain"
         echo "-> Update NVidia driver or take older Cuda compiler."
         exit -1
      fi
   fi
   if [ "$TRUST_CUDA_CC" = "" ]
   then
      TRUST_CUDA_CC=`nvidia-smi --query-gpu=compute_cap --format=csv 2>/dev/null | tail -1 | awk '{gsub("\\.","",$1);print $1}'`
      # nvidia-smi trop anciens ne supporte pas query-gpu=compute_cap:
      [ "$TRUST_CUDA_CC" = "" ] && [ "`nvidia-smi 2>&1 | grep -e A[123456]000`" != "" ] && TRUST_CUDA_CC=86 # Cartes A3000-A6000
   fi
   if [ "$TRUST_CUDA_CC" != "" ]
   then
      m="# Cuda Compute Capability:";e="TRUST_CUDA_CC=\"$TRUST_CUDA_CC\" && export TRUST_CUDA_CC";
      ecrit $m"|"$e"|"$env;eval $e
   else
      echo "Cuda Compute Capability not detected ! TRUST_CUDA_CC should be set."
      exit -1
   fi
   #########################
   # Detection CUDA run time
   #########################
   # On se base sur nvcc pour trouver les librairies
   # CUDA Toolkit:		NVIDIA HPC SDK:
   # ROOT/bin/nvcc		ROOT/compilers/bin/nvcc
   # ROOT/lib64 		ROOT/cuda/lib64
   ROOT=${CUDA_NVCC%/bin/nvcc}
   ROOT=${ROOT%/compilers}
   CUDA_LIB=`ls $ROOT/lib64/libcudart.so.*.* $ROOT/cuda/lib64/libcudart.so.*.* 2>/dev/null | head -1`
   [ "$CUDA_LIB" = "" ] && echo "Cuda lib libcudart.so not found!" && exit -1
   CUDA_LIB=`dirname $CUDA_LIB 2>/dev/null`
   echo "Cuda libraries CUDA_LIB=$CUDA_LIB"
   CUDA_ROOT=`dirname $CUDA_LIB 2>/dev/null`
   for CUDA_INC_PATH in $CUDA_ROOT/include $CUDA_ROOT/include/cuda
   do
      [ -f $CUDA_INC_PATH/cuda.h ] && export CUDA_INC_PATH && break
   done
   [ "$CUDA_ROOT" = "" ] && echo "CUDA libraries not found!" && exit -1
   
   m="# PATH to CUDA";
   e="CUDA_ROOT=\"$CUDA_ROOT\" && export CUDA_ROOT";
   ecrit $m"|"$e"|"$env;eval $e
   # PL: Comprends rien... Fixer NVHPC_CUDA_HOME met le bazar pour AmgX...
   #e="NVHPC_CUDA_HOME=\"$CUDA_ROOT\" && export NVHPC_CUDA_HOME";
   #ecrit $m"|"$e"|"$env;eval $e
   e="CUDA_INC_PATH=\"$CUDA_INC_PATH\" && export CUDA_INC_PATH";
   ecrit $m"|"$e"|"$env;eval $e
   [ "$CUDA_ROOT" != /usr ] && echo "ADD_PATH \$CUDA_ROOT/bin" >> $env # Ne pas ajouter /usr/bin au PATH car sinon python, conda pris sont ceux du systeme !
   echo "ADD_PATH `dirname $CUDA_NVCC`" >> $env # nvcc pas forcement sous $CUDA_ROOT/bin
   echo "ADD_LD_LIBRARY_PATH \$CUDA_ROOT${CUDA_LIB#$CUDA_ROOT} " >> $env
   # Ajout librairies des cuda sous NVidia SDK:
   for lib in math_libs/lib64 extras/CUPTI/lib64
   do
      [ -d $CUDA_ROOT/$lib ] && echo "ADD_LD_LIBRARY_PATH \$CUDA_ROOT/$lib " >> $env
   done
   echo "ADD_LD_LIBRARY_PATH \$TRUST_ROOT/lib/src/LIBAMGX/AmgX/lib" >> $env
fi
m="# TRUST will use CUDA ?";e="TRUST_USE_CUDA=\"$TRUST_USE_CUDA\" && export TRUST_USE_CUDA";ecrit $m"|"$e"|"$env

########
# ROCM #
########
if [ "$TRUST_USE_ROCM" = 1 ]
then
   # Detection de ROCM_PATH
   [ "$ROCM_PATH" = "" ] && [ -d /opt/rocm ] && ROCM_PATH=/opt/rocm
   [ "$ROCM_PATH" = "" ] && echo "Error, can't find ROCM environment. Specify ROCM_PATH." && exit -1
   # Ecriture
   m="# PATH to ROCM";e="ROCM_PATH=\"$ROCM_PATH\" && export ROCM_PATH";ecrit $m"|"$e"|"$env;eval $e
   echo "ADD_PATH_AFTER \$ROCM_PATH/bin" >> $env
   echo "ADD_LD_LIBRARY_PATH_AFTER \$ROCM_PATH/lib" >> $env
   # Detection de l'architecture de la carte AMD:
   ROCM_ARCH=`$ROCM_PATH/bin/rocminfo 2>&1 | awk '/ gfx/ {print $2}'`
   [ "$HOST" = adastra ] && ROCM_ARCH=gfx90a # Adastra
   # Pour les cartes mal supportees (ex PC AMD): https://community.amd.com/t5/infinity-hub-container/radeon-rx6600xt-ubuntu-22-04-and-rocm-woes/m-p/585568
   [ "${ROCM_ARCH#gfx103}" != $ROCM_ARCH ] && ROCM_ARCH=gfx1030 && echo "export HSA_OVERRIDE_GFX_VERSION=10.3.0 # Pour gfx1032 (pas supporte utilise le code de gfx1030)" >> $env
   echo "export ROCM_ARCH=$ROCM_ARCH # Carte AMD" >> $env
fi
m="# TRUST will use ROCM ?";e="TRUST_USE_ROCM=\"$TRUST_USE_ROCM\" && export TRUST_USE_ROCM";ecrit $m"|"$e"|"$env

###########################################################
# Introduction de TRUST_USE_GPU pour gerer Nvidia/AMD/Intel
###########################################################
TRUST_USE_GPU=0
[ "$TRUST_USE_CUDA" = 1 ] && TRUST_USE_GPU=1
[ "$TRUST_USE_ROCM" = 1 ] && TRUST_USE_GPU=1
# [ "$TRUST_USE_SYCL" = 1 ] && TRUST_USE_GPU=1 # Futur
m="# TRUST use GPU ?";e="TRUST_USE_GPU=\"$TRUST_USE_GPU\" && export TRUST_USE_GPU"; ecrit $m"|"$e"|"$env

#############
# Debut MPI #
#############
BATCH_SYSTEM_DETECTED=0
for cmd in sinfo qstat bqueues
do
   [ "`$cmd --help 2>&1 1>/dev/null;echo $?`" = 0 ] && BATCH_SYSTEM_DETECTED=1 && break
done
# Par defaut (aucun TRUST_FORCE specifie) alors hors clusters et Cuda, FORCE_PROVIDED_MPICH car plus pratique pour VisIt, tests de NR plus rapides, valgrind error-free:
if [ "$TRUST_FORCE_PROVIDED_OPENMPI" != 1 ] && [ "$TRUST_FORCE_LATEST_OPENMPI" != 1 ] && [ "$TRUST_FORCE_PROVIDED_MPICH" != 1 ] && [ "$TRUST_FORCE_LATEST_MPICH" != 1 ] && [ "$TRUST_FORCE_SYSTEM_MPI" != 1 ]
then
   if [ "$BATCH_SYSTEM_DETECTED" = 0 ]
   then
      if [ "$TRUST_USE_CUDA" = 1 ]
      then
         export TRUST_FORCE_PROVIDED_OPENMPI=1 # OpenMPI Cuda-Aware by default on PC
      else
         if [ "`echo $TRUST_VERSION_GNU | awk -F. '{if ($1*100+$2*10+$3>=1100) print -force_latest_mpich}'`" != "" ]
         then
            export TRUST_FORCE_LATEST_MPICH=1
         else
            export TRUST_FORCE_PROVIDED_MPICH=1
         fi
      fi
   fi
fi
COMLIBS=""
MPI_ROOT=""
MPI_INCLUDE="\$TRUST_ROOT/lib/src/LIBMPI/no_mpi"
MPI_LIB=""
TRUST_CC=""
TRUST_cc=""
TRUST_F77=""
COMM=""
if [ "$TRUST_DISABLE_MPI" = 1 ]
then
   m="# Path to MPI";e="MPI_ROOT=\"$MPI_ROOT\" && export MPI_ROOT";	ecrit $m"|"$e"|"$env;eval $e
   m="# Path to MPI include directory";e="MPI_INCLUDE=\"$MPI_INCLUDE\" && export MPI_INCLUDE"; ecrit $m"|"$e"|"$env;eval $e
   m="# COMM variable";e="COMM=\"$COMM\" && export COMM";		ecrit $m"|"$e"|"$env
else
   rep_test_mpi=`mktemp_ -d`
   echo "#include <mpi.h>
   #include <iostream>
   using std::cout;
   using std::endl;
   int main(int argc, char** argv)
   {
     if (argc>1)
     {
       MPI_Init(&argc,&argv);
       int mytid;
       MPI_Comm_rank(MPI_COMM_WORLD,&mytid);
       cout<<\"[PE \"<<mytid<<\"] coucou\"<<endl;
       MPI_Finalize();
     }
     else
     {
       cout<<\"[PE 0] coucou\"<<endl;
     }
     return 0;
   }" > $rep_test_mpi/test_mpi.cpp
   echo "#include <mpi.h>
   #include <iostream>
   using std::cout;
   using std::endl;
   int main(int argc, char** argv)
   {
     if (argc>1)
     {
       MPI_Init(&argc,&argv);
       int mytid;
       MPI_Comm_rank(MPI_COMM_WORLD,&mytid);
       cout<<\"[PE \"<<mytid<<\"] coucou\"<<endl;
       // MPI_Abort(MPI_COMM_WORLD,mytid);
       MPI_Abort(MPI_COMM_WORLD,-1);
     }
     else
     {
       cout<<\"[PE 0] coucou\"<<endl;
     }
     return 0;
   }" > $rep_test_mpi/test_abort_mpi.cpp
   echo "      program main
      integer ierr
      integer argc
      argc=iargc()
      if (argc.gt.1) then
         call mpi_init(ierr)
         print*,\" coucou\"
         call mpi_finalize(ierr)
      else
         print*,\" coucou\"
      endif
      end program" > $rep_test_mpi/test_mpi.f
   # A minima:
   COMM="_mpi";export COMM
   COMFLAGS=" -DMPI_"
   mpi_detecte=0
   if [ "$TRUST_FORCE_PROVIDED_OPENMPI" != 1 ] && [ "$TRUST_FORCE_LATEST_OPENMPI" != 1 ] && [ "$TRUST_FORCE_PROVIDED_MPICH" != 1 ] && [ "$TRUST_FORCE_LATEST_MPICH" != 1 ]
   then
      ############################################
      # Detection de MPI par le wrapper C++ trouve
      ############################################
      ec="`cherche_file mpiCC mpCC_r mpicxx mpiCC`";eval $ec
      if [ "$mpiCC" != "" ]
      then
         MPI_BIN=`dirname $mpiCC` # Variable temporaire utile ensuite
	 # On a besoin de specifier le compilateur utilise par mpiCC
	 if [ "`$mpiCC -show | grep -i openmpi`" != "" ] || [ "`$mpiCC -show | grep bullxmpi`" != "" ] || [ "`$mpiCC -show | grep ompi`" != "" ] || [ "`$mpiCC -show | grep open-mpi`" != "" ]
	 then
            m="# Compiler for mpiCC"  && e="OMPI_CXX=\"\$TRUST_CC_BASE\"  && export OMPI_CXX" && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpicc"  && e="OMPI_CC=\"\$TRUST_cc_BASE\"   && export OMPI_CC"  && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpif77" && e="OMPI_F77=\"\$TRUST_F77_BASE\" && export OMPI_F77" && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpif90" && e="OMPI_FC=\"\$TRUST_F77_BASE\"  && export OMPI_FC"  && ecrit $m"|"$e"|"$env;eval $e
	 elif [ "`$mpiCC -show | grep mpibull`" != "" ]
	 then
            m="# Compiler for mpiCC"  && e="MPIBULL_CXX=\"\$TRUST_CC_BASE\"  && export MPIBULL_CXX" && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpicc"  && e="MPIBULL_CC=\"\$TRUST_cc_BASE\"   && export MPIBULL_CC"  && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpif77" && e="MPIBULL_F77=\"\$TRUST_F77_BASE\" && export MPIBULL_F77" && ecrit $m"|"$e"|"$env;eval $e
	 elif [ "`$mpiCC -show | grep mpich`" != "" ] || [ "`grep MPICH_CXX $mpiCC`" != "" ]
	 then
	    # MPICH_CCC peut etre obsolete, a remplacer par MPICH_CXX ?
	    m="# Compiler for mpicxx" && e="MPICH_CXX=\"\$TRUST_CC_BASE\"  && export MPICH_CXX" && ecrit $m"|"$e"|"$env;eval $e
      m="# Compiler for mpiCC"  && e="MPICH_CCC=\"\$TRUST_CC_BASE\"  && export MPICH_CCC" && ecrit $m"|"$e"|"$env;eval $e
      m="# Compiler for mpicc"  && e="MPICH_CC=\"\$TRUST_cc_BASE\"   && export MPICH_CC"  && ecrit $m"|"$e"|"$env;eval $e
      m="# Compiler for mpif90" && e="MPICH_FC=\"\$TRUST_F77_BASE\" && export MPICH_FC"   && ecrit $m"|"$e"|"$env;eval $e
      #m="# Compiler for mpif77" && e="MPICH_F77=\"\$TRUST_F77_BASE\" && export MPICH_F77" && ecrit $m"|"$e"|"$env;eval $e
      #m="# Compiler for mpif90" && e="MPICH_F90=\"\$TRUST_F77_BASE\" && export MPICH_F90" && ecrit $m"|"$e"|"$env;eval $e
      # Bizarrerie pour ioulia, il faut specifier le linker en fortran sinon NP ne compile pas:
      m="# Linker pour mpif77"  && e="MPICH_FLINKER=\"\$TRUST_F77_BASE\" && export MPICH_FLINKER" && ecrit $m"|"$e"|"$env;eval $e
	 elif [ "`$mpiCC -show | grep mpi | grep intel`" != "" ] || [ "`$mpiCC -help | grep I_MPI_CXX`" != "" ]
	 then
	    m="# Compiler for mpiCC"  && e="I_MPI_CXX=\"\$TRUST_CC_BASE\"  && export I_MPI_CXX" && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpicc"  && e="I_MPI_CC=\"\$TRUST_cc_BASE\"  && export I_MPI_CC"   && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpif77" && e="I_MPI_F77=\"\$TRUST_F77_BASE\" && export I_MPI_F77" && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpif90" && e="I_MPI_F90=\"\$TRUST_F77_BASE\" && export I_MPI_F90" && ecrit $m"|"$e"|"$env;eval $e
	 elif [ "`$mpiCC -show | grep wi4mpi`" != "" ]
         then
            m="" # Rien pour le moment, depend du MPI
            echo "wi4mpi not supported yet."
            exit -1
         else
	    echo "MPI indicated by $mpiCC by not supported yet."
	    exit -1
	 fi
	 # Test du MPI trouve avec mpiCC
	 echo $ECHO_OPTS "# Check `basename $mpiCC` (mpiCC.log file): "
	 echo $mpiCC -o ./test_mpi_CC $rep_test_mpi/test_mpi.cpp
	 $mpiCC -o ./test_mpi_CC $rep_test_mpi/test_mpi.cpp 1>mpiCC.log 2>&1
	 err=$?
	 [ $err = 0 ] && run_test_mpi test_mpi_CC 1>>mpiCC.log 2>&1
	 OK $err
	 if [ $err = 0 ]
	 then
	    # Test du MPI trouve avec mpif90 ou mpif77 (nouveau pour la 1.6.3 car certains Linux avec LAM/MPI n'ont pas le support fortran)
            if [ -f $MPI_BIN/mpif90 ]
            then
               mpif=$MPI_BIN/mpif90
               echo $ECHO_OPTS "# Check `basename $mpif` (mpif.log file): "
               mpif_flag="" && [ "`basename $TRUST_F77_BASE`" = nvfortran ] && mpif_flag="-noswitcherror"
               echo $mpif $mpif_flag -o ./test_mpi_f90 $rep_test_mpi/test_mpi.f
               $mpif $mpif_flag -o ./test_mpi_f90 $rep_test_mpi/test_mpi.f 1>mpif.log 2>&1
               err=$?
               [ $err = 0 ] && run_test_mpi test_mpi_f90 1>>mpif.log 2>&1
               OK $err
            fi
            if [ $err != 0 ] && [ $TRUST_DISABLE_PETSC = 1 ]
            then
               mpif=$MPI_BIN/mpif77
               echo $ECHO_OPTS "# Check `basename $mpif` (mpif.log file): "
               echo $mpif -o ./test_mpi_f77 $rep_test_mpi/test_mpi.f
               $mpif -o ./test_mpi_f77 $rep_test_mpi/test_mpi.f 1>mpif.log 2>&1
               err=$?
               [ $err = 0 ] && run_test_mpi test_mpi_f77 1>>mpif.log 2>&1
               OK $err
            fi
	 fi
	 # On definit TRUST_CC et TRUST_cc si on trouve un mpiCC/mpi77 qui fonctionne:
	 if [ $err = 0 ]
	 then
	    mpi_detecte=1
	    mpicc=$MPI_BIN/mpicc
	    if [ "$VAMPIR_SUPPORTED" = 1 ]
	    then
	       VTCC="vtc++ -vt:cxx "
	       VTcc="vtcc -vt:cc "
	       VTF77="vtf77 -vt:f77 "
	    else
	       VTCC=""
	       VTcc=""
	       VTF77=""
	    fi
	    m="# Path to C++ compiler"     && e="TRUST_CC=\"$VTCC$mpiCC\" && export TRUST_CC"  && ecrit $m"|"$e"|"$env;eval $e
	    m="# Path to C compiler"       && e="TRUST_cc=\"$VTcc$mpicc\" && export TRUST_cc"  && ecrit $m"|"$e"|"$env;eval $e
	    m="# Path to Fortran compiler" && e="TRUST_F77=\"$VTF77$mpif\" && export TRUST_F77" && ecrit $m"|"$e"|"$env;eval $e
	    # On ameliore pour la determination de MPI_INCLUDE
	    MPI_INCLUDE=`$mpiCC -show 2>/dev/null | awk '{for(i=1;i<=NF;i++) if (gsub("-I","",$i)) print $i}' | grep /include`
	    for MPI_INCLUDE in $MPI_INCLUDE `dirname $MPI_BIN`/include
	    do
	       [ -f $MPI_INCLUDE/mpi.h ] && break # On trouve l'include mpi.h
	    done
	    if [ ! -f $MPI_INCLUDE/mpi.h ]
	    then
	       echo "mpi.h not found for $mpiCC ..."
	       mpi_detecte=0 # On n'a pas trouve l'include
	    else
	       # On recherche maintenant MPI_ROOT en se basant MPI_ROOT/lib
	       # ND : j'ajoute sed 's@"@@g' pour retirer les "" car sinon Cmake.env pas bon si intel 2021
	       MPI_LIBS=`$mpiCC -show 2>/dev/null | awk '{for(i=1;i<=NF;i++) if (gsub("-L","",$i)) print $i}' | sort -u | sed 's@"@@g'`
	       for MPI_LIB in $MPI_LIBS
	       do
	          [ -d $MPI_LIB ] && [ "`ls $MPI_LIB/libmpi*.* 2>/dev/null`" != "" ] && break # On trouve le repertoire de la librairie MPI
	       done
	       for MPI_ROOT in $MPI_LIB $MPI_BIN $MPI_INCLUDE
	       do
	          MPI_ROOT=`dirname $MPI_ROOT`
	          [ -d $MPI_ROOT/lib ] && break # On trouve le repertoire pour MPI_ROOT
	       done
	       export MPI_ROOT
	       # Recherche de mpirun
	       em="`cherche_file Mpirun $MPI_BIN/mpirun $MPI_ROOT/bin/mpirun $MPI_ROOT/bin/poe dmpirun prun mpirun mpiexec srun`";eval $em
	       # Si pas trouve (comme sur is213120) alors on quitte:
	       [ "$Mpirun" = "" ] && mpi_detecte=0 && echo "mpiexec/mpirun not found for MPI_ROOT=$MPI_ROOT..."
	       # Pb decouvert sur machine is202803 et ioulia : il ne faut pas inclure mpi++.h dans le mpi.h sinon warning qui font des erreurs avec -Wall -Werror:
	       [ -f `dirname $mpiCC`/mpicxx ] && COMFLAGS=$COMFLAGS" -DMPICH_SKIP_MPICXX"
	       # De meme desactivition du C++ bindings pour gcc recent (>=8.x) sinon erreur avec OpenMPI natif... (See https://github.com/open-mpi/ompi/issues/5157)
	       [ -f `dirname $mpiCC`/mpicxx ] && COMFLAGS=$COMFLAGS" -DOMPI_SKIP_MPICXX"
               # Test du MPI_Abort en parallel (KO avec openmpi 1.10.3 1.10.4 1.10.5)
               # desactive car pb en soumission de job hors frontale
               #echo $ECHO_OPTS "# Check `basename $mpiCC` (mpiAbort.log file): "
               #echo $mpiCC -o ./test_mpi $rep_test_mpi/test_abort_mpi.cpp
               #$mpiCC -o ./test_mpi $rep_test_mpi/test_abort_mpi.cpp 1>mpiAbort.log 2>&1
               #err=$?
               #[ $err = 0 ] && run_test_mpi_par 1>>mpiAbort.log 2>&1
               #OK $err
               #[ $err = 1 ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `mpirun --version | head -n 1`. Upgrade of MPI version."
	       if [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI)'`" != "" ]
	       then
                  echo $ECHO_OPTS "# Check version of OpenMPI (Problem if version between 1.10.3 and 1.10.7): "
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.3'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.4'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.5'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.6'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.7'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
	       fi
	    fi
	 fi
      fi
   fi
   #[ "$err" != 1 ] && rm -r -f $rep_test_mpi

   if [ $mpi_detecte = 0 ]
   then
      if [ "$TRUST_FORCE_PROVIDED_OPENMPI" != 1 ] && [ "$TRUST_FORCE_LATEST_OPENMPI" != 1 ] && [ "$TRUST_FORCE_PROVIDED_MPICH" != 1 ] && [ "$TRUST_FORCE_LATEST_MPICH" != 1 ]
      then
         if [ "$TRUST_WITHOUT_HOST" = 0 ] || [ "$BATCH_SYSTEM_DETECTED" = 1 ]
         then
            echo "Native MPI SHOULD be used on $HOST for optimal performances."
            echo "Check carefully the MPI version you want to use for parallel computing before installing the code, especially onto a HPC cluster."
            echo "The command mpicxx should be found into the bin directory of the MPI version you plan to use, to check that, run:"
            echo "  type mpicxx"
            echo "Or contact $HOST administrator to find native MPI libraries or TRUST support team."
         else
            echo "MPI not detected by TRUST:"
            echo " - On a HPC cluster, contact $HOST's administrator or TRUST support team."
            echo " - On PC, you can use: ./configure -force_provided_mpich|openmpi to force basic MPICH|OPENMPI installation."
            echo "Contact TRUST support team for further questions."
         fi
         [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
         exit -1
      fi
      mpi_detecte=1
      ###########################################
      # Pas de MPI detecte, on prend le MPI livre
      ###########################################
      COMM="_mpi"
      # Switch possible entre OpenMPI et MPICH
      # MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/openmpi" && [ "$TRUST_FORCE_PROVIDED_MPICH" = 1 ] && MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/mpich"
      # New 1.6.9 -> MPICH by default instead of OpenMPI (hangs on several cases, eg: UJV_32 on gudy)
      MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/mpich"
      # New 1.7.5 -> OpenMPI by default instead of MPICH (2.0.2 valgrind free)
      #MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/openmpi"
      if [ "$TRUST_FORCE_PROVIDED_OPENMPI" = 1 ] || [ "$TRUST_FORCE_LATEST_OPENMPI" = 1 ]
      then
         MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/openmpi"
      fi
      export MPI_ROOT # Car sinon pas retenu dans le makefile de LIBMPI
      # Installation du MPI livre
      SRC_MPI=`dirname $MPI_ROOT | sed "s?lib/src?ThirdPart/src?"`
      make_ $SRC_MPI `basename $MPI_ROOT` $TRUST_ROOT/lib/`basename $SRC_MPI`".log"

      MPI_ROOT="\$TRUST_ROOT/lib/src/LIBMPI/`basename $MPI_ROOT`";export MPI_ROOT
      MPI_INCLUDE="\$TRUST_ROOT/lib/src/LIBMPI/`basename $MPI_ROOT`/include";export MPI_INCLUDE
      Mpirun="\$MPI_ROOT/bin/mpirun";export Mpirun
      mpiCC="\$MPI_ROOT/bin/mpicxx";export mpiCC
      COMFLAGS="-DMPI_"
      if [ "`basename $MPI_ROOT`" = openmpi ]
      then
	 COMLIBS=""
	 # Pour OpenMPI on prend desormais mpiCC pour compiler en changeant le compilateur
	 m="# Compiler for mpiCC" && e="OMPI_CXX=\"\$TRUST_CC_BASE\" && export OMPI_CXX" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpicc" && e="OMPI_CC=\"\$TRUST_cc_BASE\" && export OMPI_CC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpifort" && e="OMPI_FC=\"\$TRUST_F77_BASE\" && export OMPI_FC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler C++" && e="TRUST_CC=\"$MPI_ROOT/bin/mpicxx\" && export TRUST_CC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler C" && e="TRUST_cc=\"$MPI_ROOT/bin/mpicc\" && export TRUST_cc" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler F77" && e="TRUST_F77=\"$MPI_ROOT/bin/mpif77\" && export TRUST_F77" && ecrit $m"|"$e"|"$env;eval $e
	 echo "ADD_PATH $MPI_ROOT/bin" >> $env
	 MPI_LIB="";export MPI_LIB
      elif [ "`basename $MPI_ROOT`" = mpich ]
      then
	 COMLIBS=""
	 # Pour MPICH on prend desormais mpicxx (mpiCC n'existe plus) pour compiler en changeant le compilateur
	 m="# Compiler for mpicxx" && e="MPICH_CXX=\"\$TRUST_CC_BASE\" && export MPICH_CXX" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpiCC" && e="MPICH_CCC=\"\$TRUST_CC_BASE\" && export MPICH_CCC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpicc" && e="MPICH_CC=\"\$TRUST_cc_BASE\" && export MPICH_CC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpif77" && e="MPICH_FC=\"\$TRUST_F77_BASE\" && export MPICH_FC" && ecrit $m"|"$e"|"$env;eval $e
#	 m="# Compiler for mpif77" && e="MPICH_F77=\"\$TRUST_F77_BASE\" && export MPICH_F77" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler C++" && e="TRUST_CC=\"$MPI_ROOT/bin/mpicxx\" && export TRUST_CC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler C" && e="TRUST_cc=\"$MPI_ROOT/bin/mpicc\" && export TRUST_cc" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler F77" && e="TRUST_F77=\"$MPI_ROOT/bin/mpif77\" && export TRUST_F77" && ecrit $m"|"$e"|"$env;eval $e
	 echo "ADD_PATH $MPI_ROOT/bin" >> $env
	 MPI_LIB="";export MPI_LIB
	 # Allow to relocate mpich installed by TRUST
	 for mpicompiler in mpicc mpicxx mpif77 mpifort
	 do
	   if [ "`grep "${TRUST_ROOT}" $TRUST_ROOT/lib/src/LIBMPI/mpich/bin/$mpicompiler 2>/dev/null`" != "" ]
	   then
	      sed -i "s@${TRUST_ROOT}@\$TRUST_ROOT@g" $TRUST_ROOT/lib/src/LIBMPI/mpich/bin/$mpicompiler
	   else
	      echo "$TRUST_ROOT/lib/src/LIBMPI/mpich/bin/$mpicompiler already up to date"
	   fi
	 done
      else
         echo "$MPI_ROOT not supported yet."
         [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
	 exit -1
      fi
      export COMM
   fi

   # Ecriture des variables
   m="# Path to MPI"; e="MPI_ROOT=\"$MPI_ROOT\" && export MPI_ROOT"; ecrit $m"|"$e"|"$env;eval $e
   m="# Path to MPI includes directory"; e="MPI_INCLUDE=\"$MPI_INCLUDE\" && export MPI_INCLUDE"; ecrit $m"|"$e"|"$env;eval $e
   if [ "`basename $MPI_ROOT`" = openmpi ] && [ "$TRUST_FORCE_SYSTEM_MPI" != 1 ]
   then
      m="# needed if TRUST relocated"; e="OPAL_PREFIX=\$MPI_ROOT && export OPAL_PREFIX"; ecrit $m"|"$e"|"$env;eval $e
   fi
   # On fait attention si MPI_LIB est vide (-L peut causer des soucis...)
   if [ "$MPI_LIB" != "" ]
   then
      m="# Path to MPI libraries directory";e="MPI_LIB=\"$MPI_LIB\" && export MPI_LIB"; ecrit $m"|"$e"|"$env
      MPI_LIB="-L$MPI_LIB"
   fi
   m="# Path to mpirun command"; e="Mpirun=\"$Mpirun\" && export Mpirun"; ecrit $m"|"$e"|"$env
   #################
   # MPI GPU Aware ?
   #################
   TRUST_MPI_GPU_AWARE=0
   if [ "$TRUST_USE_GPU" = 1 ]
   then
     if [ "`$MPI_ROOT/bin/ompi_info --parsable --all 2>/dev/null | grep mpi_built_with_cuda_support:value:true`" != "" ]
     then
        TRUST_MPI_GPU_AWARE=1
     elif [ "$TRUST_FORCE_MPI_GPU_AWARE" = 1 ]
     then
        echo "You ask for a MPI GPU-Aware but $MPI_ROOT is not!" && exit -1
     fi   
   fi
   m="# MPI GPU-Aware ?"; e="TRUST_MPI_GPU_AWARE=\"$TRUST_MPI_GPU_AWARE\" && export TRUST_MPI_GPU_AWARE"; ecrit $m"|"$e"|"$env
   m="# COMM variable"; e="COMM=\"$COMM\" && export COMM"; ecrit $m"|"$e"|"$env
   # ND : j'ajoute le rm ici car sinon trop de reps dans $TRUST_TMP
   rm -rf $rep_test_mpi
fi
###########
# Fin MPI #
###########

# Pas de MPI, on fixe TRUST_CC a TRUST_CC_BASE et TRUST_cc a TRUST_cc_BASE
[ "$TRUST_CC" = "" ]  && m="# Path to C++ compiler" && e="TRUST_CC=\"$TRUST_CC_BASE\"   && export TRUST_CC"  && ecrit $m"|"$e"|"$env && eval $e
[ "$TRUST_cc" = "" ]  && m="# Path to C compiler"   && e="TRUST_cc=\"$TRUST_cc_BASE\"   && export TRUST_cc"  && ecrit $m"|"$e"|"$env && eval $e
[ "$TRUST_F77" = "" ] && m="# Path to F77 compiler" && e="TRUST_F77=\"$TRUST_F77_BASE\" && export TRUST_F77" && ecrit $m"|"$e"|"$env && eval $e

##############################################################
# Intallation des packages supplementaires avec pip          #
##############################################################
pkgs="" # now, we install only mpi4py with pip if mpi enabled, so empty list
if [ "$TRUST_DISABLE_MPI" != 1 ] && [ "$TRUST_DISABLE_MPI4PY" != 1 ]
then
   pkgs="mpi4py "$pkgs
fi

# if TRUST is configured with CoolProp, we install also its python package !
if [ "$TRUST_USE_COOLPROP" != 0 ]
then
   echo "Installing coolprop python's package ..."
   $TRUST_ROOT/exec/python/bin/pip install coolprop
fi

InstallPipPkgs=0
if [ "$TRUST_WITHOUT_CONDA" != "1" ]; then
   for pkg in $pkgs
   do
      [ "`$TRUST_ROOT/exec/python/bin/conda list | grep $pkg`" = "" ] && InstallPipPkgs=1
   done
fi

if [ "$InstallPipPkgs" = 1 ]
then
   for pkg in $pkgs
   do
     echo "Installing $pkg ..."
     cmd="env MPICH_CC=gcc OMPI_CC=gcc MPICC=$TRUST_cc TMPDIR=$TRUST_TMP $TRUST_ROOT/exec/python/bin/pip install $TRUST_ROOT/externalpackages/pip/$pkg*.gz 1>$TRUST_ROOT/exec/conda_python.log 2>&1"
     eval $cmd
     if [ $? != 0 ]
     then
        # Retry by removing compiler_compat:
        rm -rf $TRUST_ROOT/exec/python/compiler_compat && echo "We remove ld from conda on $HOST and retry installing $pkg ..."
        eval $cmd
        if [ $? != 0 ]
        then
           echo "Error while installing '$pkg' with pip. see $TRUST_ROOT/exec/conda_python.log"
           echo "Contact TRUST support or run ./configure by adding: -disable-$pkg"
           exit -1
        fi
     fi
   done
fi

# If a package has not been correctly installed, we exit with an error
[ -f $TRUST_ROOT/NON_INSTALLED ] && [ "`grep ' pip' $TRUST_ROOT/NON_INSTALLED`" != "" ] &&  Display_Missing_packages && exit -1


########################
# Installation de astyle
########################
#if [ $TRUST_ARCH = linux ]
if [ "$TRUST_DISABLE_CHECK_SRC" != "1" ]
then
   make_ $TRUST_ROOT/Outils/astyle astyle $TRUST_ROOT/exec/astyle.log
fi

# Shares libs possibles ?
SHARE_LIBS=1
# Detect an software configuration management tool -> means a developer version
if [ -d $TRUST_ROOT/.git ]
then
   TRUST_SCM=1
   if [ -d $TRUST_ROOT/.git ]
   then
      GIT_ROOT=$TRUST_ROOT/.git
      # Activate and add Git hooks
      list_hooks=`cd $TRUST_ROOT/bin/GIT/hooks;ls 2>/dev/null`
      list_hooks="" # Temporary: review what really make pre-commit and post-commit
      for hook in $list_hooks
      do
          # Don't use source but . instead in .git/hooks commits
          command=". bin/GIT/hooks/$hook"
	  if [ "`grep "$command" $GIT_ROOT/hooks/$hook 2>/dev/null`" = "" ]
	  then
             echo "Activating and changing the $hook hook in $GIT_ROOT/hooks/$hook"
	     echo "If you want to deny the involved action, then comment the line into this file."
	     # I have seen some git version, where post-pre commit file do not exist and are named post-pre-commit.sample
	     # So we create if necessary:
	     [ ! -f $GIT_ROOT/hooks/$hook ] && echo "#" > $GIT_ROOT/hooks/$hook
	     # Clean previous TRUST changes
	     sed -i "/TRUST/d" $GIT_ROOT/hooks/$hook
	     #nedit $GIT_ROOT/hooks/$hook
	     # Add new one after last comment:
	     last_comment=`grep '^#' $GIT_ROOT/hooks/$hook | tail -1`
	     sed -i "s?$last_comment?$last_comment\n\n# TRUST hook (may be commented):\n$command?" $GIT_ROOT/hooks/$hook
	     #nedit $GIT_ROOT/hooks/$hook
	     chmod +x $GIT_ROOT/hooks/$hook
	  fi
      done
   fi
else
   TRUST_SCM=0
fi
m="# Using an SCM ?";e="TRUST_SCM=\"$TRUST_SCM\" && export TRUST_SCM";ecrit $m"|"$e"|"$env
# Share libs are not use if not using an SCM:
[ "$TRUST_SCM" != 1 ] && SHARE_LIBS=0
export SHARE_LIBS
m="# Shared libs activated ?";e="SHARE_LIBS=\"$SHARE_LIBS\" && export SHARE_LIBS";ecrit $m"|"$e"|"$env
# Bloquage parfois sur linux ....
#echo "Press return if necessary..."
# Questions possibles :
# OPT COMM
# Chercher libF77'*' et libsunmath pour sun5 dans /opt/SUNWspro ...

# Rajout des PATH si la configuration est mal fait sur le compte.
paths=`cat $TRUST_ENV/.path`
if [ ${#paths} != 0 ]
then
   # m="# PATH a rajouter";e="PATH=\$PATH$path && export PATH";ecrit $m"|"$e"|"$env
   # On ajoute proprement les nouveaux PATH:
   echo "# PATH added" >> $env
   for path in $paths
   do
      echo "ADD_PATH_AFTER $path" >> $env
   done
fi
# Ajout du PATH eventuel vers le bin des outils d'installation pour Linux
# devenu inutile en version open source
#[ -d $TRUST_ROOT/../bin ] && echo "ADD_PATH $TRUST_ROOT/../bin" >> $env

###############################
# Construction de make.$TRUST_ARCH_CC
############################
LINK_MALIB="\$(OBJS)"
Defines=""
SYSINC=""
SL_EXTENSION="so" && [ ${TRUST_ARCH#HPPA} != $TRUST_ARCH ] && SL_EXTENSION="sl"
[ ${TRUST_ARCH} = cygwin ] && SL_EXTENSION="dll"
[ ${TRUST_ARCH} = "darwin" ] && SL_EXTENSION="dylib"

OPTIMIZE="-O3"
TRUST_SUPPORTED=0
case $TRUST_ARCH_CC in
  linux_g++*|cygw*g++*|linux_cuda-g++*|linux_nvcc_wrapper*) TRUST_SUPPORTED=1
	[ "$TRUST_STDCPP" = c++14 ] && TRUST_SUPPORTED=`echo $TRUST_VERSION_GNU | awk -F. '{ver=$1*100+$2*10+$3;if (ver>=530 && ver<=1411) print "(Supportee)";else print "(Not yet supported or not supported anymore)"}'`
	[ "$TRUST_STDCPP" = c++17 ] && TRUST_SUPPORTED=`echo $TRUST_VERSION_GNU | awk -F. '{ver=$1*100+$2*10+$3;if (ver>=820 && ver<=1411) print "(Supportee)";else print "(Not yet supported or not supported anymore)"}'`
	m="# GNU compiler version";e="TRUST_VERSION_GNU=$TRUST_VERSION_GNU && export TRUST_VERSION_GNU";ecrit $m"|"$e"|"$env
	[ "`echo $TRUST_SUPPORTED | grep -i Not`" != "" ] && TRUST_SUPPORTED=0
	# Passage en -O2 car plantages suspects en -O3 avec egcs sur linux
	# Options TRES severes a ajouter peut etre un jour : -W -Weffc++ -Wfloat-equal
	# 26/03/10, passage enfin a -03
	# 01/07/19, passage a C++ 11
	# 23/06/23, passage a C++ 14
	[ "$TRUST_USE_OPENMP" = 1 ] && PTHREAD="-pthread" # Pour OpenBLAS ?
	FPIC="-fPIC"
	[ ${TRUST_ARCH} = cygwin ] && FPIC=""  # sous cygwin pas de -fPIC
#	if [ "$TRUST_USE_KOKKOS" = 1 ]; then
#	    # Kokkos already adds '-std=c++14' - do not doit twice since nvcc_wrapper will complain
#	    std_tmp_=""
#	else
	    std_tmp_="-std=$TRUST_STDCPP"
#	fi
	CppFlags="-O3 $FPIC $PTHREAD $std_tmp_ -fno-common -Wno-long-long -Wall -Wno-unknown-pragmas -Wnon-virtual-dtor -Wreorder -Woverloaded-virtual -Wsign-promo -Wsynth -Wshadow -Wextra -Wno-unused-parameter -pedantic -fabi-version=0 -Wno-cpp"
	[ "`echo $TRUST_VERSION_GNU | awk -F. '{print ($1>4)}'`" = 1 ] && [ $TRUST_ARCH_CC = linux_g++ ] && CppFlags=$CppFlags" -Wshadow -Werror" # Uniquement si gcc>=5
	[ "`echo $TRUST_VERSION_GNU | awk -F. '{print ($1==12)}'`" = 1 ] && [ $TRUST_ARCH_CC = linux_g++ ] && CppFlags=$CppFlags" -Wno-use-after-free" # Uniquement si gcc12 (Erreur Kokkos sinon)
	CppFlags=$CppFlags" -fno-math-errno" # Operations mathematiques optimisees sans ecarts crees (vient de F5)
	( [ "$TRUST_INT64" != 1 ] || [ "$TRUST_INT64_NEW" = 1 ] ) && CppFlags=$CppFlags" -Wconversion"
	# flag -Wsuggest-override available on gcc version >= 5.1; on gcc 5.4.0 (ub 16) this flag suggests to fix mpich 3.2, so we do not add this flag
	[ "`echo $TRUST_VERSION_GNU | awk '{split($1,a,".");print (a[1]>5||(a[1]==5&&(a[2]>4))?1:0)}'`" = 1 ] && CppFlags=$CppFlags" -Wno-array-bounds -Wsuggest-override"
	SYSLIBS=$SYSLIBS"-lgfortran"
	F77Flags_32b="-O3 -std=legacy $FPIC"
	# -fallow-argument-mismatch pour gfortran>=10.0.0 (plusieurs librairies Fortran ne compilent pas sinon dont LIBSKIT la premiere):
        [ "`echo $TRUST_VERSION_GNU | awk -F. '{print ($1>=10)}'`" = 1 ] && F77Flags_32b=$F77Flags_32b" -fallow-argument-mismatch"
	F77Flags="$F77Flags_32b" && [ "$TRUST_INT64" = "1" ] && F77Flags=$F77Flags_32b" -fdefault-integer-8"
	ccFLAGS="-O3 $FPIC $PTHREAD"
	ShLibFlag="\$(TRUST_CC) -shared"
	#cherche_include_systeme
	;;
    linux_clang++|linux_armclang++|darwin_clang++) TRUST_SUPPORTED=1
        [ "$TRUST_ARCH_CC" = linux_armclang++ ] && ArmFlags="-armpl -ffast-math" # To add optimized machine-specific library. -ffast-math interessant sur irene-arm (*2 sur HPCG, rien sur GNU)
        [ "`$TRUST_CC_BASE -version 2>&1 | grep aocc`" != "" ] && AoccFlags="-march=znver1 -mfma -fvectorize -mfma -mavx2 -m3dnow -floop-unswitch-aggressive -fuse-ld=lld"
   	Defines="-D_COMPILE_AVEC_CLANG"
   	# 26/03/10, passage enfin a -03
	CppFlags="-O3 -fPIC $ArmFlags $AoccFlags -std=$TRUST_STDCPP -fno-common -Wno-long-long -Wall -Wno-inconsistent-missing-override -Wnon-virtual-dtor -Wreorder -Woverloaded-virtual -Wsign-promo -Wsynth"
	CppFlags=$CppFlags" -Wshadow -Wextra  -Qunused-arguments -Wno-unused-parameter -Wno-cpp -Wno-undefined-var-template " #  -Wno-infinite-recursion"
	TRUST_VERSION_CLANG=`print_CLANG_VERSION`
	# sur clang v > 10 ou 11, ajouter -ffp-model=strict -ffp-exception-behavior=strict pour eviter fausses FPE
	clangFlags="-Wsuggest-override -ffp-exception-behavior=strict -Wno-unsupported-floating-point-opt" && [ "`echo $TRUST_VERSION_CLANG | awk '{split($1,a,".");print (a[1]<11?1:0)}'`" = 1 ] && clangFlags=""
	CppFlags=$CppFlags" "$clangFlags
        [ `uname -s` = "Darwin" ] && CppFlags=$CppFlags" -Wl,-w" #seul moyen de supprimer les warnings "could not create compact unwind" sur Mac
	# GF pas convaincu des erreurs trouvees
	#CppFlags=$CppFlags" -pedantic" # mis en commentaire au passage de clang 4.0.0 car sinon erreur compilation en mode debug
	CppFlags=$CppFlags" -Wno-tautological-compare -Werror"
	SYSLIBS=$SYSLIBS"-lgfortran -lgcc"
	[ "$TRUST_F77_BASE" = linux_armclang++ ] && SYSLIBS=$SYSLIBS" -lflang -lflangrti -lflangADT -lflangArger"
	[ ${TRUST_F77_BASE%flang} != $TRUST_F77_BASE ] && SYSLIBS=$SYSLIBS" -lflang -lflangrti -lpgmath -lomp"
	F77Flags_32b="-O3 -std=legacy -fPIC $ArmFlags $AoccFlags"
	TRUST_GNU_VERSION=`$TRUST_F77_BASE -v 2>&1 | awk '/gcc / && /version / {i=1;while(split($(i),a,".")==1) i++;print $(i)}'`
	[ `echo $TRUST_GNU_VERSION | awk -F. '{print ($1>=10)}'` = 1 ] && F77Flags_32b=$F77Flags_32b" -fallow-argument-mismatch"
	F77Flags="$F77Flags_32b" && [ "$TRUST_INT64" = "1" ] && F77Flags=$F77Flags_32b" -fdefault-integer-8"
	ccFLAGS="-Qunused-arguments -O3 -fPIC $ArmFlags $AoccFlags"
	ShLibFlag="\$(TRUST_CC) -shared"
#	cherche_include_systeme
	;;
   linux_crayCC|linux_amdclang++) TRUST_SUPPORTED=1
   	Defines="-D_COMPILE_AVEC_CLANG"
        if [ "$TRUST_USE_KOKKOS" = 1 ] && [ "$TRUST_USE_ROCM" = 1 ]
        then
           TRUST_STDCPP="c++17"   # For Kokkos 4.x
           CppFlags="-Wno-openmp-mapping"
           Defines=$Defines" -DTRUST_USE_ROCM"
           #CppFlags=$CppFlags" -xhip" # Mode de compilation Hip incompatible avec OpenMP: https://github.com/ROCm/ROCm/discussions/2137 & https://github.com/burlen/cuda_plus_offload
        fi   
        CppFlags=$CppFlags" -O3 -fPIC -std=$TRUST_STDCPP -fno-common -Wno-long-long -Wall -Wno-inconsistent-missing-override -Wnon-virtual-dtor -Wreorder -Woverloaded-virtual -Wsign-promo -Wsynth -Wshadow -Wextra -Qunused-arguments -Wno-unsequenced -Wno-unused-parameter -Wno-tautological-compare -Wno-undefined-var-template -Werror"
        #CppFlags=$CppFlags" -h list=all" # Genere un fichier listing pour OpenMP-target
        #[ "$TRUST_CC_BASE_EXTP" != "" ] && SYSLIBS="-L$GCC_PREFIX/snos/lib64 -lstdc++ -lgfortran -lrt" # EXTP GNU
	      [ "$TRUST_ARCH_CC" = "linux_crayCC" ] && SYSLIBS="-L$GCC_PREFIX/snos/lib64 -lstdc++ -lgfortran -lrt" # EXTP GNU
        SYSLIBS=$SYSLIBS" ${PE_MPICH_GTL_DIR_amd_gfx90a} ${PE_MPICH_GTL_LIBS_amd_gfx90a}" # Librairie GTL necessaire pour activer GPU-Direct
        F77Flags_32b="-O3 -fPIC"
        F77Flags_32b="-O1 -fPIC" # Sinon _dger_ undefined reference dans dlsode.f ! en debug il faut -g -O0 sinon meme erreur !
        F77Flags=$F77Flags_32b
        TRUST_GNU_VERSION=`$TRUST_F77_BASE -v 2>&1 | awk '/gcc / && /version / {i=1;while(split($(i),a,".")==1) i++;print $(i)}'`
        [ `echo $TRUST_GNU_VERSION | awk -F. '{print ($1>=10)}'` = 1 ] && F77Flags=$F77Flags" -fallow-argument-mismatch"
        [ "$TRUST_INT64" = "1" ] && [ "$TRUST_ARCH_CC" = "linux_crayCC" ]     && F77Flags=$F77Flags" -default64"          # crayftn
        [ "$TRUST_INT64" = "1" ] && [ "$TRUST_ARCH_CC" = "linux_amdclang++" ] && F77Flags=$F77Flags" -fdefault-integer-8" # flang
        [ "$TRUST_F77_BASE_EXTP" = gfortran ] && SYSLIBS="-lgfortran" && rep=/usr/lib/gcc/x86_64-linux-gnu/11 && [ -d $rep ] && SYSLIBS="-L$rep "$SYSLIBS # is247793.intra.cea.fr !
        ccFLAGS="-O3 -fPIC"
        ShLibFlag="\$(TRUST_CC) -shared"
	;;
   linux_FCC) TRUST_SUPPORTED=1
        Defines="-D_COMPILE_AVEC_FCC" # Kfast: induces the standard options to exploit the full performance of the A64FX such as SIMDization, software pipelining
        CppFlags="-O3 -fPIC -Kfast" # -SSL2 (for Fujitsu Blas+Lapack) -Nnoclang (fugaku for Trad mode, default)
        SYSLIBS=""
        F77Flags_32b="-O3 -fPIC -Kfast"
        F77Flags="$F77Flags_32b"
        ccFLAGS="-O3 -fPIC -Kfast"
        ShLibFlag="\$(TRUST_CC) -shared"
	;;
   linux_pgCC|linux_nvc++) TRUST_SUPPORTED=1
        Defines="-D_COMPILE_AVEC_PGCC"
        CppFlags=""
        if [ "$TRUST_USE_KOKKOS" = 1 ] && [ "$TRUST_USE_CUDA" = 1 ]
        then
           CppFlags="-cuda" # nvc++ compile cuda code to avoid use of "nvcc -ccbin=nvc++"
           # Si CUDA_VERSION est specifie explicitement dans le HOST sinon on prend le SDK:
           [ "$CUDA_VERSION" = "" ] && CUDA_VERSION=`ls $CUDA_ROOT | grep "[0-9]\.[0-9]"`
           gpu=" -gpu=cc$TRUST_CUDA_CC,cuda$CUDA_VERSION"
           #TRUST_USE_UVM=1 # Provisoire
           [ "$TRUST_USE_UVM" = 1 ] && gpu=$gpu",managed" && Defines=$Defines" -DTRUST_USE_UVM"
           # Attention -mp=gpu -gpu=nordc ne marche pas sur le GPU !!! Voir: https://forums.developer.nvidia.com/t/openmp-offload-w-cuda-interop-undefined-reference-to-fatbinwrap-nv-module-id/253051
           # Donc on active Kokkos_ENABLE_CUDA_RELOCATABLE_DEVICE_CODE=ON au niveau de Kokkos
           CppFlags=$CppFlags$gpu
	   TRUST_STDCPP="c++17"   # For Kokkos 4.x (attention C++17: NVHPC 23.5 OK, NVHPC 23.9 KO sur template !)
        fi
        CppFlags=$CppFlags" -O3 -fPIC -Ktrap=fp -Kieee -noswitcherror" # -Ktrap=fp evitent des soucis Arithmetic Exceptions...
        CppFlags=$CppFlags" -std=$TRUST_STDCPP -Wno-long-long -Wall -Wshadow -Wextra -Wno-unused-parameter -Werror --display_error_number --diag_suppress1 --diag_suppress185" #--diag_suppress111 si on veut supprimer le warning "statement is unreachable"
        CppFlags=$CppFlags" -Wunused-variable" # Flag qui detecte tous les objets C++ non utilises
        #CppFlags=$CppFlags" -Minfo=accel -Minfo=mp -Minfo=loop" # Info au build ou NVCOMPILER_ACC_NOTIFY ?
        SYSLIBS="-lgfortran -lnvf" # Car BLAS+AMGX+PETSC compile avec GNU
	      # On passe en -O1 au lieu de -O3 car plantage dans routine_fft.f dans TrioCFD
        F77Flags_32b="-O1 -fPIC -noswitcherror"
        F77Flags=$F77Flags_32b
        [ "$TRUST_INT64" = "1" ] && F77Flags=$F77Flags" -i8"
        ccFLAGS="-O3 -fPIC -noswitcherror"
        ShLibFlag="\$(TRUST_CC) -shared"
    ;;
   linux_icpc|linux_icpx) TRUST_SUPPORTED=1
	# -fp-model precise (default fast=1) pour avoir memes resultats que GNU
	# ND: -fp-model=except en plus de precise, fvca_jdd13 OK mais crash dans F5
	flag_optim="-O3 -fp-model=strict" && [ "$VT_ROOT" != "" ] && flag_optim="-g "$flag_optim # -g pour Itac, traceanalyzer
	Defines="-D_COMPILE_AVEC_INTEL"
	CppFlags="$flag_optim -std=$TRUST_STDCPP -fPIC -funroll-loops -Wno-unknown-pragmas"
	[ "${TRUST_ARCH_CC%icpx}" != "$TRUST_ARCH_CC" ] && CppFlags=$CppFlags" -Wno-undefined-var-template "
	LIB_INTEL=`dirname $TRUST_F77_BASE`
	# Recherche du repertoire /lib
	for lib in lib compiler/lib
	do
	   [ -d $LIB_INTEL/../../$lib ] && LIB_INTEL2=`echo $LIB_INTEL | sed -e 's;/bin;/'$lib';g'` && [ -d $LIB_INTEL2 ] && LIB_INTEL=$LIB_INTEL2
        done
	#SYSLIBS="-L$LIB_INTEL -lifcore -lirc -lsvml -limf -lstdc++ -liomp5"
	SYSLIBS="-L$LIB_INTEL -lifcore -lirc -lsvml -limf -liomp5"
	F77Flags_32b="$flag_optim -fPIC"
	F77Flags=$F77Flags_32b
	[ "$TRUST_INT64" = "1" ] && F77Flags=$F77Flags" -i8"
	ccFLAGS="$flag_optim -fPIC -funroll-loops"
	ShLibFlag="\$(TRUST_CC) -shared"
	cherche_include_systeme
	;;
   *) TRUST_SUPPORTED=0
        [ "$TRUST_CC_BASE" = "" ] && echo "Pas de compilateur C++ trouve!"
	echo "TRUST_ARCH_CC=$TRUST_ARCH_CC non reconnu. Modifier $0 pour faire reconnaitre"
	echo "cette nouvelle plateforme."
        [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
	exit -1
   	;;
esac

if [ $TRUST_SUPPORTED = 0 ] && [ "$TRUST_FORCE_SUPPORTED" != 1 ]
then
   echo "\$TRUST_ARCH_CC=$TRUST_ARCH_CC is an unsupported platform for TRUST cause"
   echo "the OS and/or the compiler version have not been tested yet. Please, contact TRUST support."
   echo "You can also force the configure with ./configure -force_even_unsupported"
   [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
   exit -1
elif [ $TRUST_SUPPORTED = 1 ]
then
   echo "\$TRUST_ARCH_CC=$TRUST_ARCH_CC is a supported platform for TRUST."
fi
# New: compiler may be given for External_Packages (libraries, tools,...)
if [ "$TRUST_CC_BASE_EXTP" != "" ]
then
   m="# C++ compiler for EXTP";e="TRUST_CC_BASE_EXTP=$TRUST_CC_BASE_EXTP   && export TRUST_CC_BASE_EXTP";ecrit $m"|"$e"|"$env
   m="# C   compiler for EXTP";e="TRUST_cc_BASE_EXTP=$TRUST_cc_BASE_EXTP   && export TRUST_cc_BASE_EXTP";ecrit $m"|"$e"|"$env
   m="# F77 compiler for EXTP";e="TRUST_F77_BASE_EXTP=$TRUST_F77_BASE_EXTP && export TRUST_F77_BASE_EXTP";ecrit $m"|"$e"|"$env
fi
########################
# Cas du compilateur gnu
########################
[ ${TRUST_cc_BASE%gcc} != $TRUST_cc_BASE ] && Defines=$Defines" -D_COMPILE_AVEC_GCC_"
###############
# Cas de IA64 #
###############
[ $TRUST_ARCH = linux ] && [ "`uname -m`" = ia64 ] && Defines=$Defines" -Dia64"
###############################################################
# On recompile un programme simple avec F77FLAGS (en effet sur HP, +DA2.0W change l'appel en _)
# -DF77CALLWITHOUT_ si l'appel a FORTRAN ne necessite pas d'_
# -DF77_Majuscule si l'appel a FORTRAN necessite des majuscules
###############################################################
$TRUST_F77_BASE $F77Flags -o test_exec_f $TRUST_ENV/main.f
[  -f test_exec_f.exe ] && mv test_exec_f.exe test_exec_f # pour cygwin
if [ -f test_exec_f ]
then
   [ "`nm test_exec_f | grep -i toto_`" = "" ] && Defines=$Defines" -DF77CALLWITHOUT_"
   [ "`nm test_exec_f | grep TOTO`" != "" ] && Defines=$Defines" -DF77_Majuscule"
fi
rm -f test_exec_f $TRUST_ENV/main.f

#########################################################################################
# On link une application Fortran-C++ donc il faut parfois des librairies Fortran en plus
#########################################################################################
# Attention: pas tout a fait portable --showme:link n'est pas reconnu partout...
fortran_link=`$TRUST_F77 --showme:link 2>/dev/null`
cpp_link=`$TRUST_CC --showme:link 2>/dev/null`
for item1 in $fortran_link
do
   ok=0
   for item2 in $cpp_link
   do
      [ $item1 = $item2 ] && ok=1 # Found in $cpp_link
      [ ${item1#-I} != $item1 ] && ok=1 # Suppress -I cause useless in SYSLIBS
   done
   [ $ok = 0 ] && SYSLIBS=$SYSLIBS" "$item1
done
#################################################
# test si $TRUST_F77 peut compiler du Fortran 90
#################################################
# Suppression de include 'mpif.h' car inutile avec wrapper mpi.
# Et regle le probleme de l'erreur: Array specification at (1) has more than 7 dimensions in mpif-sizeof.h
echo "
      subroutine test
      real(kind=8) a
      return
      end" > testf90.f
FC=$TRUST_F77_BASE && [ "$TRUST_CC_BASE_EXTP" != "" ] && FC=$TRUST_F77_BASE_EXTP
echo $ECHO_OPTS "Is $FC fortran 90 compliant to compile MUMPS ? \c"
$FC -c testf90.f 1>testf90.log 2>&1
# 12/02/10: Ajout test sur la version de gfortran car la compilation de MUMPS fait planter gfortran 4.0.1
if [ $? = 0 ] && [ "`$FC -v 2>&1 | $TRUST_Awk '/gcc version / {print $3}'`" != "4.0.1" ]
then
   TRUST_USE_MUMPS=1
   echo "Yes"
else
   TRUST_USE_MUMPS=0
   echo "No"
   echo "Error, check your $FC compiler." && exit -1
fi
m="# MUMPS will be used ?";e="TRUST_USE_MUMPS=\"$TRUST_USE_MUMPS\" && export TRUST_USE_MUMPS";ecrit $m"|"$e"|"$env

##########################
# Teste le support 64 bits
##########################
if [ "$TRUST_INT64" = "1" ]
then
   echo '#include <iostream>
#include <cstdint>
using namespace std;
int main() {
   cout<<"Size of int is "<<sizeof(int)<<" bytes"<<endl;
   cout<<"Size of int64_t is " << sizeof(std::int64_t) << " bytes" << endl;
   return sizeof(int64_t);
}' > test_size_64b.cpp
   $TRUST_CC -o test_size_64b.out test_size_64b.cpp
   ./test_size_64b.out  1>/dev/null
   sizeof64=$?
   if [ "$sizeof64" != 8 ]
   then
      echo "# Does the TRUST_CC compiler accept a 64-bit-indices ? : No "  | tee -a $env
      echo "You cannot unfortunately build 64-bit indices version of TRUST."
      # It could perhaps be possible to replace int by long long instead of long"
      echo "Contact TRUST support at trust@cea.fr"
      # We do not display missing packages
      exit -1;
   else
      echo "# Does the TRUST_CC compiler accept a 64-bit-indices ? : Yes "  | tee -a $env
      rm test_size_64b.out test_size_64b.cpp
   fi
   # Check Fortran flags...
   echo '
      program main
      integer i
      call EXIT(storage_size(i))
      end' > test_integer.f
   $TRUST_F77_BASE $F77Flags -o test_integer test_integer.f && ./test_integer
   if [ $? != 64 ]
   then
      echo "Error ! F77Flags=$F77Flags is not enough to convert Fortran integer type to 64 bits integer." 
      exit -1
   fi  
   rm -f test_integer.f test_integer
fi

####################################
# Test le support optimization AVX #
####################################
AVX_FLAGS=""
if [ "${TRUST_CC_BASE%icpc}" != "$TRUST_CC_BASE" ]
then
   # INTEL
   AVX_FLAGS="-xavx2 -xavx -xssse3"
else
   # GNU (il vaut mieux verifier dans le /proc/cpuinfo que l'extension existe
   # car le test de compilation ne suffit pas). A se demander si ce n'est pas
   # plus simple de l'enlever
   # Autre pb: sse4_x n'est pas gere par valgrind en 32 bits
   model=`uname -m`
   # avx512f 3 pb sur TRUST Parallel_Domain_Cutting Polyedre_volume_xg Reprise_Statistiques_Definition_Champs
   # Ok G3/mpcube/TrioCFD
   #for flag in avx512f avx2 avx `[ "$model" != i686 ] && echo sse4_2 sse4_1` ssse3
   for flag in avx2 avx `[ "$model" != i686 ] && echo sse4_2 sse4_1` ssse3
   do
      if  [ "`grep $flag /proc/cpuinfo 2>/dev/null`" != "" ]
      then
         flag=`echo $flag | awk '{gsub("_",".",$0);print $0}'`
         AVX_FLAGS=$AVX_FLAGS" -m$flag"
      fi
   done
fi
# Tester la compilation et l'execution
AVX_SUPPORTED=$TRUST_USE_AVX
for AVX_FLAG in $AVX_FLAGS
do
   file=${AVX_FLAG#-}
   echo $ECHO_OPTS "AVX support on C/C++ code with $AVX_FLAG ? \c"
   echo "#include <iostream>
int main() {
    double sum = 0.0;
    for (unsigned int i = 0; i < 1024; i++) {
        sum += static_cast<double>(i);
    }
    std::cout << sum << std::endl;
    return 0;
}" > $file.cpp
   $TRUST_CC_BASE -o $file $AVX_FLAG $file.cpp 1>$file.log 2>&1 && ./$file 1>>$file.log 2>&1 && rm -f $file $file.cpp $file.log && echo "Yes" && break
   echo "No" && AVX_FLAG=""
done
[ "$AVX_SUPPORTED" != 1 ] && echo "AVX support not activated yet by#ifdef _OPENMP_TARGET default. But you can build a version with:  make opt_avx"

#######
# Petsc
#######
m="# PATH to PETSc";e="PETSC_DIR=\"\$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH"_opt"\" && export PETSC_DIR";ecrit $m"|"$e"|"$env

################################################
# Test si le support GPU est possible sur NVidia
################################################
if [ "$TRUST_USE_CUDA" = 1 ]
then
   #############################
   # Installation NVIDIA Samples
   #############################
   echo $ECHO_OPTS "Is it a double precision NVIDIA card ? \c"
   # Compilation d'un binaire Cuda et test de la carte:
   (
       source ../env_TRUST.sh 1>/dev/null 2>&1
       LD_LIBRARY_PATH=$CUDA_LIB:$LD_LIBRARY_PATH
       rm -r -f nvc_get_devices
       tar xfz $TRUST_ROOT/externalpackages/AmgX/nvc_get_devices.tgz
       cd nvc_get_devices && ./build.sh || exit -1
       # Test eventuel (plus bloquant si echec):
       export exec=`pwd`/nvc_get_devices
       rm -f $TRUST_ENV/card.log
       trust -gpu dummy_file 1>$TRUST_ENV/card.log 2>&1 &
       $TRUST_ROOT/bin/KSH/wait_for $! 60 # Pour eviter blocage
   )
   COMPUTE_CAPABILITY="`awk '/apability/ {print $NF}' $TRUST_ENV/card.log 2>/dev/null | head -1`"
   if [ "$COMPUTE_CAPABILITY" != "" ]
   then
      # On ne supporte que les cartes double precision
      TRUST_USE_CUDA="`echo $COMPUTE_CAPABILITY | awk '{if ($1>=1.3) print 1;else print 0}'`"
      if [ "$TRUST_USE_CUDA" = 0 ]
      then
         echo "No. See error:"
         cat $TRUST_ENV/card.log
         exit -1
      else
         awk '/Device 0/ {print "Yes. The NVIDIA card is "$0}' $TRUST_ENV/card.log
      fi
   else
      rm -f $TRUST_ENV/card.log
      echo "Not tested."
   fi
   # awk '/Driver Version/ {V=11.2;if ($NF>V) print "Warning, current AmgX library only supported for CUDA<="V" !"}' $TRUST_ENV/card.log 2>/dev/null
   Defines=$Defines" -DTRUST_USE_CUDA -DPETSC_SKIP_COMPLEX"
   # Vu sur orcus (fait ch..r) -pedantic pose probleme:
   echo "Cuda: -pedantic suppressed in \$CppFlags"
   CppFlags=`echo $CppFlags | sed "s?-pedantic??g"`
elif [ "$TRUST_USE_ROCM" = 1 ]
then
   Defines=$Defines" -DTRUST_USE_ROCM -D__HIP_PLATFORM_AMD__"
fi

#################
# OpenMP on CPU #
#################
openmp=""
if [ "$TRUST_USE_KOKKOS_OPENMP" = 1 ]
then
   openmp="-fopenmp"
   [ "$TRUST_USE_OPENMP" = 1 ] && echo "Error, using -openmp and -kokkos_openmp is not possible." && exit -1
   # Set two important environment variables for efficient Kokkos OpenMP: See http://www.hpc-carpentry.org/tuning_lammps/07-kokkos-openmp/index.html
   m="# Set the thread affinity policy to be used for parallel regions: ";e="OMP_PROC_BIND=spread && export OMP_PROC_BIND";ecrit $m"|"$e"|"$env
   m="# Specifies on which CPUs (or subset of cores of a CPU) the threads should be placed: ";e="OMP_PLACES=threads && export OMP_PLACES";ecrit $m"|"$e"|"$env
fi
if [ "$TRUST_USE_KOKKOS_OPENMP" = 1 ] || [ "$TRUST_USE_OPENMP" = 1 ]
then
   # Dans l'environnement TRUST, on fixe OMP_NUM_THREADS=1 par defaut (no black box) car performances catastrophiques si l'utilisateur mixe MPI et OpenMP sans savoir ce qu'il fait...
   # L'utilisateur devra faire: OMP_NUM_THREADS=n $exec jdd ou utiliser le script trust qui permettra de specifier le nombre de threads, ex: trust -n 2 -m 4 jdd (2 MPI et 4 threads par task MPI)
   m="# Default, no multi-threading. User should explicitly enable the number of OpenMP threads.";e="OMP_NUM_THREADS=1 && export OMP_NUM_THREADS";ecrit $m"|"$e"|"$env
fi

########################
# OpenMP-target on GPU #
########################
m="# TRUST will use OpenMP-target ?";e="TRUST_USE_OPENMP=\"$TRUST_USE_OPENMP\" && export TRUST_USE_OPENMP";ecrit $m"|"$e"|"$env
openmp_target=""
if [ "$TRUST_USE_OPENMP" = 1 ]
then
   openmp="-fopenmp"
   TRUST_OPENMP_CC=`basename $TRUST_CC_BASE`
   # Compilateurs OpenMP ranges du plus teste au moins teste...
   if [ $TRUST_OPENMP_CC = crayCC ] ||  [ $TRUST_OPENMP_CC = amdclang++ ]
   then
      [ "$TRUST_USE_CUDA" = 1 ] && target=nvptx64-nvidia-cuda && march=""
      [ "$TRUST_USE_ROCM" = 1 ] && target=amdgcn-amd-amdhsa   && march="-march=$ROCM_ARCH"
      # -fsave-loopmark est une option pour creer un .lst a la compilation mais il faut aussi le retirer pour eviter un crash du compilateur
      openmp_target="-fopenmp-targets=$target -Xopenmp-target=$target $march "
  elif [ $TRUST_OPENMP_CC = nvc++ ]
  then
     # See https://www.openmp.org/wp-content/uploads/20210924-OpenMP-update-for-DOE.pdf
     openmp="-mp"
     if [ "$TRUST_USE_CUDA" = 1 ]
     then
        # A partir de HPC SDK 21.3 et necessite compute_capability 70 !
        openmp_target="-target=gpu $march" # Desormais detecte
        #openmp_target="-target=gpu $march" # ToDo OpenMP -gpu=cc86 pour a5000/a6000, detecter nvidia-smi ou autre et pour cluster mettre dans HOST.sh. Gain limite: 1% sur petra ?
        # Sur cluster pour compiler sur la frontale (pas de carte):
        # https://forums.developer.nvidia.com/t/compile-error-for-openmp-code-with-target-offloading-in-nvhpc-20-11/164188
        # ToDo: faire un TRUST_CUDA_CC=70 (v100), 80 (A100), 86 (A5000, A6000) et mettre ici ou ailleurs (ex: PETSc/install)
        # Mais comment detecter ? Placer dans le HOST deja... Sinon, faire un nvidia-smi...
        #[ "$BATCH_SYSTEM_DETECTED" = 1 ] && openmp_target=$openmp_target" -gpu=cc70,cc80" # cc80 pour topaze (A100)
        #Flags utiles du debug:
        #export NVCOMPILER_ACC_NOTIFY = 1|2|4|8|16
        #export NVCOMPILER_ACC_TIME = 1
     fi
   elif [ $TRUST_OPENMP_CC = clang++ ]
   then
      openmp="-fopenmp"
      #[ "$TRUST_USE_ROCM" = 1 ]    && target=amdgcn  && march="-march=gfx90a"
      if [ "$TRUST_USE_CUDA" = 1 ] # Compilation de clang pour offload OpenMP: See https://gist.github.com/anjohan/9ee746295ea1a00d9ca69415f40fafc9
      then
         target=nvptx64 && march=""
         openmp_target="-fopenmp-targets=$target"
         openmp_target=$openmp_target" -Wno-unsequenced" # Hmmm... Operation suspecte pour les classes tableaux de TRUST...
         # Bidouille car clang++ compile pour offload OpenMP
         openmp_target=$openmp_target" -lomptarget -L`dirname $TRUST_CC_BASE`/../lib"
      fi
   elif [ $TRUST_OPENMP_CC = g++ ]
   then
      openmp="-fopenmp"
      target=disable # Pas de carte See https://gcc.gnu.org/wiki/Offloading
      [ "$TRUST_USE_CUDA" = 1 ] && target=nvptx-none    && march="" # Complique gcc a recompiler: voir https://gist.github.com/matthiasdiener/e318e7ed8815872e9d29feb3b9c8413f
      [ "$TRUST_USE_ROCM" = 1 ] && target=amdgcn-amdhsa && march="-march=gfx90a" # Device AMD Radeon MI200
      openmp_target="-foffload=$target $march"
   elif [ $TRUST_OPENMP_CC = icpc ]
   then
      openmp=$openmp" -mkl=parallel" # Ajout de -mkl=parallel pour etre sur de linker avec Mkl BLAS parallele et non sequential (Vu sur sagittarius)
   fi
fi
# Test offloading
if [ "$openmp_target" != "" ]
then
   cmd="$TRUST_CC_BASE $openmp $openmp_target -o offload_openmp offload_openmp.cpp"
   echo "#include <iostream>
int main()
{
double a[3];
double b[3];
#pragma omp target
   for (int i=0;i<3;i++)
      a[i]=b[i]+1;
   for (int i=0;i<3;i++)
      std::cout << a[i] << std::endl;
  return 0;
}" > offload_openmp.cpp && echo $cmd && eval $cmd
   if [ $? != 0 ]
   then
      echo "Error, $TRUST_CC_BASE compiler doesn't support OpenMP offloading."
      echo "Suppress -openmp flag of the configure"
      #[ "$TRUST_USE_CUDA" = 1 ] && [ "$TRUST_VERSION_GNU" != "" ] && echo "Try adding the feature to your GNU compiler for instance on Fedora: sudo dnf install gcc-offload-nvptx"
      exit -1
   else
      echo "$TRUST_CC_BASE support OpenMP offloading..."
   fi
fi
# Ajout des flags OpenMP:
CppFlags=$openmp" "$openmp_target" "$CppFlags
#F77Flags=$openmp" "$openmp_target" "$F77Flags
SYSLIBS=$SYSLIBS" "$openmp

##########
# VAMPIR #
##########
if [ "$VAMPIR_SUPPORTED" = 1 ]
then
   # If you want to instrument MPI events only (this creates smaller trace files and less overhead) use the option -vt:inst manual to disable automatic instrumentation of user functions
   # See http://tu-dresden.de/die_tu_dresden/zentrale_einrichtungen/zih/forschung/projekte/vampirtrace/dateien/VT-UserManual-5.14.4.pdf
   VT_OPTION="-vt:inst manual"
   CppFlags=$CppFlags" "$VT_OPTION
   ccFLAGS=$ccFLAGS" "$VT_OPTION
   F77Flags=$F77Flags" "$VT_OPTION
   Defines=$Defines" -DVTRACE"
fi

##############
# rocALUTION #
##############
if [ "$TRUST_ROCALUTION" = 0 ]
then
   echo "unset TRUST_ROCALUTION" >> $env
   rm -r -f $TRUST_ROOT/lib/src/LIBROCALUTION
else   
   [ "$TRUST_ROCALUTION" = 1 ] && TRUST_ROCALUTION=\""\$TRUST_ROOT/lib/src/LIBROCALUTION"\"
   m="# PATH to rocALUTION";e="TRUST_ROCALUTION=$TRUST_ROCALUTION && export TRUST_ROCALUTION";ecrit $m"|"$e"|"$env
   echo "ADD_LD_LIBRARY_PATH $TRUST_ROCALUTION/lib" >> $env
fi

############
# Topology #
############
if [ "$TRUST_DISABLE_MPI" != 1 ] && [ "$TRUST_DISABLE_HWLOC" != 1 ]
then
   echo "Run ./configure with -disable-hwloc if hwloc install fails:"
   make_ $TRUST_ROOT/Outils/hwloc hwloc $TRUST_ROOT/exec/hwloc.log
   echo "ADD_PATH \$TRUST_ROOT/exec/hwloc/bin" >> $env
fi

###################
# Memory bandwith #
###################
#cd stream
#./check_stream
#cd - 1>/dev/null 2>&1

############################
# LIBCCC_USER support (CCRT)
############################
# Access to:
# remaining time of the current batch application
# time already used by the current batch application
# usable time of the current batch application
# curent resident memory usage of the program
# max virtual memory usage of the program
# Seems to crash with mvapich:
if [ "$LIBCCC_USER_ROOT" != "" ] && [ "`echo $MPI_ROOT | grep -i bullxmpi`" != "" ]
then
   Defines=$Defines" -DLIBCCC_USER"
   SYSLIBS=$SYSLIBS" "$LIBCCC_USER_LDFLAGS
fi

#######################
# Ecriture des fichiers
#######################
Defines=$Defines" $COMFLAGS -D\$(TRUST_ARCH) -DNDEBUG"

#####################################################
# Ajout de variables eventuelles creees par configure
#####################################################
if [ -f configure.env ]
then
   cat configure.env >> machine.env
fi
suffixes=`echo $TRUST_ARCH_CC"_opt" $TRUST_ARCH_CC`
for suffixe in $suffixes
do
   OPT_FLAG="" && [ "$AVX_SUPPORTED" = 1 ] && [ ${suffixe%_opt} != $suffixe ] && OPT_FLAG=$AVX_FLAG
   tmp=`mktemp_`
   echo "Defines = $Defines
SYSINC = $SYSINC
SYSINC_DEP = $SYSINC_DEP
CppFlags = $TRUST_ADD_CXXFLAGS $OPT_FLAG $CppFlags $MPI_Flags \$(Includes) \$(SYSINC) \$(Defines)
SYSLIBS = $MPI_LIB $COMLIBS $SYSLIBS
F77Flags = $TRUST_ADD_FFLAGS $F77Flags
F77Flags_32b = $TRUST_ADD_FFLAGS $F77Flags_32b
ccFLAGS = $TRUST_ADD_CFLAGS $OPT_FLAG $ccFLAGS
ShLibFlag = $ShLibFlag
SL_EXTENSION = $SL_EXTENSION
LINK_MALIB = $LINK_MALIB" > $tmp
   update_file $tmp make.$suffixe

   # On supprime -DNDEBUG
   Defines=${Defines% -DNDEBUG}
   # On remplace -O? par -g
   F77Flags=`echo $F77Flags | sed "1,$ s?-O[0-9]?-g?g"`
   F77Flags_32b=`echo $F77Flags_32b | sed "1,$ s?-O[0-9]?-g?g"`
   ccFLAGS=`echo $ccFLAGS | sed "1,$ s?-O[0-9]?-g?g"`
   CppFlags=`echo $CppFlags | sed "1,$ s?-O[0-9]?-g -O0?g"`
   ### Sur gcc >= 11, -g utilise dwarf5 qui empeche addr2line des versions < 2.35.2 de binutils de convertir les adresses des binaires en numero ligne du code source
   [[ $(echo $TRUST_VERSION_GNU | cut -d '.' -f 1) -ge 11 ]] && CppFlags=${CppFlags/-g /-gdwarf-4 }
   ### sur Adastra-gpu avec crayftn, il faut passer -O0 sinon make debug passe pas( _dger_ undefined reference dans dlsode.f)
   [ "$TRUST_ARCH_CC" = "linux_crayCC" ] && F77Flags=`echo $F77Flags | sed "1,$ s?-g?-g -O0?g"`
   [ "$TRUST_ARCH_CC" = "linux_crayCC" ] && F77Flags_32b=`echo $F77Flags_32b | sed "1,$ s?-g?-g -O0?g"`
   #############################
   # Creation du fichier profile
   #############################
   tmp=`mktemp_`
   cp -f make.$suffixe $tmp
   # 30/08/04: Pour les makefile avec profile, rajout de -a (profile par ligne avec gprof -l) : non gcc 3.2 n'accepte pas...
   # Il semble qu'il faille utiliser -g pour cela ou -fprofile-arcs -ftest-coverage pour gcov (en tout -g pour valgrind --tool=cachegrind
   # et de -fno-inline pour Linux afin de voir le + plus precisement possible ou est depense le CPU
   #sed -i "s?$O?-pg `[ $TRUST_ARCH = linux ] && echo "-fno-inline -fprofile-arcs -ftest-coverage"` $O?g" make.$suffixe2
   # On vire -fprofile-arcs -ftest-coverage car plante sur tantale en parallele....
   # On vire -fno-inline car on peut compiler fichier par fichier
   #sed -i "s?$O?-g -pg `[ $TRUST_ARCH = linux ] && echo "-fno-inline"` $O?g" make.$suffixe2
   option_profile="-pg" && [ "`uname -m`" = ia64 ] && option_profile="-p" # -qp devient obsolete Intel 10
   if [ "`uname -m`" = i686 ] || [ "`uname -m | grep 64`" != "" ]
   then
      # le -gstab1 booste litteralement l'analyse par gprof avec GNU (>*10)
      # http://www.arcknowledge.com/gmane.comp.gnu.binutils.bugs/2006-04/msg00030.html
      [ "`basename $TRUST_CC_BASE`" = g++ ] && option_profile=$option_profile" -gstabs1"
      # Avec icpc l'inlining ne se fait pas avec -pg on le force:
      [ "`basename $TRUST_CC_BASE`" = icpc ] && option_profile=$option_profile" -inline-forceinline"
   fi
   sed -i "s?-O?-g $option_profile -O?g" $tmp
   # Pour le link il faut -pg !
   sed -i "s?SYSLIBS =?SYSLIBS = $option_profile?g" $tmp

   suffixe2=$TRUST_ARCH_CC${suffixe#$TRUST_ARCH_CC}"_pg"
   update_file $tmp make.$suffixe2
   #O="-g"
   ##############################
   # Creation du fichier coverage
   ##############################
   if [ ${TRUST_CC_BASE%g++} != $TRUST_CC_BASE ]
   then
      tmp=`mktemp_`
      # Creation d'un fichier d'environnement pour la compilation avec -ftest-coverage -fprofile-arcs
      cp -f make.$suffixe $tmp
      GCOV_FLAG="-fno-inline -ftest-coverage -fprofile-arcs"
      sed -i "s?CppFlags =?CppFlags = $GCOV_FLAG?g" $tmp
      sed -i "s?F77Flags =?F77Flags = $GCOV_FLAG?g" $tmp
      sed -i "s?F77Flags_32b =?F77Flags_32b = $GCOV_FLAG?g" $tmp
      sed -i "s?ccFLAGS =?ccFLAGS = $GCOV_FLAG?g"  $tmp
      # O3 -> O0 pour cachegrind:
      sed -i "1,$ s?-O3?-g -O0?g" $tmp
      # Attention mpiCC --showme:link depend de MPI (-link_info sur castor): a ameliorer si necessaire
      sed -i "s?SYSLIBS =?SYSLIBS = `$TRUST_CC --showme:link 2>/dev/null` -ftest-coverage -fprofile-arcs ?g" $tmp
      suffixe3=$TRUST_ARCH_CC${suffixe#$TRUST_ARCH_CC}"_gcov"
      update_file $tmp make.$suffixe3
   fi
done
# Creation d'une version make.$ARCH_semi_opt pour avoir une version qui tourne
# vite pour les tests de non regression
tmp=`mktemp_`
cp -f make.$TRUST_ARCH_CC"_opt" $tmp
sed -i "s?-DNDEBUG??g" $tmp
# PL: Ajout sur GNU semi_opt de -fsanitize=address : https://www.osc.edu/resources/getting_started/howto/howto_use_address_sanitizer
# Non affreusement lent a l'execution
# fsan="" && [ "$GNU_VERSION" != "" ] && fsan=-fsanitize=address
# On ne met pas -g car augmente la taille du semi-opt et de toutes les facons variables non debugable -> optimized-out
#sed -i "s?-O3?-g -O3 $fsan?g" $tmp
suffixe4=$TRUST_ARCH_CC"_semi_opt"
update_file $tmp make.$suffixe4

# Creation d'une version make.$ARCH_opt_avx pour tester le support de AVX
if [ "$AVX_SUPPORTED" = 0 ]
then
   tmp=`mktemp_`
   cp -f make.$TRUST_ARCH_CC"_opt" $tmp
   sed -i "s?-O3?-O3 $AVX_FLAG?g" $tmp
   sed -i "s?Defines =?Defines = -DWITH_SSE?g" $tmp
   suffixe5=$TRUST_ARCH_CC"_opt_avx"
   update_file $tmp make.$suffixe5
fi

# Options de compilation sur native
if [ "$TRUST_ADD_NATIVE_FLAGS" = 1 ]
then
   # PL: -xHOST ou -march=native ajoute des flags de vectorisation comme -mavx2 ou mieux... L'option opt_avx va devenir inutile
   # Pas mal d'erreurs encore a corriger:
   # The following tests FAILED:
   #     251 - Obstacle_reprise (Failed)
   #     271 - PETSC_VDF (Failed)
   #     339 - Reprise_Statistiques_Definition_Champs (Failed)
   #     631 - conv_poiseuille_jdd2 (Failed)
   if [ "$TRUST_VERSION_GNU" = "" ]
   then
      sed -i "1,$ s? -O3 ? -O3 -xHOST ?" make.$TRUST_ARCH_CC"_opt"
   else
      # -ffast-math -mtune=native fait des exceptions arithmetiques: ToDo a voir...
      sed -i "1,$ s? -O3 ? -O3 -g -march=native ?" make.$TRUST_ARCH_CC"_opt"
   fi
fi
############################################################
# Outil pour la creation de dependances
############################################################
TRUST_MD="makedepend"
m="# Path to makedepend command";e="`cherche_file TRUST_MD $TRUST_MD`";ecrit $m"|"$e"|"$env;eval $e
[ "$ligne_supp" != "" ] &&       echo $ligne_supp  >> $env

############################
# Fin creation machine.env #
############################
echo "File machine.env created."

# Generation de Cmake.env a partir des make.$TRUST_ARCH
find_flags()
{
    What=$1
    marq=$2
    shift;shift
    ajout=$*
    echo "SET(CMAKE_${What}_FLAGS_${MODE} \""$ajout `grep "$marq =" make.${TRUST_ARCH_CC}$suf | sed "s/\\$(Includes) \\$(SYSINC) \\$(Defines)//" |sed "s/$marq =//"` "\" CACHE STRING \"from make.${TRUST_ARCH_CC}$suf\" FORCE)" >> Cmake.env
    echo "MARK_AS_ADVANCED(CMAKE_${What}_FLAGS_${MODE})" >> Cmake.env
}
defines_base=`grep "Defines ="  make.${TRUST_ARCH_CC}| sed "s/Defines =//"`
echo "SET(ADD_CPPFLAGS \""`grep "Defines ="  make.${TRUST_ARCH_CC} | sed "s/Defines =//" | awk -F\$ '{print $1}'` "-D$TRUST_ARCH \")"| sed "s/-D //" > Cmake.env
for mode in Debug Release Profil Coverage semi_opt Release_avx
do
  case $mode in
      Debug) suf="" ;;
      Release) suf="_opt";;
      Release_avx) suf="_opt_avx";;
      Profil) suf="_opt_pg";;
      Coverage) suf="_opt_gcov";;
      semi_opt) suf="_semi_opt";;
      *) echo $mode inconnue ;
         [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages ;
         exit -1 ;;
  esac;
  if [ -f make.${TRUST_ARCH_CC}$suf ]
      then
      MODE=`echo $mode | awk '{print toupper($0)}'`
      ajout=`grep "Defines =" make.${TRUST_ARCH_CC}$suf | sed "s/$defines_base//;s/Defines =//"`
      find_flags CXX CppFlags  $ajout
      if [ "$TRUST_INT64_NEW" = "1" ]; then
        find_flags Fortran F77Flags_32b   # with the proper 64b version the Fortran part of TRUST only needs 32b compile
      else
        find_flags Fortran F77Flags
      fi
      find_flags C ccFLAGS
      find_flags EXE_LINKER SYSLIBS
  fi
done
echo "SET( CMAKE_BUILD_TYPE \"\${CMAKE_BUILD_TYPE}\" CACHE STRING \"Choose the type of build, options are: Debug Release Profil Coverage semi_opt. \"    FORCE )" >> Cmake.env
echo "File Cmake.env created."

cd $TRUST_ROOT/bin

# Update/create instancie_xxx files - MAIN must be done last!!
echo $ECHO_OPTS "Updating instancie_xxx files..."
for ze_dir in `find $TRUST_ROOT/src -type d -not -wholename $TRUST_ROOT/src/MAIN -not -wholename $TRUST_ROOT/src`
do
   (cd $ze_dir; mk_Instancie) #&   # Go parallel crash on mezel
done
(cd $TRUST_ROOT/src/MAIN; mk_Instancie)
echo $ECHO_OPTS "done."

# Mise a jour du fichier $TRUST_ENV/Cmake.libs
./mklibs

# Cree le repertoire $TRUST_ROOT/include pour l'atelier
./cree_include

# Fichier include non existant, on cree un fichier vide
includes="
$TRUST_ROOT/lib/src/LIBAMGX/AmgXWrapper/include/AmgXSolver.hpp
$TRUST_ROOT/lib/src/LIBAMGX/AmgX/include/amgx_c.h
$TRUST_ROOT/lib/src/LIBROCALUTION/include/rocalution_for_kernel.h
$TRUST_ROOT/lib/src/LIBMETIS/include/metis.h
$TRUST_ROOT/lib/src/LIBMED/MED/include/med.h
$TRUST_ROOT/lib/src/LIBLATAFILTER/include/LataV1_field_definitions.h
$TRUST_ROOT/lib/src/LIBLATAFILTER/include/LmlReader.h
$TRUST_ROOT/lib/src/LIBLATAFILTER/include/LataFilter.h
$MPI_INCLUDE/mpi.h
$TRUST_ROOT/lib/src/LIBVC/include/Vc/Vc
$TRUST_ROOT/lib/src/LIBCGNS/include/cgns++.h
"
for petsc_option in _ _opt _opt_pg _opt_gcov _semi_opt _opt_avx _custom
do
   [ $petsc_option = "_" ] && petsc_option=""
   includes=$includes" "$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH$petsc_option/include/petsc_for_kernel.h" "$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH$petsc_option/include/metis.h" "$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH$petsc_option/include/ptscotch++.h" "$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH$petsc_option/include/parmetis++.h
done

for include in $includes
do
   dir_include=`dirname $include`
   [ ! -d $dir_include ] && mkdir -p $dir_include
   [ ! -f $include ] && echo > $include
done

# Pour MPI c'est un peu special
comm_incl=$TRUST_ROOT/src/Kernel/Utilitaires/comm_incl.h
# Si MPI_ROOT a change depuis le dernier configure
# on fait un touch du comm_incl.h si celui ci est modifiable
# ou on previent au moins...
if [ -f machine.env.old ] && [ "`diff machine.env machine.env.old | grep MPI_ROOT=`" != "" ]
then
   if [ "`ls -l $comm_incl | cut -c3`" = "w" ]
   then
      echo "MPI distribution has changed since last configure so $comm_incl.h is touched..."
      touch $comm_incl
   else
      echo "MPI distribution has changed since last configure so a make clean should be done."
   fi
fi
# Menage
rm -f $TRUST_ENV/.path

# Edit sources for 64 bit integers build - old method:
if [ "$TRUST_INT64" = "1" ] && [ "$TRUST_INT64_NEW" != "1" ]
then
    echo "We will edit sources to build 64 bits version, please wait..."
    (cd $TRUST_ROOT && ./bin/BUILD64/GO)
fi

exit 0
