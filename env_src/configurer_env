#!/bin/bash
# Script de recherche automatique de
# certaines variables d'environnement
# Strategie :
# Une liste de variable par defaut :
# On verifie qu'une d'entre elle existe par whence
# Puis eventuellement, on fait un find.... Dans le cas ou le compte
# est mal configure

Display_Missing_packages()
{
   echo ""
   echo "These packages are missing:"
   echo "---------------------------"
   cat $TRUST_ROOT/NON_INSTALLED
   [ "$multiple_choices" = 1 ] && echo "(*) Only one command is needed but none has been found."
   echo "Contact your system administrator to install it."
}


########################################################
make_()
{
   directory_package=$1
   cd $directory_package
   package_name=$2 && [ "$package_name" = "" ] && package_name=`basename $directory_package`
   package_log=$3 && [ "$package_log" = "" ] && package_log=`pwd`/`basename $directory_package`".log"
   echo $ECHO_OPTS "Trying to install $package_name...\c"
   # On lance la compilation
   make 1>$package_log 2>&1
   if [ $? = 0 ]
   then
      echo "OK"
   else
      echo "KO (See $package_log)"
      echo "You need $1 installed correctly. Contact TRUST support."
      echo "Error while installing $package_name. " >> $TRUST_ROOT/NON_INSTALLED
      echo "See $package_log" >> $TRUST_ROOT/NON_INSTALLED
      echo "You need $1 installed correctly." >> $TRUST_ROOT/NON_INSTALLED
      if [ "$package_name" = "Tcl/Tk" ] ; then
         echo "=> You may have to first install libX11-dev" >> $TRUST_ROOT/NON_INSTALLED
      elif [ "$package_name" = "mpich" ] && [ "$TRUST_DISABLE_CCACHE" != 1 ] ; then
         #echo "=> Adding the option -disable-ccache in the configure step may fix this problem." >> $TRUST_ROOT/NON_INSTALLED
         echo "=> Try using another MPI package, for instance -force_latest_mpich in the configure step, to fix this problem." >> $TRUST_ROOT/NON_INSTALLED
      fi
      echo "---" >> $TRUST_ROOT/NON_INSTALLED
   fi
   # On ecrit dans prog.log pour la desinstallation
   echo `pwd` | sed "s?$TRUST_ROOT/??" >> $TRUST_ROOT/env/prog.log
   cd - 1>/dev/null 2>&1
}

########################################################
run_test_mpi()
{
   test_mpi=$1
   rm -f $test_mpi.log
   # Pour aider on ajoute le LD_LIBRARY_PATH de MPI (ex: mars,eris)
   lib=`dirname $mpiCC`
   lib=$lib/../`\ls $lib/.. | grep lib`
   # On essaie d'executer en sequentiel
   LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$lib ./$test_mpi 1>$test_mpi.log 2>&1 &
   $TRUST_ROOT/bin/KSH/wait_for $! 30
   if [ ! -s $test_mpi.log ]
   then
      err=0
   elif [ "`grep coucou $test_mpi.log`" = "" ]
   then
      err=1
   fi
}
run_test_mpi_par()
{
   test_mpi=$1
   rm -f $test_mpi.log
   lib=`dirname $mpiCC`
   # On essaie d'executer en parallele
   $lib/mpirun -np 2 ./$test_mpi 2 1>$test_mpi.log 2>&1 &
   $TRUST_ROOT/bin/KSH/wait_for $! 30
   if [ ! -s $test_mpi.log ]
   then
      err=0
   #elif [ "`grep mpi-abort $test_mpi.log`" != "" ]
   elif [ "`grep coucou $test_mpi.log`" = "" ]
   then
      err=1
   fi
}

########################################################
configure_compilateur_ccache()
{
   if [ -d $TRUST_ROOT/exec/ccache ]
   then
      variable=`echo $e | awk -F= '{print $1}'`
      chemin=`echo $e | awk -F\" '{print $2}'`
      if [ "$chemin" = "" ]
      then
         eval $e
         if [ "$TRUST_CC_BASE" = "" ]
         then
            echo "Error! No C++11 compiler found. For a GNU compiler, you would need a version>=4.8.1" && exit -1
         fi
      fi
      compilateur=`basename $chemin`
      # On cree un script g++ et gcc
      eval $e
      script=$TRUST_ROOT/exec/ccache/$compilateur
      echo $ECHO_OPTS "#!/bin/bash\n\$TRUST_ROOT/exec/ccache/bin/ccache $chemin \"\$@\"" > $script
      chmod +x $script
      e=$variable=\""\$TRUST_ROOT/exec/ccache/$compilateur\" && export $variable"
   fi
}

########################################################
whence_()
{
   # Existe ?
   if [ -f $1 ]
   then
      echo $1
   elif [ `uname -s` = Darwin ]; then
       which "$1"
   else
      # Test de whence sinon whereis -b
      if [ "`uname -s`" = OSF1 ]
      then
	 err=1
      else
	 a=`whence ls 2>/dev/null`
	 err=$?
      fi
      if [ $err = 0 ]
      then
	 # Comportement etrange sur DEC de `whence $file` !
	 # Si `whence $file` = "" alors a=`whence $file` contient n'importe quoi !
	 #w=`whence $file`
	 # Solution : Passer par un fichier :
	 whence $1 > .toto
	 cat .toto
      else
	 # On essaie type car cherche aussi
	 # dans le PATH contrairement a whereis...
	 a=`type $1 2>/dev/null | awk '{print $NF}'`
	 if [ $? = 0 ] && [ -f $a ]
	 then
            echo $a
	 else
            whereis -b $1 | awk '{if (NF>1) print $2}'
	 fi
      fi
   fi
}

########################################################
update_file()
{
   # Usage: update_file file1 file2
   if [ "$1" = "" ] || [ ! -f $1 ]
   then
      echo "$1 not defined or not found!"
   else
      if [ ! -f $2 ]
      then
         # mv -f $1 $2
	 # cat et pas mv car mktemp ne suit pas le umask !
         cat $1 > $2
	 rm -f $1
	 echo "File $2 created."
      elif [ "`diff $1 $2 2>/dev/null`" != "" ]
      then
	 #mv -f $1 $2
	 # cat et pas mv car mktemp ne suit pas le umask !
         cat $1 > $2
	 rm -f $1
	 echo "File $2 updated. TRUST version built with $2 will be cleaned now or later and rebuilt."
	 # On efface de suite la version (pour les librairies si make.$TRUST_ARCH"_opt" ou make.$TRUST_ARCH"_semi_opt" modifie
	 if [ ${2%_opt} != $2 ]
	 then
	    echo "Cleaning now..."
	    (cd $TRUST_ROOT;make clean 1>/dev/null 2>&1 )
	 fi
      else
	 rm -f $1
      fi
   fi
}

########################################################
OK()
{
   if [ $1 = 0 ]
   then
      echo $ECHO_OPTS "OK!"
   else
      echo $ECHO_OPTS "KO!"
   fi
}

########################################################
cherche_file()
{
   word=$1
   liste=$*
   liste=${liste#$word}
   for file in $liste
   do
      fic=`whence_ $file`
      if [ ${#fic} != 0 ] && [ "`xxx $fic`" = 1 ]
      then
	 # Set TRUST_ROOT in the path if necessary:
	 [ $fic != ${fic#$TRUST_ROOT} ] && fic="\$TRUST_ROOT"${fic#$TRUST_ROOT}
	 # New 1.6.8: We do NOT take a path from other TRUST installation
	 if [ "`echo $fic | grep /TRUST/`" = "" ]
         then
	    echo "$word=\"$fic\" && export $word" && exit
	 fi
      fi
      for rep in `cat $TRUST_ROOT/env/.rep`
      do
	 fic=$rep/$file
	 if [ -f $fic ]
	 then
            # On detecte desormais les includes et les librairies aussi
            include=0 && [ $fic != ${fic%.h} ] && include=1
	    library=0 && [ $fic != ${fic%.a} ] && library=1;[ $fic != ${fic%.so} ] && library=1
            binary=0 && [ "`xxx $fic`" = 1 ] && binary=1
            if [ $include = 1 ] || [ $binary = 1 ] || [ $library = 1 ]
            then
	       # Eviter les chemins en dur dans le fichier machine.env
	       [ $fic != ${fic#$TRUST_ROOT} ] && fic="\$TRUST_ROOT"${fic#$TRUST_ROOT}
               echo "$word=\"$fic\" && export $word"
               [ "`grep $rep .path`" = "" ] && echo $ECHO_OPTS $rep >> .path
	       exit
            fi
	 fi
      done
   done
   echo "$word=\"\" && export $word"
}

########################################################
ecrit()
{
   chaine=$*
   m=`echo $chaine | cut -f1 -d"|"`
   e=`echo $chaine | cut -f2 -d"|"`
   env=`echo $chaine | cut -f3 -d"|"`
   echo $m" : "$e;echo $e"       "$m >> $env
}

########################################################
# Pour verifier que l'on a bien un executable :
xxx()
   {
   f=$1
   # Faux si lien absolu :
   #[ -L $f ] && f=`dirname $f`/`ls -la $f | awk '{print $NF}'`
   l=`ls -la $f`;ok=1
   # Bug decouvert: un compilo peut etre installe root et ne pas etre executable par root
   # Donc il faut x pour group et other
   # if [ "`echo $l | cut -c7`" != x ] || [ "`echo $l | cut -c10`" != x ]
   # on ne verifie plus other
   if [ "`echo $l | cut -c4`" = - ] || [ "`echo $l | cut -c7`" = - ] # || [ "`echo $l | cut -c10`" = - ]
   then
      ok=0
   else
   # Verifie en plus si les compilos marchent ou le browser marche :
      log=`basename $f`.log
      case $word in
	   TRUST_CC_BASE) if [ "`echo $f | grep /ccache/`" != "" ]
	   then
	      ok=0 # We don't take ccache/g++ version for the moment (eg:Fedora 18)
	   else
              # Ajout du test du support obligatoire de C++11 a partir de TRUST 1.7.9
	      echo $ECHO_OPTS "#include <iostream>\n#include <vector>\nint main() {std::vector<int> v = {0,1};for (auto i : v) std::cout << i << ' ';return 0;}" > main.cpp;$f -std=c++11 -o test_exec main.cpp 1>$log 2>&1;./test_exec 1>>$log 2>&1;[ $? != 0 ] && ok=0
	   fi;;
	   TRUST_cc_BASE) if [ "`echo $f | grep /ccache/`" != "" ]
	   then
	      ok=0 # We don't take ccache/gcc version for the moment (eg:Fedora 18)
	   else
	      echo "main() {return 0;}" > main.c;$f -o test_exec main.c 1>$log 2>&1;./test_exec 1>>$log 2>&1;[ $? != 0 ] && ok=0
	   fi;;
	   TRUST_F77_BASE) echo $ECHO_OPTS "      PROGRAM main\n      END\n      SUBROUTINE TOTO\n      RETURN\n      END" > $TRUST_ENV/main.f;$f -o test_exec_f $TRUST_ENV/main.f 1>$log 2>&1;./test_exec_f 1>>$log 2>&1;[ $? != 0 ] && ok=0;;
	   # GUI plus supporte: on ne teste plus le browser trouve.
	   #TRUST_WEBBROWSER) if [ "`echo $f | grep -i acrobat`" != "" ]
	   #then
	      # On passe le script netscape livre avec Acrobat
	      # car cela bloque la configuration (ex: PC verde...)
	      # Attention, il semble aussi que mozilla -v bloque
	      # aussi parfois (ex: PC verde...)
	      #ok=0
	   #else
	   #   rm -f $log
           #   $f -v 1>$log 2>&1 &
	   #   $TRUST_ROOT/bin/KSH/wait_for $! 2
	   #   [ $! != 0 ] && ok=0 		# Blocage
	   #   [ ! -s $log ] && ok=0	# Si le navigateur fonctionne, un log doit etre ecrit
	   #fi;;
	   # On cherche le MPI natif donc pas celui livre:
	   Mpirun) [ $f = $TRUST_ROOT/bin/mpirun ] && ok=0;;
	   mpiCC)  [ "`echo $f | grep lib/src/LIBMPI`" != "" ] && ok=0; # Elimination d'une version MPI livree avec TRUST
		   # Elimination de LAM qui n est pas supporte par TRUST et en voie d obsolescence:
		   [ "`echo $f | grep LAM6`" != "" ] && ok=0;
		   [ -f /usr/bin/mpirun ] && [ "`/usr/bin/mpirun -v 2>&1 | grep LAM/MPI`" != "" ] && ok=0;
		   # Elimination de mpiCC sur RedHat Enterprise qui compile en 32 bits (-m32) sur des machines 64 bits
		   [ "`$f --show 2>/dev/null | grep m32`" != "" ] && ok=0;
		   # Elimination de mpicxx sur tantale
		   [ "`basename $f`" = mpicxx ] && [ -f /opt/hpmpi/bin/mpiCC ] && ok=0;
		   # Elimination si mpif77 n'est pas trouve au meme endroit (ex: buda)
		   [ ! -f "`dirname $f`"/mpif77 ] && [ ! -f "`dirname $f`"/mpxlf_r ] && ok=0;
		   # Elimination du OpenMPI 1.3.3 trouve (blocages vus sur is212958)
		   [ -f /usr/bin/mpirun ] && [ "`/usr/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.3.3'`" != "" ] && ok=0;
		   # Elimination du OpenMPI 1.7.2 trouve (blocages cas test PETSc)
		   [ -f /usr/lib64/openmpi/bin/mpirun ] && [ "`/usr/lib64/openmpi/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.7.2'`" != "" ] && ok=0;
		   ;;
	   *);;
      esac
   fi
   # Detruit car sinon pb de droit pour les autres users
   rm -f main.c test_exec
   echo $ok
}

########################################################
cherche_include_systeme()
{
   # Nouveau: recherche des repertoires includes systemes pour la commande makedepend -I....
   # PL: 1.5.7 ftsream.h->fstream, iostream.h->iostream, new.h supprime
   echo $ECHO_OPTS "#include<fstream>\n#include<iostream>\n#include<stdarg.h>\n#include<stddef.h>\n#include<strstream>" > es.cxx
   includes=`$TRUST_CC -M es.cxx | grep -v es.cxx | awk '{print $1}'`
   Y=/usr/include/sys
   # -Y ne marche que pour 1 repertoire (et on prend astucieusement /usr/include/sys pour eviter des nested includes)
   SYSINC_DEP="-Y$Y "`for include in $includes
   do
      dir=\`dirname $include\`
      cd $dir # Astuce pour ne pas avoir de chemins trops longs en ../../..
      dir=\`pwd\` && [ "$dir" != $Y ] && echo $dir
   done | sed "s/\/bits//g" | sort -u | awk '{printf("-I%s ",$1)}'`
   rm -f es.cxx
}

########################################################
check_nvidia_cuda()
{
   # Ne marche pas car donne la carte de l'ecran depuis lequel l'installation est lancee:
   #nvidia_card=`nvidia-settings -g 2>&1 | awk -F: '/renderer string/ {print $2}'`
   #[ "$nvidia_card" != "" ] && echo "NVIDIA card found:"$nvidia_card
   #########################
   # To active CUDA support:
   #########################
   # Fedora: See https://forums.developer.nvidia.com/t/cuda-10-installation-on-fedora-30-with-gcc-9-1-1-20190503/74989/7
   # -Drivers NVidia installed
   # -Cuda Compilateur nvcc found or installed
   # SDK     : CUDA_ROOT=/opt/nvidia/hpc_sdk	$CUDA_ROOT/include
   [ "$NVIDIA_VERSION" != "" ] && echo "NVIDIA drivers detected on $HOSTNAME: Version $NVIDIA_VERSION"
   ################
   # Detection nvcc
   ################
   m="# Path to CUDA compiler";e="`cherche_file CUDA_NVCC nvcc`";ecrit $m"|"$e"|"$env;eval $e
   if [ "`$CUDA_NVCC --version 2>/dev/null`" = "" ]
   then
      echo "Error, no nvcc cuda compiler found."
      echo "On Fedora, for instance you will install CUDA runtime with:"
      echo "dnf config-manager --add-repo=https://negativo17.org/repos/fedora-nvidia.repo"
      echo "sudo dnf install nvidia-driver nvidia-driver-cuda cuda cuda-devel akmod-nvidia nvidia-settings cuda-gcc cuda-gcc-c++ cuda-gcc-gfortran cuda-samples"
      echo "See more there: https://forums.developer.nvidia.com/t/cuda-10-installation-on-fedora-30-with-gcc-9-1-1-20190503/74989/7"
      exit -1
   fi
   #########################
   # Detection CUDA run time
   #########################
   # On se base sur nvcc pour trouver les librairies
   # CUDA Toolkit:		NVIDIA HPC SDK:
   # ROOT/bin/nvcc		ROOT/compilers/bin/nvcc
   # ROOT/lib64 		ROOT/cuda/lib64
   ROOT=${CUDA_NVCC%/bin/nvcc}
   ROOT=${ROOT%/compilers}
   CUDA_LIB=`ls $ROOT/lib64/libcudart.so.*.* $ROOT/cuda/lib64/libcudart.so.*.* 2>/dev/null | head -1`
   [ "$CUDA_LIB" = "" ] && echo "Cuda lib libcudart.so not found!" && exit -1
   CUDA_LIB=`dirname $CUDA_LIB 2>/dev/null`
   echo "Cuda libraries CUDA_LIB=$CUDA_LIB"
   CUDA_ROOT=`dirname $CUDA_LIB 2>/dev/null`
   for CUDA_INC_PATH in $CUDA_ROOT/include $CUDA_ROOT/include/cuda
   do
      [ -f $CUDA_INC_PATH/cuda.h ] && export CUDA_INC_PATH && break
   done
}

########################################################
print_OS()
{
   for file in /etc/system-release /etc/release /etc/issue.net /etc/issue
   do
      if [ -f $file ]
      then
         echo "# OS for the machine : `head -1 $file`"
	 break
         # En 2 fois pour supprimer les \n \l qui empechent une comparaison correcte
         #chaine=`head -1 /etc/issue`
         #echo "# OS for the machine : `echo $ECHO_OPTS $chaine | head -1`"
      fi
   done
}

########################################################
print_GNU_VERSION()
{
   # Verifie que le compilateur est bien GNU:
   [ "${TRUST_CC_BASE%g++}" != "$TRUST_CC_BASE" ] && $TRUST_CC_BASE -v 2>&1 | awk '/gcc / && /version / {i=1;while(split($(i),a,".")==1) i++;print $(i)}'
}

########################################################
print_CLANG_VERSION()
{
   # Renvoi la version CLANG si utilise pour configurer TRUST: Pour aocc, clang++ -v renvoi AOCCxxx clang version x.y.z donc je retire AOCCxxx du resultat
   [ "${TRUST_CC_BASE%clang++}" != "$TRUST_CC_BASE" ] && $TRUST_CC_BASE -v 2>&1 | grep -o "clang.*" | awk '/clang / && /version / {i=1;while(split($(i),a,".")==1) i++;print $(i)}'
}
########################################################
clean_previous_install()
{
   cd $TRUST_ROOT
   echo "TRUST_ROOT changed since previous install... cleaning TRUST installation"
   rm -rf exec/python MonoDir* Outils/ICoCo/ICoCo_src/configure
   for f in `find ThirdPart Outils -type f -name "?akefile"` ; do
      touch $f
   done
   cd -
}
#
#########################################################################################################################################################################
#########################################################################################################################################################################
#
###################
# Debut du script #
###################
if [ "$1" = -check ]
then
   # On verifie que le machine.env est correct
   if [ -f $TRUST_ROOT/env/machine.env ]
   then
      err=""
      OS_changed=0
      [ "$TRUST_DISABLE_CHECK_OS" = "1" ] && echo "Warning: You are loading TRUST environment with TRUST_DISABLE_CHECK_OS, contact TRUST support team at $TRUST_MAIL"
      # Check if the OS has changed:
      OS=`print_OS`
      if [ "$OS" != "" ] && [ "`grep 'OS for the machine' $TRUST_ROOT/env/machine.env`" != "" ] && [ "`grep "$OS" $TRUST_ROOT/env/machine.env`" = "" ] && [ "$TRUST_DISABLE_CHECK_OS" != "1" ]
      then
         err="The OS of your machine has changed"
	 OS_changed=1
      else
	 GNU_VERSION=`print_GNU_VERSION`
	 if [ "$GNU_VERSION" != "" ]
	 then
	    GNU_VERSION_ENV=`awk '/TRUST_VERSION_GNU/ {print $1}' $TRUST_ROOT/env/machine.env | awk -F= '{print $2}'`
            # Check if the machine.env file is corrupted:
	    if [ "$GNU_VERSION_ENV" = "" ]
	    then
	       err="The configure has failed (machine.env is incomplete)."
	    # Check if the GNU compiler has changed:
	    elif [ "$GNU_VERSION" != "$GNU_VERSION_ENV" ]
	    then
	       err="The compiler of your machine has changed ($GNU_VERSION_ENV -> $GNU_VERSION) since the TRUST installation."
	    fi
	 fi
      fi
      if [ "$err" != "" ]
      then
         echo "**********************************************************************"
	 echo "$err"
	 echo "The TRUST installation (or configure) MUST be done again"
	 echo "cause it is now broken because of the previous change."
	 if [ $OS_changed = 1 ]
	 then
	    echo ""
	    echo "Tip: you can load TRUST environment by:"
	    echo "   export TRUST_DISABLE_CHECK_OS=1"
	    echo "   source $TRUST_ROOT/env_TRUST.sh"
	    echo "Contact TRUST support team at: $TRUST_MAIL"
	 fi
	 echo "**********************************************************************"
	 exit -1
      fi
      exit 0
   else
      echo "machine.env file not found. Please run: ./configure under $TRUST_ROOT"
      exit -1
   fi
fi

if [ "$1" = -TRUST_NB_PROCS ]
then
   TRUST_NB_PROCS=1
   if [ -f /proc/cpuinfo ]
   then
      TRUST_NB_PROCS=`$TRUST_Awk '/processor/ {n++} END {print n}' /proc/cpuinfo`
      # Limitations sur la frontale des clusters:
      if [ -d /ccc ] || [ $HOST = callisto ] || [ $HOST = jean-zay ] || [ ${HOST#orcus-} != $HOST ]
      then
        TRUST_NB_PROCS=8
      elif [ "${HOST#summer}" != $HOST ]
      then
        TRUST_NB_PROCS=1
      fi
   elif [ `uname -s` = "Darwin" ]; then
     TRUST_NB_PROCS=$(sysctl -n hw.perflevel0.logicalcpu)
   fi
   echo $TRUST_NB_PROCS
   exit 0
fi

# Nettoyage des programmes installes par le configure
if [ "$1" = clean ]
then
   if [ -f prog.log ]
   then
      for prog in `cat prog.log`
      do
         cd ../$prog
         make clean
         cd -
      done
   fi
   cd $TRUST_ROOT
   rm -r -f $TRUST_ROOT/env_TRUST.sh $TRUST_ROOT/env/ $TRUST_ROOT/lib $TRUST_ROOT/exec $TRUST_ROOT/include $TRUST_ROOT/Makefile $TRUST_ROOT/MonoDir* $TRUST_ROOT/build
   rm -f $TRUST_ROOT/configure.log
   rm -f  $TRUST_ROOT/tags $TRUST_ROOT/TAGS  $TRUST_ROOT/compile*log $TRUST_ROOT/License.txt_*
   rm -f $TRUST_ROOT/.toto
   # Plus on efface le $TRUST_TMP
   rm -r -f $TRUST_TMP
   rm -r -f $TRUST_ROOT/Outils/Salome/SALOME-*
   exit 0
else
   rm -f prog.log
fi

###########################
# Definition de TRUST_ROOT
###########################
export TRUST_ROOT=`pwd`
TRUST_ROOT=${TRUST_ROOT%/env}
echo TRUST_ROOT=$TRUST_ROOT
export TRUST_ENV=$TRUST_ROOT/env
# Pour des commandes comme mktemp_
export PATH=$TRUST_ROOT/bin/KSH:$PATH
# liste="pwd whoami uname find cut"
# for com in $liste
# do
#    if [ "`whence_ $com`" = "" ]; then
#       echo "$com command not accessible: host misconfigured."
#       exit
#    fi
# done

rm -f $TRUST_ENV/.path
touch $TRUST_ENV/.path
# Probleme du echo /usr/ucb/echo "\c" -> /usr/bin/echo "\c" OK
# Probleme du grep ?
rep=/usr/bin
[ -d $rep ] && [ -d /usr/ucb ] && PATH=$rep:$PATH && export PATH

##################################
# Cherche la liste des repertoires
##################################
echo "/" > $TRUST_ROOT/env/.rep
echo "Looking for system directories..."
#liste="/bin /etc /lib /opt /product /sbin /usr /var"
# Rajout /usr/lpp pour IBM Orleans (14/10/03)
# On supprime /usr/local et /usr/lpp trop longs sur IBM Orleans
liste=$TRUST_FORCE_SEARCH" /bin /sbin /usr/bin /usr/ibmcxx /usr/sbin /usr/dt /usr/bsd /usr/etc /usr/X11R6 /usr/freeware /usr/ccs /usr/lib /usr/lib32 /usr/lib64"
for rep in $liste
do
   # Essai avec -follow ?
   # Certaines machines ne connaissent pas follow
   # Rajout du -print necessaire pour Fujitsu
   # F="" && find . -follow -print 1>/dev/null 2>/dev/null && F="-follow"
   # Essayer sans follow pour accelerer...
   F=""
   [ -d $rep ] && echo $rep && find $rep $F -type d -print 2>/dev/null | grep -v ".snapshot" 1>>$TRUST_ROOT/env/.rep
done

######################
# Fichier machine.env:
######################
env=$TRUST_ROOT/env/machine.env
[ -f $env ] && cp -f $env $env".old"
echo "# Environment file created during the install" > $env
echo "# uname -a : `uname -a`" | tee -a $env
print_OS | tee -a $env
echo "# hostname : `hostname`" | tee -a $env
echo "# domainname : `domainname 2>/dev/null`" | tee -a $env

#################
# Variable HOST #
#################
. ./HOST.env
# Variables define_modules_config
if [ "$TRUST_WITHOUT_HOST" = 0 ]
then
   . ./HOST_$HOST_BUILD.sh
else
   . ./HOST_default.sh
fi

#####################
# Modules ou config #
#####################
TRUST_VERSION=`awk '/version/ && /Release notes/ {print $4;exit}' $TRUST_ROOT/RELEASE_NOTES`
ligne_supp=""
# See HOST_???.sh file called above
define_modules_config

#######################
# Variable TRUST_TMP #
#######################
. ./TRUST_TMP.env

###################################
# Si configure a cree des variables
###################################
if [ -f configure.env ]
then
   echo "TRUST_WITHOUT_HOST=$TRUST_WITHOUT_HOST && export TRUST_WITHOUT_HOST	# Disable/enable reading of HOST file"	>> configure.env
   [ "$TRUST_WITHOUT_HOST" = 0 ] && TRUST_DISABLE_JUPYTER=1
   # TRUST_DISABLE_CHECK_SRC=1 sur clusters (machine de production parfois lente a compiler):
   [ "$TRUST_WITHOUT_HOST" = 0 ] && TRUST_DISABLE_CHECK_SRC=1
   echo "TRUST_DISABLE_CHECK_SRC=$TRUST_DISABLE_CHECK_SRC && export TRUST_DISABLE_CHECK_SRC # No check sources before compiling `[ "$TRUST_WITHOUT_HOST" = 0 ] && echo since TRUST_WITHOUT_HOST=0`" >> configure.env
   echo "TRUST_DISABLE_JUPYTER=$TRUST_DISABLE_JUPYTER && export TRUST_DISABLE_JUPYTER  # disable jupyter build`[ "$TRUST_WITHOUT_HOST" = 0 ] && echo since TRUST_WITHOUT_HOST=0`." >> configure.env
   . ./configure.env
fi

#######################
# Quelle architecture ?
#######################
arch=`uname -s`
case $arch in
   Linux) TRUST_ARCH=linux
	TRUST_EDITOR="gedit nedit kate kedit xemacs xedit emacs"
	# On met Intel en 1er/GNU car plus rapide que GNU
	cuda="" && [ "$TRUST_USE_CUDA" = 1 ] && cuda="cuda-" # Uniquement si on demande Cuda, recherche en priorite des wrappers pour les compilateurs GNU
	# Pas prudent de mettre les compilateurs NVidia en premier... Sauf si -openmp ou -openacc ?
        #TRUST_CC_BASE=" nvc++     FCC icpc  armclang++ "$cuda"g++      g++"
	#TRUST_F77_BASE="nvfortran frt ifort armflang   "$cuda"gfortran gfortran"
	#TRUST_cc_BASE=" nvc       fc  icc   armclang   "$cuda"gcc      gcc"
	TRUST_CC_BASE=" crayCC  FCC icpc  armclang++ "$cuda"g++      g++"
	TRUST_F77_BASE="crayftn frt ifort armflang   "$cuda"gfortran gfortran"
	TRUST_cc_BASE=" craycc  fc  icc   armclang   "$cuda"gcc      gcc"
	# On rajoute les autres compilateurs
	TRUST_CC_BASE=$TRUST_CC_BASE" pgCC"
	TRUST_F77_BASE=$TRUST_F77_BASE" pgf90 f90 pgf77 f77"
	TRUST_cc_BASE=$TRUST_cc_BASE" pgcc cc"
	Dtterm="xterm dtterm nxterm rxvt konsole"
	IP=`$TRUST_ROOT/bin/admin/ping_ $HOSTNAME | awk '/PING/ {print $3}'`
	;;
   CYGWIN*) TRUST_ARCH=cygwin
	TRUST_EDITOR="nedit kedit xemacs xedit emacs"
	TRUST_CC_BASE="g++ icpc icc ecc"
	TRUST_F77_BASE="gfortran ifort ifc efc"
	TRUST_cc_BASE="gcc icc ecc"
	# On rajoute les autres compilateurs
	TRUST_CC_BASE=$TRUST_CC_BASE" pgCC"
	TRUST_F77_BASE=$TRUST_F77_BASE" pgf90 f90 pgf77 f77"
	TRUST_cc_BASE=$TRUST_cc_BASE" pgcc cc"
	Dtterm="xterm dtterm nxterm rxvt konsole"
	IP=`$TRUST_ROOT/bin/admin/ping_ $HOSTNAME | awk '/PING/ {print $3}'`
	;;
   Darwin) TRUST_ARCH=darwin
	TRUST_EDITOR="nano"
	# par defaut, clang/clang++ (fourni par MacOS) / gfortran (a installer par l'utilisateur)
	TRUST_CC_BASE=$TRUST_CC_BASE" clang++"
	TRUST_F77_BASE=$TRUST_F77_BASE" gfortran"
	TRUST_cc_BASE=$TRUST_cc_BASE" clang"
	Dtterm="xterm"
	IP=`$TRUST_ROOT/bin/admin/ping_ $HOSTNAME | awk '/PING/ {print $3}'`
	;;
   *) TRUST_ARCH=autre
	TRUST_EDITOR="nedit xedit dtpad xemacs"
	TRUST_CC_BASE="g++ CC"
	TRUST_F77_BASE="g77 f77 fort77"
	TRUST_cc_BASE="gcc cc"
	Dtterm="dtterm xterm"
	;;
esac
# Si on ne trouve pas f77, on essaie avec g77 et f90 (TRUST a deja marche sur HP avec f90)
TRUST_F77_BASE=$TRUST_F77_BASE" g77 f90"
# On ajoute en priorite le compilateur donne par option
TRUST_CC_BASE=$TRUST_FORCE_CC" "$TRUST_CC_BASE
TRUST_cc_BASE=$TRUST_FORCE_cc" "$TRUST_cc_BASE
TRUST_F77_BASE=$TRUST_FORCE_F77" "$TRUST_F77_BASE
echo "# IP machine: $IP" | tee -a $env
m="# Simplified machine name ";e="HOST=$HOST && export HOST";ecrit $m"|"$e"|"$env
m="# Building machine name ";e="HOST_BUILD=$HOST_BUILD && export HOST_BUILD";ecrit $m"|"$e"|"$env
##############################################
shell=`basename $SHELL` && echo "# The login shell is : $shell"
m="# Machine architecture";e="TRUST_ARCH=$TRUST_ARCH && export TRUST_ARCH";ecrit $m"|"$e"|"$env;eval $e
ECHO_OPTS="" && [ "`echo -e`" != "-e" ] && ECHO_OPTS="-e" && export ECHO_OPTS
m="# Echo option";e="ECHO_OPTS=\"$ECHO_OPTS\" && export ECHO_OPTS";ecrit $m"|"$e"|"$env
m="# Login of the TRUST install";e="TRUST_LOGIN=`whoami` && export TRUST_LOGIN";ecrit $m"|"$e"|"$env
# Verification de l'existence de certaines variables :
m="# Path to awk command";e="`cherche_file TRUST_Awk gawk awk nawk oawk mawk`";ecrit $m"|"$e"|"$env;eval $e
m="# Path to an text editor";e="`cherche_file TRUST_EDITOR $TRUST_EDITOR`";ecrit $m"|"$e"|"$env

# Nouveau 2010, on regarde le nombre de processeurs disponibles des machines Linux:
TRUST_NB_PROCS=`./configurer_env -TRUST_NB_PROCS`
# Variable TRUST_MAKE for the parallel builds:
TRUST_MAKE="make -j $TRUST_NB_PROCS"
if [ -f /proc/cpuinfo ]
then
   # Nombre de processeurs physiques:
   procs=`grep "physical id" /proc/cpuinfo | sort -u | wc -l` && [ "$procs" = 0 ] && procs=1
   cores_per_proc=`grep "core id" /proc/cpuinfo | sort -u | wc -l` && [ "$cores_per_proc" = 0 ] && cores_per_proc=1
   total_cores=`echo $procs $cores_per_proc | awk '{print $1*$2}'`
   echo "# Detected $procs processors of $cores_per_proc cores means a total of $total_cores physical cores." | tee -a $env
   CACHE_SIZE=`awk '/cache size/ {print $(NF-1)}' /proc/cpuinfo | sort -u`
   echo "# Detected a size cache of $CACHE_SIZE KB." | tee -a $env
   m="# Number of physical cores";e="TRUST_NB_PHYSICAL_CORES=$total_cores && export TRUST_NB_PHYSICAL_CORES";ecrit $m"|"$e"|"$env;eval $e
fi
m="# Number of logical cores used for build";e="TRUST_NB_PROCS=$TRUST_NB_PROCS && export TRUST_NB_PROCS";ecrit $m"|"$e"|"$env;eval $e
m="# Path to make command used";e="TRUST_MAKE=\"$TRUST_MAKE\" && export TRUST_MAKE";ecrit $m"|"$e"|"$env;eval $e

###############################################################################################################
# Contournement d'un probleme rencontre sur Fedora 18 ou ccache/gcc trouve en premier au lieu de /usr/bin/gcc #
# Le CCACHE_DIR pointait vers un repertoire inexistant suite a un configure clean et le ccache/gcc plantait...#
###############################################################################################################
unset CCACHE_DIR
unset CCACHE_PREFIX
export CCACHE_DISABLE=1 # pas de ccache lors de la configuration

###############################################################################################################
# Contournement d'un pb rencontre lors du deplacement/renommage d'une installation TRUST. touch des makefile  #
# plus efficace que make clean : si MPI installee lors du configure, make clean de TRUST ne la nettoie pas    #
###############################################################################################################
conda="$TRUST_ROOT/exec/python/bin/conda"
[ -f $conda ] && [ "`grep $TRUST_ROOT/exec/python $conda`" = "" ] && clean_previous_install

########################################################################################
# Installation de ccache pour instaurer un cache du preprocessing lors de la compilation
########################################################################################
INSTALL_CCACHE=0
[ "$TRUST_DISABLE_CCACHE" != "1" ] && [ $TRUST_ARCH = linux ] && INSTALL_CCACHE=1
if [ $INSTALL_CCACHE =  1 ]
then
   make_ $TRUST_ROOT/env/ccache ccache $TRUST_ROOT/exec/ccache.log
fi
rm -f $TRUST_ROOT/exec/ccache/g??

#########################################################################
# On utilise python de conda pour PETSc, Run_fiche, MED, MEDCOUPLING, IHM
#########################################################################
unset PYTHONPATH # We get a warning from Miniconda if we do not unset this variable

# check the previous install of conda and conda packages if it exists
model=`uname -m`
system=`uname -s` && [ "$system" = Darwin ] && system=MacOSX
pkgs="pyqt nomkl numpy matplotlib swig cmake=3.18 scipy xorg-libsm=1.2.3 sympy libgd pandas libstdcxx-ng=9.3.0 bison `[ "$TRUST_DISABLE_JUPYTER" != 1 ] && echo jupyter pandoc psutil`"
local_channel="-c file://$TRUST_ROOT/externalpackages/Miniconda/local_channel --override-channels"
[ "$model" = aarch64 ] && local_channel="" && pkgs="nomkl numpy matplotlib swig cmake=3.18 scipy xorg-libsm=1.2.3 sympy libgd pandas bison libstdcxx-ng=9.3.0 `[ "$TRUST_DISABLE_JUPYTER" != 1 ] && echo jupyter pandoc psutil`" && [ -d /ccc ] && pkgs="" # Pas internet au CCRT
[ "$model" = arm64 ] && local_channel="" && pkgs="nomkl numpy matplotlib swig cmake scipy sympy libgd pandas bison `[ "$TRUST_DISABLE_JUPYTER" != 1 ] && echo jupyter pandoc psutil`" # internet OK sous Mac

if [ -d $TRUST_ROOT/exec/python/bin ] && [ -f $TRUST_ROOT/exec/python/bin/conda ]
then
   # check of python version
   PYTHON_VERSION_OK=`$TRUST_ROOT/exec/python/bin/python --version 2>&1 | awk '/Python/ {split($2,a,".");v=a[1]*100+a[2]*10+a[3];print (v==379||v==376?1:0)}'`
   PYTHON_TEST_OK=1 && [ "`$TRUST_ROOT/exec/python/bin/python ./test.py 1>/dev/null 2>&1;echo $?`" != 0 ] && PYTHON_TEST_OK=0
   INSTALL_OK=1
   # list of packages already-installed/to-install in conda, we ignore mpi4py since installed with pip
   $TRUST_ROOT/exec/python/bin/conda list | grep -v mpi4py > conda_list.check
   if [ "$system" = "Linux" ] && [ $model = "x86_64" ] #&& [ -f $TRUST_ROOT/exec/conda_list.ref ]
   then
      # Strict check of conda packages
      if [ "$TRUST_DISABLE_JUPYTER" != 1 ]
      then
         cat $TRUST_ROOT/externalpackages/Miniconda/conda_list_ref | sed "s?TRUSTR?$TRUST_ROOT?g" | cut -f1 -d',' > conda_list.ref
      else
         cat $TRUST_ROOT/externalpackages/Miniconda/conda_list_ref | sed "s?TRUSTR?$TRUST_ROOT?g" | grep -v jupyter > conda_list.ref
      fi

      if [ `diff conda_list.ref conda_list.check 1>/dev/null 2>&1; echo $?` != 0 ]
      then
         echo "# The current miniconda install contains some supplementary or missing packages, we clean it..."
         INSTALL_OK=0
      else
         rm -f conda_list.ref
      fi
   else
      for pkg in $pkgs
      do
        pkg=`echo $pkg | awk -F= '{print $1}'` # Pour ne pas avoir le numero de version
        [ "`grep $pkg conda_list.check`" = "" ] && INSTALL_OK=0
      done
   fi
   rm -f conda_list.check
   if [ "$PYTHON_VERSION_OK" != 1 ] || [ "$PYTHON_TEST_OK" != 1 ] || [ "$INSTALL_OK" != 1 ]
   then
      INSTALL_CONDA=1
   else
      echo "# The current install of python, python packages, swig and cmake from miniconda seems OK... we skip it"
   fi
else
   INSTALL_CONDA=1
fi

if [ "$INSTALL_CONDA" = 1 ]
then
    # If a previous installation folder exists, we remove it.
    [ -d $TRUST_ROOT/exec/python ] && rm -rf $TRUST_ROOT/exec/python

    # Then we install miniconda and the different packages
    conda_installer=`cd $TRUST_ROOT/externalpackages/Miniconda;ls Mini*3*-$system"-"$model.sh`
    echo "Trying to install $conda_installer"
    # PL: Change le TMPDIR car par defaut sur /tmp et pb si mis a noexec
    TMPDIR=$TRUST_TMP $TRUST_ROOT/externalpackages/Miniconda/./$conda_installer -p $TRUST_ROOT/exec/python/ -b 1>$TRUST_ROOT/exec/conda_python.log 2>&1
    [ $? != 0 ] && echo "Error while installing $conda_installer. See $TRUST_ROOT/exec/conda_python.log" >> $TRUST_ROOT/NON_INSTALLED && exit -1

    # Installing packages from local channel
    cd $TRUST_ROOT/exec/python/bin
    for pkg in $pkgs
    do
      echo "Installing $pkg ... "
      ./conda install $local_channel $pkg -y 1>>$TRUST_ROOT/exec/conda_python.log 2>&1
      [ $? != 0 ] && echo "Error while installing '$pkg' from Miniconda3 local_channel. see $TRUST_ROOT/exec/conda_python.log" >> $TRUST_ROOT/NON_INSTALLED
    done
	[ `uname -s` = Darwin ] && ln -s python3-config python-config #on MacOS, we need python-config to point to the Conda install
    cd - 1>/dev/null 2>&1
    # If a package has not been correctly installed, we exit with an error
    [ -f $TRUST_ROOT/NON_INSTALLED ] && [ "`grep Miniconda $TRUST_ROOT/NON_INSTALLED`" != "" ] &&  Display_Missing_packages && exit -1
fi
# clean of the install folder
rm -r $TRUST_ROOT/exec/python/pkgs
mkdir $TRUST_ROOT/exec/python/pkgs
# We touch all conda files, otherwise it will be deleted from SCRATCH of clusters (e.g. jean-zay)
[ "${TRUST_ROOT#*scratch}" != "$TRUST_ROOT" ] && find $TRUST_ROOT/exec/python -exec touch {} +
# export PATH
PYTHON_ROOT=$TRUST_ROOT/exec/python/bin
echo "export PYTHONLIBS_ROOT_DIR=\$TRUST_ROOT/exec/python" >> $env
echo "export PYTHONINTERP_ROOT_DIR=\$PYTHONLIBS_ROOT_DIR/bin" >> $env
echo "ADD_PATH \$PYTHONLIBS_ROOT_DIR/bin" >> $env
echo "unset PYTHONPATH" >> $env # Pour la CentOS6.5, PYTHONPATH contient le chemin vers python2.6

# Gestion d'une librairie systeme plus recente que miniconda (ex: libtinfo.so.6.0.29 sur Ubuntu 20 et Debian 10), on vire:
tinfo_conda=`cd $TRUST_ROOT/exec/python/lib;ls libtinfo.so.6.* 2>/dev/null | cut -d'.' -f3-5`
if [ "$tinfo_conda" != "" ]
then
    libtinfo_sys=`ls /usr/lib*/libtinfo.so.6.* /usr/lib*/*64-linux-gnu/libtinfo.so.6.* 2>/dev/null | head -1`
    tinfo_sys=`echo $libtinfo_sys | $TRUST_Awk -F/ '{print $NF}' | cut -d'.' -f3-5`
    remove_libtinfo_conda=0 && [ "$tinfo_sys" != "" ] && remove_libtinfo_conda=`echo $tinfo_sys $tinfo_conda | awk '{ print ($1>=$2?1:0) }'`
    if [ $remove_libtinfo_conda -eq 1 ]
    then
       echo "We remove libtinfo and libncursesw from conda and create symlinks from system libs"
       rm -r $TRUST_ROOT/exec/python/lib/libtinfo.so* $TRUST_ROOT/exec/python/lib/libncursesw.so*
       dirlibtinfo=`dirname $libtinfo_sys`
       for file in `ls $dirlibtinfo/libtinfo.so* $dirlibtinfo/libncursesw.so* 2>/dev/null`
       do
          echo "Creating a link: ln -s -f `dirname $libtinfo_sys`/`basename $file` $TRUST_ROOT/exec/python/lib/`basename $file`"
          ln -s -f `dirname $libtinfo_sys`/`basename $file` $TRUST_ROOT/exec/python/lib/`basename $file`
       done
    fi
fi

# Adding utility package 'trustutils' in PYTHONPATH
echo "export PYTHONPATH=\$TRUST_ROOT/Outils/TRUST_STATS_JUPYTER:\$PYTHONPATH" >> $env

# Disable autosave in jupyter
jupyter_config_js=$TRUST_ROOT/exec/python/lib/python3.7/site-packages/notebook/static/custom/custom.js
if [ "$TRUST_DISABLE_JUPYTER" != 1 ] && [ -f $jupyter_config_js ] && [ "`grep 'Jupyter.notebook.set_autosave_interval(0)' $jupyter_config_js 2>/dev/null`" = "" ]
then
   echo "Disabling autosave in jupyter-notebook"
   echo "Jupyter.notebook.set_autosave_interval(0); // disable autosave" >> $jupyter_config_js
fi

# Install pre_save hook for Jupyter notebook
jupyter_nb_exe=$TRUST_ROOT/exec/python/bin/jupyter-notebook
if [ "$TRUST_DISABLE_JUPYTER" != 1 ] && [ "`grep 'sys.argv.append' $jupyter_nb_exe 2>/dev/null`" = "" ]
then
   echo "Installing pre_save hook in jupyter-notebook"
   s="
    import os
    tr=os.environ['TRUST_ROOT']
    s=os.path.join(tr, 'env_src', 'jupyter_notebook_config.py')
    sys.argv.append('--config')
    sys.argv.append(s)

    sys.exit(main())
"
   $TRUST_Awk -v r="$s" '{gsub(/sys.exit\(main\(\)\)/,r)}1' $jupyter_nb_exe > jupyter-notebook_tmp
   cat jupyter-notebook_tmp > $jupyter_nb_exe
   rm -f jupyter-notebook_tmp
fi

# Increase number of attemp when connecting to Jupyter Kernel (to avoid exception: "zmq.error.ZMQError: Address already in use"
jy_kernel_app=$TRUST_ROOT/exec/python/lib/python3.7/site-packages/ipykernel/kernelapp.py
if [ "$TRUST_DISABLE_JUPYTER" != 1 ] && [ -f $jy_kernel_app ]
then
    sed -i "s@max_attempts = 1 if port else 100@max_attempts = 100 if port else 100@" $jy_kernel_app
fi

####################
# Compilateurs C/C++
####################
m="# Path to C++ compiler";e="`cherche_file TRUST_CC_BASE $TRUST_CC_BASE`";configure_compilateur_ccache;ecrit $m"|"$e"|"$env;eval $e
m="# Path to C compiler";e="`cherche_file TRUST_cc_BASE $TRUST_cc_BASE`";configure_compilateur_ccache;ecrit $m"|"$e"|"$env;eval $e
TRUST_ARCH_CC="$TRUST_ARCH"_`echo $TRUST_CC_BASE | awk -F/ '{print $NF}'`
m="# Machine-compiler architecture";e="TRUST_ARCH_CC=$TRUST_ARCH_CC && export TRUST_ARCH_CC";ecrit $m"|"$e"|"$env
m="# Path to Fortran compiler";e="`cherche_file TRUST_F77_BASE $TRUST_F77_BASE`";ecrit $m"|"$e"|"$env;eval $e
TRUST_VERSION_GNU=`print_GNU_VERSION`
####################################################
# Verification que les compilateurs ont ete trouves.
####################################################
compiler_found=1
# csh plus necessaire pour VisIt
#[ ! -f /bin/csh ] && [ "$TRUST_WITHOUT_VISIT" != 1 ] && echo "/bin/csh not found. Please install the C shell." && compiler_found=0
[ "$TRUST_CC_BASE" = "" ] && echo "C++ compiler not found. Please install a C++ compiler." && compiler_found=0
[ "$TRUST_cc_BASE" = "" ] && echo "C compiler not found. Please install a C compiler." && compiler_found=0
[ "$TRUST_F77_BASE" = "" ] && echo "Fortran compiler not found. Please install a Fortran compiler." && compiler_found=0
if [ "$compiler_found" = 0 ] ; then
  echo "Then install again the code."
  [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
  exit -1
fi

# Gestion d'une librairie systeme plus recente que miniconda (ex: libstdc++.so.6.0.29 sur Fedora34 pour libstdc++.so.6.0.28 dans conda avec libstdcxx-ng=9.3.0), on vire:
# Le pb se produit au niveau du test Python de l'import MEDCoupling ou d'un editeur comme gedit: GLIBCXX_X.Y.Z not found
stdcpp_conda=`cd $TRUST_ROOT/exec/python/lib;ls libstdc++.so.6.0.* 2>/dev/null | cut -d'.' -f3-6`
if [ "$stdcpp_conda" != "" ]
then
    root_gnu=`dirname $TRUST_F77_BASE` && root_gnu=`dirname $root_gnu`
    libstd_sys=`ls $root_gnu/lib64/libstdc++.so.6.0.?? /usr/lib*/libstdc++.so.6.0.* /usr/lib*/*64-linux-gnu/libstdc++.so.6.0.* 2>/dev/null | head -1`
    stdcpp_sys=`echo $libstd_sys | $TRUST_Awk -F/ '{print $NF}' | cut -d'.' -f3-6`
    remove_stdcpp_conda=0 && [ "$stdcpp_sys" != "" ] && remove_stdcpp_conda=`echo $stdcpp_sys $stdcpp_conda | awk '{ print ($1>$2?1:0) }'`
    if [ $remove_stdcpp_conda -eq 1 ]
    then
       echo "Warning! Look for a newer conda package than libstdcxx-ng=9.3.0 to avoid this hack:"
       #rm $TRUST_ROOT/exec/python/lib/libstdc++.so*
       #dirlibstd=`dirname $libstd_sys`
       for file in `ls $TRUST_ROOT/exec/python/lib/libstdc++.so* 2>/dev/null`
       do
          echo "Creating a link: ln -s -f $libstd_sys $file"
          ln -s -f $libstd_sys $file
       done
    fi
fi


######################################################################
# On va avoir besoin de cmake 2.8 pour Metis et 2.8.10.2 pour VisIt 2.7.0
# Update to 3.0.1 to fix recursive cmake
# Update to 4.0 and include in conda
######################################################################
#echo "Installing cmake in conda ... "
#$TRUST_ROOT/exec/python/bin/conda install -c file://$TRUST_ROOT/externalpackages/Miniconda/local_channel --override-channels cmake -y  1>>$TRUST_ROOT/exec/conda_python.log 2>&1
## If cmake from conda has not been correctly installed, we exit with an error
#if [ $? != 0 ]
#then
#   echo "Error while installing 'cmake' from Miniconda2 local_channel. see $TRUST_ROOT/exec/conda_python.log" >> $TRUST_ROOT/NON_INSTALLED
#   Display_Missing_packages && exit -1
#fi

##############################
# Installation de makedepend #
##############################
e="`cherche_file TRUST_MD makedepend`";eval $e
if [ "$TRUST_MD" = ""  ]
then
echo "Compilation of makedepend"
make_ $TRUST_ROOT/Outils/makedepend makedepend $TRUST_ROOT/exec/makedepend.log
fi

m="# Path to dtterm command";e="`cherche_file Dtterm $Dtterm`";ecrit $m"|"$e"|"$env;eval $e
m="# Path to xterm command";e="`cherche_file Xterm xterm rxvt konsole`";ecrit $m"|"$e"|"$env;eval $e
[ ${#Dtterm} = 0 ] || [ ${#Xterm} = 0 ] && echo "Warning. The TRUST GUI (Graphical User Interface) will not work cause Dtterm or Xterm not found. "

#################################################################
# Si on ne trouve pas la librairie graphique Tcl/Tk on l'installe
#################################################################
m="# Path to Tcl/Tk";e="`cherche_file TRUST_WISH /usr/bin/wish /bin/wish wish`";eval $e
if [ "$TRUST_WISH" = "" ] && [ "$TRUST_DISABLE_TCL_TK" != "1" ]
then
   make_ $TRUST_ROOT/Outils/tcl_tk Tcl/Tk $TRUST_ROOT/exec/tcl_tk.log
   e="`cherche_file TRUST_WISH $TRUST_ROOT/exec/tcl_tk/bin/wish`";
fi
ecrit $m"|"$e"|"$env

#################################################################
# Recherche de GNU make>=3.81 (3.80 ne marche pas avec Metis 5.0)
#################################################################
e="`cherche_file gmake gmake make`";eval $e
GMAKE_VERSION_OK=`$gmake --version 2>&1 | awk '/GNU Make/ && ($3>=3.81) {print 1}'`
if [ "$GMAKE_VERSION_OK" != 1 ]
then
   make_ $TRUST_ROOT/env/gmake gmake $TRUST_ROOT/exec/gmake.log
fi

# On efface les paquets inutiles si installation
[ "$install" = 1 ] && \ls *gz | grep -v $TRUST_ARCH | xargs rm -f
cd $TRUST_ROOT/env
# Mozilla est desormais supporte mais Konqueror pas encore completement ...
#echo $ECHO_OPTS "Trying to find and test a browser...\c"
m="# Path to a browser";e="`cherche_file TRUST_WEBBROWSER google-chrome firefox mozilla-firefox mozilla netscape`";ecrit $m"|"$e"|"$env
#echo OK
###############
# NATIVE BLAS #
###############
TRUST_BLAS_LAPACK=""
# Try to improve detection of MKL (Intel):
[ "$MKLROOT" = "" ] && MKLROOT=$MKL_ROOTDIR # Sur sagittarius
[ "$MKLROOT" = "" ] && MKLROOT=$MKL_ROOT # Intel 20
[ "$MKLROOT" = "" ] && MKLROOT=`type -p icpc 2>/dev/null | awk -F/bin '{print $1}'`
if [ "$MKLROOT" != "" ]
then
   # MKL: Math Kernel Library d'INTEL detecte (seems to work with Intel or Gnu compilers)
   TRUST_BLAS_LAPACK=`ls $MKLROOT/lib/*64*/libmkl_core.a $MKL_BASE/lib/*64*/libmkl_core.a 2>/dev/null | head -1`
   [ "$TRUST_BLAS_LAPACK" != "" ] && TRUST_BLAS_LAPACK=`dirname $TRUST_BLAS_LAPACK`
elif [ "$CRAY_LIBSCI_PREFIX" != "" ] || [ "$CRAY_LIBSCI_PREFIX_DIR" != "" ]
then
   # CRAY blas
   TRUST_BLAS_LAPACK=`ls $CRAY_LIBSCI_PREFIX/lib/libsci_cray.a $CRAY_LIBSCI_PREFIX_DIR/lib/libsci_cray.a 2>/dev/null | head -1`
   [ "$TRUST_BLAS_LAPACK" != "" ] && TRUST_BLAS_LAPACK=`dirname $TRUST_BLAS_LAPACK`
fi
m="# Path to optimized BLAS";e="TRUST_BLAS_LAPACK=\"$TRUST_BLAS_LAPACK\" && export TRUST_BLAS_LAPACK";ecrit $m"|"$e"|"$env

########
# CUDA #
########
if [ "$TRUST_USE_CUDA" = 1 ]
then
   [ "$TRUST_DISABLE_PETSC" = 1 ] && echo "Error, you need PETSc with -cuda option." && exit -1
   check_nvidia_cuda
   [ "$CUDA_ROOT" = "" ] && echo "CUDA libraries not found!" && exit -1
   m="# PATH to CUDA";
   e="CUDA_ROOT=\"$CUDA_ROOT\" && export CUDA_ROOT";
   ecrit $m"|"$e"|"$env;eval $e
   e="CUDA_INC_PATH=\"$CUDA_INC_PATH\" && export CUDA_INC_PATH";
   ecrit $m"|"$e"|"$env;eval $e
   [ "$CUDA_ROOT" != /usr ] && echo "ADD_PATH \$CUDA_ROOT/bin" >> $env # Ne pas ajouter /usr/bin au PATH car sinon python, conda pris sont ceux du systeme !
   echo "ADD_LD_LIBRARY_PATH \$CUDA_ROOT${CUDA_LIB#$CUDA_ROOT} " >> $env
   echo "ADD_LD_LIBRARY_PATH \$TRUST_ROOT/lib/src/LIBAMGX/AmgX/lib" >> $env
else
   TRUST_USE_CUDA=0
fi

#############
# Debut MPI #
#############
BATCH_SYSTEM_DETECTED=0
for cmd in sinfo qstat bqueues
do
   [ "`$cmd --help 2>&1 1>/dev/null;echo $?`" = 0 ] && BATCH_SYSTEM_DETECTED=1 && break
done
# Par defaut (aucun TRUST_FORCE specifie) alors hors clusters et Cuda, FORCE_PROVIDED_MPICH car plus pratique pour VisIt, tests de NR plus rapides, valgrind error-free:
if [ "$TRUST_FORCE_PROVIDED_OPENMPI" != 1 ] && [ "$TRUST_FORCE_LATEST_OPENMPI" != 1 ] && [ "$TRUST_FORCE_PROVIDED_MPICH" != 1 ] && [ "$TRUST_FORCE_LATEST_MPICH" != 1 ] && [ "$TRUST_FORCE_SYSTEM_MPI" != 1 ]
then
   if [ "$BATCH_SYSTEM_DETECTED" = 0 ] && [ "$TRUST_WITHOUT_HOST" = 1 ]
   then
      if [ "$TRUST_USE_CUDA" = 1 ]
      then
         export TRUST_FORCE_LATEST_OPENMPI=1 # OpenMPI Cuda-Aware
      elif [ "`echo $TRUST_VERSION_GNU | awk -F. '{if ($1*100+$2*10+$3>=1100) print -force_latest_mpich}'`" != "" ]
      then
         export TRUST_FORCE_LATEST_MPICH=1
      else
         export TRUST_FORCE_PROVIDED_MPICH=1
      fi
   fi
fi
COMLIBS=""
MPI_ROOT=""
MPI_INCLUDE="\$TRUST_ROOT/lib/src/LIBMPI/no_mpi"
MPI_LIB=""
TRUST_CC=""
TRUST_cc=""
TRUST_F77=""
COMM=""
if [ "$TRUST_DISABLE_MPI" = 1 ]
then
   m="# Path to MPI";e="MPI_ROOT=\"$MPI_ROOT\" && export MPI_ROOT";	ecrit $m"|"$e"|"$env;eval $e
   m="# Path to MPI include directory";e="MPI_INCLUDE=\"$MPI_INCLUDE\" && export MPI_INCLUDE"; ecrit $m"|"$e"|"$env;eval $e
   m="# COMM variable";e="COMM=\"$COMM\" && export COMM";		ecrit $m"|"$e"|"$env
else
   rep_test_mpi=`mktemp_ -d`
   echo "#include <mpi.h>
   #include <iostream>
   using std::cout;
   using std::endl;
   int main(int argc, char** argv)
   {
     if (argc>1)
     {
       MPI_Init(&argc,&argv);
       int mytid;
       MPI_Comm_rank(MPI_COMM_WORLD,&mytid);
       cout<<\"[PE \"<<mytid<<\"] coucou\"<<endl;
       MPI_Finalize();
     }
     else
     {
       cout<<\"[PE 0] coucou\"<<endl;
     }
     return 0;
   }" > $rep_test_mpi/test_mpi.cpp
   echo "#include <mpi.h>
   #include <iostream>
   using std::cout;
   using std::endl;
   int main(int argc, char** argv)
   {
     if (argc>1)
     {
       MPI_Init(&argc,&argv);
       int mytid;
       MPI_Comm_rank(MPI_COMM_WORLD,&mytid);
       cout<<\"[PE \"<<mytid<<\"] coucou\"<<endl;
       // MPI_Abort(MPI_COMM_WORLD,mytid);
       MPI_Abort(MPI_COMM_WORLD,-1);
     }
     else
     {
       cout<<\"[PE 0] coucou\"<<endl;
     }
     return 0;
   }" > $rep_test_mpi/test_abort_mpi.cpp
   echo "      program main
      include 'mpif.h'
      integer ierr
      integer argc
      argc=iargc()
      if (argc.gt.1) then
         call mpi_init(ierr)
         print*,\" coucou\"
         call mpi_finalize(ierr)
      else
         print*,\" coucou\"
      endif
      end program" > $rep_test_mpi/test_mpi.f
   # A minima:
   COMM="_mpi";export COMM
   COMFLAGS=" -DMPI_"
   mpi_detecte=0
   if [ "$TRUST_FORCE_PROVIDED_OPENMPI" != 1 ] && [ "$TRUST_FORCE_LATEST_OPENMPI" != 1 ] && [ "$TRUST_FORCE_PROVIDED_MPICH" != 1 ] && [ "$TRUST_FORCE_LATEST_MPICH" != 1 ]
   then
      ############################################
      # Detection de MPI par le wrapper C++ trouve
      ############################################
      ec="`cherche_file mpiCC mpCC_r mpicxx mpiCC`";eval $ec
      if [ "$mpiCC" != "" ]
      then
         MPI_BIN=`dirname $mpiCC` # Variable temporaire utile ensuite
	 # On a besoin de specifier le compilateur utilise par mpiCC
	 if [ "`$mpiCC -show | grep openmpi`" != "" ] || [ "`$mpiCC -show | grep bullxmpi`" != "" ] || [ "`$mpiCC -show | grep ompi`" != "" ] || [ "`$mpiCC -show | grep open-mpi`" != "" ]
	 then
            m="# Compiler for mpiCC"  && e="OMPI_CXX=\"\$TRUST_CC_BASE\"  && export OMPI_CXX" && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpicc"  && e="OMPI_CC=\"\$TRUST_cc_BASE\"   && export OMPI_CC"  && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpif77" && e="OMPI_F77=\"\$TRUST_F77_BASE\" && export OMPI_F77" && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpif90" && e="OMPI_FC=\"\$TRUST_F77_BASE\"  && export OMPI_FC"  && ecrit $m"|"$e"|"$env;eval $e
	 elif [ "`$mpiCC -show | grep mpibull`" != "" ]
	 then
            m="# Compiler for mpiCC"  && e="MPIBULL_CXX=\"\$TRUST_CC_BASE\"  && export MPIBULL_CXX" && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpicc"  && e="MPIBULL_CC=\"\$TRUST_cc_BASE\"   && export MPIBULL_CC"  && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpif77" && e="MPIBULL_F77=\"\$TRUST_F77_BASE\" && export MPIBULL_F77" && ecrit $m"|"$e"|"$env;eval $e
	 elif [ "`$mpiCC -show | grep mpich`" != "" ]
	 then
	    # MPICH_CCC peut etre obsolete, a remplacer par MPICH_CXX ?
	    m="# Compiler for mpicxx" && e="MPICH_CXX=\"\$TRUST_CC_BASE\"  && export MPICH_CXX" && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpiCC"  && e="MPICH_CCC=\"\$TRUST_CC_BASE\"  && export MPICH_CCC" && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpicc"  && e="MPICH_CC=\"\$TRUST_cc_BASE\"   && export MPICH_CC"  && ecrit $m"|"$e"|"$env;eval $e
            m="# Compiler for mpif77" && e="MPICH_F77=\"\$TRUST_F77_BASE\" && export MPICH_F77" && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpif90" && e="MPICH_F90=\"\$TRUST_F77_BASE\" && export MPICH_F90" && ecrit $m"|"$e"|"$env;eval $e
            # Bizarrerie pour ioulia, il faut specifier le linker en fortran sinon NP ne compile pas:
            m="# Linker pour mpif77"      && e="MPICH_FLINKER=\"\$TRUST_F77_BASE\" && export MPICH_FLINKER" && ecrit $m"|"$e"|"$env;eval $e
	 elif [ "`$mpiCC -show | grep mpi | grep intel`" != "" ] || [ "`$mpiCC -help | grep I_MPI_CXX`" != "" ]
	 then
	    m="# Compiler for mpiCC"  && e="I_MPI_CXX=\"\$TRUST_CC_BASE\"  && export I_MPI_CXX" && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpicc"  && e="I_MPI_CC=\"\$TRUST_cc_BASE\"  && export I_MPI_CC"   && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpif77" && e="I_MPI_F77=\"\$TRUST_F77_BASE\" && export I_MPI_F77" && ecrit $m"|"$e"|"$env;eval $e
	    m="# Compiler for mpif90" && e="I_MPI_F90=\"\$TRUST_F77_BASE\" && export I_MPI_F90" && ecrit $m"|"$e"|"$env;eval $e
	 elif [ "`$mpiCC -show | grep wi4mpi`" != "" ]
         then
            m="" # Rien pour le moment, depend du MPI
            echo "wi4mpi not supported yet."
            exit -1
         else
	    echo "MPI indicated by $mpiCC by not supported yet."
	    exit -1
	 fi
	 # Test du MPI trouve avec mpiCC
	 echo $ECHO_OPTS "# Check `basename $mpiCC` (mpiCC.log file): "
	 echo $mpiCC -o ./test_mpi_CC $rep_test_mpi/test_mpi.cpp
	 $mpiCC -o ./test_mpi_CC $rep_test_mpi/test_mpi.cpp 1>mpiCC.log 2>&1
	 err=$?
	 [ $err = 0 ] && run_test_mpi test_mpi_CC 1>>mpiCC.log 2>&1
	 OK $err
	 if [ $err = 0 ]
	 then
	    # Test du MPI trouve avec mpif90 ou mpif77 (nouveau pour la 1.6.3 car certains Linux avec LAM/MPI n'ont pas le support fortran)
            if [ -f $MPI_BIN/mpif90 ]
            then
               mpif=$MPI_BIN/mpif90
               echo $ECHO_OPTS "# Check `basename $mpif` (mpif.log file): "
               echo $mpif -o ./test_mpi_f90 $rep_test_mpi/test_mpi.f
               $mpif -o ./test_mpi_f90 $rep_test_mpi/test_mpi.f 1>mpif.log 2>&1
               err=$?
               [ $err = 0 ] && run_test_mpi test_mpi_f90 1>>mpif.log 2>&1
               OK $err
            fi
            if [ $err != 0 ] && [ $TRUST_DISABLE_PETSC = 1 ]
            then
               mpif=$MPI_BIN/mpif77
               echo $ECHO_OPTS "# Check `basename $mpif` (mpif.log file): "
               echo $mpif -o ./test_mpi_f77 $rep_test_mpi/test_mpi.f
               $mpif -o ./test_mpi_f77 $rep_test_mpi/test_mpi.f 1>mpif.log 2>&1
               err=$?
               [ $err = 0 ] && run_test_mpi test_mpi_f77 1>>mpif.log 2>&1
               OK $err
            fi
	 fi
	 # On definit TRUST_CC et TRUST_cc si on trouve un mpiCC/mpi77 qui fonctionne:
	 if [ $err = 0 ]
	 then
	    mpi_detecte=1
	    mpicc=$MPI_BIN/mpicc
	    if [ "$VAMPIR_SUPPORTED" = 1 ]
	    then
	       VTCC="vtc++ -vt:cxx "
	       VTcc="vtcc -vt:cc "
	       VTF77="vtf77 -vt:f77 "
	    else
	       VTCC=""
	       VTcc=""
	       VTF77=""
	    fi
	    m="# Path to C++ compiler"     && e="TRUST_CC=\"$VTCC$mpiCC\" && export TRUST_CC"  && ecrit $m"|"$e"|"$env;eval $e
	    m="# Path to C compiler"       && e="TRUST_cc=\"$VTcc$mpicc\" && export TRUST_cc"  && ecrit $m"|"$e"|"$env;eval $e
	    m="# Path to Fortran compiler" && e="TRUST_F77=\"$VTF77$mpif\" && export TRUST_F77" && ecrit $m"|"$e"|"$env;eval $e
	    # On ameliore pour la determination de MPI_INCLUDE
	    MPI_INCLUDE=`$mpiCC -show 2>/dev/null | awk '{for(i=1;i<=NF;i++) if (gsub("-I","",$i)) print $i}' | grep /include`
	    for MPI_INCLUDE in $MPI_INCLUDE `dirname $MPI_BIN`/include
	    do
	       [ -f $MPI_INCLUDE/mpi.h ] && break # On trouve l'include mpi.h
	    done
	    if [ ! -f $MPI_INCLUDE/mpi.h ]
	    then
	       echo "mpi.h not found for $mpiCC ..."
	       mpi_detecte=0 # On n'a pas trouve l'include
	    else
	       # On recherche maintenant MPI_ROOT en se basant MPI_ROOT/lib
	       MPI_LIBS=`$mpiCC -show 2>/dev/null | awk '{for(i=1;i<=NF;i++) if (gsub("-L","",$i)) print $i}' | sort -u`
	       for MPI_LIB in $MPI_LIBS
	       do
	          [ -d $MPI_LIB ] && [ "`ls $MPI_LIB/libmpi*.* 2>/dev/null`" != "" ] && break # On trouve le repertoire de la librairie MPI
	       done
	       for MPI_ROOT in $MPI_LIB $MPI_BIN $MPI_INCLUDE
	       do
	          MPI_ROOT=`dirname $MPI_ROOT`
	          [ -d $MPI_ROOT/lib ] && break # On trouve le repertoire pour MPI_ROOT
	       done
	       export MPI_ROOT
	       # Recherche de mpirun
	       em="`cherche_file Mpirun $MPI_BIN/mpirun $MPI_ROOT/bin/mpirun $MPI_ROOT/bin/poe dmpirun prun mpirun mpiexec srun`";eval $em
	       # Si pas trouve (comme sur is213120) alors on quitte:
	       [ "$Mpirun" = "" ] && mpi_detecte=0 && echo "mpiexec/mpirun not found for MPI_ROOT=$MPI_ROOT..."
	       # Pb decouvert sur machine is202803 et ioulia : il ne faut pas inclure mpi++.h dans le mpi.h sinon warning qui font des erreurs avec -Wall -Werror:
	       [ -f `dirname $mpiCC`/mpicxx ] && COMFLAGS=$COMFLAGS" -DMPICH_SKIP_MPICXX"
	       # De meme desactivition du C++ bindings pour gcc recent (>=8.x) sinon erreur avec OpenMPI natif... (See https://github.com/open-mpi/ompi/issues/5157)
	       [ -f `dirname $mpiCC`/mpicxx ] && COMFLAGS=$COMFLAGS" -DOMPI_SKIP_MPICXX"
               # Test du MPI_Abort en parallel (KO avec openmpi 1.10.3 1.10.4 1.10.5)
               # desactive car pb en soumission de job hors frontale
               #echo $ECHO_OPTS "# Check `basename $mpiCC` (mpiAbort.log file): "
               #echo $mpiCC -o ./test_mpi $rep_test_mpi/test_abort_mpi.cpp
               #$mpiCC -o ./test_mpi $rep_test_mpi/test_abort_mpi.cpp 1>mpiAbort.log 2>&1
               #err=$?
               #[ $err = 0 ] && run_test_mpi_par 1>>mpiAbort.log 2>&1
               #OK $err
               #[ $err = 1 ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `mpirun --version | head -n 1`. Upgrade of MPI version."
	       if [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI)'`" != "" ]
	       then
                  echo $ECHO_OPTS "# Check version of OpenMPI (Problem if version between 1.10.3 and 1.10.7): "
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.3'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.4'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.5'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.6'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
		  [ "`$MPI_ROOT/bin/mpirun --version 2>&1 | grep 'mpirun (Open MPI) 1.10.7'`" != "" ] && mpi_detecte=0 && echo "Problem with MPI_ABORT of `$MPI_ROOT/bin/mpirun --version | head -n 1`.";
	       fi
	    fi
	 fi
      fi
   fi
   [ "$err" != 1 ] && rm -r -f $rep_test_mpi

   if [ $mpi_detecte = 0 ]
   then
      if [ "$TRUST_FORCE_PROVIDED_OPENMPI" != 1 ] && [ "$TRUST_FORCE_PROVIDED_MPICH" != 1 ] && [ "$TRUST_MPI_NATIF" = 1 ]
      then
         if [ "$TRUST_WITHOUT_HOST" = 0 ] || [ "$BATCH_SYSTEM_DETECTED" = 1 ]
         then
            echo "Native MPI SHOULD be used on $HOST for optimal performances."
            echo "Check carefully the MPI version you want to use for parallel computing before installing the code, especially onto a HPC cluster."
            echo "The command mpicxx should be found into the bin directory of the MPI version you plan to use, to check that, run:"
            echo "  type mpicxx"
            echo "Or contact $HOST administrator to find native MPI libraries or TRUST support team."
         else
            echo "MPI not detected by TRUST:"
            echo " - On a HPC cluster, contact $HOST's administrator or TRUST support team."
            echo " - On PC, you can use: ./configure -force_provided_mpich|openmpi to force basic MPICH|OPENMPI installation."
            echo "Contact TRUST support team for further questions."
         fi
         [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
         exit -1
      fi
      mpi_detecte=1
      ###########################################
      # Pas de MPI detecte, on prend le MPI livre
      ###########################################
      COMM="_mpi"
      # Switch possible entre OpenMPI et MPICH
      # MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/openmpi" && [ "$TRUST_FORCE_PROVIDED_MPICH" = 1 ] && MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/mpich"
      # New 1.6.9 -> MPICH by default instead of OpenMPI (hangs on several cases, eg: UJV_32 on gudy)
      MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/mpich"
      # New 1.7.5 -> OpenMPI by default instead of MPICH (2.0.2 valgrind free)
      #MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/openmpi"
      if [ "$TRUST_FORCE_PROVIDED_OPENMPI" = 1 ] || [ "$TRUST_FORCE_LATEST_OPENMPI" = 1 ]
      then
         MPI_ROOT="$TRUST_ROOT/lib/src/LIBMPI/openmpi"
      fi
      export MPI_ROOT # Car sinon pas retenu dans le makefile de LIBMPI
      # Installation du MPI livre
      SRC_MPI=`dirname $MPI_ROOT | sed "s?lib/src?ThirdPart/src?"`
      make_ $SRC_MPI `basename $MPI_ROOT` $TRUST_ROOT/lib/`basename $SRC_MPI`".log"

      MPI_ROOT="\$TRUST_ROOT/lib/src/LIBMPI/`basename $MPI_ROOT`";export MPI_ROOT
      MPI_INCLUDE="\$TRUST_ROOT/lib/src/LIBMPI/`basename $MPI_ROOT`/include";export MPI_INCLUDE
      Mpirun="\$MPI_ROOT/bin/mpirun";export Mpirun
      mpiCC="\$MPI_ROOT/bin/mpicxx";export mpiCC
      COMFLAGS="-DMPI_"
      if [ "`basename $MPI_ROOT`" = openmpi ]
      then
	 COMLIBS=""
	 # Pour OpenMPI on prend desormais mpiCC pour compiler en changeant le compilateur
	 m="# Compiler for mpiCC" && e="OMPI_CXX=\"\$TRUST_CC_BASE\" && export OMPI_CXX" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpicc" && e="OMPI_CC=\"\$TRUST_cc_BASE\" && export OMPI_CC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpifort" && e="OMPI_FC=\"\$TRUST_F77_BASE\" && export OMPI_FC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler C++" && e="TRUST_CC=\"$MPI_ROOT/bin/mpicxx\" && export TRUST_CC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler C" && e="TRUST_cc=\"$MPI_ROOT/bin/mpicc\" && export TRUST_cc" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler F77" && e="TRUST_F77=\"$MPI_ROOT/bin/mpif77\" && export TRUST_F77" && ecrit $m"|"$e"|"$env;eval $e
	 echo "ADD_PATH $MPI_ROOT/bin" >> $env
	 MPI_LIB="";export MPI_LIB
      elif [ "`basename $MPI_ROOT`" = mpich ]
      then
	 COMLIBS=""
	 # Pour MPICH on prend desormais mpicxx (mpiCC n'existe plus) pour compiler en changeant le compilateur
	 m="# Compiler for mpiCC" && e="MPICH_CCC=\"\$TRUST_CC_BASE\" && export MPICH_CCC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpicc" && e="MPICH_CC=\"\$TRUST_cc_BASE\" && export MPICH_CC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler for mpif77" && e="MPICH_F77=\"\$TRUST_F77_BASE\" && export MPICH_F77" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler C++" && e="TRUST_CC=\"$MPI_ROOT/bin/mpicxx\" && export TRUST_CC" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler C" && e="TRUST_cc=\"$MPI_ROOT/bin/mpicc\" && export TRUST_cc" && ecrit $m"|"$e"|"$env;eval $e
	 m="# Compiler F77" && e="TRUST_F77=\"$MPI_ROOT/bin/mpif77\" && export TRUST_F77" && ecrit $m"|"$e"|"$env;eval $e
	 echo "ADD_PATH $MPI_ROOT/bin" >> $env
	 MPI_LIB="";export MPI_LIB
	 sed -i "s@${TRUST_ROOT}@\$TRUST_ROOT@g" $TRUST_ROOT/lib/src/LIBMPI/mpich/bin/mpicxx
	 sed -i "s@${TRUST_ROOT}@\$TRUST_ROOT@g" $TRUST_ROOT/lib/src/LIBMPI/mpich/bin/mpicc
	 sed -i "s@${TRUST_ROOT}@\$TRUST_ROOT@g" $TRUST_ROOT/lib/src/LIBMPI/mpich/bin/mpif77
      else
         echo "$MPI_ROOT not supported yet."
         [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
	 exit -1
      fi
      export COMM
   fi

   # Ecriture des variables
   m="# Path to MPI"; e="MPI_ROOT=\"$MPI_ROOT\" && export MPI_ROOT"; ecrit $m"|"$e"|"$env;eval $e
   m="# Path to MPI includes directory"; e="MPI_INCLUDE=\"$MPI_INCLUDE\" && export MPI_INCLUDE"; ecrit $m"|"$e"|"$env;eval $e
   # On fait attention si MPI_LIB est vide (-L peut causer des soucis...)
   if [ "$MPI_LIB" != "" ]
   then
      m="# Path to MPI libraries directory";e="MPI_LIB=\"$MPI_LIB\" && export MPI_LIB"; ecrit $m"|"$e"|"$env
      MPI_LIB="-L$MPI_LIB"
   fi
   m="# Path to mpirun command"; e="Mpirun=\"$Mpirun\" && export Mpirun"; ecrit $m"|"$e"|"$env
   m="# COMM variable"; e="COMM=\"$COMM\" && export COMM"; ecrit $m"|"$e"|"$env
fi
###########
# Fin MPI #
###########

# Pas de MPI, on fixe TRUST_CC a TRUST_CC_BASE et TRUST_cc a TRUST_cc_BASE
[ "$TRUST_CC" = "" ]  && m="# Path to C++ compiler" && e="TRUST_CC=\"$TRUST_CC_BASE\"   && export TRUST_CC"  && ecrit $m"|"$e"|"$env && eval $e
[ "$TRUST_cc" = "" ]  && m="# Path to C compiler"   && e="TRUST_cc=\"$TRUST_cc_BASE\"   && export TRUST_cc"  && ecrit $m"|"$e"|"$env && eval $e
[ "$TRUST_F77" = "" ] && m="# Path to F77 compiler" && e="TRUST_F77=\"$TRUST_F77_BASE\" && export TRUST_F77" && ecrit $m"|"$e"|"$env && eval $e

##############################################################
# Intallation des packages supplementaires avec pip de conda #
##############################################################
pkgs="" # now, we install only mpi4py with pip if mpi enabled, so umpty list
if [ "$TRUST_DISABLE_MPI" != 1 ] && [ "`basename $TRUST_CC_BASE`" != nvc++ ] && [ "$TRUST_DISABLE_MPI4PY" != 1 ]
then
   pkgs="mpi4py "$pkgs
fi
# ld from conda does not recognize openmpi configuration on TGCC
if [ "${HOST#irene}" != $HOST ] || [ "${HOST#jean-zay}" != $HOST ] || [ "${HOST_BUILD#jean-zay}" != $HOST ] || [ "${HOST#topaze}" != $HOST ]
then
   rm -rf $TRUST_ROOT/exec/python/compiler_compat && echo "We remove ld from conda on $HOST ..."
fi
InstallPipPkgs=0
for pkg in $pkgs
do
  [ "`$TRUST_ROOT/exec/python/bin/conda list | grep $pkg`" = "" ] && InstallPipPkgs=1
done
# On desactive en zone (pb de build):
[ "${HOST#sagittarius}" != $HOST ] && InstallPipPkgs=0
if [ "$InstallPipPkgs" = 1 ]
then
   for pkg in $pkgs
   do
     echo "Installing $pkg ..."
     env MPICC=$TRUST_cc $TRUST_ROOT/exec/python/bin/pip install $TRUST_ROOT/externalpackages/pip/$pkg*.gz 1>$TRUST_ROOT/exec/conda_python.log 2>&1
     if [ $? != 0 ]
     then
        echo "Error while installing '$pkg' with pip. see $TRUST_ROOT/exec/conda_python.log"
        echo "Contact TRUST support or run ./configure by adding: -disable-$pkg"
        exit -1
     fi   
   done
fi

# If a package has not been correctly installed, we exit with an error
[ -f $TRUST_ROOT/NON_INSTALLED ] && [ "`grep ' pip' $TRUST_ROOT/NON_INSTALLED`" != "" ] &&  Display_Missing_packages && exit -1

################################################
# Checking the size of type 'long' for BUILD64 #
################################################
if [ "$TRUST_INT64" = "1" ]
then
   echo '#include <iostream>
using namespace std;
int main() {
   cout<<"Size of int is "<<sizeof(int)<<" bytes"<<endl;
   cout<<"Size of long is "<<sizeof(long)<<" bytes"<<endl;
   return sizeof(long);
}' > test_size_long.cpp
   $TRUST_CC -o test_size_long.out test_size_long.cpp
   ./test_size_long.out  1>/dev/null
   sizeoflong=$?
   if [ "$sizeoflong" != 8 ]
   then
      echo "# Does the TRUST_CC compiler accept a 64-bit-indices ? : No "  | tee -a $env
      echo "Fatal error: it seems that sizeoflong = $sizeoflong which is not 8 bytes"
      echo "You cannot unfortunately build 64-bit indices version of TRUST."
      # It could perhaps be possible to replace int by long long instead of long"
      echo "Contact TRUST support at trust@cea.fr"
      # We do not display missing packages
      exit -1;
   else
      echo "# Does the TRUST_CC compiler accept a 64-bit-indices ? : Yes "  | tee -a $env
      rm test_size_long.out test_size_long.cpp
   fi
fi


########################
# Installation de astyle
########################
#if [ $TRUST_ARCH = linux ]
if [ "$TRUST_DISABLE_CHECK_SRC" != "1" ]
then
   make_ $TRUST_ROOT/Outils/astyle astyle $TRUST_ROOT/exec/astyle.log
fi

########################
# Installation de Salome
########################
version_salome=9.9.0
if [ $TRUST_DOWNLOAD_SALOME = 1 ]
then
   package=SALOME-$version_salome
   echo $ECHO_OPTS "Trying to install $package...\c"
   if [ -d $TRUST_ROOT/Outils/Salome/$package ]
   then
      err=0
   else
      cd $TRUST_TMP #$TRUST_ROOT/Outils/Salome
      $TRUST_ROOT/bin/KSH/wget_ ftp://ftp.cea.fr/pub/salome/targz/SALOME-"$version_salome"/SALOME-"$version_salome".tar.gz 1>$package.log 2>&1
      err=$?
      if [ $err != 0 ]
      then
         # We try to download SALOME from salome-platform.org
         $TRUST_ROOT/bin/KSH/wget_ http://files.salome-platform.org/Salome/Salome$version_salome/SALOME-$version_salome.tar.gz  1>$package.log 2>&1
         err=$?
      fi
      [ $err != 0 ] && echo "SALOME download failed, see $TRUST_TMP/$package.log"  && exit -1
      cd $TRUST_ROOT/Outils/Salome
      tar xzf $TRUST_TMP/SALOME-"$version_salome".tar.gz
      err=$?
      cd $TRUST_ROOT/env
   fi
   if [ $err = 0 ]
   then
      echo "OK"
      echo "ADD_PATH \$TRUST_ROOT/Outils/Salome/SALOME-$version_salome/" >> $env
   else
      echo "KO (See `pwd`/$package.log)"
      echo "Contact TRUST support."
      [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
      exit -1
   fi
#else
#   # Try to detect last Salome version
#   X=`echo $version_salome | awk -F. '{print $1}'`
#   SALOME_BIN_ROOT=`ls -rt /export/home/salome/V$X"_"*/APPLI/runAppli 2>/dev/null | tail -1`
#   if [ "$SALOME_BIN_ROOT" != "" ]
#   then
#      SALOME_BIN_ROOT=`dirname $SALOME_BIN_ROOT`
#      echo "Salome $version_salome detected under $SALOME_BIN_ROOT and added to the TRUST environment."
#      echo "ADD_PATH $SALOME_BIN_ROOT" >> $env
#   fi
fi

# Shares libs possibles ?
SHARE_LIBS=1
# Detect an software configuration management tool -> means a developer version
if [ -d $TRUST_ROOT/.git ]
then
   TRUST_SCM=1
   if [ -d $TRUST_ROOT/.git ]
   then
      GIT_ROOT=$TRUST_ROOT/.git
      # Activate and add Git hooks
      list_hooks=`cd $TRUST_ROOT/bin/GIT/hooks;ls 2>/dev/null`
      list_hooks="" # Temporary: review what really make pre-commit and post-commit
      for hook in $list_hooks
      do
          # Don't use source but . instead in .git/hooks commits
          command=". bin/GIT/hooks/$hook"
	  if [ "`grep "$command" $GIT_ROOT/hooks/$hook 2>/dev/null`" = "" ]
	  then
             echo "Activating and changing the $hook hook in $GIT_ROOT/hooks/$hook"
	     echo "If you want to deny the involved action, then comment the line into this file."
	     # I have seen some git version, where post-pre commit file do not exist and are named post-pre-commit.sample
	     # So we create if necessary:
	     [ ! -f $GIT_ROOT/hooks/$hook ] && echo "#" > $GIT_ROOT/hooks/$hook
	     # Clean previous TRUST changes
	     sed -i "/TRUST/d" $GIT_ROOT/hooks/$hook
	     #nedit $GIT_ROOT/hooks/$hook
	     # Add new one after last comment:
	     last_comment=`grep '^#' $GIT_ROOT/hooks/$hook | tail -1`
	     sed -i "s?$last_comment?$last_comment\n\n# TRUST hook (may be commented):\n$command?" $GIT_ROOT/hooks/$hook
	     #nedit $GIT_ROOT/hooks/$hook
	     chmod +x $GIT_ROOT/hooks/$hook
	  fi
      done
   fi
else
   TRUST_SCM=0
fi
m="# Using an SCM ?";e="TRUST_SCM=\"$TRUST_SCM\" && export TRUST_SCM";ecrit $m"|"$e"|"$env
# Share libs are not use if not using an SCM:
[ "$TRUST_SCM" != 1 ] && SHARE_LIBS=0
export SHARE_LIBS
m="# Shared libs activated ?";e="SHARE_LIBS=\"$SHARE_LIBS\" && export SHARE_LIBS";ecrit $m"|"$e"|"$env
# Apache ?
UTILISE_APPACHE=0 && [ $TRUST_ARCH = linux ] && UTILISE_APPACHE=1
m="# Apache server activated ?";e="UTILISE_APPACHE=\"$UTILISE_APPACHE\" && export UTILISE_APPACHE";ecrit $m"|"$e"|"$env
# Bloquage parfois sur linux ....
#echo "Press return if necessary..."
# Questions possibles :
# OPT COMM
# Chercher libF77'*' et libsunmath pour sun5 dans /opt/SUNWspro ...

# Rajout des PATH si la configuration est mal fait sur le compte.
paths=`cat $TRUST_ENV/.path`
if [ ${#paths} != 0 ]
then
   # m="# PATH a rajouter";e="PATH=\$PATH$path && export PATH";ecrit $m"|"$e"|"$env
   # On ajoute proprement les nouveaux PATH:
   echo "# PATH added" >> $env
   for path in $paths
   do
      echo "ADD_PATH_AFTER $path" >> $env
   done
fi
# Ajout du PATH eventuel vers le bin des outils d'installation pour Linux
# devenu inutile en version open source
#[ -d $TRUST_ROOT/../bin ] && echo "ADD_PATH $TRUST_ROOT/../bin" >> $env

###############################
# Construction de make.$TRUST_ARCH_CC
############################
LINK_MALIB="\$(OBJS)"
Defines=""
SYSINC=""
SL_EXTENSION="so" && [ ${TRUST_ARCH#HPPA} != $TRUST_ARCH ] && SL_EXTENSION="sl"
[ ${TRUST_ARCH} = cygwin ] && SL_EXTENSION="dll"

OPTIMIZE="-O3"
TRUST_SUPPORTED=0
case $TRUST_ARCH_CC in
   linux_g++*|cygw*g++*|linux_cuda-g++*) TRUST_SUPPORTED=1
	TRUST_SUPPORTED=`echo $TRUST_VERSION_GNU | awk -F. '{ver=$1*100+$2*10+$3;if (ver>=485 && ver<=1201) print "(Supportee)";else print "(Not yet supported or not supported anymore)"}'`
	m="# GNU compiler version";e="TRUST_VERSION_GNU=$TRUST_VERSION_GNU && export TRUST_VERSION_GNU";ecrit $m"|"$e"|"$env
	[ "`echo $TRUST_SUPPORTED | grep -i Not`" != "" ] && TRUST_SUPPORTED=0
	# Passage en -O2 car plantages suspects en -O3 avec egcs sur linux
	# Options TRES severes a ajouter peut etre un jour : -W -Weffc++ -Wfloat-equal
	# 26/03/10, passage enfin a -03
	# 01/07/19, passage a C++ 11
	[ "$TRUST_USE_OPENMP" = 1 ] && PTHREAD="-pthread" # Pour OpenBLAS ?
	FPIC="-fPIC"
	[ ${TRUST_ARCH} = cygwin ] && FPIC=""  # sous cygwin pas de -fPIC
	CppFlags="-O3 $FPIC $PTHREAD -std=c++11 -fno-common -Wno-long-long -Wall -Wnon-virtual-dtor -Wreorder -Woverloaded-virtual -Wsign-promo -Wsynth -Wshadow -Wextra -Wno-unused-parameter -pedantic -fabi-version=0 -Wno-cpp"
	[ "$TRUST_INT64" != "1" ] && CppFlags=$CppFlags" -Wconversion"
	# flag -Wsuggest-override available on gcc version >= 5.1; on gcc 5.4.0 (ub 16) this flag suggests to fix mpich 3.2, so we do not add this flag
	[ "`echo $TRUST_VERSION_GNU | awk '{split($1,a,".");print (a[1]>5||(a[1]==5&&(a[2]>4))?1:0)}'`" = 1 ] && CppFlags=$CppFlags" -Wno-array-bounds -Wsuggest-override"
	# include <sstream> fait un warning sur gcc 2.96, impossible d'utiliser #pragma supporte dans 4.2.x:
	# Idem OpenMPI 1.3.2 sur certaines clusters provoque un warning: type-punning to incomplete type might break strict-aliasing rules
	[ $TRUST_ARCH_CC = linux_g++ ] && [ "`echo $Mpirun | grep 1.3.2`" = "" ] && CppFlags=$CppFlags" -Werror"
	# Attention fort77&f2c et g77&g2c sinon pb avec Blas !
	# On ne met pas -static car plante en // sur dom1 avec scali meme avec -ldl
	if [ ${TRUST_F77_BASE%gfortran} != $TRUST_F77_BASE ]
	then
	   # Parfois libgfortran non trouve (castor, kata,...), on teste et on prend la version 64 bits:
	   touch test.cpp
	   if [ "`$TRUST_CC -o test test.cpp -lgfortran 2>&1 | grep gfortran | grep ld`" != "" ]
	   then
	      L=`ls /usr/lib/gcc/*/*/libgfortran.a 2>/dev/null | grep 64`
	      SYSLIBS="-L"`dirname $L`" "
	   fi
	   rm -f test.cpp
	   # SYSLIBS=$SYSLIBS"-lgfortran -Wl,--allow-multiple-definition" # Pourquoi -Wl,--allow-multiple-definition sur GNU ?
	   SYSLIBS=$SYSLIBS"-lgfortran"
	elif [ "`echo $TRUST_F77_BASE | grep absoft`" != "" ]
	then
	   SYSLIBS=$SYSLIBS"-L/usr/local/absoft/lib -lfio -lf77math"
        elif [ "`basename $TRUST_F77_BASE`" = g77 ]
        then
	   SYSLIBS=$SYSLIBS"-lg2c"
        fi
	F77Flags="-O3 $FPIC" && [ "$TRUST_INT64" = "1" ] && F77Flags=$F77Flags" -fdefault-integer-8"
	# -fallow-argument-mismatch pour gfortran>=10.0.0 (plusieurs librairies Fortran ne compilent pas sinon dont LIBSKIT la premiere):
        [ "`echo $TRUST_VERSION_GNU | awk -F. '{print ($1>=10)}'`" = 1 ] && F77Flags=$F77Flags" -fallow-argument-mismatch"
	ccFLAGS="-O3 $FPIC $PTHREAD"
	ShLibFlag="\$(TRUST_CC) -shared"
	cherche_include_systeme
	;;
    linux_clang++|linux_armclang++|darwin_clang++) TRUST_SUPPORTED=1
        [ "$TRUST_ARCH_CC" = linux_armclang++ ] && ArmFlags="-armpl -ffast-math" # To add optimized machine-specific library. -ffast-math interessant sur irene-arm (*2 sur HPCG, rien sur GNU)
        [ "`$TRUST_CC_BASE -version 2>&1 | grep aocc`" != "" ] && AoccFlags="-march=znver1 -mfma -fvectorize -mfma -mavx2 -m3dnow -floop-unswitch-aggressive -fuse-ld=lld"
   	Defines="-D_COMPILE_AVEC_CLANG"
   	# 26/03/10, passage enfin a -03
	CppFlags="-O3 -fPIC $ArmFlags $AoccFlags -std=c++11 -fno-common -Wno-long-long -Wall -Wno-inconsistent-missing-override -Wnon-virtual-dtor -Wreorder -Woverloaded-virtual -Wsign-promo -Wsynth"
	CppFlags=$CppFlags" -Wshadow -Wextra  -Qunused-arguments -Wno-unused-parameter -Wno-cpp " #  -Wno-infinite-recursion"
	TRUST_VERSION_CLANG=`print_CLANG_VERSION`
	clangFlags="-Wsuggest-override" && [ "`echo $TRUST_VERSION_CLANG | awk '{split($1,a,".");print (a[1]<11?1:0)}'`" = 1 ] && clangFlags=""
	CppFlags=$CppFlags" "$clangFlags
	# GF pas convaincu des erreurs trouvees
	#CppFlags=$CppFlags" -pedantic" # mis en commentaire au passage de clang 4.0.0 car sinon erreur compilation en mode debug
	CppFlags=$CppFlags" -Wno-tautological-compare -Werror"
	if [ "`basename $TRUST_F77_BASE`" = g77 ]
        then
	   SYSLIBS=$SYSLIBS"-lg2c"
        fi
	if [ ${TRUST_F77_BASE%gfortran} != $TRUST_F77_BASE ]
	then
	   # Parfois libgfortran non trouve (castor, kata,...), on teste et on prend la version 64 bits:
	   touch test.cpp
	   if [ "`$TRUST_CC -o test test.cpp -lgfortran 2>&1 | grep gfortran | grep ld`" != "" ]
	   then
	      L=`ls /usr/lib/gcc/*/*/libgfortran.a 2>/dev/null | grep 64`
	      SYSLIBS="-L"`dirname $L`" "
	   fi
	   rm -f test.cpp
	   SYSLIBS=$SYSLIBS"-lgfortran -lgcc"
	   TRUST_GNU_VERSION=`$TRUST_F77_BASE -v 2>&1 | awk '/gcc / && /version / {i=1;while(split($(i),a,".")==1) i++;print $(i)}'`
	fi
	[ "$TRUST_F77_BASE" = linux_armclang++ ] && SYSLIBS=$SYSLIBS" -lflang -lflangrti -lflangADT -lflangArger"
	[ ${TRUST_F77_BASE%flang} != $TRUST_F77_BASE ] && SYSLIBS=$SYSLIBS" -lflang -lflangrti -lpgmath -lomp"        
	F77Flags="-O3 -fPIC $ArmFlags $AoccFlags"
	[ `echo $TRUST_GNU_VERSION | awk -F. '{print ($1>=10)}'` = 1 ] && F77Flags=$F77Flags" -fallow-argument-mismatch"
	ccFLAGS="-Qunused-arguments -O3 -fPIC $ArmFlags $AoccFlags"
	ShLibFlag="\$(TRUST_CC) -shared"
#	cherche_include_systeme
	;;
   linux_crayCC) TRUST_SUPPORTED=1
   	Defines="-D_COMPILE_AVEC_CLANG"
	CppFlags="-O3 -fPIC -std=c++11 -Wno-inconsistent-missing-override"
	SYSLIBS="-lrt "
	F77Flags="-O3 -fPIC"
	ccFLAGS="-O3 -fPIC"
	ShLibFlag="\$(TRUST_CC) -shared"
	;;
   linux_FCC) TRUST_SUPPORTED=1
        Defines="-D_COMPILE_AVEC_FCC" # Kfast: induces the standard options to exploit the full performance of the A64FX such as SIMDization, software pipelining
        CppFlags="-O3 -fPIC -Kfast" # -SSL2 (for Fujitsu Blas+Lapack) -Nnoclang (fugaku for Trad mode, default)
        SYSLIBS=""
        F77Flags="-O3 -fPIC -Kfast"
        ccFLAGS="-O3 -fPIC -Kfast"
        ShLibFlag="\$(TRUST_CC) -shared"
	;;
   linux_pgCC|linux_nvc++) TRUST_SUPPORTED=1
        m="# TMPDIR ?";e="TMPDIR=\"$TRUST_TMP\" && export TMPDIR";ecrit $m"|"$e"|"$env # Plantage vus avec /tmp par defaut
   	Defines="-D_COMPILE_AVEC_PGCC"
	CppFlags="-O3 -fPIC"
	#SYSLIBS="-lpgftnrtl -lrt" && [ "`basename $TRUST_F77_BASE`" = pgf90 ] && SYSLIBS="-lpgf90 -lpgf90rtl -lpghpf_mpi -lpghpf2 "$SYSLIBS
	F77Flags="-O3 -fPIC"
	ccFLAGS="-O3 -fPIC"
	ShLibFlag="\$(TRUST_CC) -shared"
	;;
   linux_icpc) TRUST_SUPPORTED=1
	Cpp_flag_optim="-O3" && [ "$VT_ROOT" != "" ] && Cpp_flag_optim="-g -O3" # -g pour Itac, traceanalyzer
	Defines="-D_COMPILE_AVEC_INTEL"
	CppFlags="$Cpp_flag_optim -std=c++11 -fPIC -unroll"
	LIB_INTEL=`dirname $TRUST_F77_BASE`
	# Recherche du repertoire /lib
	for lib in lib compiler/lib
	do
	   [ -d $LIB_INTEL/../../$lib ] && LIB_INTEL2=`echo $LIB_INTEL | sed -e 's;/bin;/'$lib';g'` && [ -d $LIB_INTEL2 ] && LIB_INTEL=$LIB_INTEL2
        done
	#SYSLIBS="-L$LIB_INTEL -lifcore -lirc -lsvml -limf -lstdc++ -liomp5"
	SYSLIBS="-L$LIB_INTEL -lifcore -lirc -lsvml -limf -liomp5"
	F77Flags="-O3 -fPIC" && [ "$TRUST_INT64" = "1" ] && F77Flags=$F77Flags" -i8"
	ccFLAGS="-O3 -fPIC -unroll"
	ShLibFlag="\$(TRUST_CC) -shared"
	cherche_include_systeme
	;;
   *) TRUST_SUPPORTED=0
        [ "$TRUST_CC_BASE" = "" ] && echo "Pas de compilateur C++ trouve!"
	echo "TRUST_ARCH_CC=$TRUST_ARCH_CC non reconnu. Modifier $0 pour faire reconnaitre"
	echo "cette nouvelle plateforme."
        [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
	exit -1
   	;;
esac

if [ $TRUST_SUPPORTED = 0 ] && [ "$TRUST_FORCE_SUPPORTED" != 1 ]
then
   echo "\$TRUST_ARCH_CC=$TRUST_ARCH_CC is an unsupported platform for TRUST cause"
   echo "the OS and/or the compiler version have not been tested yet. Please, contact TRUST support."
   echo "You can also force the configure with ./configure -force_even_unsupported"
   [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages
   exit -1
elif [ $TRUST_SUPPORTED = 1 ]
then
   echo "\$TRUST_ARCH_CC=$TRUST_ARCH_CC is a supported platform for TRUST."
fi
########################
# Cas du compilateur gnu
########################
[ ${TRUST_cc_BASE%gcc} != $TRUST_cc_BASE ] && Defines=$Defines" -D_COMPILE_AVEC_GCC_"
###############
# Cas de IA64 #
###############
[ $TRUST_ARCH = linux ] && [ "`uname -m`" = ia64 ] && Defines=$Defines" -Dia64"
###############################################################
# On recompile un programme simple avec F77FLAGS (en effet sur HP, +DA2.0W change l'appel en _)
# -DF77CALLWITHOUT_ si l'appel a FORTRAN ne necessite pas d'_
# -DF77_Majuscule si l'appel a FORTRAN necessite des majuscules
###############################################################
$TRUST_F77_BASE $F77Flags -o test_exec_f $TRUST_ENV/main.f
[  -f test_exec_f.exe ] && mv test_exec_f.exe test_exec_f # pour cygwin
if [ -f test_exec_f ]
then
   [ "`nm test_exec_f | grep -i toto_`" = "" ] && Defines=$Defines" -DF77CALLWITHOUT_"
   [ "`nm test_exec_f | grep TOTO`" != "" ] && Defines=$Defines" -DF77_Majuscule"
fi
rm -f test_exec_f $TRUST_ENV/main.f

#########################################################################################
# On link une application Fortran-C++ donc il faut parfois des librairies Fortran en plus
#########################################################################################
# Attention: pas tout a fait portable --showme:link n'est pas reconnu partout...
fortran_link=`$TRUST_F77 --showme:link 2>/dev/null`
cpp_link=`$TRUST_CC --showme:link 2>/dev/null`
for item1 in $fortran_link
do
   ok=0
   for item2 in $cpp_link
   do
      [ $item1 = $item2 ] && ok=1 # Found in $cpp_link
      [ ${item1#-I} != $item1 ] && ok=1 # Suppress -I cause useless in SYSLIBS
   done
   [ $ok = 0 ] && SYSLIBS=$SYSLIBS" "$item1
done
#################################################
# test si $TRUST_F77 peut compiler du Fortran 90
#################################################
echo "
      subroutine test
      real(kind=8) a
      return
      end" > testf90.f
echo $ECHO_OPTS "Is $TRUST_F77_BASE fortran 90 compliant to compile MUMPS ? \c"
$TRUST_F77 -c testf90.f 1>testf90.log 2>&1
# 12/02/10: Ajout test sur la version de gfortran car la compilation de MUMPS fait planter gfortran 4.0.1
if [ $? = 0 ] && [ "`$TRUST_F77_BASE -v 2>&1 | $TRUST_Awk '/gcc version / {print $3}'`" != "4.0.1" ]
then
   TRUST_USE_MUMPS=1
   echo "Yes"
else
   TRUST_USE_MUMPS=0
   echo "No"
fi
#[ "$TRUST_INT64" = "1" ] && TRUST_USE_MUMPS=0 # Mumps provided by Petsc does not accept 64 bit integers
m="# MUMPS will be used ?";e="TRUST_USE_MUMPS=\"$TRUST_USE_MUMPS\" && export TRUST_USE_MUMPS";ecrit $m"|"$e"|"$env

####################################
# Test le support optimization AVX #
####################################
AVX_FLAGS=""
if [ "${TRUST_CC_BASE%icpc}" != "$TRUST_CC_BASE" ]
then
   # INTEL
   AVX_FLAGS="-axavx -xavx -xssse3"
else
   # GNU (il vaut mieux verifier dans le /proc/cpuinfo que l'extension existe
   # car le test de compilation ne suffit pas). A se demander si ce n'est pas
   # plus simple de l'enlever
   # Autre pb: sse4_x n'est pas gere par valgrind en 32 bits
   model=`uname -m`
   for flag in avx `[ "$model" != i686 ] && echo sse4_2 sse4_1` ssse3
   do
      if  [ "`grep $flag /proc/cpuinfo 2>/dev/null`" != "" ]
      then
         flag=`echo $flag | awk '{gsub("_",".",$0);print $0}'`
         AVX_FLAGS=$AVX_FLAGS" -m$flag"
      fi
   done
fi
# Tester la compilation et l'execution
AVX_SUPPORTED=0
for AVX_FLAG in $AVX_FLAGS
do
   file=${AVX_FLAG#-}
   echo $ECHO_OPTS "AVX support on C/C++ code with $AVX_FLAG ? \c"
   echo "#include <iostream>
int main() {
    double sum = 0.0;
    for (unsigned int i = 0; i < 1024; i++) {
        sum += static_cast<double>(i);
    }
    std::cout << sum << std::endl;
    return 0;
}" > $file.cpp
   $TRUST_CC_BASE -o $file $AVX_FLAG $file.cpp 1>$file.log 2>&1 && ./$file 1>>$file.log 2>&1 && rm -f $file $file.cpp $file.log && echo "Yes" && break
   echo "No" && AVX_FLAG=""
done
# Ajout d'une option de log de vectorization sur Intel (pas trouve sur GNU)
if [ "$AVX_FLAG" != "" ]
then
   [ "${TRUST_CC_BASE%icpc}" != "$TRUST_CC_BASE" ] && AVX_FLAG=$AVX_FLAG" -vec-report1"
fi
[ "$AVX_SUPPORTED" != 1 ] && echo "AVX support not activated yet by default. But you can build a version with:  make opt_avx"

################################################
# Test si le support GPU est possible avec PETSc
################################################
m="# PATH to PETSc";e="PETSC_DIR=\"\$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH"_opt"\" && export PETSC_DIR";ecrit $m"|"$e"|"$env
if [ "$TRUST_USE_CUDA" = 1 ]
then
   #############################
   # Installation NVIDIA Samples
   #############################
   echo $ECHO_OPTS "Is it a double precision NVIDIA card ? \c"
   # Compilation d'un binaire Cuda et test de la carte:
   (
       source ../env_TRUST.sh 1>/dev/null 2>&1
       LD_LIBRARY_PATH=$CUDA_LIB:$LD_LIBRARY_PATH
       rm -r -f nvc_get_devices
       tar xfz $TRUST_ROOT/externalpackages/AmgX/nvc_get_devices.tgz
       cd nvc_get_devices && ./build.sh || exit -1
       # Test eventuel (plus bloquant si echec):
       export exec=`pwd`/nvc_get_devices
       rm -f $TRUST_ENV/card.log
       trust -gpu dummy_file 1>$TRUST_ENV/card.log 2>&1 &
       $TRUST_ROOT/bin/KSH/wait_for $! 60 # Pour eviter blocage
   )
   COMPUTE_CAPABILITY="`awk '/apability/ {print $NF}' $TRUST_ENV/card.log 2>/dev/null | head -1`"
   if [ "$COMPUTE_CAPABILITY" != "" ]
   then
      # On ne supporte que les cartes double precision
      TRUST_USE_CUDA="`echo $COMPUTE_CAPABILITY | awk '{if ($1>=1.3) print 1;else print 0}'`"
      if [ "$TRUST_USE_CUDA" = 0 ]
      then
         echo "No. See error:"
         cat $TRUST_ENV/card.log
         exit -1
      else
         awk '/Device 0/ {print "Yes. The NVIDIA card is "$0}' $TRUST_ENV/card.log
      fi
   else
      rm -f $TRUST_ENV/card.log
      echo "Not tested."
   fi
   m="# TRUST will use CUDA ?";e="TRUST_USE_CUDA=\"$TRUST_USE_CUDA\" && export TRUST_USE_CUDA";ecrit $m"|"$e"|"$env
   Defines=$Defines" -DTRUST_USE_CUDA -DPETSC_SKIP_COMPLEX"
   # Vu sur orcus (fait ch..r) -pedantic pose probleme:
   echo "Cuda: -pedantic suppressed in \$CppFlags"
   CppFlags=`echo $CppFlags | sed "s?-pedantic??g"`
fi
##########
# VAMPIR #
##########
if [ "$VAMPIR_SUPPORTED" = 1 ]
then
   # If you want to instrument MPI events only (this creates smaller trace files and less overhead) use the option -vt:inst manual to disable automatic instrumentation of user functions
   # See http://tu-dresden.de/die_tu_dresden/zentrale_einrichtungen/zih/forschung/projekte/vampirtrace/dateien/VT-UserManual-5.14.4.pdf
   VT_OPTION="-vt:inst manual"
   CppFlags=$CppFlags" "$VT_OPTION
   ccFLAGS=$ccFLAGS" "$VT_OPTION
   F77Flags=$F77Flags" "$VT_OPTION
   Defines=$Defines" -DVTRACE"
fi

##########
# OpenMP #
##########
if [ "$TRUST_USE_OPENMP" = 1 ]
then
   if [ "`basename $TRUST_CC_BASE`" = icpc ]
   then
      openmp="-openmp" # Take care, "man icpc" says if -openmp misunderstood, it creates an object name penmp so:
      openmp="-fopenmp -mkl=parallel" # Ajout de -mkl=parallel pour etre sur de linker avec Mkl BLAS parallele et non sequential (Vu sur sagittarius)
   else
      openmp="-fopenmp"
   fi
   CppFlags=$CppFlags" "$openmp
   SYSLIBS=$SYSLIBS" "$openmp
fi

############
# Topology #
############
if [ "$TRUST_DISABLE_MPI" != 1 ]
then
   make_ $TRUST_ROOT/Outils/hwloc hwloc $TRUST_ROOT/exec/hwloc.log
   echo "ADD_PATH \$TRUST_ROOT/exec/hwloc/bin" >> $env
fi

###################
# Memory bandwith #
###################
#cd stream
#./check_stream
#cd - 1>/dev/null 2>&1
m="# TRUST will use OpenMP ?";e="TRUST_USE_OPENMP=\"$TRUST_USE_OPENMP\" && export TRUST_USE_OPENMP";ecrit $m"|"$e"|"$env
# Si support OpenMP, alors on fixe OMP_NUM_THREADS=1 par defaut (no black box) car performances catastrophiques si l'utilisateur mixe MPI et OpenMP sans savoir ce qu'il fait...
# L'utilisateur devra faire: OMP_NUM_THREADS=n $exec jdd ou utiliser le script trust qui permettra de specifier le nombre de threads, ex: trust -n 2 -m 4 jdd (2 MPI et 4 threads par task MPI)
if [ "$TRUST_USE_OPENMP" = 1 ]
then
   m="# Default, no multithreading. User should explicitly enable the number of OpenMP threads.";e="OMP_NUM_THREADS=1 && export OMP_NUM_THREADS";ecrit $m"|"$e"|"$env
fi

#################################################################
# Creation des cas tests ou non a partir des fiches de validation
#################################################################
TRUST_CREATE_TESTS_FROM_VALIDATION_FORMS=0
# 0 by default, except for the TRUST_ROOT which is building the code (<=> $TRUST_ROOT used in the crontab)
[ "`crontab -l 2>/dev/null | grep $TRUST_ROOT`" != "" ] && TRUST_CREATE_TESTS_FROM_VALIDATION_FORMS=1
m="# Create tests from validation forms with lance_test ?";e="TRUST_CREATE_TESTS_FROM_VALIDATION_FORMS=\"$TRUST_CREATE_TESTS_FROM_VALIDATION_FORMS\" && export TRUST_CREATE_TESTS_FROM_VALIDATION_FORMS";ecrit $m"|"$e"|"$env

############################
# LIBCCC_USER support (CCRT)
############################
# Access to:
# remaining time of the current batch application
# time already used by the current batch application
# usable time of the current batch application
# curent resident memory usage of the program
# max virtual memory usage of the program
# Seems to crash with mvapich:
if [ "$LIBCCC_USER_ROOT" != "" ] && [ "`echo $MPI_ROOT | grep -i bullxmpi`" != "" ]
then
   Defines=$Defines" -DLIBCCC_USER"
   SYSLIBS=$SYSLIBS" "$LIBCCC_USER_LDFLAGS
fi

#######################
# Ecriture des fichiers
#######################
Defines=$Defines" $COMFLAGS -D\$(TRUST_ARCH) -D_INLINE_EVALUATEURS_ -DNDEBUG"

#####################################################
# Ajout de variables eventuelles creees par configure
#####################################################
if [ -f configure.env ]
then
   cat configure.env >> machine.env
fi
suffixes=`echo $TRUST_ARCH_CC"_opt" $TRUST_ARCH_CC`
for suffixe in $suffixes
do
   tmp=`mktemp_`
   echo "Defines = $Defines
SYSINC = $SYSINC
SYSINC_DEP = $SYSINC_DEP
CppFlags = $TRUST_ADD_CXXFLAGS `[ "$AVX_SUPPORTED" = 1 ] && echo $AVX_FLAG` $CppFlags $MPI_Flags \$(Includes) \$(SYSINC) \$(Defines)
SYSLIBS = $MPI_LIB $COMLIBS $SYSLIBS
F77Flags = $TRUST_ADD_FFLAGS $F77Flags
ccFLAGS = $TRUST_ADD_CFLAGS `[ "$AVX_SUPPORTED" = 1 ] && echo $AVX_FLAG` $ccFLAGS
ShLibFlag = $ShLibFlag
SL_EXTENSION = $SL_EXTENSION
LINK_MALIB = $LINK_MALIB" > $tmp
   update_file $tmp make.$suffixe

   # On supprime -D_INLINE_EVALUATEURS_ -DNDEBUG
   Defines=${Defines% -D_INLINE_EVALUATEURS_ -DNDEBUG}
   # On remplace -O par -g
   O=`echo $CppFlags | awk '{print $1}'`
   CppFlags="-g -O0"${CppFlags#$O}
   O=`echo $F77Flags | awk '{print $1}'`
   F77Flags="-g"${F77Flags#$O}
   # 16/03/2010: Ajout de -fbounds-check en debug sur gfortran
   # D'apres http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33745 -fbounds-check ne marche pas bien pour gfortran ancien
   # On a eu des problemes sur 4.0.1 (peyrolle: TAB(N,*) annonce un depassement tableau, TAB(N,M) non) et 4.1 (castor)
   # On a aussi un pb sur Fedora 18 At line 1 of file pilaenv.f : Fortran runtime error: Actual string length is shorter than the declared one for... (MC2 en debug)
   # 19-09-2016: probleme avec clang sur cas test Lire_unv => on commente
   #if [ $TRUST_F77_BASE != ${TRUST_F77_BASE%gfortran} ] && [ "`$TRUST_F77_BASE -v 2>&1 | awk '/gcc / && /version / {print ($3>=4.2?1:0)}'`" = 1 ] && [ "`grep 'Fedora release' /etc/issue`" = "" ]
   #then
   #   F77Flags=$F77Flags" -fbounds-check"
   #fi
   O=`echo $ccFLAGS | awk '{print $1}'`
   ccFLAGS="-g"${ccFLAGS#$O}
   #############################
   # Creation du fichier profile
   #############################
   tmp=`mktemp_`
   cp -f make.$suffixe $tmp
   # 30/08/04: Pour les makefile avec profile, rajout de -a (profile par ligne avec gprof -l) : non gcc 3.2 n'accepte pas...
   # Il semble qu'il faille utiliser -g pour cela ou -fprofile-arcs -ftest-coverage pour gcov (en tout -g pour valgrind --tool=cachegrind
   # et de -fno-inline pour Linux afin de voir le + plus precisement possible ou est depense le CPU
   #echo $ECHO_OPTS "1,$ s?$O?-pg `[ $TRUST_ARCH = linux ] && echo "-fno-inline -fprofile-arcs -ftest-coverage"` $O?g\nw" | ed make.$suffixe2 1>/dev/null 2>&1
   # On vire -fprofile-arcs -ftest-coverage car plante sur tantale en parallele....
   # On vire -fno-inline car on peut compiler fichier par fichier
   #echo $ECHO_OPTS "1,$ s?$O?-g -pg `[ $TRUST_ARCH = linux ] && echo "-fno-inline"` $O?g\nw" | ed make.$suffixe2 1>/dev/null 2>&1
   option_profile="-pg" && [ "`uname -m`" = ia64 ] && option_profile="-p" # -qp devient obsolete Intel 10
   if [ "`uname -m`" = i686 ] || [ "`uname -m | grep 64`" != "" ]
   then
      # le -gstab1 booste litteralement l'analyse par gprof avec GNU (>*10)
      # http://www.arcknowledge.com/gmane.comp.gnu.binutils.bugs/2006-04/msg00030.html
      [ "`basename $TRUST_CC_BASE`" = g++ ] && option_profile=$option_profile" -gstabs1"
      # Avec icpc l'inlining ne se fait pas avec -pg on le force:
      [ "`basename $TRUST_CC_BASE`" = icpc ] && option_profile=$option_profile" -inline-forceinline"
   fi
   echo $ECHO_OPTS "1,$ s?$O?-g $option_profile $O?g\nw" | ed $tmp 1>/dev/null 2>&1
   # Pour le link il faut -pg !
   echo $ECHO_OPTS "1,$ s?SYSLIBS =?SYSLIBS = $option_profile?g\nw" | ed $tmp 1>/dev/null 2>&1

   suffixe2=$TRUST_ARCH_CC${suffixe#$TRUST_ARCH_CC}"_pg"
   update_file $tmp make.$suffixe2
   O="-g"
   ##############################
   # Creation du fichier coverage
   ##############################
   if [ ${TRUST_CC_BASE%g++} != $TRUST_CC_BASE ]
   then
      tmp=`mktemp_`
      # Creation d'un fichier d'environnement pour la compilation avec -ftest-coverage -fprofile-arcs
      cp -f make.$suffixe $tmp
      GCOV_FLAG="-fno-inline -ftest-coverage -fprofile-arcs"
      echo $ECHO_OPTS "1,$ s?CppFlags =?CppFlags = $GCOV_FLAG?g\nw" | ed $tmp 1>/dev/null 2>&1
      echo $ECHO_OPTS "1,$ s?F77Flags =?F77Flags = $GCOV_FLAG?g\nw" | ed $tmp 1>/dev/null 2>&1
      echo $ECHO_OPTS "1,$ s?ccFLAGS =?ccFLAGS = $GCOV_FLAG?g\nw"   | ed $tmp 1>/dev/null 2>&1
      # O3 -> O0 pour cachegrind:
      sed -i "1,$ s?-O3?-g -O0?g" $tmp
      # Attention mpiCC --showme:link depend de MPI (-link_info sur castor): a ameliorer si necessaire
      echo $ECHO_OPTS "1,$ s?SYSLIBS =?SYSLIBS = `$TRUST_CC --showme:link 2>/dev/null` -ftest-coverage -fprofile-arcs ?g\nw" | ed $tmp 1>/dev/null 2>&1
      suffixe3=$TRUST_ARCH_CC${suffixe#$TRUST_ARCH_CC}"_gcov"
      update_file $tmp make.$suffixe3
   fi
done
# Creation d'une version make.$ARCH_semi_opt pour avoir une version qui tourne
# vite pour les tests de non regression
tmp=`mktemp_`
cp -f make.$TRUST_ARCH_CC"_opt" $tmp
echo $ECHO_OPTS "1,$ s?-DNDEBUG??g\nw"  | ed $tmp 1>/dev/null 2>&1
# PL: Ajout sur GNU semi_opt de -fsanitize=address : https://www.osc.edu/resources/getting_started/howto/howto_use_address_sanitizer
# Non affreusement lent a l'execution
# fsan="" && [ "$GNU_VERSION" != "" ] && fsan=-fsanitize=address
echo $ECHO_OPTS "1,$ s?-O3?-g -O3 $fsan?g\nw" | ed $tmp 1>/dev/null 2>&1
suffixe4=$TRUST_ARCH_CC"_semi_opt"
update_file $tmp make.$suffixe4

# Creation d'une version make.$ARCH_opt_avx pour tester le support de AVX
if [ "$AVX_SUPPORTED" = 0 ]
then
   tmp=`mktemp_`
   cp -f make.$TRUST_ARCH_CC"_opt" $tmp
   echo $ECHO_OPTS "1,$ s?-O3?-O3 $AVX_FLAG?g\nw" | ed $tmp 1>/dev/null 2>&1
   echo $ECHO_OPTS "1,$ s?Defines =?Defines = -DWITH_SSE?g\nw" | ed $tmp 1>/dev/null 2>&1
   suffixe5=$TRUST_ARCH_CC"_opt_avx"
   update_file $tmp make.$suffixe5
fi

# Options de compilation sur native
if [ "$TRUST_ADD_NATIVE_FLAGS" = 1 ]
then
   # PL: -xHOST ou -march=native ajoute des flags de vectorisation comme -mavx2 ou mieux... L'option opt_avx va devenir inutile
   # Pas mal d'erreurs encore a corriger:
   # The following tests FAILED:
   #     251 - Obstacle_reprise (Failed)
   #     271 - PETSC_VDF (Failed)
   #     339 - Reprise_Statistiques_Definition_Champs (Failed)
   #     631 - conv_poiseuille_jdd2 (Failed)
   if [ "$TRUST_VERSION_GNU" = "" ]
   then
      sed -i "1,$ s? -O3 ? -O3 -xHOST ?" make.$TRUST_ARCH_CC"_opt"
   else
      # -ffast-math -mtune=native fait des exceptions arithmetiques: ToDo a voir...
      sed -i "1,$ s? -O3 ? -O3 -g -march=native ?" make.$TRUST_ARCH_CC"_opt"
   fi
fi
############################################################
# Liste des outils possibles pour la creation de dependances
############################################################
# Fait a la fin car pour les tests de rapidite les make.*opt doivent etre crees
if [ 0 -eq 1 ]
then
TRUST_MD="ccmakedep $TRUST_ROOT/exec/makedepend/bin/makedepend"
echo "Test between $TRUST_MD to pick the fastest command:"
time_ccmakedep=` (time -p env TRUST_MD=ccmakedep fait_makefile $TRUST_ROOT/src/Kernel/Framework 2>&1) 2>&1 | awk '/real / {print $2}'`
echo "ccmakedep: $time_ccmakedep s"
time_makedepend=`(time -p env TRUST_MD=$TRUST_ROOT/exec/makedepend/bin/makedepend fait_makefile $TRUST_ROOT/src/Kernel/Framework 2>&1) 2>&1 | awk '/real / {print $2}'`
rm $TRUST_ROOT/src/Kernel/Framework/makefile
echo "makedepend: $time_makedepend s"
[ "`echo $time_ccmakedep $time_makedepend | awk '{print ($1>$2)}'`" = 1 ] && TRUST_MD="$TRUST_ROOT/exec/makedepend/bin/makedepend ccmakedep" # makedepend plus rapide
else
TRUST_MD="makedepend $TRUST_ROOT/exec/makedepend/bin/makedepend makedepend"
fi
m="# Path to makedepend command";e="`cherche_file TRUST_MD $TRUST_MD`";ecrit $m"|"$e"|"$env;eval $e
[ "$ligne_supp" != "" ] &&       echo $ligne_supp  >> $env

############################
# Fin creation machine.env #
############################
echo "File machine.env created."

# Generation de Cmake.env a partir des make.$TRUST_ARCH
find_flags()
{
    What=$1
    marq=$2
    shift;shift
    ajout=$*
    echo "SET(CMAKE_${What}_FLAGS_${MODE} \""$ajout `grep "$marq =" make.${TRUST_ARCH_CC}$suf | sed "s/\\$(Includes) \\$(SYSINC) \\$(Defines)//" |sed "s/$marq =//"` "\" CACHE STRING \"from make.${TRUST_ARCH_CC}$suf\" FORCE)" >> Cmake.env
    echo "MARK_AS_ADVANCED(CMAKE_${What}_FLAGS_${MODE})" >> Cmake.env
}
defines_base=`grep "Defines ="  make.${TRUST_ARCH_CC}| sed "s/Defines =//"`
echo "SET(ADD_CPPFLAGS \""`grep "Defines ="  make.${TRUST_ARCH_CC} | sed "s/Defines =//" | awk -F\$ '{print $1}'` "-D$TRUST_ARCH \")"| sed "s/-D //" > Cmake.env
for mode in Debug Release Profil Coverage semi_opt Release_avx
do
  case $mode in
      Debug) suf="" ;;
      Release) suf="_opt";;
      Release_avx) suf="_opt_avx";;
      Profil) suf="_opt_pg";;
      Coverage) suf="_opt_gcov";;
      semi_opt) suf="_semi_opt";;
      *) echo $mode inconnue ;
         [ -f $TRUST_ROOT/NON_INSTALLED ] && Display_Missing_packages ;
         exit -1 ;;
  esac;
  if [ -f make.${TRUST_ARCH_CC}$suf ]
      then
      MODE=`echo $mode | awk '{print toupper($0)}'`
      ajout=`grep "Defines =" make.${TRUST_ARCH_CC}$suf | sed "s/$defines_base//;s/Defines =//"`
      find_flags CXX CppFlags  $ajout
      find_flags Fortran F77Flags
      find_flags C ccFLAGS
      find_flags EXE_LINKER SYSLIBS
  fi
done
echo "SET( CMAKE_BUILD_TYPE \"\${CMAKE_BUILD_TYPE}\" CACHE STRING \"Choose the type of build, options are: Debug Release Profil Coverage semi_opt. \"    FORCE )" >> Cmake.env
echo "File Cmake.env created."

cd $TRUST_ROOT/bin
# Mise a jour du fichier rep.TRUST
./mkrep
# Mise a jour des fichiers make.lib$SO_EXTENSION
./mklibs
# Cree le repertoire $TRUST_ROOT/include pour l'atelier
./cree_include

# Fichier include non existant, on cree un fichier vide
includes="
$TRUST_ROOT/lib/src/LIBAMGX/AmgXWrapper/include/AmgXSolver.hpp
$TRUST_ROOT/lib/src/LIBAMGX/AmgX/include/amgx_c.h
$TRUST_ROOT/lib/src/LIBMETIS/include/metis.h
$TRUST_ROOT/lib/src/LIBMED/MED/include/med.h
$TRUST_ROOT/lib/src/LIBLATAFILTER/include/LataV1_field_definitions.h
$TRUST_ROOT/lib/src/LIBLATAFILTER/include/LmlReader.h
$TRUST_ROOT/lib/src/LIBLATAFILTER/include/LataFilter.h
$MPI_INCLUDE/mpi.h
"
for petsc_option in _ _opt _opt_pg _opt_gcov _semi_opt _opt_avx _custom
do
   [ $petsc_option = "_" ] && petsc_option=""
   includes=$includes" "$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH$petsc_option/include/petsc_for_kernel.h" "$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH$petsc_option/include/metis.h" "$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH$petsc_option/include/ptscotch++.h" "$TRUST_ROOT/lib/src/LIBPETSC/petsc/$TRUST_ARCH$petsc_option/include/parmetis++.h
done

for include in $includes
do
   dir_include=`dirname $include`
   [ ! -d $dir_include ] && mkdir -p $dir_include
   [ ! -f $include ] && echo > $include
done

# Pour MPI c'est un peu special
comm_incl=$TRUST_ROOT/src/Kernel/Utilitaires/comm_incl.h
# Si MPI_ROOT a change depuis le dernier configure
# on fait un touch du comm_incl.h si celui ci est modifiable
# ou on previent au moins...
if [ -f machine.env.old ] && [ "`diff machine.env machine.env.old | grep MPI_ROOT=`" != "" ]
then
   if [ "`ls -l $comm_incl | cut -c3`" = "w" ]
   then
      echo "MPI distribution has changed since last configure so $comm_incl.h is touched..."
      touch $comm_incl
   else
      echo "MPI distribution has changed since last configure so a make clean should be done."
   fi
fi
# Menage
rm -f $TRUST_ENV/.rep $TRUST_ENV/.path

# Edit sources for 64 bit integers build :
if [ "$TRUST_INT64" = "1" ]
then
    echo "We will edit sources to build 64 bits version, please wait..."
    (cd $TRUST_ROOT && ./bin/BUILD64/GO)
fi
exit 0
